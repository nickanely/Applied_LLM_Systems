[
  {
    "code": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef insert(root, key):\n    if root is None:\n        return Node(key)\n    else:\n        if root.value < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef is_bst(node, left=float('-inf'), right=float('inf')):\n    if node is None:\n        return True\n    if not (left < node.value < right):\n        return False\n    return (is_bst(node.left, left, node.value) and\n            is_bst(node.right, node.value, right))\n\ndef build_bst(keys):\n    if not keys:\n        return None\n    root = None\n    for key in keys:\n        root = insert(root, key)\n    return root\n\ndef kth_smallest_element(root, k):\n    def inorder_traversal(node):\n        if not node:\n            return []\n        return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)\n\n    return inorder_traversal(root)[k-1]\n\n# Example usage:\nif __name__ == \"__main__\":\n    keys = [20, 8, 22, 4, 12, 10, 14]\n    bst_root = build_bst(keys)\n    print(\"Is the tree a valid BST?\", is_bst(bst_root))\n    kth = 3\n    print(f\"The {kth} smallest element in the BST is:\", kth_smallest_element(bst_root, kth))",
    "label": 0,
    "original_ref": "def cost_function(h: np.ndarray, y: np.ndarray) -> float:\n    \"\"\"\n    Cost function quantifies the error between predicted and expected values.\n    The cost function used in Logistic Regression is called Log Loss\n    or Cross Entropy Function.\n\n    J(\u03b8) = (1/m) * \u03a3 [ -y * log(h\u03b8(x)) - (1 - y) * log(1 - h\u03b8(x)) ]\n\n    Where:\n       - J(\u03b8) is the cost that we want to minimize during training\n       - m is the number of training examples\n       - \u03a3 represents the summation over all training examples\n       - y is the actual binary label (0 or 1) for a given example\n       - h\u03b8(x) is the predicted probability that x belongs to the positive class\n\n    @param h: the output of sigmoid function. It is the estimated probability\n    that the input example 'x' belongs to the positive class\n\n    @param y: the actual binary label associated with input example 'x'\n\n    Examples:\n    >>> estimations = sigmoid_function(np.array([0.3, -4.3, 8.1]))\n    >>> cost_function(h=estimations,y=np.array([1, 0, 1]))\n    0.18937868932131605\n    >>> estimations = sigmoid_function(np.array([4, 3, 1]))\n    >>> cost_function(h=estimations,y=np.array([1, 0, 0]))\n    1.459999655669926\n    >>> estimations = sigmoid_function(np.array([4, -3, -1]))\n    >>> cost_function(h=estimations,y=np.array([1,0,0]))\n    0.1266663223365915\n    >>> estimations = sigmoid_function(0)\n    >>> cost_function(h=estimations,y=np.array([1]))\n    0.6931471805599453\n\n    References:\n       - https://en.wikipedia.org/wiki/Logistic_regression\n    \"\"\"\n    return float((-y * np.log(h) - (1 - y) * np.log(1 - h)).mean())",
    "original_similarity": 0.05813518346572444,
    "max_corpus_similarity": 0.5378988676356312
  },
  {
    "code": "def check_symmetry(root: Node) -> bool:\n    if root: \n        return mirror_check(root.left_child, root.right_child)\n    return True",
    "label": 1,
    "original_ref": "def is_symmetric_tree(tree: Node) -> bool:\n    \"\"\"\n    Check if a binary tree is symmetric (i.e., a mirror of itself).\n\n    Parameters:\n    tree: The root node of the binary tree.\n\n    Returns:\n    bool: True if the tree is symmetric, False otherwise.\n\n    Example:\n    >>> is_symmetric_tree(make_symmetric_tree())\n    True\n    >>> is_symmetric_tree(make_asymmetric_tree())\n    False\n    \"\"\"\n    if tree:\n        return is_mirror(tree.left, tree.right)\n    return True  # An empty tree is considered symmetric.",
    "ast_similarity": 0.9072709329268468,
    "token_jaccard": 0.15555555555555556
  },
  {
    "code": "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u, v, weight):\n        self.graph.append([u, v, weight])\n\n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    def kruskal_mst(self):\n        result = []\n        i = 0\n        e = 0\n\n        self.graph = sorted(self.graph, key=lambda item: item[2])\n\n        parent = []\n        rank = []\n\n        for node in range(self.V):\n            parent.append(node)\n            rank.append(0)\n\n        while e < self.V - 1:\n            u, v, w = self.graph[i]\n            i += 1\n            x = self.find(parent, u)\n            y = self.find(parent, v)\n\n            if x != y:\n                e += 1\n                result.append([u, v, w])\n                self.union(parent, rank, x, y)\n\n        print(\"Edges in the constructed MST\")\n        for u, v, weight in result:\n            print(\"%d -- %d == %d\" % (u, v, weight))\n\n\n# Example usage:\ng = Graph(4)\ng.add_edge(0, 1, 10)\ng.add_edge(0, 2, 6)\ng.add_edge(0, 3, 5)\ng.add_edge(1, 3, 15)\ng.add_edge(2, 3, 4)\n\ng.kruskal_mst()",
    "label": 0,
    "original_ref": "def is_symmetric_tree(tree: Node) -> bool:\n    \"\"\"\n    Check if a binary tree is symmetric (i.e., a mirror of itself).\n\n    Parameters:\n    tree: The root node of the binary tree.\n\n    Returns:\n    bool: True if the tree is symmetric, False otherwise.\n\n    Example:\n    >>> is_symmetric_tree(make_symmetric_tree())\n    True\n    >>> is_symmetric_tree(make_asymmetric_tree())\n    False\n    \"\"\"\n    if tree:\n        return is_mirror(tree.left, tree.right)\n    return True  # An empty tree is considered symmetric.",
    "original_similarity": 0.1656458042190034,
    "max_corpus_similarity": 0.5992964949362191
  },
  {
    "code": "def knight_path(size: int) -> list[list[int]]:\n    chessboard = [[0 for x in range(size)] for y in range(size)]\n    for x in range(size):\n        for y in range(size):\n            chessboard[x][y] = 1\n            if knight_path_solver(chessboard, (x, y), 1):\n                return chessboard\n            chessboard[x][y] = 0\n    error_message = f\"Open Knight Tour cannot be performed on a board of size {size}\"\n    raise ValueError(error_message)",
    "label": 1,
    "original_ref": "def open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)",
    "ast_similarity": 0.9776341924866149,
    "token_jaccard": 0.3333333333333333
  },
  {
    "code": "class Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef build_tree(level_order, n, index):\n    root = None\n    if index < n:\n        root = Node(level_order[index])\n        root.left = build_tree(level_order, n, 2 * index + 1)\n        root.right = build_tree(level_order, n, 2 * index + 2)\n    return root\n\ndef is_leaf(node):\n    return node is not None and node.left is None and node.right is None\n\ndef all_path_sums(root, sum_so_far, paths, target_sum, node_path):\n    if root is None:\n        return\n\n    node_path.append(root.val)\n    sum_so_far += root.val\n\n    if is_leaf(root) and sum_so_far == target_sum:\n        paths.append(node_path[:])\n    else:\n        all_path_sums(root.left, sum_so_far, paths, target_sum, node_path)\n        all_path_sums(root.right, sum_so_far, paths, target_sum, node_path)\n\n    node_path.pop()\n\ndef path_sum(level_order, target_sum):\n    n = len(level_order)\n    root = build_tree(level_order, n, 0)\n    paths = []\n    all_path_sums(root, 0, paths, target_sum, [])\n    return paths\n\n# Example Usage\nlevel_order = [5, 4, 8, 11, None, 13, 4, 7, 2, None, None, 5, 1]\ntarget_sum = 22\nprint(path_sum(level_order, target_sum))",
    "label": 0,
    "original_ref": "def open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)",
    "original_similarity": 0.30122373279959336,
    "max_corpus_similarity": 0.5768201181361557
  },
  {
    "code": "def treeTraversal(self, start):\n    def traverse(node):\n        if not node: return\n        traverse(node.left)\n        result.append(node.val)\n        traverse(node.right)\n    \n    result = []\n    traverse(start)\n    return result",
    "label": 1,
    "original_ref": "    def inorderTraversal(self, root):\n        def helper(node):\n            if not node: return\n            helper(node.left)\n            opt.append(node.val)\n            helper(node.right)\n            \n        opt = []\n        helper(root)\n        return opt",
    "ast_similarity": 0.9999081772158047,
    "token_jaccard": 0.30434782608695654
  },
  {
    "code": "class Knapsack:\n    def __init__(self, weights, values, capacity):\n        self.weights = weights\n        self.values = values\n        self.capacity = capacity\n        self.n = len(weights)\n        self.memo = {}\n\n    def solve(self):\n        return self.knapsack(self.capacity, self.n - 1)\n\n    def knapsack(self, remaining_capacity, index):\n        if index < 0 or remaining_capacity <= 0:\n            return 0\n\n        if (remaining_capacity, index) in self.memo:\n            return self.memo[(remaining_capacity, index)]\n\n        if self.weights[index] > remaining_capacity:\n            result = self.knapsack(remaining_capacity, index - 1)\n        else:\n            included = self.values[index] + self.knapsack(remaining_capacity - self.weights[index], index - 1)\n            excluded = self.knapsack(remaining_capacity, index - 1)\n            result = max(included, excluded)\n\n        self.memo[(remaining_capacity, index)] = result\n        return result\n\n# Example usage:\nweights = [1, 3, 4, 5]\nvalues = [10, 40, 50, 70]\ncapacity = 7\nknapsack = Knapsack(weights, values, capacity)\n\nmax_value = knapsack.solve()\nprint(\"Maximum value in Knapsack:\", max_value)",
    "label": 0,
    "original_ref": "    def inorderTraversal(self, root):\n        def helper(node):\n            if not node: return\n            helper(node.left)\n            opt.append(node.val)\n            helper(node.right)\n            \n        opt = []\n        helper(root)\n        return opt",
    "original_similarity": 0.19991084321395208,
    "max_corpus_similarity": 0.5890876069316759
  },
  {
    "code": "def extract_links(obj):\n  result=[]; \n  for source in obj.connections: \n    for destination in obj.connections[source]: \n      result.append((source, destination, obj.connections[destination][source]))\n  return result",
    "label": 1,
    "original_ref": "    def get_edges(self):\n        \"\"\"\n        Returna all edges in the graph\n        \"\"\"\n        output = []\n        for tail in self.adjacency:\n            for head in self.adjacency[tail]:\n                output.append((tail, head, self.adjacency[head][tail]))\n        return output",
    "ast_similarity": 0.9459760905184071,
    "token_jaccard": 0.12903225806451613
  },
  {
    "code": "class Node:\n    def __init__(self, key, left=None, right=None):\n        self.key = key\n        self.left = left\n        self.right = right\n\ndef insert_into_bst(root, key):\n    if root is None:\n        return Node(key)\n    if key < root.key:\n        root.left = insert_into_bst(root.left, key)\n    else:\n        root.right = insert_into_bst(root.right, key)\n    return root\n\ndef bst_to_sorted_array(root, result):\n    if root is None:\n        return\n    bst_to_sorted_array(root.left, result)\n    result.append(root.key)\n    bst_to_sorted_array(root.right, result)\n\ndef has_sum_path(node, target_sum):\n    if node is None:\n        return target_sum == 0\n    target_sum -= node.key\n    return (has_sum_path(node.left, target_sum) or\n            has_sum_path(node.right, target_sum))\n\ndef find_all_paths(node, target_sum, current_path, all_paths):\n    if node is None:\n        return\n\n    current_path.append(node.key)\n    if node.left is None and node.right is None and sum(current_path) == target_sum:\n        all_paths.append(list(current_path))\n    else:\n        find_all_paths(node.left, target_sum, current_path, all_paths)\n        find_all_paths(node.right, target_sum, current_path, all_paths)\n\n    current_path.pop()\n\ndef count_unique_bst(n):\n    dp = [0] * (n + 1)\n    dp[0], dp[1] = 1, 1\n\n    for nodes in range(2, n + 1):\n        for root in range(1, nodes + 1):\n            dp[nodes] += dp[root - 1] * dp[nodes - root]\n\n    return dp[n]\n\n# Example Usage\nroot = None\nkeys = [10, 5, 1, 7, 40, 50]\nfor key in keys:\n    root = insert_into_bst(root, key)\n\nsorted_keys = []\nbst_to_sorted_array(root, sorted_keys)\nprint(\"BST to Sorted Array:\", sorted_keys)\n\nprint(\"Has Sum Path (22):\", has_sum_path(root, 22))\n\nall_paths = []\nfind_all_paths(root, 18, [], all_paths)\nprint(\"All Paths with Sum 18:\", all_paths)\n\nunique_bsts = count_unique_bst(3)\nprint(\"Number of Unique BSTs with 3 nodes:\", unique_bsts)",
    "label": 0,
    "original_ref": "    def get_edges(self):\n        \"\"\"\n        Returna all edges in the graph\n        \"\"\"\n        output = []\n        for tail in self.adjacency:\n            for head in self.adjacency[tail]:\n                output.append((tail, head, self.adjacency[head][tail]))\n        return output",
    "original_similarity": 0.09393920076926113,
    "max_corpus_similarity": 0.5369019040144964
  },
  {
    "code": "def calculateMaxArea(heights):\n    right, left = len(heights) - 1, 0\n    maximum_area = float('-inf')\n    while right > left:\n        maximum_area = max(maximum_area, (right - left) * min(heights[right], heights[left]))\n        if heights[right] > heights[left]:\n            left += 1\n        else:\n            right -= 1\n    return maximum_area",
    "label": 1,
    "original_ref": "    def maxArea(self, H):\n        r, l = len(H)-1, 0\n        ans = float('-inf')\n\n        while r>l:\n            ans = max(ans, (r-l)*min(H[r], H[l]))\n            if H[r]>H[l]:\n                l = l+1\n            else:\n                r = r-1\n        return ans",
    "ast_similarity": 0.9924755346677846,
    "token_jaccard": 0.18604651162790697
  },
  {
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef uniquePaths(m, n):\n    # Create a grid that represents the number of unique paths to each cell\n    grid = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Basis: There's one unique way to reach any cell in the first row (all move right)\n    for i in range(n):\n        grid[0][i] = 1\n    \n    # Basis: There's one unique way to reach any cell in the first column (all move down)\n    for j in range(m):\n        grid[j][0] = 1\n\n    # Fill the grid using dynamic programming\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] = grid[i-1][j] + grid[i][j-1]\n\n    # The value in the bottom-right cell is the answer\n    return grid[-1][-1]\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj_list = {i: [] for i in range(vertices)}\n    \n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n    \n    def dfs(self, v, visited):\n        visited.add(v)\n        \n        for neighbor in self.adj_list[v]:\n            if neighbor not in visited:\n                self.dfs(neighbor, visited)\n    \n    def connected_components(self):\n        visited = set()\n        count = 0\n        \n        for vertex in range(self.V):\n            if vertex not in visited:\n                self.dfs(vertex, visited)\n                count += 1\n        \n        return count\n\n# Usage\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\n\ngraph = Graph(5)\ngraph.add_edge(0, 1)\ngraph.add_edge(1, 2)\ngraph.add_edge(3, 4)\n\n# Finding number of unique paths in an m x n grid\nprint(uniquePaths(3, 3))  # Output: 6\n\n# Finding number of connected components in the graph\nprint(graph.connected_components())  # Output: 2",
    "label": 0,
    "original_ref": "    def maxArea(self, H):\n        r, l = len(H)-1, 0\n        ans = float('-inf')\n\n        while r>l:\n            ans = max(ans, (r-l)*min(H[r], H[l]))\n            if H[r]>H[l]:\n                l = l+1\n            else:\n                r = r-1\n        return ans",
    "original_similarity": 0.18435303604038578,
    "max_corpus_similarity": 0.5595695258995999
  },
  {
    "code": "def explore(s, path, index, balance):\n  if balance < 0: return\n  if len(path) > self.maxLength: return\n\n  if index >= len(s):\n    if len(path) == self.maxLength and balance == 0:\n      self.result.append(path)\n    return\n  \n  if s[index] != '(' and s[index] != ')':\n    explore(s, path + s[index], index + 1, balance)\n  elif not path or s[index] != path[-1]:\n    explore(s, path + s[index], index + 1, balance + (1 if s[index] == '(' else -1))\n    explore(s, path, index + 1, balance)\n  elif s[index] == path[-1]:\n    explore(s, path + s[index], index + 1, balance + (1 if s[index] == '(' else -1))",
    "label": 1,
    "original_ref": "        def dfs(s, curr, i, count):\n            if count<0: return\n            if len(curr)>self.maxLen: return\n            \n            if i>=len(s):\n                if len(curr)==self.maxLen and count==0:\n                    self.ans.append(curr)\n                return\n            \n            if s[i]!='(' and s[i]!=')':\n                dfs(s, curr+s[i], i+1, count)\n            elif not curr or s[i]!=curr[-1]:\n                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))\n                dfs(s, curr, i+1, count)\n            elif s[i]==curr[-1]:\n                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))",
    "ast_similarity": 0.9999602317983239,
    "token_jaccard": 0.19642857142857142
  },
  {
    "code": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef minDiffInBST(root):\n    def inorder(node):\n        return inorder(node.left) + [node.val] + inorder(node.right) if node else []\n\n    inorder_vals = inorder(root)\n    return min(inorder_vals[i+1] - inorder_vals[i] for i in range(len(inorder_vals) - 1))\n\n# Example Usage:\n# Constructing a simple BST\n#       4\n#      / \\\n#     2   6\n#    / \\\n#   1   3\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n\nprint(minDiffInBST(root))  # Output will be 1, which is the minimum difference between adjacent nodes in the inorder traversal of the BST.",
    "label": 0,
    "original_ref": "        def dfs(s, curr, i, count):\n            if count<0: return\n            if len(curr)>self.maxLen: return\n            \n            if i>=len(s):\n                if len(curr)==self.maxLen and count==0:\n                    self.ans.append(curr)\n                return\n            \n            if s[i]!='(' and s[i]!=')':\n                dfs(s, curr+s[i], i+1, count)\n            elif not curr or s[i]!=curr[-1]:\n                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))\n                dfs(s, curr, i+1, count)\n            elif s[i]==curr[-1]:\n                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))",
    "original_similarity": 0.20405076226885985,
    "max_corpus_similarity": 0.5718280582417178
  },
  {
    "code": "def calculate_threshold(min_length: int = 50) -> int:\n    fill_counts = [1] * min_length\n    from itertools import count\n    for index in count(min_length):\n        fill_counts.append(1)        \n        for length in range(min_length, index + 1):\n            for start in range(index - length):\n                fill_counts[index] += fill_counts[index - start - length - 1]\n            fill_counts[index] += 1        \n        if fill_counts[index] > 1_000_000:\n            break\n    return index",
    "label": 1,
    "original_ref": "def solution(min_block_length: int = 50) -> int:\n    \"\"\"\n    Returns for given minimum block length the least value of n\n    for which the fill-count function first exceeds one million\n\n    >>> solution(3)\n    30\n\n    >>> solution(10)\n    57\n    \"\"\"\n\n    fill_count_functions = [1] * min_block_length\n\n    for n in count(min_block_length):\n        fill_count_functions.append(1)\n\n        for block_length in range(min_block_length, n + 1):\n            for block_start in range(n - block_length):\n                fill_count_functions[n] += fill_count_functions[\n                    n - block_start - block_length - 1\n                ]\n\n            fill_count_functions[n] += 1\n\n        if fill_count_functions[n] > 1_000_000:\n            break\n\n    return n",
    "ast_similarity": 0.9523920680205191,
    "token_jaccard": 0.2876712328767123
  },
  {
    "code": "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = {}\n\n    def add_edge(self, u, v, w):\n        if u in self.graph:\n            self.graph[u].append((v, w))\n        else:\n            self.graph[u] = [(v, w)]\n\n    def all_paths_with_cost(self, start, end, max_cost, visited, path, current_cost):\n        visited[start] = True\n        path.append(start)\n\n        if start == end and current_cost <= max_cost:\n            print(f\"Path: {path}, Cost: {current_cost}\")\n        else:\n            for (i, w) in self.graph.get(start, []):\n                if not visited.get(i, False) and current_cost + w <= max_cost:\n                    self.all_paths_with_cost(i, end, max_cost, visited, path, current_cost + w)\n\n        path.pop()\n        visited[start] = False\n\n    def find_all_paths_with_cost(self, start, end, max_cost):\n        visited = {}\n        path = []\n        self.all_paths_with_cost(start, end, max_cost, visited, path, 0)\n\n# Example usage\nif __name__ == \"__main__\":\n    g = Graph(5)\n    g.add_edge(0, 1, 10)\n    g.add_edge(0, 2, 3)\n    g.add_edge(1, 3, 2)\n    g.add_edge(2, 1, 1)\n    g.add_edge(2, 3, 8)\n    g.add_edge(3, 4, 7)\n\n    max_cost = 15\n    print(f\"Paths from 0 to 4 with cost up to {max_cost} are:\")\n    g.find_all_paths_with_cost(0, 4, max_cost)",
    "label": 0,
    "original_ref": "def solution(min_block_length: int = 50) -> int:\n    \"\"\"\n    Returns for given minimum block length the least value of n\n    for which the fill-count function first exceeds one million\n\n    >>> solution(3)\n    30\n\n    >>> solution(10)\n    57\n    \"\"\"\n\n    fill_count_functions = [1] * min_block_length\n\n    for n in count(min_block_length):\n        fill_count_functions.append(1)\n\n        for block_length in range(min_block_length, n + 1):\n            for block_start in range(n - block_length):\n                fill_count_functions[n] += fill_count_functions[\n                    n - block_start - block_length - 1\n                ]\n\n            fill_count_functions[n] += 1\n\n        if fill_count_functions[n] > 1_000_000:\n            break\n\n    return n",
    "original_similarity": 0.16319079648613394,
    "max_corpus_similarity": 0.5581562909432402
  },
  {
    "code": "def calc_binom_prob(k: int, n: int, p: float) -> float:\n\n    if k > n:raise ValueError(\"\"\"k must be lower or equal to n\"\"\")\n    if n < 0 or k < 0:raise ValueError(\"the function is defined for non-negative integers\")\n    if not isinstance(k, int) or not isinstance(n, int):raise ValueError(\"the function is defined for non-negative integers\")\n    if not 0 < p < 1:raise ValueError(\"p has to be in range of 1 - 0\")\n    prob_result = (p**k) * ((1 - p) ** (n - k))\n    coeff = float(factorial(n))\n    coeff /= factorial(k) * factorial(n - k)\n    return prob_result * coeff",
    "label": 1,
    "original_ref": "def binomial_distribution(successes: int, trials: int, prob: float) -> float:\n    \"\"\"\n    Return probability of k successes out of n tries, with p probability for one\n    success\n\n    The function uses the factorial function in order to calculate the binomial\n    coefficient\n\n    >>> binomial_distribution(3, 5, 0.7)\n    0.30870000000000003\n    >>> binomial_distribution (2, 4, 0.5)\n    0.375\n    \"\"\"\n    if successes > trials:\n        raise ValueError(\"\"\"successes must be lower or equal to trials\"\"\")\n    if trials < 0 or successes < 0:\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not isinstance(successes, int) or not isinstance(trials, int):\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not 0 < prob < 1:\n        raise ValueError(\"prob has to be in range of 1 - 0\")\n    probability = (prob**successes) * ((1 - prob) ** (trials - successes))\n    # Calculate the binomial coefficient: n! / k!(n-k)!\n    coefficient = float(factorial(trials))\n    coefficient /= factorial(successes) * factorial(trials - successes)\n    return probability * coefficient",
    "ast_similarity": 0.9757232970779698,
    "token_jaccard": 0.3418803418803419
  },
  {
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\n\nclass AutoCompleteSystem:\n    def __init__(self, words):\n        self.root = TrieNode()\n        for word in words:\n            self._insert(word)\n\n    def _insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search_by_prefix(self, prefix):\n        node = self._find_node(prefix)\n        return self._dfs(node, prefix) if node else []\n\n    def _find_node(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char in node.children:\n                node = node.children[char]\n            else:\n                return None\n        return node\n\n    def _dfs(self, node, prefix):\n        results = []\n        if node.is_end_of_word:\n            results.append(prefix)\n        for char, child in node.children.items():\n            results.extend(self._dfs(child, prefix + char))\n        return results\n\n\n# Example usage\ntrie = AutoCompleteSystem([\"dog\", \"dark\", \"cat\", \"car\", \"dart\"])\nprint(trie.search_by_prefix(\"da\"))  # ['dark', 'dart']\nprint(trie.search_by_prefix(\"c\"))   # ['cat', 'car']\nprint(trie.search_by_prefix(\"do\"))  # ['dog']",
    "label": 0,
    "original_ref": "def binomial_distribution(successes: int, trials: int, prob: float) -> float:\n    \"\"\"\n    Return probability of k successes out of n tries, with p probability for one\n    success\n\n    The function uses the factorial function in order to calculate the binomial\n    coefficient\n\n    >>> binomial_distribution(3, 5, 0.7)\n    0.30870000000000003\n    >>> binomial_distribution (2, 4, 0.5)\n    0.375\n    \"\"\"\n    if successes > trials:\n        raise ValueError(\"\"\"successes must be lower or equal to trials\"\"\")\n    if trials < 0 or successes < 0:\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not isinstance(successes, int) or not isinstance(trials, int):\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not 0 < prob < 1:\n        raise ValueError(\"prob has to be in range of 1 - 0\")\n    probability = (prob**successes) * ((1 - prob) ** (trials - successes))\n    # Calculate the binomial coefficient: n! / k!(n-k)!\n    coefficient = float(factorial(trials))\n    coefficient /= factorial(successes) * factorial(trials - successes)\n    return probability * coefficient",
    "original_similarity": 0.11112810273871304,
    "max_corpus_similarity": 0.5622055044975361
  },
  {
    "code": "def peek(self) -> Any:\n    head = self.fetch()\n    self.add(head)\n    self.shift(self.size - 1)\n    return head",
    "label": 1,
    "original_ref": "    def front(self) -> Any:\n        front = self.get()\n        self.put(front)\n        self.rotate(self.length - 1)\n        return front",
    "ast_similarity": 0.9999810034732268,
    "token_jaccard": 0.4117647058823529
  },
  {
    "code": "from collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nclass FlightGraph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u: str, v: str, cost: int):\n        self.graph[u].append((v, cost))\n    \n    def minimum_cost_path(self, start: str, end: str) -> Tuple[int, List[str]]:\n        def dfs(node: str, cost: int, path: List[str]):\n            if cost >= self.min_cost[end][0]:\n                return\n            if node == end:\n                if cost < self.min_cost[end][0]:\n                    self.min_cost[end] = (cost, path.copy())\n                return\n            visited.add(node)\n            for neighbor, flight_cost in self.graph[node]:\n                if neighbor not in visited:\n                    dfs(neighbor, cost + flight_cost, path + [neighbor])\n            visited.remove(node)\n\n        visited = set()\n        self.min_cost = {key: (float('inf'), []) for key in self.graph.keys()}\n        dfs(start, 0, [start])\n        return self.min_cost[end] if self.min_cost[end][0] != float('inf') else None\n\ndef find_min_cost_flights(flights: List[Tuple[str, str, int]], start: str, end: str) -> Tuple[int, List[str]]:\n    flight_graph = FlightGraph()\n    for u, v, c in flights:\n        flight_graph.add_edge(u, v, c)\n    return flight_graph.minimum_cost_path(start, end)\n\n# Test code\nflights_list = [\n    (\"JFK\", \"LAX\", 300),\n    (\"JFK\", \"ORD\", 150),\n    (\"ORD\", \"LAX\", 200),\n    (\"LAX\", \"HOU\", 250),\n    (\"ORD\", \"HOU\", 175)\n]\ncost, path = find_min_cost_flights(flights_list, \"JFK\", \"HOU\")\nprint(\"Minimum Cost:\", cost)\nprint(\"Path:\", path)",
    "label": 0,
    "original_ref": "    def front(self) -> Any:\n        front = self.get()\n        self.put(front)\n        self.rotate(self.length - 1)\n        return front",
    "original_similarity": 0.1014843811354954,
    "max_corpus_similarity": 0.5884559204042432
  },
  {
    "code": "def explore(seen, network, vertex):\n if vertex not in seen:\n  print(vertex, end=\" \")\n  seen.add(vertex)\n  for adjacent in network[vertex]: explore(seen, network, adjacent)",
    "label": 1,
    "original_ref": "def dfs(visited, graph, node):\n    if node not in visited:\n        print (node, end=\" \")\n        visited.add(node)\n        for neighbour in graph[node]:\n            dfs(visited, graph, neighbour)",
    "ast_similarity": 0.9999966817475767,
    "token_jaccard": 0.25
  },
  {
    "code": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef build_tree(keys):\n    def insert(root, key):\n        if root is None:\n            return TreeNode(key)\n        if key < root.value:\n            root.left = insert(root.left, key)\n        else:\n            root.right = insert(root.right, key)\n        return root\n\n    root = None\n    for key in keys:\n        root = insert(root, key)\n    return root\n\ndef longest_path_sum(tree):\n    def find_max_sum(node):\n        if node is None:\n            return (0, [])\n        \n        left_sum, left_path = find_max_sum(node.left)\n        right_sum, right_path = find_max_sum(node.right)\n\n        if left_sum > right_sum:\n            return (left_sum + node.value, left_path + [node.value])\n        else:\n            return (right_sum + node.value, right_path + [node.value])\n    \n    max_sum, path = find_max_sum(tree)\n    return max_sum, path[::-1]\n\nkeys = [5, 3, 8, 2, 4, 7, 9]\ntree = build_tree(keys)\nmax_sum, path = longest_path_sum(tree)\nprint(\"Longest Path Sum:\", max_sum)\nprint(\"Path:\", path)",
    "label": 0,
    "original_ref": "def dfs(visited, graph, node):\n    if node not in visited:\n        print (node, end=\" \")\n        visited.add(node)\n        for neighbour in graph[node]:\n            dfs(visited, graph, neighbour)",
    "original_similarity": 0.25447154436531827,
    "max_corpus_similarity": 0.5695230401492621
  },
  {
    "code": "def rearrangeSequence(self, sequence):\n    length = len(sequence)\n    if length <= 1:\n        return\n    combinations = []\n    for a in range(length):\n        for b in range(a + 1, length):\n            if sequence[a] < sequence[b]:\n                combinations.append([a, b])\n    index = 0\n    if len(combinations) > 0:\n        self.exchange(sequence, combinations[-1][0], combinations[-1][1])\n        index = combinations[-1][0] + 1\n    for a in range(index, length):\n        for b in range(a + 1, length):\n            if sequence[a] > sequence[b]:\n                self.exchange(sequence, a, b)",
    "label": 1,
    "original_ref": "    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ls = len(nums)\n        if ls <= 1:\n            return\n        pair = []\n        for i in range(ls):\n            for j in range(i + 1, ls):\n                # append ascending order pair\n                if nums[i] < nums[j]:\n                    pair.append([i,j])\n        pos = 0\n        if len(pair) > 0:\n            self.swap(nums, pair[-1][0], pair[-1][1])\n            pos = pair[-1][0] + 1\n        # sort from pos\n        for i in range(pos, ls):\n            for j in range(i + 1, ls):\n                if nums[i] > nums[j]:\n                    self.swap(nums, i, j)",
    "ast_similarity": 0.9573333957423642,
    "token_jaccard": 0.2
  },
  {
    "code": "class SudokuSolver:\n    def __init__(self, board):\n        self.board = board\n        self.size = 9\n        self.empty_cell = '0'\n\n    def solve(self):\n        if self.backtrack():\n            return self.board\n        else:\n            return None\n\n    def find_empty_location(self, l):\n        for row in range(self.size):\n            for col in range(self.size):\n                if self.board[row][col] == self.empty_cell:\n                    l[0] = row\n                    l[1] = col\n                    return True\n        return False\n\n    def used_in_row(self, row, num):\n        return any(self.board[row][col] == num for col in range(self.size))\n\n    def used_in_col(self, col, num):\n        return any(self.board[row][col] == num for row in range(self.size))\n\n    def used_in_box(self, box_start_row, box_start_col, num):\n        for i in range(3):\n            for j in range(3):\n                if self.board[i + box_start_row][j + box_start_col] == num:\n                    return True\n        return False\n\n    def is_safe(self, row, col, num):\n        return not self.used_in_row(row, num) and not self.used_in_col(col, num) and not self.used_in_box(row - row % 3, col - col % 3, num)\n\n    def backtrack(self):\n        l = [0, 0]\n        if not self.find_empty_location(l):\n            return True\n\n        row, col = l[0], l[1]\n        for num in map(str, range(1, self.size + 1)):\n            if self.is_safe(row, col, num):\n                self.board[row][col] = num\n\n                if self.backtrack():\n                    return True\n                self.board[row][col] = self.empty_cell\n        return False\n\n\nboard = [\n    ['5', '3', '0', '0', '7', '0', '0', '0', '0'],\n    ['6', '0', '0', '1', '9', '5', '0', '0', '0'],\n    ['0', '9', '8', '0', '0', '0', '0', '6', '0'],\n    ['8', '0', '0', '0', '6', '0', '0', '0', '3'],\n    ['4', '0', '0', '8', '0', '3', '0', '0', '1'],\n    ['7', '0', '0', '0', '2', '0', '0', '0', '6'],\n    ['0', '6', '0', '0', '0', '0', '2', '8', '0'],\n    ['0', '0', '0', '4', '1', '9', '0', '0', '5'],\n    ['0', '0', '0', '0', '8', '0', '0', '7', '9']\n]\n\nsolver = SudokuSolver(board)\nsolution = solver.solve()\nif solution:\n    for row in solution:\n        print(\" \".join(row))\nelse:\n    print(\"No solution exists.\")",
    "label": 0,
    "original_ref": "    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ls = len(nums)\n        if ls <= 1:\n            return\n        pair = []\n        for i in range(ls):\n            for j in range(i + 1, ls):\n                # append ascending order pair\n                if nums[i] < nums[j]:\n                    pair.append([i,j])\n        pos = 0\n        if len(pair) > 0:\n            self.swap(nums, pair[-1][0], pair[-1][1])\n            pos = pair[-1][0] + 1\n        # sort from pos\n        for i in range(pos, ls):\n            for j in range(i + 1, ls):\n                if nums[i] > nums[j]:\n                    self.swap(nums, i, j)",
    "original_similarity": 0.22405587320101175,
    "max_corpus_similarity": 0.5996488330249452
  },
  {
    "code": "def check_prime(num): \n    if num <= 1: \n        return False \n    for div in range(2, int(num**0.5) + 1): \n        if num % div == 0: \n            return False \n    return True",
    "label": 1,
    "original_ref": "def isPrime(N):\n        if N<=1:\n                return False\n        \n        for i in range(2, int(N**0.5) + 1):\n                if N%i==0:\n                        return False\n\n        return True",
    "ast_similarity": 0.9991610464238856,
    "token_jaccard": 0.4166666666666667
  },
  {
    "code": "class GridPaths:\n    def __init__(self, grid):\n        self.grid = grid\n        self.rows = len(grid)\n        self.cols = len(grid[0])\n        self.dp = [[-1 for _ in range(self.cols)] for _ in range(self.rows)]\n        \n    def num_paths(self, x=0, y=0):\n        if x == self.rows - 1 and y == self.cols - 1:\n            return 1 if self.grid[x][y] == 0 else 0\n        \n        if x >= self.rows or y >= self.cols or self.grid[x][y] == 1:\n            return 0\n        \n        if self.dp[x][y] != -1:\n            return self.dp[x][y]\n        \n        right_paths = self.num_paths(x, y + 1)\n        down_paths = self.num_paths(x + 1, y)\n        \n        self.dp[x][y] = right_paths + down_paths\n        return self.dp[x][y]\n\n# Example of usage\ngrid = [\n    [0, 0, 0],\n    [0, 1, 0],\n    [0, 0, 0]\n]\ngp = GridPaths(grid)\nprint(gp.num_paths())  # Output: 2",
    "label": 0,
    "original_ref": "def isPrime(N):\n        if N<=1:\n                return False\n        \n        for i in range(2, int(N**0.5) + 1):\n                if N%i==0:\n                        return False\n\n        return True",
    "original_similarity": 0.1380111606028516,
    "max_corpus_similarity": 0.5636818172189109
  },
  {
    "code": "def convert_length(val: float, src_unit: str, tgt_unit: str) -> float: \n    new_src = src_unit.lower().rstrip(\"s\")\n    new_tgt = tgt_unit.lower().rstrip(\"s\")\n    new_src = UNIT_MAP.get(new_src, new_src)\n    new_tgt = UNIT_MAP.get(new_tgt, new_tgt)\n    if new_src not in CONVERSION_FACTORS: \n        err_msg = (f\"Invalid 'src_unit' value: {src_unit!r}.\\n\"\n                   f\"Conversion abbreviations are: {', '.join(CONVERSION_FACTORS)}\")\n        raise ValueError(err_msg)\n    if new_tgt not in CONVERSION_FACTORS:\n        err_msg = (f\"Invalid 'tgt_unit' value: {tgt_unit!r}.\\n\"\n                   f\"Conversion abbreviations are: {', '.join(CONVERSION_FACTORS)}\")\n        raise ValueError(err_msg)\n    return (val * CONVERSION_FACTORS[new_src].from_factor \n                * CONVERSION_FACTORS[new_tgt].to_factor)",
    "label": 1,
    "original_ref": "def length_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between length units.\n\n    >>> length_conversion(4, \"METER\", \"FEET\")\n    13.12336\n    >>> length_conversion(4, \"M\", \"FT\")\n    13.12336\n    >>> length_conversion(1, \"meter\", \"kilometer\")\n    0.001\n    >>> length_conversion(1, \"kilometer\", \"inch\")\n    39370.1\n    >>> length_conversion(3, \"kilometer\", \"mile\")\n    1.8641130000000001\n    >>> length_conversion(2, \"feet\", \"meter\")\n    0.6096\n    >>> length_conversion(4, \"feet\", \"yard\")\n    1.333329312\n    >>> length_conversion(1, \"inch\", \"meter\")\n    0.0254\n    >>> length_conversion(2, \"inch\", \"mile\")\n    3.15656468e-05\n    >>> length_conversion(2, \"centimeter\", \"millimeter\")\n    20.0\n    >>> length_conversion(2, \"centimeter\", \"yard\")\n    0.0218722\n    >>> length_conversion(4, \"yard\", \"meter\")\n    3.6576\n    >>> length_conversion(4, \"yard\", \"kilometer\")\n    0.0036576\n    >>> length_conversion(3, \"foot\", \"meter\")\n    0.9144000000000001\n    >>> length_conversion(3, \"foot\", \"inch\")\n    36.00001944\n    >>> length_conversion(4, \"mile\", \"kilometer\")\n    6.43736\n    >>> length_conversion(2, \"miles\", \"InChEs\")\n    126719.753468\n    >>> length_conversion(3, \"millimeter\", \"centimeter\")\n    0.3\n    >>> length_conversion(3, \"mm\", \"in\")\n    0.1181103\n    >>> length_conversion(4, \"wrongUnit\", \"inch\")\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\n    Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi\n    \"\"\"\n    new_from = from_type.lower().rstrip(\"s\")\n    new_from = TYPE_CONVERSION.get(new_from, new_from)\n    new_to = to_type.lower().rstrip(\"s\")\n    new_to = TYPE_CONVERSION.get(new_to, new_to)\n    if new_from not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if new_to not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    return (\n        value\n        * METRIC_CONVERSION[new_from].from_factor\n        * METRIC_CONVERSION[new_to].to_factor\n    )",
    "ast_similarity": 0.9900854599842477,
    "token_jaccard": 0.1323529411764706
  },
  {
    "code": "class City:\n    def __init__(self, name):\n        self.name = name\n        self.neighbors = {}\n\nclass RouteManager:\n    def __init__(self):\n        self.cities = {}\n    \n    def add_city(self, name):\n        if name not in self.cities:\n            self.cities[name] = City(name)\n    \n    def add_route(self, from_city, to_city, distance):\n        if from_city not in self.cities or to_city not in self.cities:\n            raise ValueError(\"City not found in the network.\")\n        self.cities[from_city].neighbors[to_city] = distance\n    \n    def shortest_path(self, start_city):\n        if start_city not in self.cities:\n            raise ValueError(\"City not found in the network.\")\n        \n        distances = {city: float('inf') for city in self.cities}\n        distances[start_city] = 0\n        visited = set()\n\n        while len(visited) < len(self.cities):\n            current_city = min((city for city in self.cities if city not in visited), key=lambda city: distances[city])\n            visited.add(current_city)\n            current_distance = distances[current_city]\n\n            for neighbor, distance in self.cities[current_city].neighbors.items():\n                if neighbor not in visited:\n                    new_distance = current_distance + distance\n                    if new_distance < distances[neighbor]:\n                        distances[neighbor] = new_distance\n        \n        return distances\n\n# Example usage\nroute_manager = RouteManager()\nroute_manager.add_city(\"A\")\nroute_manager.add_city(\"B\")\nroute_manager.add_city(\"C\")\nroute_manager.add_city(\"D\")\nroute_manager.add_route(\"A\", \"B\", 5)\nroute_manager.add_route(\"A\", \"C\", 10)\nroute_manager.add_route(\"B\", \"C\", 2)\nroute_manager.add_route(\"C\", \"D\", 1)\n\ndistances_from_A = route_manager.shortest_path(\"A\")\nprint(distances_from_A)  # Example output: {'A': 0, 'B': 5, 'C': 7, 'D': 8}",
    "label": 0,
    "original_ref": "def length_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between length units.\n\n    >>> length_conversion(4, \"METER\", \"FEET\")\n    13.12336\n    >>> length_conversion(4, \"M\", \"FT\")\n    13.12336\n    >>> length_conversion(1, \"meter\", \"kilometer\")\n    0.001\n    >>> length_conversion(1, \"kilometer\", \"inch\")\n    39370.1\n    >>> length_conversion(3, \"kilometer\", \"mile\")\n    1.8641130000000001\n    >>> length_conversion(2, \"feet\", \"meter\")\n    0.6096\n    >>> length_conversion(4, \"feet\", \"yard\")\n    1.333329312\n    >>> length_conversion(1, \"inch\", \"meter\")\n    0.0254\n    >>> length_conversion(2, \"inch\", \"mile\")\n    3.15656468e-05\n    >>> length_conversion(2, \"centimeter\", \"millimeter\")\n    20.0\n    >>> length_conversion(2, \"centimeter\", \"yard\")\n    0.0218722\n    >>> length_conversion(4, \"yard\", \"meter\")\n    3.6576\n    >>> length_conversion(4, \"yard\", \"kilometer\")\n    0.0036576\n    >>> length_conversion(3, \"foot\", \"meter\")\n    0.9144000000000001\n    >>> length_conversion(3, \"foot\", \"inch\")\n    36.00001944\n    >>> length_conversion(4, \"mile\", \"kilometer\")\n    6.43736\n    >>> length_conversion(2, \"miles\", \"InChEs\")\n    126719.753468\n    >>> length_conversion(3, \"millimeter\", \"centimeter\")\n    0.3\n    >>> length_conversion(3, \"mm\", \"in\")\n    0.1181103\n    >>> length_conversion(4, \"wrongUnit\", \"inch\")\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\n    Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi\n    \"\"\"\n    new_from = from_type.lower().rstrip(\"s\")\n    new_from = TYPE_CONVERSION.get(new_from, new_from)\n    new_to = to_type.lower().rstrip(\"s\")\n    new_to = TYPE_CONVERSION.get(new_to, new_to)\n    if new_from not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if new_to not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    return (\n        value\n        * METRIC_CONVERSION[new_from].from_factor\n        * METRIC_CONVERSION[new_to].to_factor\n    )",
    "original_similarity": 0.1873627640513248,
    "max_corpus_similarity": 0.4796401645498095
  },
  {
    "code": "def contains_one(n):\n if not n: return False\n l_has_one = contains_one(n.left)\n r_has_one = contains_one(n.right)\n if not l_has_one: n.left = None\n if not r_has_one: n.right = None\n return n.val==1 or l_has_one or r_has_one",
    "label": 1,
    "original_ref": "        def hasOne(node):\n            if not node: return False\n\n            left_has_one = hasOne(node.left)\n            right_has_one = hasOne(node.right)\n\n            if not left_has_one: node.left = None\n            if not right_has_one: node.right = None\n\n            return node.val==1 or left_has_one or right_has_one",
    "ast_similarity": 0.9993874165987576,
    "token_jaccard": 0.26666666666666666
  },
  {
    "code": "class Graph:\n    def __init__(self, vertices):\n        self.graph = {i: [] for i in range(vertices)}\n        self.V = vertices\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbor in self.graph[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False\n\ndef find_longest_path(graph):\n    def dfs(node, visited, dp):\n        if visited[node]:\n            return dp[node]\n        \n        visited[node] = True\n        max_length = 0\n        \n        for neighbor in graph[node]:\n            current_length = dfs(neighbor, visited, dp)\n            max_length = max(max_length, current_length)\n        \n        dp[node] = 1 + max_length\n        return dp[node]\n\n    visited = [False] * len(graph.graph)\n    dp = [0] * len(graph.graph)\n\n    longest_path = 0\n\n    for node in range(len(graph.graph)):\n        if not visited[node]:\n            current_length = dfs(node, visited, dp)\n            longest_path = max(longest_path, current_length)\n\n    return longest_path\n\n# Example Usage\ng = Graph(6)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 3)\ng.add_edge(2, 4)\ng.add_edge(4, 5)\n\nprint(\"Graph contains cycle:\", g.is_cyclic())\nprint(\"Longest path length in DAG:\", find_longest_path(g))",
    "label": 0,
    "original_ref": "        def hasOne(node):\n            if not node: return False\n\n            left_has_one = hasOne(node.left)\n            right_has_one = hasOne(node.right)\n\n            if not left_has_one: node.left = None\n            if not right_has_one: node.right = None\n\n            return node.val==1 or left_has_one or right_has_one",
    "original_similarity": 0.19645983970229985,
    "max_corpus_similarity": 0.5426749274205425
  },
  {
    "code": "def compute_product(number: int) -> int:\n      result = 1\n    for index in range(1, number + 1): result *= index\n    return result",
    "label": 1,
    "original_ref": "def factorial(num: int) -> int:\n    \"\"\"Find the factorial of a given number n\"\"\"\n    fact = 1\n    for i in range(1, num + 1):\n        fact *= i\n    return fact",
    "ast_similarity": 0.9677045624207617,
    "token_jaccard": 0.5
  },
  {
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def add_word(self, word: str):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search_helper(self, word: str, node: TrieNode) -> bool:\n        for i, char in enumerate(word):\n            if char == '.':\n                for child in node.children.values():\n                    if self.search_helper(word[i+1:], child):\n                        return True\n                return False\n            else:\n                if char not in node.children:\n                    return False\n                node = node.children[char]\n        return node.is_end_of_word\n\n    def search(self, word: str) -> bool:\n        return self.search_helper(word, self.root)\n\ndef main():\n    wd = WordDictionary()\n    wd.add_word(\"cat\")\n    wd.add_word(\"bat\")\n    wd.add_word(\"rat\")\n    \n    print(wd.search(\"cat\"))  # True\n    print(wd.search(\"bat\"))  # True\n    print(wd.search(\"rat\"))  # True\n    print(wd.search(\"c.t\"))  # True\n    print(wd.search(\"r.t\"))  # True\n    print(wd.search(\"dog\"))  # False\n    \nif __name__ == \"__main__\":\n    main()",
    "label": 0,
    "original_ref": "def factorial(num: int) -> int:\n    \"\"\"Find the factorial of a given number n\"\"\"\n    fact = 1\n    for i in range(1, num + 1):\n        fact *= i\n    return fact",
    "original_similarity": 0.06348068859251495,
    "max_corpus_similarity": 0.5768866764210054
  },
  {
    "code": "def calculateMinimumCost(self, expenses):\n        def recursiveFunction(index):\n            if index in memoization: return memoization[index]\n            if index > len(expenses) - 1:\n                memoization[index] = 0\n            elif index == len(expenses) - 1 or index == len(expenses) - 2:\n                memoization[index] = expenses[index]\n            elif index < len(expenses) - 2:\n                memoization[index] = expenses[index] + min(recursiveFunction(index + 1), recursiveFunction(index + 2))\n            return memoization[index]\n        \n        memoization = {}\n        return min(recursiveFunction(0), recursiveFunction(1))",
    "label": 1,
    "original_ref": "    def minCostClimbingStairs(self, cost):\n        def helper(i):\n            if i in history: return history[i]\n            \n            if i>len(cost)-1:\n                history[i] = 0\n            elif i==len(cost)-1 or i==len(cost)-2:\n                history[i] = cost[i]\n            elif i<len(cost)-2:\n                history[i] = cost[i] + min(helper(i+1), helper(i+2))\n                \n            return history[i]\n        \n        history = {}\n        return min(helper(0), helper(1))",
    "ast_similarity": 0.9999881203276209,
    "token_jaccard": 0.20833333333333334
  },
  {
    "code": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(root, left=float('-inf'), right=float('inf')):\n    if not root:\n        return True\n    if not (left < root.value < right):\n        return False\n    return (is_valid_bst(root.left, left, root.value) and\n            is_valid_bst(root.right, root.value, right))\n\ndef construct_minimal_bst(sorted_list):\n    if not sorted_list:\n        return None\n\n    mid_index = len(sorted_list) // 2\n    node = TreeNode(sorted_list[mid_index])\n\n    node.left = construct_minimal_bst(sorted_list[:mid_index])\n    node.right = construct_minimal_bst(sorted_list[mid_index + 1:])\n\n    return node\n\ndef find_max_bst_path_sum(root):\n    def helper(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        left_gain = max(helper(node.left), 0)\n        right_gain = max(helper(node.right), 0)\n        current_path_sum = node.value + left_gain + right_gain\n        max_sum = max(max_sum, current_path_sum)\n        return node.value + max(left_gain, right_gain)\n\n    max_sum = float('-inf')\n    helper(root)\n    return max_sum\n\nif __name__ == '__main__':\n    sorted_list = [-10, -3, 0, 5, 9]\n    bst_root = construct_minimal_bst(sorted_list)\n    \n    print(\"Is Valid BST:\", is_valid_bst(bst_root))\n    print(\"Max BST Path Sum:\", find_max_bst_path_sum(bst_root))",
    "label": 0,
    "original_ref": "    def minCostClimbingStairs(self, cost):\n        def helper(i):\n            if i in history: return history[i]\n            \n            if i>len(cost)-1:\n                history[i] = 0\n            elif i==len(cost)-1 or i==len(cost)-2:\n                history[i] = cost[i]\n            elif i<len(cost)-2:\n                history[i] = cost[i] + min(helper(i+1), helper(i+2))\n                \n            return history[i]\n        \n        history = {}\n        return min(helper(0), helper(1))",
    "original_similarity": 0.31019799199147896,
    "max_corpus_similarity": 0.5734775911100181
  },
  {
    "code": "def combineTwoLinkedLists(self, firstList: Optional[ListNode], secondList: Optional[ListNode]) -> Optional[ListNode]:\n  initialNode = ListNode()\n  currentNode = initialNode\n  while firstList and secondList:\n      if firstList.val < secondList.val:\n          currentNode.next = firstList\n          firstList = firstList.next\n      else:\n          currentNode.next = secondList\n          secondList = secondList.next\n      currentNode = currentNode.next\n  currentNode.next = firstList or secondList\n  return initialNode.next",
    "label": 1,
    "original_ref": "    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        head = ListNode() #dummy\n        node = head\n        while list1 and list2:\n            if list1.val<list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n        \n        node.next = list1 or list2\n        return head.next",
    "ast_similarity": 0.9837049819991758,
    "token_jaccard": 0.325
  },
  {
    "code": "from collections import defaultdict\nfrom typing import Dict, List\n\nclass Graph:\n    def __init__(self, vertices: int):\n        self.graph: Dict[int, List[int]] = defaultdict(list)\n        self.V = vertices\n\n    def add_edge(self, u: int, v: int):\n        self.graph[u].append(v)\n\n    def find_cycle_util(self, v: int, visited: List[bool], rec_stack: List[bool]) -> bool:\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbor in self.graph[v]:\n            if not visited[neighbor]:\n                if self.find_cycle_util(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def has_cycle(self) -> bool:\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n        for node in range(self.V):\n            if not visited[node]:\n                if self.find_cycle_util(node, visited, rec_stack):\n                    return True\n        return False\n\ndef main():\n    g = Graph(4)\n    g.add_edge(0, 1)\n    g.add_edge(1, 2)\n    g.add_edge(2, 3)\n    g.add_edge(3, 1)\n    print(\"Graph has cycle:\", g.has_cycle())\n\nif __name__ == \"__main__\":\n    main()",
    "label": 0,
    "original_ref": "    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        head = ListNode() #dummy\n        node = head\n        while list1 and list2:\n            if list1.val<list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n        \n        node.next = list1 or list2\n        return head.next",
    "original_similarity": 0.17564952983289,
    "max_corpus_similarity": 0.5706900739780165
  },
  {
    "code": "def computeLongestIncreasingSubsequence(self, sequence):\n  size = len(sequence)\n  subsequence = []\n  for element in sequence:\n    position = bisect.bisect_left(subsequence, element)\n    if position == len(subsequence):\n      subsequence.append(element)\n    else:\n      subsequence[position] = element\n  return len(subsequence)",
    "label": 1,
    "original_ref": "    def lengthOfLIS(self, nums):\n        N = len(nums)\n        dp = []\n        \n        for n in nums:\n            i = bisect.bisect_left(dp, n)\n            \n            if i==len(dp):\n                dp.append(n)\n            else:\n                dp[i] = n\n        \n        return len(dp)",
    "ast_similarity": 0.9999707710701705,
    "token_jaccard": 0.21621621621621623
  },
  {
    "code": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef find_path(root, path, k):\n    if root is None:\n        return False\n    path.append(root.val)\n    if root.val == k:\n        return True\n    if ((root.left is not None and find_path(root.left, path, k)) or\n            (root.right is not None and find_path(root.right, path, k))):\n        return True\n    path.pop()\n    return False\n\ndef find_lca(root, n1, n2):\n    path1 = []\n    path2 = []\n    if (not find_path(root, path1, n1) or not find_path(root, path2, n2)):\n        return -1\n    i = 0\n    while (i < len(path1) and i < len(path2)):\n        if path1[i] != path2[i]:\n            break\n        i += 1\n    return path1[i-1]\n\ndef build_tree(edges):\n    root = TreeNode(edges[0][0])\n    for edge in edges:\n        insert(root, edge[0])\n        insert(root, edge[1])\n    return root\n\nedges = [(20, 8), (20, 22), (8, 4), (8, 12), (12, 10), (12, 14)]\nn1, n2 = 10, 14\nroot = build_tree(edges)\nprint(f\"LCA of {n1} and {n2} is {find_lca(root, n1, n2)}\")",
    "label": 0,
    "original_ref": "    def lengthOfLIS(self, nums):\n        N = len(nums)\n        dp = []\n        \n        for n in nums:\n            i = bisect.bisect_left(dp, n)\n            \n            if i==len(dp):\n                dp.append(n)\n            else:\n                dp[i] = n\n        \n        return len(dp)",
    "original_similarity": 0.23995670017044868,
    "max_corpus_similarity": 0.5662686286015288
  },
  {
    "code": "def calc_geo_mean(values: list) -> float:\n\n    if not isinstance(values, list): raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n\n    if len(values) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n\n    product = 1\n\n    for num in values: product *= num\n\n    return pow(product, 1 / len(values))",
    "label": 1,
    "original_ref": "def geometric_mean(series: list) -> float:\n    \"\"\"\n    return the geometric mean of series\n\n    >>> geometric_mean([2, 4, 8])\n    3.9999999999999996\n    >>> geometric_mean([3, 6, 12, 24])\n    8.48528137423857\n    >>> geometric_mean([4, 8, 16])\n    7.999999999999999\n    >>> geometric_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\n    >>> geometric_mean([1, 2, 3])\n    1.8171205928321397\n    >>> geometric_mean([0, 2, 3])\n    0.0\n    >>> geometric_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 1\n    for value in series:\n        answer *= value\n    return pow(answer, 1 / len(series))",
    "ast_similarity": 0.9648230120956554,
    "token_jaccard": 0.39285714285714285
  },
  {
    "code": "class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef construct_bst(preorder):\n    if not preorder:\n        return None\n\n    root = Node(preorder[0])\n    stack = [root]\n\n    for val in preorder[1:]:\n        node = None\n\n        while stack and stack[-1].key < val:\n            node = stack.pop()\n\n        if node:\n            node.right = Node(val)\n            stack.append(node.right)\n        else:\n            stack[-1].left = Node(val)\n            stack.append(stack[-1].left)\n\n    return root\n\ndef inorder_traversal(root):\n    return inorder_traversal(root.left) + [root.key] + inorder_traversal(root.right) if root else []\n\ndef unique_bst_count(preorder):\n    if not preorder:\n        return 0\n\n    def count_unique_bsts(low, high):\n        if low > high:\n            return 1\n        total_count = 0\n\n        for i in range(low, high + 1):\n            left_count = count_unique_bsts(low, i - 1)\n            right_count = count_unique_bsts(i + 1, high)\n            total_count += left_count * right_count\n\n        return total_count\n\n    return count_unique_bsts(0, len(preorder) - 1)\n\n# Test cases\npreorder_sequence = [8, 5, 1, 7, 10, 12]\nroot = construct_bst(preorder_sequence)\ninorder_output = inorder_traversal(root)\nprint(\"Inorder traversal of constructed BST:\", inorder_output)\ntotal_unique_bsts = unique_bst_count(preorder_sequence)\nprint(\"Total unique BSTs that can be created with the given preorder sequence:\", total_unique_bsts)",
    "label": 0,
    "original_ref": "def geometric_mean(series: list) -> float:\n    \"\"\"\n    return the geometric mean of series\n\n    >>> geometric_mean([2, 4, 8])\n    3.9999999999999996\n    >>> geometric_mean([3, 6, 12, 24])\n    8.48528137423857\n    >>> geometric_mean([4, 8, 16])\n    7.999999999999999\n    >>> geometric_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\n    >>> geometric_mean([1, 2, 3])\n    1.8171205928321397\n    >>> geometric_mean([0, 2, 3])\n    0.0\n    >>> geometric_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 1\n    for value in series:\n        answer *= value\n    return pow(answer, 1 / len(series))",
    "original_similarity": 0.1095458515511123,
    "max_corpus_similarity": 0.5604474325915427
  },
  {
    "code": "def find_left_child_index(idx: int) -> int:\n return (2 * idx) + 1",
    "label": 1,
    "original_ref": "def get_child_left_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the left child of the current node\n\n    >>> get_child_left_position(0)\n    1\n    \"\"\"\n    return (2 * position) + 1",
    "ast_similarity": 0.9417730987577295,
    "token_jaccard": 0.3333333333333333
  },
  {
    "code": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef find_peak_elements(root):\n    if not root:\n        return []\n\n    result = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        is_peak = True\n        if node.left and node.left.value >= node.value:\n            is_peak = False\n        if node.right and node.right.value >= node.value:\n            is_peak = False\n\n        if is_peak:\n            result.append(node.value)\n\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n    return result\n\n# Helper function to insert nodes in the binary tree\ndef insert_node(root, value):\n    if root is None:\n        return TreeNode(value)\n\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node.left is None:\n            node.left = TreeNode(value)\n            break\n        else:\n            queue.append(node.left)\n\n        if node.right is None:\n            node.right = TreeNode(value)\n            break\n        else:\n            queue.append(node.right)\n\n    return root\n\n# Helper function to create a binary tree from a list of values\ndef create_tree(values):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    for value in values[1:]:\n        insert_node(root, value)\n    return root\n\n# Example usage\nif __name__ == \"__main__\":\n    values = [10, 8, 15, 3, 9, 12, 20]\n    tree_root = create_tree(values)\n    peak_elements = find_peak_elements(tree_root)\n    print(\"Peak elements in the binary tree:\", peak_elements)",
    "label": 0,
    "original_ref": "def get_child_left_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the left child of the current node\n\n    >>> get_child_left_position(0)\n    1\n    \"\"\"\n    return (2 * position) + 1",
    "original_similarity": 0.2794557176871111,
    "max_corpus_similarity": 0.549482713718906
  },
  {
    "code": "def insert(\n        self,\n        operation_kind: OpType,\n        arguments: list[Variable],\n        result: Variable,\n        additional_args: dict | None = None,\n    ) -> None:\n        op_instance = Operation(operation_kind, other_params=additional_args)\n        argument_nodes = []\n        for argument in arguments:\n            argument.add_param_to(op_instance)\n            argument_nodes.append(argument)\n        op_instance.add_params(argument_nodes)\n\n        result.add_result_of(op_instance)\n        op_instance.add_output(result)",
    "label": 1,
    "original_ref": "    def append(\n        self,\n        op_type: OpType,\n        params: list[Variable],\n        output: Variable,\n        other_params: dict | None = None,\n    ) -> None:\n        \"\"\"\n        Adds Operation object to the related Variable objects for\n        creating computational graph for calculating gradients.\n\n        Args:\n            op_type: Operation type\n            params: Input parameters to the operation\n            output: Output variable of the operation\n        \"\"\"\n        operation = Operation(op_type, other_params=other_params)\n        param_nodes = []\n        for param in params:\n            param.add_param_to(operation)\n            param_nodes.append(param)\n        output.add_result_of(operation)\n\n        operation.add_params(param_nodes)\n        operation.add_output(output)",
    "ast_similarity": 0.9733773116278452,
    "token_jaccard": 0.23880597014925373
  },
  {
    "code": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef find_LCA(root, n1, n2):\n    if root is None:\n        return None\n\n    if root.val > n1 and root.val > n2:\n        return find_LCA(root.left, n1, n2)\n\n    if root.val < n1 and root.val < n2:\n        return find_LCA(root.right, n1, n2)\n\n    return root\n\ndef in_order_traversal(root):\n    def inorder(node):\n        if not node:\n            return\n        inorder(node.left)\n        traversal.append(node.val)\n        inorder(node.right)\n    \n    traversal = []\n    inorder(root)\n    return traversal\n\ndef level_order_traversal(root):\n    if not root:\n        return []\n\n    queue = [root]\n    levels = []\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.pop(0)\n            current_level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        levels.append(current_level)\n\n    return levels\n\nif __name__ == \"__main__\":\n    keys = [20, 8, 22, 4, 12, 10, 14]\n    root = None\n    for key in keys:\n        root = insert(root, key)\n\n    print(\"In-order traversal:\", in_order_traversal(root))\n    print(\"Level-order traversal:\", level_order_traversal(root))\n\n    n1, n2 = 10, 14\n    t = find_LCA(root, n1, n2)\n    print(f\"LCA of {n1} and {n2} is {t.val}\")\n\n    n1, n2 = 14, 8\n    t = find_LCA(root, n1, n2)\n    print(f\"LCA of {n1} and {n2} is {t.val}\")\n\n    n1, n2 = 10, 22\n    t = find_LCA(root, n1, n2)\n    print(f\"LCA of {n1} and {n2} is {t.val}\")",
    "label": 0,
    "original_ref": "    def append(\n        self,\n        op_type: OpType,\n        params: list[Variable],\n        output: Variable,\n        other_params: dict | None = None,\n    ) -> None:\n        \"\"\"\n        Adds Operation object to the related Variable objects for\n        creating computational graph for calculating gradients.\n\n        Args:\n            op_type: Operation type\n            params: Input parameters to the operation\n            output: Output variable of the operation\n        \"\"\"\n        operation = Operation(op_type, other_params=other_params)\n        param_nodes = []\n        for param in params:\n            param.add_param_to(operation)\n            param_nodes.append(param)\n        output.add_result_of(operation)\n\n        operation.add_params(param_nodes)\n        operation.add_output(output)",
    "original_similarity": 0.1608406314941785,
    "max_corpus_similarity": 0.5966907806540417
  },
  {
    "code": "def trimArb(self, rootNode):\n        def containsOne(currNode):\n            if not currNode: return False\n            l_contains = containsOne(currNode.left)\n            r_contains = containsOne(currNode.right)\n            if not l_contains: currNode.left = None\n            if not r_contains: currNode.right = None\n            return currNode.val==1 or l_contains or r_contains\n        \n        return rootNode if containsOne(rootNode) else None",
    "label": 1,
    "original_ref": "    def pruneTree(self, root):\n        def hasOne(node):\n            if not node: return False\n\n            left_has_one = hasOne(node.left)\n            right_has_one = hasOne(node.right)\n\n            if not left_has_one: node.left = None\n            if not right_has_one: node.right = None\n\n            return node.val==1 or left_has_one or right_has_one\n        \n        return root if hasOne(root) else None",
    "ast_similarity": 0.9998049708089369,
    "token_jaccard": 0.23076923076923078
  },
  {
    "code": "class DisjointSet:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v):\n        rootU = self.find(u)\n        rootV = self.find(v)\n        if rootU != rootV:\n            if self.rank[rootU] < self.rank[rootV]:\n                self.parent[rootU] = rootV\n            elif self.rank[rootU] > self.rank[rootV]:\n                self.parent[rootV] = rootU\n            else:\n                self.parent[rootV] = rootU\n                self.rank[rootU] += 1\n\ndef countIslands(grid):\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    dsu = DisjointSet(rows * cols)\n\n    def index(r, c):\n        return r * cols + c\n\n    directions = [(1, 0), (0, 1)]\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1:\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                        dsu.union(index(r, c), index(nr, nc))\n\n    root_set = set(dsu.find(index(r, c)) for r in range(rows) for c in range(cols) if grid[r][c] == 1)\n    return len(root_set)\n\n# Example usage:\ngrid = [\n    [1, 1, 0, 0],\n    [0, 1, 0, 1],\n    [1, 0, 0, 0],\n    [0, 0, 1, 1]\n]\nprint(countIslands(grid))  # Output: 3",
    "label": 0,
    "original_ref": "    def pruneTree(self, root):\n        def hasOne(node):\n            if not node: return False\n\n            left_has_one = hasOne(node.left)\n            right_has_one = hasOne(node.right)\n\n            if not left_has_one: node.left = None\n            if not right_has_one: node.right = None\n\n            return node.val==1 or left_has_one or right_has_one\n        \n        return root if hasOne(root) else None",
    "original_similarity": 0.1935656265152484,
    "max_corpus_similarity": 0.5924691702329866
  },
  {
    "code": "def findNearest(self, coordinates, num):\n return heapq.nsmallest(num, coordinates, key=lambda point: point[0]**2 + point[1]**2)",
    "label": 1,
    "original_ref": "    def kClosest(self, points, K):\n        # K smallest heaq\n        return heapq.nsmallest(K, points, key=lambda x: x[0] ** 2 + x[1] ** 2)",
    "ast_similarity": 0.9551684772202169,
    "token_jaccard": 0.16
  },
  {
    "code": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef construct_bst_from_sorted_array(arr):\n    if not arr:\n        return None\n    \n    mid = len(arr) // 2\n    root = TreeNode(arr[mid])\n    root.left = construct_bst_from_sorted_array(arr[:mid])\n    root.right = construct_bst_from_sorted_array(arr[mid+1:])\n    \n    return root\n\ndef find_min_path_sum(root):\n    if root is None:\n        return 0\n    \n    left_sum = find_min_path_sum(root.left)\n    right_sum = find_min_path_sum(root.right)\n    \n    if root.left is None:\n        return right_sum + root.val\n    if root.right is None:\n        return left_sum + root.val\n    \n    return min(left_sum, right_sum) + root.val\n\ndef get_minimum_path_sum(arr):\n    bst_root = construct_bst_from_sorted_array(arr)\n    return find_min_path_sum(bst_root)\n\n# Example usage:\nsorted_array = [2, 3, 5, 7, 11, 13, 17, 19]\nmin_path_sum = get_minimum_path_sum(sorted_array)\nprint(\"Minimum path sum in BST:\", min_path_sum)",
    "label": 0,
    "original_ref": "    def kClosest(self, points, K):\n        # K smallest heaq\n        return heapq.nsmallest(K, points, key=lambda x: x[0] ** 2 + x[1] ** 2)",
    "original_similarity": 0.1551675734888261,
    "max_corpus_similarity": 0.5484593151699203
  },
  {
    "code": "def execute():\n import argparse as ap\n arg_handler = ap.ArgumentParser()\n arg_handler.add_argument(\"-m\", \"--memory\", help=\"amount of memory to use for sorting\", default=\"100M\")\n arg_handler.add_argument(\"file\", metavar=\"<filename>\", nargs=1, help=\"name of file to sort\")\n parameters = arg_handler.parse_args()\n sorting_machine = ExternalSort(parse_memory(parameters.memory))\n sorting_machine.sort(parameters.file[0])",
    "label": 1,
    "original_ref": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-m\", \"--mem\", help=\"amount of memory to use for sorting\", default=\"100M\"\n    )\n    parser.add_argument(\n        \"filename\", metavar=\"<filename>\", nargs=1, help=\"name of file to sort\"\n    )\n    args = parser.parse_args()\n\n    sorter = ExternalSort(parse_memory(args.mem))\n    sorter.sort(args.filename[0])",
    "ast_similarity": 0.9225274638874261,
    "token_jaccard": 0.28888888888888886
  },
  {
    "code": "class Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, key, value):\n        if self.root is None:\n            self.root = Node(key, value)\n        else:\n            self._insert(self.root, key, value)\n    \n    def _insert(self, current_node, key, value):\n        if key < current_node.key:\n            if current_node.left is None:\n                current_node.left = Node(key, value)\n            else:\n                self._insert(current_node.left, key, value)\n        elif key > current_node.key:\n            if current_node.right is None:\n                current_node.right = Node(key, value)\n            else:\n                self._insert(current_node.right, key, value)\n        else:\n            current_node.value = value\n    \n    def find(self, key):\n        return self._find(self.root, key)\n    \n    def _find(self, current_node, key):\n        if current_node is None:\n            return None\n        if key < current_node.key:\n            return self._find(current_node.left, key)\n        elif key > current_node.key:\n            return self._find(current_node.right, key)\n        else:\n            return current_node.value\n    \n    def traverse(self):\n        result = []\n        self._traverse_in_order(self.root, result)\n        return result\n    \n    def _traverse_in_order(self, node, result):\n        if node is not None:\n            self._traverse_in_order(node.left, result)\n            result.append((node.key, node.value))\n            self._traverse_in_order(node.right, result)\n    \nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = dict()\n        self.access_order = BinarySearchTree()\n        self.current_size = 0\n        self.clock = 0\n        \n    def get(self, key):\n        if key in self.cache:\n            self._update_access_order(key)\n            return self.cache[key]\n        else:\n            return -1\n    \n    def put(self, key, value):\n        if key not in self.cache and self.current_size >= self.capacity:\n            self._evict_least_recently_used()\n        if key not in self.cache:\n            self.current_size += 1\n        self.cache[key] = value\n        self._update_access_order(key)\n        \n    def _update_access_order(self, key):\n        self.access_order.insert(self.clock, key)\n        self.clock += 1\n        \n    def _evict_least_recently_used(self):\n        access_order_list = self.access_order.traverse()\n        _, lru_key = access_order_list[0]\n        del self.cache[lru_key]\n        self.current_size -= 1\n\n# Example usage\ncache = LRUCache(2)\ncache.put(1, 'A')\ncache.put(2, 'B')\nprint(cache.get(1)) # Outputs: 'A'\ncache.put(3, 'C')    # Evicts key 2\nprint(cache.get(2)) # Outputs: -1\ncache.put(4, 'D')    # Evicts key 1\nprint(cache.get(1)) # Outputs: -1\nprint(cache.get(3)) # Outputs: 'C'\nprint(cache.get(4)) # Outputs: 'D'",
    "label": 0,
    "original_ref": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-m\", \"--mem\", help=\"amount of memory to use for sorting\", default=\"100M\"\n    )\n    parser.add_argument(\n        \"filename\", metavar=\"<filename>\", nargs=1, help=\"name of file to sort\"\n    )\n    args = parser.parse_args()\n\n    sorter = ExternalSort(parse_memory(args.mem))\n    sorter.sort(args.filename[0])",
    "original_similarity": 0.2023339473408085,
    "max_corpus_similarity": 0.561970368350041
  },
  {
    "code": "def detach_element_links(element: Node) -> None:\n  if element.next:\n     element.next.prev = element.prev\n  if element.prev:\n     element.prev.next = element.next\n  element.prev = None\n  element.next = None",
    "label": 1,
    "original_ref": "    def remove_node_pointers(node: Node) -> None:\n        if node.next:\n            node.next.previous = node.previous\n\n        if node.previous:\n            node.previous.next = node.next\n\n        node.next = None\n        node.previous = None",
    "ast_similarity": 0.9999958039811265,
    "token_jaccard": 0.3333333333333333
  },
  {
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef count_unique_paths(tree):\n    def dfs(node, visited):\n        if not node:\n            return 0\n        if node.val in visited:\n            return 0\n        visited.add(node.val)\n\n        if not node.left and not node.right:\n            unique_count = 1\n        else:\n            left_paths = dfs(node.left, visited)\n            right_paths = dfs(node.right, visited)\n            unique_count = left_paths + right_paths\n\n        visited.remove(node.val)\n        return unique_count\n\n    return dfs(tree, set())\n\n# Example Usage\ntree = TreeNode(1)\ntree.left = TreeNode(2)\ntree.right = TreeNode(3)\ntree.left.left = TreeNode(4)\ntree.left.right = TreeNode(5)\ntree.right.left = TreeNode(6)\ntree.right.right = TreeNode(7)\n\nunique_paths = count_unique_paths(tree)\nprint(\"Number of unique paths:\", unique_paths)",
    "label": 0,
    "original_ref": "    def remove_node_pointers(node: Node) -> None:\n        if node.next:\n            node.next.previous = node.previous\n\n        if node.previous:\n            node.previous.next = node.next\n\n        node.next = None\n        node.previous = None",
    "original_similarity": 0.22586085377487158,
    "max_corpus_similarity": 0.5706711400211655
  },
  {
    "code": "def transform_text(num: int, text: str) -> str:\n    encrypted = [\"\"] * num\n    for idx in range(num):\n        pos = idx\n        while pos < len(text):\n            encrypted[idx] += text[pos]\n            pos += num\n    return \"\".join(encrypted)",
    "label": 1,
    "original_ref": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)",
    "ast_similarity": 0.9785440325879117,
    "token_jaccard": 0.32558139534883723
  },
  {
    "code": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_valid_bst(node, left=float('-inf'), right=float('inf')):\n    if not node:\n        return True\n    if not (left < node.value < right):\n        return False\n    return (is_valid_bst(node.left, left, node.value) and\n            is_valid_bst(node.right, node.value, right))\n\ndef insert_into_bst(root, value):\n    if root is None:\n        return TreeNode(value)\n    elif value < root.value:\n        root.left = insert_into_bst(root.left, value)\n    else:\n        root.right = insert_into_bst(root.right, value)\n    return root\n\ndef find_kth_smallest(node, k):\n    def inorder_traversal(node):\n        nonlocal count, result\n        if not node or count >= k:\n            return\n        inorder_traversal(node.left)\n        count += 1\n        if count == k:\n            result = node.value\n            return\n        inorder_traversal(node.right)\n\n    count = 0\n    result = None\n    inorder_traversal(node)\n    return result\n\n# Example usage:\n# Constructing a tree and finding the k-th smallest element\nroot = TreeNode(8)\nroot = insert_into_bst(root, 3)\nroot = insert_into_bst(root, 10)\nroot = insert_into_bst(root, 1)\nroot = insert_into_bst(root, 6)\nroot = insert_into_bst(root, 14)\nroot = insert_into_bst(root, 4)\nroot = insert_into_bst(root, 7)\nroot = insert_into_bst(root, 13)\n\nprint(\"Is the tree a valid BST?\", is_valid_bst(root)) # True\nk = 3\nprint(f\"The {k}-th smallest element is:\", find_kth_smallest(root, k)) # 4",
    "label": 0,
    "original_ref": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)",
    "original_similarity": 0.06245953909899592,
    "max_corpus_similarity": 0.5780528937468372
  },
  {
    "code": "def calc_value(num: float) -> float:\n    return 10 - num*num",
    "label": 1,
    "original_ref": "def equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x",
    "ast_similarity": 0.9414819744779558,
    "token_jaccard": 0.3333333333333333
  },
  {
    "code": "import heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge(self, u, v, weight):\n        if u not in self.edges:\n            self.edges[u] = []\n        self.edges[u].append((v, weight))\n\n    def shortest_path(self, start, end):\n        heap = [(0, start)]\n        visited = set()\n        min_dist = {start: 0}\n\n        while heap:\n            cur_dist, node = heapq.heappop(heap)\n\n            if node in visited:\n                continue\n            visited.add(node)\n\n            if node == end:\n                return cur_dist\n\n            for neighbor, weight in self.edges.get(node, []):\n                if neighbor in visited:\n                    continue\n                new_dist = cur_dist + weight\n                if new_dist < min_dist.get(neighbor, float('inf')):\n                    min_dist[neighbor] = new_dist\n                    heapq.heappush(heap, (new_dist, neighbor))\n        \n        return float('inf')\n\n\ndef solve_knapsack(items, max_weight):\n    dp = [[0 for _ in range(max_weight + 1)] for _ in range(len(items) + 1)]\n\n    for i in range(1, len(items) + 1):\n        for w in range(max_weight + 1):\n            value, weight = items[i-1]\n            if weight <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value)\n            else:\n                dp[i][w] = dp[i-1][w]\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    g = Graph()\n    g.add_edge(1, 2, 1)\n    g.add_edge(2, 3, 1)\n    g.add_edge(1, 3, 4)\n    g.add_edge(3, 4, 2)\n    \n    print(\"Shortest path from 1 to 4:\", g.shortest_path(1, 4))\n\n    items = [(60, 10), (100, 20), (120, 30)]\n    max_weight = 50\n    print(\"Optimal Knapsack value:\", solve_knapsack(items, max_weight))",
    "label": 0,
    "original_ref": "def equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x",
    "original_similarity": 0.13852886292886482,
    "max_corpus_similarity": 0.528456404470352
  },
  {
    "code": "def findPaths(self, start, goalSum):\n    if not start:return[]\n    result=[];nodes=[(start,start.val,[start.val])]\n    while nodes:\n        current,value,route=nodes.pop()\n        if not current.left and not current.right and value==goalSum:result.append(route)\n        if current.left:nodes.append((current.left,value+current.left.val,route+[current.left.val]))\n        if current.right:nodes.append((current.right,value+current.right.val,route+[current.right.val]))\n    return result",
    "label": 1,
    "original_ref": "    def pathSum(self, root, targetSum):\n        if not root: return []\n        \n        ans = []\n        stack = [(root, root.val, [root.val])]\n        \n        while stack:\n            node, total, path = stack.pop()\n            \n            if not node.left and not node.right and total==targetSum: ans.append(path)\n            if node.left: stack.append((node.left, total+node.left.val, path+[node.left.val]))\n            if node.right: stack.append((node.right, total+node.right.val, path+[node.right.val]))\n                \n        return ans",
    "ast_similarity": 0.9963848543839334,
    "token_jaccard": 0.1276595744680851
  },
  {
    "code": "class Graph:\n    def __init__(self):\n        self.nodes = {}\n    \n    def add_edge(self, u, v):\n        if u not in self.nodes:\n            self.nodes[u] = []\n        if v not in self.nodes:\n            self.nodes[v] = []\n        self.nodes[u].append(v)\n\ndef longest_simple_path(graph, start):\n    visited = set()\n    memo = {}\n\n    def dfs(node):\n        if node in memo:\n            return memo[node]\n        \n        max_length = 0\n        visited.add(node)\n        for neighbor in graph.nodes.get(node, []):\n            if neighbor not in visited:\n                length = 1 + dfs(neighbor)\n                if length > max_length:\n                    max_length = length\n        visited.remove(node)\n\n        memo[node] = max_length\n        return max_length\n\n    return dfs(start)\n\n# Example usage\ng = Graph()\ng.add_edge(1, 2)\ng.add_edge(1, 3)\ng.add_edge(3, 4)\ng.add_edge(2, 4)\n\nstart_node = 1\nprint(\"Longest Simple Path Length starting from node\", start_node, \":\", longest_simple_path(g, start_node))",
    "label": 0,
    "original_ref": "    def pathSum(self, root, targetSum):\n        if not root: return []\n        \n        ans = []\n        stack = [(root, root.val, [root.val])]\n        \n        while stack:\n            node, total, path = stack.pop()\n            \n            if not node.left and not node.right and total==targetSum: ans.append(path)\n            if node.left: stack.append((node.left, total+node.left.val, path+[node.left.val]))\n            if node.right: stack.append((node.right, total+node.right.val, path+[node.right.val]))\n                \n        return ans",
    "original_similarity": 0.25701398528365393,
    "max_corpus_similarity": 0.5621319377697267
  },
  {
    "code": "def locateLeafNodes(aux_node, output):\n if aux_node is None:\n  return -1\n current_level = 1 + max(self.locateLeafNodes(aux_node.left, output), self.locateLeafNodes(aux_node.right, output))\n if len(output) < current_level + 1:\n  output.append([])\n output[current_level].append(aux_node.val)\n return current_level",
    "label": 1,
    "original_ref": "    def findLeaves_helper(self, node, res):\n        if node is None:\n            return -1\n        level = 1 + max(self.findLeaves_helper(node.left, res), self.findLeaves_helper(node.right, res))\n        if len(res) < level + 1:\n            res.append([])\n        res[level].append(node.val)\n        return level",
    "ast_similarity": 0.9948277919619853,
    "token_jaccard": 0.3235294117647059
  },
  {
    "code": "class Graph:\n    def __init__(self, vertices):\n        self.graph = {i: [] for i in range(vertices)}\n        self.vertices = vertices\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.graph[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def contains_cycle(self):\n        visited = [False] * self.vertices\n        rec_stack = [False] * self.vertices\n        for node in range(self.vertices):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False\n\n    def longest_path_util(self, v, visited, dp):\n        visited[v] = True\n\n        current_longest = 0\n        for i in self.graph[v]:\n            if not visited[i]:\n                current_longest = max(current_longest, self.longest_path_util(i, visited, dp))\n            else:\n                current_longest = max(current_longest, dp[i])\n\n        dp[v] = 1 + current_longest\n        visited[v] = False\n        return dp[v]\n\n    def longest_path(self):\n        if self.contains_cycle():\n            return -1\n\n        dp = [-1] * self.vertices\n        visited = [False] * self.vertices\n        overall_longest = 0\n        \n        for v in range(self.vertices):\n            if dp[v] == -1:\n                overall_longest = max(overall_longest, self.longest_path_util(v, visited, dp))\n        \n        return overall_longest\n\n# Create a graph instance, add edges and test\ng = Graph(6)\ng.add_edge(0, 1)\ng.add_edge(1, 2)\ng.add_edge(1, 3)\ng.add_edge(3, 2)\ng.add_edge(4, 0)\ng.add_edge(4, 5)\n\nprint(\"Graph contains cycle: \", g.contains_cycle())  # Should return False\nprint(\"Length of the longest path: \", g.longest_path())  # Should return 3",
    "label": 0,
    "original_ref": "    def findLeaves_helper(self, node, res):\n        if node is None:\n            return -1\n        level = 1 + max(self.findLeaves_helper(node.left, res), self.findLeaves_helper(node.right, res))\n        if len(res) < level + 1:\n            res.append([])\n        res[level].append(node.val)\n        return level",
    "original_similarity": 0.19437952253243285,
    "max_corpus_similarity": 0.48027426920039124
  },
  {
    "code": "def dfs_sort(network: dict[int, list[int]], node: int, checked: list[bool]) -> list[int]:\n    checked[node]=True\n    sequence=[]\n    for adjacent in network[node]:\n        if not checked[adjacent]:\n            sequence+=dfs_sort(network, adjacent, checked)\n    sequence.append(node)\n    return sequence",
    "label": 1,
    "original_ref": "def topology_sort(\n    graph: dict[int, list[int]], vert: int, visited: list[bool]\n) -> list[int]:\n    \"\"\"\n    Use depth first search to sort graph\n    At this time graph is the same as input\n    >>> topology_sort(test_graph_1, 0, 5 * [False])\n    [1, 2, 4, 3, 0]\n    >>> topology_sort(test_graph_2, 0, 6 * [False])\n    [2, 1, 5, 4, 3, 0]\n    \"\"\"\n\n    visited[vert] = True\n    order = []\n\n    for neighbour in graph[vert]:\n        if not visited[neighbour]:\n            order += topology_sort(graph, neighbour, visited)\n\n    order.append(vert)\n\n    return order",
    "ast_similarity": 0.9655497630328271,
    "token_jaccard": 0.14473684210526316
  },
  {
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str):\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        current.is_end = True\n\n    def search(self, word: str) -> bool:\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return current.is_end\n\ndef partition(s: str) -> list[list[str]]:\n    def is_palindrome(low, high):\n        while low < high:\n            if s[low] != s[high]:\n                return False\n            low, high = low + 1, high - 1\n        return True\n\n    def backtrack(start: int, path: list[str]):\n        if start == len(s):\n            result.append(path[:])\n            return\n        for end in range(start, len(s)):\n            if is_palindrome(start, end):\n                path.append(s[start:end+1])\n                backtrack(end + 1, path)\n                path.pop()\n    \n    result = []\n    backtrack(0, [])\n    return result\n\n# Example usage\ntrie = Trie()\nwords = [\"cat\", \"cater\", \"dog\", \"doom\", \"do\"]\nfor word in words:\n    trie.insert(word)\n\nprint(trie.search(\"cater\"))  # True\nprint(trie.search(\"cat\"))    # True\nprint(trie.search(\"bat\"))    # False\n\n# Finding all palindromic partitions\nstring = \"aab\"\nprint(partition(string))  # [['a', 'a', 'b'], ['aa', 'b']]",
    "label": 0,
    "original_ref": "def topology_sort(\n    graph: dict[int, list[int]], vert: int, visited: list[bool]\n) -> list[int]:\n    \"\"\"\n    Use depth first search to sort graph\n    At this time graph is the same as input\n    >>> topology_sort(test_graph_1, 0, 5 * [False])\n    [1, 2, 4, 3, 0]\n    >>> topology_sort(test_graph_2, 0, 6 * [False])\n    [2, 1, 5, 4, 3, 0]\n    \"\"\"\n\n    visited[vert] = True\n    order = []\n\n    for neighbour in graph[vert]:\n        if not visited[neighbour]:\n            order += topology_sort(graph, neighbour, visited)\n\n    order.append(vert)\n\n    return order",
    "original_similarity": 0.20008032442280899,
    "max_corpus_similarity": 0.5892088417572806
  }
]