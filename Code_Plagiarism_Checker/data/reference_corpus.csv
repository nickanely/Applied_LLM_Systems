,id,code,file_path,function_name,token_count
0,counting_inversions.py::count_split_inv::8,"def count_split_inv(arr, left, right):
  split_inv = ridx = lidx = 0
  size = len(arr)
  lsize = len(left)
  rsize = len(right)
  for i in range(size):
    if lidx != lsize and ridx != rsize:
      if right[ridx] < left[lidx]:
        arr[i] = right[ridx]
        ridx += 1
        split_inv += lsize - lidx
      else:
        arr[i] = left[lidx]
        lidx += 1
    elif lidx == lsize:
      arr[i] = right[ridx]
      ridx += 1
    elif ridx == rsize:
      arr[i] = left[lidx]
      lidx += 1
  return split_inv",data\repos\DSA\algorithms\Python\arrays\counting_inversions.py,count_split_inv,175
1,counting_inversions.py::count_inversions::31,"def count_inversions(arr) -> int:
  """"""
  Sort arr and return the number of inversions required.

  >>> numbers
  [8, 2, 1, 5, 7, 3, 9, 2, 0, 1]
  >>> count_inversions(numbers)
  28
  >>> numbers  # numbers has been sorted!!
  [0, 1, 1, 2, 2, 3, 5, 7, 8, 9]
  >>> count_inversions(numbers)
  0
  """"""
  size = len(arr)
  if size == 1:
    return 0
  mid = int(size/2)
  left = arr[:mid]
  right = arr[mid:]
  l_inv = count_inversions(left)
  r_inv = count_inversions(right)
  split_inv = count_split_inv(arr, left, right)

  return l_inv + r_inv + split_inv",data\repos\DSA\algorithms\Python\arrays\counting_inversions.py,count_inversions,203
2,dutch_national_flag_algo.py::DNFS::21,"def DNFS(numbers: list) -> list:
    length = len(numbers)
    low = 0
    high = length - 1
    mid = 0
    while mid <= high:
        if numbers[mid] == 0:
            numbers[low], numbers[mid] = numbers[mid], numbers[low]
            low = low + 1
            mid = mid + 1
        elif numbers[mid] == 1:
            mid = mid + 1
        else:
            numbers[mid], numbers[high] = numbers[high], numbers[mid]
            high = high - 1
    return numbers",data\repos\DSA\algorithms\Python\arrays\dutch_national_flag_algo.py,DNFS,130
3,majority_element.py::majority_element::7,"def majority_element(numbers):
    m = float(""inf"")
    cnt = 0
    for num in numbers:
        if cnt == 0:
            m = num
            cnt += 1
        elif m == num:
            cnt += 1
        else:
            cnt -= 1
    # to verify the most frequent number is greater than length of aaray//2
    recheck_cnt = 0
    for num in numbers:
        if num == m:
            recheck_cnt += 1
    return m if recheck_cnt > len(numbers)//2 else None",data\repos\DSA\algorithms\Python\arrays\majority_element.py,majority_element,124
4,max_sub_array_sum.py::max_sub_arr_sum::18,"def max_sub_arr_sum(arr): 
    arr_size = len(arr)
    max_sum = arr[0]
    max_sum_curr = arr[0]
     
    for i in range(1, arr_size):
        max_sum_curr = max(arr[i], max_sum_curr + arr[i])
        max_sum = max(max_sum, max_sum_curr)
         
    return max_sum",data\repos\DSA\algorithms\Python\arrays\max_sub_array_sum.py,max_sub_arr_sum,77
5,missing_number.py::missing_number::8,"def missing_number(numbers, n):
    s = sum(numbers)
    expected_s = (n*(n+1))//2 #for C++ or similar, keep in mind expected_s can overflow MAX INT limit.
    return expected_s - s",data\repos\DSA\algorithms\Python\arrays\missing_number.py,missing_number,50
6,remove_duplicates_list.py::make_distinct::10,"def make_distinct(values: list) -> list:
    """"""
    Remove duplicate elements in an array inplace without creating new array.

    Here, we are iterating the list backwards instead of forward because if we
    remove elements in an array it will cause some issues.

    Note : Wrapped with * are sample.
    """"""
    # *length = 10*
    length = len(values)
    for index in range(len(values)):
        # *index_position = 0 - 10*
        # *index_position = -10*
        index_position = index - length
        if values[index_position] in values[0:index_position]:
            values.remove(values[index_position])

    return values",data\repos\DSA\algorithms\Python\arrays\remove_duplicates_list.py,make_distinct,139
7,rotate_array.py::rotate_array::8,"def rotate_array(numbers, k):
    n = len(numbers)
    k = k % n
    if k == 0:
        return numbers
    for i in range(n-k):
        if i>((n-k)//2):
            break
        numbers[i], numbers[n-k-(i+1)] = numbers[n-k-(i+1)], numbers[i]

    for i in range(k):
        if i>k//2:
            break
        numbers[-1-i], numbers[-k+i] = numbers[-k+i], numbers[-1-i]
    reversed_numbers = numbers[::-1]
    return reversed_numbers",data\repos\DSA\algorithms\Python\arrays\rotate_array.py,rotate_array,126
8,two-sum.py::twoSum::22,"def twoSum(nums, target):
    dictionary = {}
    # using enumerate to iterate through the list keeping track of both index and element
    for i, val in enumerate(nums):
        diff = target - val
        if diff in dictionary:
            return [dictionary[diff], i]
        dictionary[val] = i
    return [-1, -1]",data\repos\DSA\algorithms\Python\dictionaries\two-sum.py,twoSum,74
9,two-sum.py::main::33,"def main():
    try:
        arr = list(map(int, input(""Enter space-seperated integers: "").split()))
        tar = int(input(""Enter target: ""))
    except ValueError:
        arr = [2, 7, 11, 15]
        tar = 9
    print(twoSum(arr, tar))",data\repos\DSA\algorithms\Python\dictionaries\two-sum.py,main,69
10,catalan_sequence.py::catalan::11,"def catalan(n):
    """"""
    >>> catalan(2)
    2
    >>> catalan(5)
    42
    >>> catalan(-1)
    Traceback (most recent call last):
        ...
    IndexError: list assignment index out of range
    """"""
    # Base Case
    if n == 0 or n == 1:
        return 1

    # To store the result of subproblems

    cat_num = [0] * (n + 1)

    cat_num[0] = 1
    cat_num[1] = 1

    for i in range(2, n + 1):
        for j in range(i):
            cat_num[i] += cat_num[j] * cat_num[i - j - 1]
    return cat_num[n]",data\repos\DSA\algorithms\Python\dynamic_programming\catalan_sequence.py,catalan,171
11,fibonacci_series.py::fibo::32,"def fibo(n):
    if n in d.keys():
        return d[n]
    else:
        d[n] = fibo(n - 1) + fibo(n - 2)
        print(""\t"", d[n], end="" "")
        return d[n]",data\repos\DSA\algorithms\Python\dynamic_programming\fibonacci_series.py,fibo,56
12,fibonacci_series_nth_term.py::fibo::24,"def fibo(n):
    if n in d.keys():
        return d[n]
    else:
        d[n] = fibo(n - 1) + fibo(n - 2)
        return d[n]",data\repos\DSA\algorithms\Python\dynamic_programming\fibonacci_series_nth_term.py,fibo,45
13,fibonacci_series_sum.py::fibo::30,"def fibo(n):
    if n in d.keys():
        return d[n]
    else:
        d[n] = fibo(n - 1) + fibo(n - 2)
        global sum
        sum += d[n]
        return d[n]",data\repos\DSA\algorithms\Python\dynamic_programming\fibonacci_series_sum.py,fibo,55
14,knapsack.py::knapsack::12,"def knapsack(items, capacity):
    dp = [[0 for _ in range(capacity+1)] for _ in range(len(items)+1)]

    for row in range(1, len(dp)):
        for col in range(1, len(dp[row])):
            current_weight = items[row-1][1]
            current_value = items[row-1][0]

            if current_weight > col:
                dp[row][col] = dp[row-1][col]
            else:
                dp[row][col] = max(dp[row-1][col], dp[row-1][col-current_weight]+current_value)
    return dp[-1][-1]",data\repos\DSA\algorithms\Python\dynamic_programming\knapsack.py,knapsack,135
15,levenshtein_distance.py::levenshtein_distance::14,"def levenshtein_distance(word_1, chars_1, word_2, chars_2):
    # base case if the strings are empty
    if chars_1 == 0:
        return chars_2
    if chars_2 == 0:
        return chars_1

    # if last characters of the string match, the cost of
    # operations is 0, i.e. no changes are made
    if word_1[chars_1 - 1] == word_2[chars_2 - 1]:
        cost = 0
    else:
        cost = 1

    # calculating the numbers of operations recursively
    deletion =  levenshtein_distance(word_1, chars_1 - 1, word_2, chars_2) + 1
    insertion = levenshtein_distance(word_1, chars_1, word_2, chars_2 - 1) + 1
    substitution = levenshtein_distance(word_1, chars_1 - 1, word_2, chars_2 - 1) + cost

    return min(deletion, insertion, substitution)",data\repos\DSA\algorithms\Python\dynamic_programming\levenshtein_distance.py,levenshtein_distance,246
16,bfs-sequence.py::ShowGraph::18,"def ShowGraph(Adj_Dict: dict[int, list[int]])->None :  #displays graph
   for i in Adj_Dict:
       print(i,""->"",Adj_Dict[i])
   return",data\repos\DSA\algorithms\Python\graphs\bfs-sequence.py,ShowGraph,44
17,bfs-sequence.py::Display_BFS::22,"def Display_BFS(curr:int ,Adj_Dict: dict[int, list[int]]) -> None: # displays BFS sequence
   global rear
   global front
   print(curr,end="" "")
   if curr in Adj_Dict :
       if curr not in visited: 
           visited.append(curr) 
           queue.append(curr) 
           rear+=1
       for i in Adj_Dict[curr]: # iterate over all neighbours of curr
           if i not in visited: 
               queue.append(i)
               visited.append(i)
               rear+=1            
   queue[front]=-1 # all nodes adjecent to curr are visited
   front+=1
   if front==rear: # no new node to visit
       return
   else:
       Display_BFS(queue[front],Adj_Dict) # go to next node
   return",data\repos\DSA\algorithms\Python\graphs\bfs-sequence.py,Display_BFS,173
18,depth-first-search.py::dfs::15,"def dfs(edges, vis, node):
	if(vis[node]!=1):
		vis[node] = 1
		print(node, end = "" "")
	
	for i in edges[node]:
		if(vis[i]!=1):
			dfs(edges, vis, i)",data\repos\DSA\algorithms\Python\graphs\depth-first-search.py,dfs,53
19,depth-first-search.py::main::25,"def main():
	"""""" Main Function """"""

	#First example

	graph1 = []
	graph1.append([1,2,3])
	graph1.append([0,2])
	graph1.append([0,1,4])
	graph1.append([0])
	graph1.append([2])	

	vis = []
	for i in range(0,10):
		vis.append(0)

	print(""DFS for Graph 1 is:"")
	dfs(graph1, vis, 0)

	#Making visited list elements 0 for second graph
	for i in range(0,10):
		vis[i] = 0

	graph2 = []
	graph2.append([1, 2, 3])
	graph2.append([3])
	graph2.append([4])
	graph2.append([5, 6])
	graph2.append([5, 7])
	graph2.append([2])
	graph2.append([])
	graph2.append([])

	print(""\n\nDFS for Graph 2 is:"")
	dfs(graph2, vis, 0)",data\repos\DSA\algorithms\Python\graphs\depth-first-search.py,main,207
20,graph.py::getpath::49,"    def getpath(self, start, end, path=[]):
        path = path + [start]
        if start == end:
            return [path]

        if start not in self.graph_dict:  # if one-way between one node, say Chennai; return []
            # Chennai is not as a starting point, so it has no route associated
            return []

        paths = []
        for node in self.graph_dict[start]:
            if node not in path:
                new_path = self.getpath(node, end, path)
                for p in new_path:
                    paths.append(p)
        return paths",data\repos\DSA\algorithms\Python\graphs\graph.py,getpath,123
21,graph.py::getShortestPath::67,"    def getShortestPath(self, start, end, path=[]):
        path = path + [start]

        # if starting-point and end-point are same
        if start == end:
            return path

        # If no path available from a point, return None
        if start not in self.graph_dict:
            return None

        # searching for shortest path
        shortest_path = None  # shortest path initialised
        for node in self.graph_dict[start]:
            if node not in path:
                sp = self.getShortestPath(node, end, path)
                if sp:
                    # if no shortest path is available; but in later iteration, we may have a path
                    # so check if it is shorter than original path (array of routes) or not
                    if shortest_path is None or len(sp) < len(shortest_path):
                        shortest_path = sp  # shortest path returned

        return shortest_path",data\repos\DSA\algorithms\Python\graphs\graph.py,getShortestPath,192
22,cycle-detection-and-removal-linkedlist.py::cycleDetectionAndRemoval::29,"    def cycleDetectionAndRemoval(self):
        temp = self.head
        if temp is None or temp.next is None:
            return 'No Cycle Detected'
        slow_ptr = temp
        fast_ptr = temp

        while (slow_ptr and fast_ptr and fast_ptr.next):
            # moving slow pointer by one node and fast by two node.
            slow_ptr = slow_ptr.next
            fast_ptr = fast_ptr.next.next

            # if slow equals to fast, then we have encountered cycle
            if slow_ptr == fast_ptr:
                slow_ptr = temp

                while slow_ptr != fast_ptr:
                    slow_ptr = slow_ptr.next
                    fast_ptr = fast_ptr.next

                # removing cycle
                fast_ptr.next = None
                return 'Cycle Detected and Removed'
        return 'No Cycle Detected'",data\repos\DSA\algorithms\Python\linked_lists\cycle-detection-and-removal-linkedlist.py,cycleDetectionAndRemoval,168
23,doubly.py::push::51,"    def push(self, data):
        node = Node(data)
        node.next = self.head
        if self.head:
            self.head.prev = node
        self.head = node",data\repos\DSA\algorithms\Python\linked_lists\doubly.py,push,37
24,middle-node-linkedlist.py::middle_element::22,"    def middle_element(self):
        if self.head is None:
            return None
        slow = self.head
        fast = self.head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow.data",data\repos\DSA\algorithms\Python\linked_lists\middle-node-linkedlist.py,middle_element,53
25,reverse-linkedlist.py::reverse::29,"    def reverse(self):
        dummy = None
        cur = self.head
        while cur:
            nextTemp = cur.next
            cur.next = dummy
            dummy = cur
            cur = nextTemp
        self.head = dummy",data\repos\DSA\algorithms\Python\linked_lists\reverse-linkedlist.py,reverse,49
26,singly.py::pop::59,"    def pop(self):
        """"""
        >>> ll = LinkedList()
        >>> len(ll)
        0
        >>> ll.push(""push/pop"")
        >>> len(ll)
        1
        >>> ll.pop()
        'push/pop'
        >>> len(ll)
        0
        >>> ll.pop()
        Traceback (most recent call last):
            ...
        IndexError: pop from empty LinkedList
        """"""
        node = self.head
        if not node:
            raise IndexError(""pop from empty LinkedList"")
        self.head = node.next
        return node.data",data\repos\DSA\algorithms\Python\linked_lists\singly.py,pop,115
27,singly.py::insertEnd::82,"    def insertEnd(self, data):
        '''
        Insert node at the end of linked list
        '''
        node = Node(data)
        if self.head is None:
            self.head = node
            return

        # Linked list traversal
        temp = self.head
        while(temp.next is not None):
            temp = temp.next

        temp.next = node
        return",data\repos\DSA\algorithms\Python\linked_lists\singly.py,insertEnd,78
28,singly.py::deleteData::99,"    def deleteData(self, data):
        '''
        Delete first occurrence of given data
        '''
        temp = self.head
        
        # raise exception if linked list is empty
        if temp is None:
            raise Exception(""Linked List is empty"")

        # if head node is deleted
        if temp.data == data:
            self.head = temp.next
            temp = None
            return

        # search for data
        # previous node data is stored
        while(temp):
            found = False
            if temp.data == data:
                found = True
                break
            prev = temp
            temp = temp.next
            
        # raise exception if data not found
        if not found:
            raise Exception(""Data not present"")

        # delete the link
        prev.next = temp.next
        temp = None
        return",data\repos\DSA\algorithms\Python\linked_lists\singly.py,deleteData,172
29,karatsuba_algorithm.py::equalize_strings::6,"def equalize_strings(x_value, y_value):
    """"""
        >>> def eq_str(x, y):
        ...   max_len = max(len(x), len(y))
        ...   return x.zfill(max_len), y.zfill(max_len), max_len
        >>>
        >>> all(equalize_strings(x, y) == eq_str(x, y) for x, y
        ...   in (('x' * i, 'y' * (i // 2)) for i in range(10)))
        True
    """"""
    n_value = len(x_value)
    m_value = len(y_value)
    zeros = abs(n_value - m_value) * '0'
    if n_value > m_value:
        y_value = zeros + y_value
    elif m_value > n_value:
        x_value = zeros + x_value
    return x_value, y_value, len(x_value)",data\repos\DSA\algorithms\Python\multiplication\karatsuba_algorithm.py,equalize_strings,186
30,karatsuba_algorithm.py::add_function::26,"def add_function(x_value, y_value):
    """"""
        >>> all(add_function(str(x), str(y)) == str(x + y) for x, y
        ...   in ((0, 0), (0, 1), (1, 0), (1, 1234567890), (543210, 9876543)))
        True
    """"""
    x_value, y_value, size = equalize_strings(x_value, y_value)
    carry = 0
    result = ''

    for i in range(1, size+1):
        # print(i)
        dgt1 = int(x_value[size - i])
        dgt2 = int(y_value[size - i])
        dgt3 = (dgt1 + dgt2 + carry) % 10
        result = str(dgt3) + result
        carry = int((dgt1 + dgt2 + carry) / 10)
        # print(dgt1, dgt2, dgt3, result, carry)

    if carry:
        result = '1' + result

    return result",data\repos\DSA\algorithms\Python\multiplication\karatsuba_algorithm.py,add_function,232
31,karatsuba_algorithm.py::absolute_difference::51,"def absolute_difference(x_value, y_value):
    """"""
        >>> all(absolute_difference(str(x), str(y)) == str(abs(x - y)) for x, y
        ...   in ((0, 0), (0, 1), (1, 0), (1, 1234567890), (543210, 9876543)))
        True
    """"""
    x_value, y_value, size = equalize_strings(x_value, y_value)
    carry = 0
    result = """"

    for i in range(size):
        if y_value[i] <= x_value[i]:
            break
        #tmp = x_value
        #x_value = y_value
        #y_value = tmp
        x_value, y_value = y_value, x_value
        break

    for i in range(1, size+1):
        dgt1 = int(x_value[size - i])
        dgt2 = int(y_value[size - i])
        dgt3 = dgt1 - dgt2 - carry

        if dgt3 < 0:
            dgt3 += 10
            carry = 1
        else:
            carry = 0
        result = str(dgt3) + result

    return result",data\repos\DSA\algorithms\Python\multiplication\karatsuba_algorithm.py,absolute_difference,264
32,karatsuba_algorithm.py::kmul_function::85,"def kmul_function(x_value ,y_value):
    """"""
        >>> all(kmul_function(str(x), str(y)) == str(x * y) for x, y
        ...   in ((0, 0), (0, 1), (1, 0), (1, 1234567890), (543210, 9876543)))
        True
    """"""
    x_value, y_value, size = equalize_strings(x_value, y_value)
    if size == 1:
        return str(int(x_value) * int(y_value))

    mid = int(size / 2)
    a_value = x_value[:mid]
    b_value = x_value[mid:]
    c_value = y_value[:mid]
    d_value = y_value[mid:]
    ac_value = kmul_function(a_value, c_value)
    bd_value = kmul_function(b_value, d_value)
    ab_cd_value = kmul_function(add_function(a_value, b_value), add_function(c_value, d_value))
    ad_bc_value = absolute_difference(ab_cd_value, add_function(ac_value, bd_value))
    zeros = ""0"" * (size - mid)
    result = add_function(ac_value + 2 * zeros, ad_bc_value + zeros)
    result = add_function(result, bd_value)
    result = result.lstrip('0')
    return result",data\repos\DSA\algorithms\Python\multiplication\karatsuba_algorithm.py,kmul_function,282
33,prime_number.py::isPrime::4,"def isPrime(N):
        if N<=1:
                return False
        
        for i in range(2, int(N**0.5) + 1):
                if N%i==0:
                        return False

        return True",data\repos\DSA\algorithms\Python\number_theory\prime_number.py,isPrime,48
34,fifo-queue.py::enqueue::13,"    def enqueue(self, n) -> None:
        """"""
        adds n to the end of the queue in O(1) time

        n: Any
        """"""
        self.arr.append(n)",data\repos\DSA\algorithms\Python\queues\fifo-queue.py,enqueue,41
35,fifo-queue.py::dequeue::21,"    def dequeue(self):
        """"""
        removes the first element from the queue and returns it in O(1) time
        """"""
        return self.arr.pop(0)",data\repos\DSA\algorithms\Python\queues\fifo-queue.py,dequeue,35
36,fifo-queue.py::front::27,"    def front(self):
        """"""
        returns the first element of the queue in O(1) time
        """"""
        return self.arr[0]",data\repos\DSA\algorithms\Python\queues\fifo-queue.py,front,31
37,fifo-queue.py::rear::33,"    def rear(self):
        """"""
        returns the last element of the queue in O(1) time
        """"""
        return self.arr[-1]",data\repos\DSA\algorithms\Python\queues\fifo-queue.py,rear,31
38,factorial.py::factorial_nonrecursion::3,"def factorial_nonrecursion(number):
    """"""
    >>> factorial_nonrecursion(3)
    6
    >>> factorial_nonrecursion(5)
    120
    >>> factorial_nonrecursion(0)
    1
    >>> factorial_nonrecursion(1)
    1
    """"""
    if isinstance(number, float):
        raise ValueError(""Non integer number is not allowed"")
    if number < 0:
        raise ValueError(""Negative number is not allowed"") # Raise an error here
    if number in {0,1}:
        return 1

    result = 1
    for i in range(1, number+1):
        result = result * i
    return result",data\repos\DSA\algorithms\Python\recursion\factorial.py,factorial_nonrecursion,147
39,factorial.py::factorial_recursion::26,"def factorial_recursion(number):
    """"""
    >>> factorial_recursion(3)
    6
    >>> factorial_recursion(5)
    120
    >>> factorial_recursion(0)
    1
    >>> factorial_recursion(1)
    1
    """"""
    if isinstance(number, float) is True:
        raise ValueError(""Non integer number is not allowed"")
    if number < 0:
        raise ValueError(""Negative number is not allowed"")
    if number in {0,1}:
        return 1

    return number * factorial_recursion(number-1)",data\repos\DSA\algorithms\Python\recursion\factorial.py,factorial_recursion,122
40,factorial.py::main::46,"def main():
    """""" main function for factorial """"""
    test_factorial = factorial_nonrecursion(5)
    print(test_factorial)

    test_recursion = factorial_recursion(4)
    print(test_recursion)",data\repos\DSA\algorithms\Python\recursion\factorial.py,main,45
41,gcd_using_recursion.py::gcd::3,"def gcd(a, b):
	if a<0:
		a = -a  
	if b<0:
		b = -b
	if b==0:
		return a  
	else:
		return gcd(b, a%b)",data\repos\DSA\algorithms\Python\recursion\gcd_using_recursion.py,gcd,48
42,nth_fibonacci_number.py::fibonacci::7,"def fibonacci(n_val):
    """"""Fibonacci Number Main Function""""""
    if n_val < 0:
        sol = ""Incorrect input""
    elif n_val == 0:
        sol = 0
    elif n_val <= len(FibArray):
        sol = FibArray[n_val-1]
    else:
        temp_fib = fibonacci(n_val-1)+fibonacci(n_val-2)
        FibArray.append(temp_fib)
        sol = temp_fib
    return sol",data\repos\DSA\algorithms\Python\recursion\nth_fibonacci_number.py,fibonacci,102
43,recursive_insertion_sort.py::insertion_sort_rec::7,"def insertion_sort_rec(array, length_arr):
    """"""Base Case""""""
    if length_arr <= 1:
        return
    # Sort first n-1 elements
    insertion_sort_rec(array, length_arr-1)
    # Insert last element at its correct position in sorted array.
    end = array[length_arr-1]
    j = length_arr-2

    # Move elements of arr[0..i-1], that are
    # greater than key, to one position ahead
    # of their current position
    while (j >= 0 and array[j] > end):
        array[j+1] = array[j]
        j -= 1
    array[j+1] = end",data\repos\DSA\algorithms\Python\recursion\recursive_insertion_sort.py,insertion_sort_rec,147
44,interval_scheduling.py::get_opt_schedule::22,"def get_opt_schedule(jobs):
  """"""
  Return the job_id's in the optimal jobs
  https://en.wikipedia.org/wiki/Interval_scheduling#Greedy_polynomial_solution

  >>> get_opt_schedule(jobs)
  [5, 4, 1, 7]
  """"""  
  opt_schedule = []
  sorted_jobs = sorted(jobs, key=lambda j: j[2])
  number_of_jobs = len(sorted_jobs)
  opt_schedule.append(sorted_jobs[0][0])
  for i in range(1, number_of_jobs):
    if sorted_jobs[i][1] >= jobs[opt_schedule[-1]][2]:
      opt_schedule.append(sorted_jobs[i][0])
  return opt_schedule",data\repos\DSA\algorithms\Python\scheduling\interval_scheduling.py,get_opt_schedule,146
45,binary_search.py::binary_search::12,"def binary_search(array: list, target: int) -> bool:
    """"""
    Search a sorted list to find a target integer

    >>> all(binary_search(x.array, x.target) == x.expected for x in test_data)
    True
    """"""
    if len(array) < 1:
        return False
    if len(array) == 1:
        return array[0] == target
    mid = len(array) // 2
    if array[mid] < target:
        return binary_search(array[mid:], target)
    elif array[mid] > target:
        return binary_search(array[:mid], target)
    else:
        return True",data\repos\DSA\algorithms\Python\searching\binary_search.py,binary_search,134
46,breadth-first-search.py::BFS::10,"def BFS(graph,start,goal):
    Visited=[]
    queue=[[start]]
    while queue:
        path=queue.pop(0)
        node=path[-1]
        if node in Visited:
            continue
        Visited.append(node)
        if node==goal:
            return path
        else:
            adjecent_nodes=graph.get(node,[])
            for node2 in adjecent_nodes:
                new_path=path.copy()
                new_path.append(node2)
                queue.append(new_path)",data\repos\DSA\algorithms\Python\searching\breadth-first-search.py,BFS,103
47,interpolation_search.py::interpolation_search::1,"def interpolation_search(array, x):
    """"""
    Use interpolation search to find a specified integer
    """"""
    if isinstance(x, int) and isinstance(array, list): # check that x is integer and array is list
        if len(array) < 1: # if array length is less than 1 print message
            return False
        elif len(array) == 1 and x in array: # if x is only element of array return index 0
            return 0
        elif len(array) > 1 and x in array: # search if array length > 1 and x is in the array
            min = 0
            max = len(array) - 1
            while min <= max:
                if array[min] == array[max] == x:
                    return min
                elif array[min] == array[max] != x:
                    return False
                else:
                    p = int(min + (x-array[min])*(max-min) / (array[max]-array[min]))
                    if array[p] == x:
                        return p
                    elif x < array[p]:
                        max = p - 1
                        continue
                    elif x > array[p]:
                        min = p + 1
                        continue
        else:
            return False # if x is not in array return false
    else:
        raise Exception('Please make sure x is an integer and array is a list.')",data\repos\DSA\algorithms\Python\searching\interpolation_search.py,interpolation_search,293
48,jump_search.py::jump_search::16,"def jump_search(arr: list, x: int) -> int:
    """"""
    >>> jump_search(arr, target) == (arr.index(target) if target in arr else -1)
    True
    """"""
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n) - 1] < x:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1
    while arr[prev] < x:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == x:
        return prev
    return -1",data\repos\DSA\algorithms\Python\searching\jump_search.py,jump_search,154
49,jump_search.py::check_sort::37,"def check_sort(test: list) -> bool:
    """"""checks whether the given list is sorted or not.""""""
    if sorted(test) == test:
        return True
    else:
        return False",data\repos\DSA\algorithms\Python\searching\jump_search.py,check_sort,40
50,linear_search.py::linear_search::5,"def linear_search(arr, target):
    """"""
    >>> all(linear_search(arr, x) == arr.index(x) if x in arr else -1 for x in targets)
    True
    """"""
    for i, item in enumerate(arr):
        if item == target:
            return i
    return -1",data\repos\DSA\algorithms\Python\searching\linear_search.py,linear_search,64
51,ternary_search.py::ternarySearch::14,"def ternarySearch(arr, target):
    left, right = 0, len(arr) - 1
    index = -1

    while(left <= right):
        mid1, mid2 = left + (right - left) // 3, right - (right - left) // 3

        # checking for condition 1
        if target == arr[mid1]:
            index = mid1
            break
        if target == arr[mid2]:
            index = mid2
            break

        # checking for condition 2
        if target > arr[mid1] and target < arr[mid2]:
            left, right = mid1 + 1, mid2 - 1

        # checking for condition 3
        elif target < arr[mid1]:
            right = mid1 - 1

        # checking for condition 4
        else:
            left = mid2 + 1
    return index",data\repos\DSA\algorithms\Python\searching\ternary_search.py,ternarySearch,194
52,uniform_cost_search.py::path_cost::12,"def path_cost(path):
    total_cost=0
    for (node, cost) in path:
        total_cost+=cost
    return total_cost , path[-1][0]",data\repos\DSA\algorithms\Python\searching\uniform_cost_search.py,path_cost,38
53,uniform_cost_search.py::UCS::21,"def UCS(graph, start, goal):
    visited=[]
    queue=[[(start,0)]]
    while queue:
        queue.sort(key=path_cost)#sorting by cost
        path=queue.pop(0)#choosing least cost
        node=path[-1][0]
        if node in visited:
            continue
        visited.append(node)
        if node==goal:
            return path
        else:
            adjacent_nodes=graph.get(node,[])
            for(node2,cost)in adjacent_nodes:
                new_path=path.copy()
                new_path.append((node2,cost))
                queue.append(new_path)",data\repos\DSA\algorithms\Python\searching\uniform_cost_search.py,UCS,125
54,bubble_sort.py::bubbleSort::4,"def bubbleSort(arr):
    """"""
    >>> bubbleSort(arr)
    [11, 12, 23, 25, 34, 54, 90]
    """"""
    n = len(arr)
    for i in range(n-1):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",data\repos\DSA\algorithms\Python\sorting\bubble_sort.py,bubbleSort,97
55,comb_sort.py::combSort::11,"def combSort(arr):
    """"""
    >>> combSort(arr)
    [-12, 1, 3, 7, 12, 22, 100]
    """"""
    gap = len(arr)
    shrink = int(gap * 10 / 13)
    sorted = False
    while gap > 1 or sorted == False:
        gap = int(gap / shrink)
        if gap <= 1:
            gap = 1
            sorted = True
        for i in range(len(arr)-gap):
            if arr[i] > arr[i+gap]:
                arr[i], arr[i+gap] = arr[i+gap], arr[i]
                sorted = False
    return arr",data\repos\DSA\algorithms\Python\sorting\comb_sort.py,combSort,146
56,count-sort.py::count_sort::2,"def count_sort(a):
    max_element = int(max(a))
    min_element = int(min(a))
    range_of_elements = max_element - min_element + 1
    # Create a count array to store count of individual
    # elements and initialize count array as 0
    c= [0 for _ in range(range_of_elements)]
    o= [0 for _ in range(len(a))]
    for i in range(0, len(a)):
        c[a[i]-min_element] += 1
    for i in range(1, len(c)):
        c[i] += c[i-1]
    for i in range(len(a)-1, -1, -1):
        o[c[a[i] - min_element] - 1] = a[i]
        c[a[i] - min_element] -= 1
    for i in range(0, len(a)):
        a[i] = o[i]
 
    return a",data\repos\DSA\algorithms\Python\sorting\count-sort.py,count_sort,197
57,heap-sort.py::heap_data::6,"def heap_data(nums, index, heap_size):
    largest_num = index
    left_index = 2 * index + 1
    right_index = 2 * index + 2
    if left_index < heap_size and nums[left_index] > nums[largest_num]:
        largest_num = left_index

    if right_index < heap_size and nums[right_index] > nums[largest_num]:
        largest_num = right_index
    if largest_num != index:
        nums[largest_num], nums[index] = nums[index], nums[largest_num]
        heap_data(nums, largest_num, heap_size)",data\repos\DSA\algorithms\Python\sorting\heap-sort.py,heap_data,126
58,heap-sort.py::heap_sort::20,"def heap_sort(nums):
    n = len(nums)
    for i in range(n // 2 - 1, -1, -1):
        heap_data(nums, i, n)
    for i in range(n - 1, 0, -1):
        nums[0], nums[i] = nums[i], nums[0]
        heap_data(nums, 0, i)
    return nums",data\repos\DSA\algorithms\Python\sorting\heap-sort.py,heap_sort,84
59,insertion_sort.py::insertion_sort::12,"def insertion_sort(arr):
	""""""
	>>> insertion_sort(arr)
	>>> arr
	[-12, 1, 3, 7, 12, 22, 100]
	""""""
	for j in range(1, len(arr)):
		key = arr[j]
		# insert the key into the sorted sequence arr[1, ... , j - 1]
		i = j - 1
		while i >= 0 and arr[i] > key:
			arr[i + 1] = arr[i]
			i -= 1
		arr[i + 1] = key",data\repos\DSA\algorithms\Python\sorting\insertion_sort.py,insertion_sort,125
60,merge_sort.py::merge_sort::3,"def merge_sort(list):
    # if list size <= 1, the list is anyway sorted! :)
    if len(list)==1: return list
    #splitting the list into half 
    mid = len(list)//2 # integer division
    l = list[:mid]
    r = list[mid:]
    merge_sort(l) # recursive calling of left part of list 
    merge_sort(r) # recursive calling of right part of list
    #merging the left and right parts
    i=j=k=0
    while(i<len(l)and j<len(r)): 
        if l[i]<=r[j]:
            list[k]=l[i]
            i+=1
        else:
            list[k]=r[j]
            j+=1
        k+=1
    while(i<len(l)):
        list[k]=l[i]
        i+=1
        k+=1
    while(j<len(r)):
        list[k]=r[j]
        j+=1
        k+=1
    return list",data\repos\DSA\algorithms\Python\sorting\merge_sort.py,merge_sort,210
61,quicksort.py::quicksort::4,"def quicksort(arr):
    """"""
    >>> quicksort(arr)
    [-23, 0, 1, 1, 2, 6, 7, 10, 23, 53, 53, 235, 256]
    >>> from string import ascii_letters
    >>> quicksort(list(reversed(ascii_letters))) == sorted(ascii_letters)
    True
    """"""
    length = len(arr)
    if length in (0, 1):
        return arr
    pi = 0
    left = [arr[i] for i in range(length) if arr[i] <= arr[pi] and i != pi]
    right = [arr[i] for i in range(length) if arr[i] > arr[pi]]
    return quicksort(left) + [arr[pi]] + quicksort(right)",data\repos\DSA\algorithms\Python\sorting\quicksort.py,quicksort,175
62,radix_sort.py::radix_sort::7,"def radix_sort(arr, simulation=False):
    position = 1
    max_number = max(arr)

    iteration = 0
    if simulation:
        print(""iteration"", iteration, "":"", *arr)

    while position <= max_number:
        queue_list = [list() for _ in range(10)]

        for num in arr:
            digit_number = num // position % 10
            queue_list[digit_number].append(num)

        index = 0
        for numbers in queue_list:
            for num in numbers:
                arr[index] = num
                index += 1

        if simulation:
            iteration = iteration + 1
            print(""iteration"", iteration, "":"", *arr)

        position *= 10
    return arr",data\repos\DSA\algorithms\Python\sorting\radix_sort.py,radix_sort,156
63,selection_sort.py::selection_sort::18,"def selection_sort(arr):
	""""""
	>>> all(selection_sort(arr) or arr == sorted(arr) for arr in arrays)
	True
	""""""
	for i in range(len(arr) - 1, 0, -1):
		k = 0
		for j in range(1, i + 1):
			if arr[j] > arr[k]:
				k = j
		arr[i], arr[k] = arr[k], arr[i]  # swap",data\repos\DSA\algorithms\Python\sorting\selection_sort.py,selection_sort,97
64,shell-sort.py::shellSort::1,"def shellSort(input_list):
    
    gap = len(input_list) // 2
    while gap > 0:

        for i in range(gap, len(input_list)):
            temp = input_list[i]
            j = i
# Sort the sub list for this gap

            while j >= gap and input_list[j - gap] > temp:
                input_list[j] = input_list[j - gap]
                j = j-gap
            input_list[j] = temp

# Reduce the gap for the next element

        gap = gap//2",data\repos\DSA\algorithms\Python\sorting\shell-sort.py,shellSort,114
65,add_string.py::add_string::14,"def add_string(num1, num2):
    carry = 0
    ptr1, ptr2 = len(num1) - 1, len(num2) - 1
    result = """"
    
    while ptr1 >= 0 or ptr2 >= 0 or carry:
        if ptr1 >= 0:
            carry += (ord(num1[ptr1]) - ord(""0""))
            ptr1 -= 1
        if ptr2 >= 0:
            carry += (ord(num2[ptr2]) - ord('0'))
            ptr2 -= 1
        
        result = str(carry % 10) + result
        carry //= 10
    return result",data\repos\DSA\algorithms\Python\strings\add_string.py,add_string,143
66,find_all_permutations.py::permutation::9,"def permutation(head, left, permutations):
    if len(left) == 0:
        permutations.append(head)
    else:
        for i in range(len(left)):
            permutation(head+left[i], left[:i]+left[i+1:], permutations)",data\repos\DSA\algorithms\Python\strings\find_all_permutations.py,permutation,51
67,first_non_repeating_character.py::first_non_repeating_character::11,"def first_non_repeating_character(string):
    """"""
    One way to do this is to have two dictionaries one which keeps the count of character,
    other dictionary will keep the first appearance of the character (index).
    After a traversal. Look in first dictionary for characters occurring once and output the one which
    has the first appearance as per second dictionary.

    Since in this case we have special constraint in mind. We will go with a cleverer way by reducing more stack space.
    """"""
    n = len(string)
    occurrence = [n]*26
    for i in range(len(string)):
        index = ord(string[i])-ord('a')
        if index < 0 or index > 25:
            return (""Invalid"")
        if occurrence[index] == n:
            occurrence[index] = i
        else:
            occurrence[index] += n
    return string[min(occurrence)] if min(occurrence) < n else -1",data\repos\DSA\algorithms\Python\strings\first_non_repeating_character.py,first_non_repeating_character,194
68,is_good_str.py::is_good_str::9,"def is_good_str(s: str) -> bool:
    """"""
    >>> is_good_str(""aeioup??"")
    True
    >>> is_good_str(""bcdaeiou??"")
    False
    """"""
    c_or_v = """"
    for char in s.lower():
        if char in constants:
            c_or_v += ""c""
        else:
            c_or_v += ""v"" if char in vowels else char
    return not ""c"" * 4 in c_or_v.replace(""?"", ""c"") and (
        not ""v"" * 6 in c_or_v.replace(""?"", ""v"")
    )",data\repos\DSA\algorithms\Python\strings\is_good_str.py,is_good_str,130
69,longest_common_subsequence.py::longest_common_subsequence::2,"    def longest_common_subsequence(self, text1: str, text2: str) -> int:
        n,m = len(text1),len(text2)
        
        grid=[[0] * (m+1) for z in range(n+1)]
        
        for i in range(n):
            for j in range(m):
                
                if text1[i]==text2[j]:
                    grid[i+1][j+1]=grid[i][j] +1
                    
                else:
                    grid[i+1][j+1]=max(grid[i][j+1], grid[i+1][j])
                    
        return grid[-1][-1]",data\repos\DSA\algorithms\Python\strings\longest_common_subsequence.py,longest_common_subsequence,134
70,palindrome.py::palindrome::11,"def palindrome(s: str) -> bool:
    """"""
    >>> palindrome(string_1)
    True
    >>> palindrome(string_2)
    True
    >>> palindrome(string_3)
    False
    """"""
    # Reverse string using idiomatic python
    reversed_string = s[::-1]
    # return the answer, by comparing string and its reverse
    return s == reversed_string",data\repos\DSA\algorithms\Python\strings\palindrome.py,palindrome,79
71,palindrome.py::is_palindrome::27,"def is_palindrome(s: str):
    # if string is palindrome
    if palindrome(s):
        print(f""{s} is a palindrome"")
    else:
        print(f""{s} is not a palindrome"")",data\repos\DSA\algorithms\Python\strings\palindrome.py,is_palindrome,44
72,rabin-karp-algorithm.py::rabin_karp::20,"def rabin_karp(T: str, P: str, q: int ,d: int = 256) -> None :
    '''
    Parameters:
    
            T: string
               The string where the pattern needs to be searched

            P: string 
               The pattern to be searched

            q: int
               An appropriately chosen prime number based on length of input strings
               The higher the prime number, the lower the collisions and spurious hits
               
            d: int, default value 256
               Denotes the no of unique character that is used for encoding
    
    

    
    
    
    Example:
    
    >>> pos = rabin_karp(""AAEXCRTDDEAAFT"",""AA"",101)
    Pattern found at pos: 0
    Pattern found at pos: 10
    
    '''
    
    n = len(T)   # length of text
    m = len(P)   # length of pattern
    p=0          # Hash value of pattern
    t=0          # Hash value of text
    
    #Computing h: (h=d^m-1 mod q)
    h=1
    for i in range(1,m):
        h = (h*d)%q
    
    #Computing hash value of pattern and initial window (of size m) of text
    for j in range(m):
        p = (d*p + ord(P[j])) % q
        t = (d*t + ord(T[j])) % q
    
    
    found = False
    pos=[] # To store positions
    
    #Sliding window and matching
    for s in range(n-m+1):
        if p==t: # if hash value matches
            if P == T[s:s+m]: # check for string match
                pos.append(s)
                if not found:
                    found = True
    
        if s<n-m:
            t = (d*(t-ord(T[s])*h) + ord(T[s+m])) % q # updating hash value of t for next window
            if t<0:
                t = t+q # To make sure t is positive integer
    
    if not found: # If pattern not found in text
        pos.append(-1)
        
    #Printing results
    if pos[0]==-1:
        print(""Pattern not found"")
    else:
        for i in pos:
            print(f""Pattern found at pos: {i}"")",data\repos\DSA\algorithms\Python\strings\rabin-karp-algorithm.py,rabin_karp,501
73,remove_duplicates_from_a_string.py::remove_duplicate::12,"def remove_duplicate(string):
    alphabet = ""0"" * 26 # instead of going for classic use of sets, dictionaries we can use string containing bits. Either way is fine.
    ans_string = """"
    for letter in string:
        index = ord(letter)-ord('a')
        if index < 0 or index > 25:
            return (""Invalid"")
        if alphabet[index] == ""1"":
            pass
        else:
            index = ord(letter)-ord('a')
            if index == 0:
                alphabet = ""1"" + alphabet[1:]
            else:
                alphabet = alphabet[0:index] + ""1"" + alphabet[index+1:]
            ans_string += letter
    return ans_string",data\repos\DSA\algorithms\Python\strings\remove_duplicates_from_a_string.py,remove_duplicate,149
74,roman-to-int.py::is_valid_roman_string::10,"def is_valid_roman_string(roman_number: str) -> bool:
    """"""Returns True if all characters of the given string are valid roman numbers""""""
    return set(roman_number).issubset(equivalence.keys())",data\repos\DSA\algorithms\Python\strings\roman-to-int.py,is_valid_roman_string,46
75,roman-to-int.py::conversion::15,"def conversion(roman_number: str) -> int:
    """"""Traverses a given roman number and returns its decimal equivalent""""""
    digits = len(roman_number)
    result = 0

    for i, char in enumerate(roman_number):
        if i < digits - 1 and equivalence[char] < equivalence[roman_number[i + 1]]:
            result -= equivalence[char]
        else:
            result += equivalence[char]

    return result",data\repos\DSA\algorithms\Python\strings\roman-to-int.py,conversion,91
76,roman-to-int.py::roman_to_int::29,"def roman_to_int(roman_number: str) -> int | ValueError:
    """"""Main function""""""
    if not is_valid_roman_string(roman_number):
        raise ValueError(f'The string must contain only valid roman numbers: {equivalence.keys()}')

    return conversion(roman_number)",data\repos\DSA\algorithms\Python\strings\roman-to-int.py,roman_to_int,59
77,unique_character.py::is_unique::7,"def is_unique(s: str) -> bool:
    """"""
    >>> is_unique('ABCDE')
    True
    """"""
    """"""
    >>> is_unique('programmer')
    False
    """"""
    
    
    arr = [False for _ in range(128)] #creating hashtable with False input
    for character in s:        #iterate throughout the string
        char_value = ord(character)
        if arr[char_value]:
            return False
        else:
            arr[char_value] = True
    return True",data\repos\DSA\algorithms\Python\strings\unique_character.py,is_unique,103
78,word_count.py::word_count::6,"def word_count(s: str) -> int:
    """"""
    >>> word_count(test_string)
    10
    """"""
    s = re.sub('[^A-Za-z0-9 ]+', '', s)
    return len(s.lower().split())",data\repos\DSA\algorithms\Python\strings\word_count.py,word_count,51
79,word_count.py::unique_word_count::15,"def unique_word_count(s: str) -> int:
    """"""
    >>> unique_word_count(test_string)
    8
    """"""
    s = re.sub('[^A-Za-z0-9 ]+', '', s)
    return len(set(s.lower().split()))",data\repos\DSA\algorithms\Python\strings\word_count.py,unique_word_count,54
80,binary_search_tree.py::build_tree::205,"def build_tree(elements):
    """""" constructor """"""
    root = Node(elements[0])

    for i in range(1, len(elements)):
        root.add_child(elements[i])
    return root",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,build_tree,38
81,binary_search_tree.py::add_child::65,"    def add_child(self, data):
        """"""Insert data as child in Tree""""""

        # checking if entered data is already present
        if data == self.data:
            return None

        # if tree is empty means no node(root) at tree
        # else incoming data will be treated as node(root(tree))
        if self.data:
            # check if data(right) > data(left) & node(parent)
            if data < self.data:  # data is smaller than data of node(parent)
                if self.left is None:  # and if no element is present at left of node
                    self.left = Node(data)  # insert data at left
                else:
                    self.left.add_child(data)  # consider node(left) {current node} as node(root)

            elif data > self.data:  # if data is greater than root node
                if self.right is None:  # and if no data(right) is None
                    self.right = Node(data)  # insert data at right of node(parent)
                else:  # if data is already present at right of node
                    self.right.add_child(data)  # consider node(right) {current node} as node(root)
        else:
            self.data = data  # if tree is empty; treat incoming data as root of the tree

        return None",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,add_child,276
82,binary_search_tree.py::in_order_traversal::93,"    def in_order_traversal(self):
        """""" constructor """"""
        elements = []  # list to be filled with all elements of BST in specific order

        # In-order-Traversal : left sub-tree >> root node >> right sub-tree
        if self.left:  # put elements of left sub-tree in list[elements]
            elements += self.left.in_order_traversal()

        elements.append(self.data)  # put root node data in list[elements]

        if self.right:   # put elements of right sub-tree in list[elements]
            elements += self.right.in_order_traversal()

        return elements  # return list[elements]",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,in_order_traversal,132
83,binary_search_tree.py::pre_order_traversal::109,"    def pre_order_traversal(self):
        """""" constructor """"""
        elements = []

        # Pre-Order-Traversal : root node >> left sub-tree >> right sub-tree

        elements.append(self.data)  # put root node data in list[elements]

        if self.left:  # put elements of left sub-tree in list[elements]
            elements += self.left.in_order_traversal()

        if self.right:  # put elements of right sub-tree in list[elements]
            elements += self.right.in_order_traversal()

        return elements  # return list[elements]",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,pre_order_traversal,118
84,binary_search_tree.py::post_order_traversal::125,"    def post_order_traversal(self):
        """""" constructor """"""
        elements = []

        # Pre-Order-Traversal : left sub-tree  >> right sub-tree >> root node

        if self.left:  # put elements of left sub-tree in list[elements]
            elements += self.left.in_order_traversal()

        if self.right:  # put elements of right sub-tree in list[elements]
            elements += self.right.in_order_traversal()

        elements.append(self.data)  # put root node data in list[elements]

        return elements  # return list[elements]",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,post_order_traversal,119
85,binary_search_tree.py::search::141,"    def search(self, val):
        """""" Search element in binary search tree""""""
        if self.data == val:
            return True

        if val < self.data:
            # search for val in left sub-tree
            if self.left:
                return self.left.search(val)
            return False

        if val > self.data:
            # search for val in right sub-tree
            if self.right:
                return self.right.search(val)
            return False

        return None",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,search,96
86,binary_search_tree.py::max::160,"    def max(self):
        '''Maximum element of tree: keep searching on right sub-tree to find maximum element '''
        if self.right is None:  # leaf node
            return self.data
        return self.right.max()",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,max,46
87,binary_search_tree.py::min::166,"    def min(self):
        ''' Minimum element of tree: keep searching on left sub-tree to find minimum element '''
        if self.left is None:  # leaf node
            return self.data
        return self.left.min()",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,min,46
88,binary_search_tree.py::delete::173,"    def delete(self, val):
        """""" constructor """"""
        if val < self.data:  # search for element in left sub-tree
            if self.left:  # check if there is any left sub-tree
                self.left = self.left.delete(val)  # delete recursion
        elif val > self.data:  # search for element in right sub-tree
            if self.right:  # check if there is any right sub-tree
                self.right = self.right.delete(val)  # delete recursion
        else:
            if self.left is None and self.right is None:  # if left & right sub-tree are empty
                return None
            if self.left is None:  # right sub-tree is present but not left sub-tree
                return self.right  # return right sub-tree-child
            if self.right is None:  # left sub-tree is present but not right sub-tree
                return self.right  # return left sub-tree-child

            min_val = self.right.min()  # find minimuum element from right sub-tree
            self.data = min_val  #
            self.right = self.right.delete(min_val)

        return self",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,delete,239
89,binary_search_tree.py::display::196,"    def display(self):
        """""" Display tree """"""
        if self.left:
            self.left.display()  # display tree(left)
        print(self.data)  # display node(root)
        if self.right:
            self.right.display()  # display tree(right)",data\repos\DSA\algorithms\Python\trees\binary_search_tree.py,display,53
90,binary_tree.py::inorder::37,"def inorder(tree):
    """""" in this we traverse first to the leftmost node,
    then print its data and then traverse for rightmost node """"""
    if tree:
        inorder(tree.get_left())
        print(tree.get_data(), end = ' ')
        inorder(tree.get_right())",data\repos\DSA\algorithms\Python\trees\binary_tree.py,inorder,56
91,binary_tree.py::preorder::45,"def preorder(tree):
    """""" in this we first print the root node
    and then traverse towards leftmost node and then to the rightmost node """"""
    if tree:
        print(tree.get_data(), end = ' ')
        preorder(tree.get_left())
        preorder(tree.get_right())",data\repos\DSA\algorithms\Python\trees\binary_tree.py,preorder,57
92,binary_tree.py::postorder::53,"def postorder(tree):
    """""" in this we first traverse to the leftmost node
    and then to the rightmost node and then print the data """"""
    if tree:
        postorder(tree.get_left())
        postorder(tree.get_right())
        print(tree.get_data(), end = ' ')",data\repos\DSA\algorithms\Python\trees\binary_tree.py,postorder,60
93,Knights_tour.py::knights_tour::1,"def knights_tour(n, row, col):
    visited = [[False]*n for i in range(n)]
    res = []
    def path_gen(path,r,c,visited,step):
        if r < 0 or c < 0 or r >= n or c >= n or visited[r][c]:
            return
        if step == n*n:
            res.append(path + f'({r},{c})')
            return   
        visited[r][c] = True
        path_gen(path + f'({r},{c}) ', r - 2, c + 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r - 2, c - 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r - 1, c + 2, visited, step+1)
        path_gen(path + f'({r},{c}) ', r - 1, c - 2, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 2, c + 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 2, c - 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 1, c + 2, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 1, c - 2, visited, step+1)
        visited[r][c] = False
    path_gen('', row, col,visited,1)
    return res",data\repos\Python-DSA\Backtracking\Knights_tour.py,knights_tour,355
94,Knights_tour.py::path_gen::4,"    def path_gen(path,r,c,visited,step):
        if r < 0 or c < 0 or r >= n or c >= n or visited[r][c]:
            return
        if step == n*n:
            res.append(path + f'({r},{c})')
            return   
        visited[r][c] = True
        path_gen(path + f'({r},{c}) ', r - 2, c + 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r - 2, c - 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r - 1, c + 2, visited, step+1)
        path_gen(path + f'({r},{c}) ', r - 1, c - 2, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 2, c + 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 2, c - 1, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 1, c + 2, visited, step+1)
        path_gen(path + f'({r},{c}) ', r + 1, c - 2, visited, step+1)
        visited[r][c] = False",data\repos\Python-DSA\Backtracking\Knights_tour.py,path_gen,312
95,N_queens.py::n_queens::1,"def n_queens(n):
    res = []
    board = [['.']*n for i in range(n)]
    cols = set()
    pdiags = set()
    ndiags = set()
    def gen(r):
        if r == n:
            res.append([''.join(row) for row in board])
            return
        for c in range(n):
            if c in cols or r+c in pdiags or r-c in ndiags:
                continue
            board[r][c] = 'Q'
            cols.add(c)
            pdiags.add(r+c)
            ndiags.add(r-c)
            gen(r + 1)
            board[r][c] = '.'
            cols.remove(c)
            pdiags.remove(r+c)
            ndiags.remove(r-c)
    gen(0)
    return res",data\repos\Python-DSA\Backtracking\N_queens.py,n_queens,175
96,N_queens.py::gen::7,"    def gen(r):
        if r == n:
            res.append([''.join(row) for row in board])
            return
        for c in range(n):
            if c in cols or r+c in pdiags or r-c in ndiags:
                continue
            board[r][c] = 'Q'
            cols.add(c)
            pdiags.add(r+c)
            ndiags.add(r-c)
            gen(r + 1)
            board[r][c] = '.'
            cols.remove(c)
            pdiags.remove(r+c)
            ndiags.remove(r-c)",data\repos\Python-DSA\Backtracking\N_queens.py,gen,125
97,Rat_in_a_Maze.py::printSolution::4,"def printSolution( sol ):
     
    for i in sol:
        for j in i:
            print(str(j) + "" "", end ="""")
        print("""")",data\repos\Python-DSA\Backtracking\Rat_in_a_Maze.py,printSolution,33
98,Rat_in_a_Maze.py::isSafe::11,"def isSafe( maze, x, y ):
    if x >= 0 and x < N and y >= 0 and y < N and maze[x][y] == 1:
        return True
     
    return False",data\repos\Python-DSA\Backtracking\Rat_in_a_Maze.py,isSafe,46
99,Rat_in_a_Maze.py::solveMaze::17,"def solveMaze( maze ):
    # Creating a 4 * 4 2-D list
    sol = [ [ 0 for j in range(4) ] for i in range(4) ]
     
    if solveMazeUtil(maze, 0, 0, sol) == False:
        print(""Solution doesn't exist"");
        return False
    printSolution(sol)
    return True",data\repos\Python-DSA\Backtracking\Rat_in_a_Maze.py,solveMaze,85
100,Rat_in_a_Maze.py::solveMazeUtil::27,"def solveMazeUtil(maze, x, y, sol):
    # if (x, y is goal) return True
    if x == N - 1 and y == N - 1:
        sol[x][y] = 1
        return True
         
    # Check if maze[x][y] is valid
    if isSafe(maze, x, y) == True:
        # mark x, y as part of solution path
        sol[x][y] = 1
         
        # Move forward in x direction
        if solveMazeUtil(maze, x + 1, y, sol) == True:
            return True
             
        # If moving in x direction doesn't give solution
        # then Move down in y direction
        if solveMazeUtil(maze, x, y + 1, sol) == True:
            return True
         
        # If none of the above movements work then
        # BACKTRACK: unmark x, y as part of solution path
        sol[x][y] = 0
        return False",data\repos\Python-DSA\Backtracking\Rat_in_a_Maze.py,solveMazeUtil,228
101,Check Bracketing.py::verif_t::12,"def verif_t(l):
    list_elem = []
    for el in l:
        if el == ""("" or el ==""["" or el ==""{"":
            list_elem.append(el)
        elif el=="")"" or el==""]"" or el==""}"":
            if len(list_elem)!=0:
                if el == "")"" and list_elem[-1]==""("":
                    list_elem.pop()
                elif el == ""]"" and list_elem[-1]==""["":
                    list_elem.pop()
                elif el == ""}"" and list_elem[-1]==""{"":
                    list_elem.pop()
                else:
                    return False
            else:
                return False
    return len(list_elem)==0",data\repos\Python-DSA\DSA\Check Bracketing.py,verif_t,137
102,circularLinkedList.py::addToEmpty::10,"    def addToEmpty(self, data):

        if self.last != None:
            return self.last

        # allocate memory to the new node and add data to the node
        newNode = Node(data)

        # assign last to newNode
        self.last = newNode

        # create link to iteself
        self.last.next = self.last
        return self.last",data\repos\Python-DSA\DSA\circularLinkedList.py,addToEmpty,75
103,circularLinkedList.py::addFront::25,"    def addFront(self, data):

        # check if the list is empty
        if self.last == None:
            return self.addToEmpty(data)

        # allocate memory to the new node and add data to the node
        newNode = Node(data)

        # store the address of the current first node in the newNode
        newNode.next = self.last.next

        # make newNode as last
        self.last.next = newNode

        return self.last",data\repos\Python-DSA\DSA\circularLinkedList.py,addFront,92
104,circularLinkedList.py::addEnd::42,"    def addEnd(self, data):
        # check if the node is empty
        if self.last == None:
            return self.addToEmpty(data)

        # allocate memory to the new node and add data to the node
        newNode = Node(data)

        # store the address of the last node to next of newNode
        newNode.next = self.last.next

        # point the current last node to the newNode
        self.last.next = newNode

        # make newNode as the last node
        self.last = newNode

        return self.last",data\repos\Python-DSA\DSA\circularLinkedList.py,addEnd,111
105,circularLinkedList.py::addAfter::61,"    def addAfter(self, data, item):

        # check if the list is empty
        if self.last == None:
            return None

        newNode = Node(data)
        p = self.last.next
        while p:

            # if the item is found, place newNode after it
            if p.data == item:

                # make the next of the current node as the next of newNode
                newNode.next = p.next

                # put newNode to the next of p
                p.next = newNode

                if p == self.last:
                    self.last = newNode
                    return self.last
                else:
                    return self.last
            p = p.next
            if p == self.last.next:
                print(item, ""The given node is not present in the list"")
                break",data\repos\Python-DSA\DSA\circularLinkedList.py,addAfter,162
106,circularLinkedList.py::deleteNode::90,"    def deleteNode(self, last, key):

        # If linked list is empty
        if last == None:
            return

        # If the list contains only a single node
        if (last).data == key and (last).next == last:

            last = None

        temp = last
        d = None

        # if last node is to be deleted
        if (last).data == key:

            # find the node before the last node
            while temp.next != last:
                temp = temp.next

            # point temp node to the next of last i.e. first node
            temp.next = (last).next
            last = temp.next

        # travel to the node to be deleted
        while temp.next != last and temp.next.data != key:
            temp = temp.next

        # if node to be deleted was found
        if temp.next.data == key:
            d = temp.next
            temp.next = d.next

        return last",data\repos\Python-DSA\DSA\circularLinkedList.py,deleteNode,205
107,circularLinkedList.py::traverse::126,"    def traverse(self):
        if self.last == None:
            print(""The list is empty"")
            return

        newNode = self.last.next
        while newNode:
            print(newNode.data, end="" "")
            newNode = newNode.next
            if newNode == self.last.next:
                break",data\repos\Python-DSA\DSA\circularLinkedList.py,traverse,59
108,deque.py::append::29,"    def append(self, x):
        if self.is_full():
            self.__extend()
        self.buf[self.tail] = x
        self.tail += 1
        self.tail %= self.length",data\repos\Python-DSA\DSA\deque.py,append,40
109,deque.py::appendleft::36,"    def appendleft(self, x):
        if self.is_full():
            self.__extend()
        self.buf[(self.head - 1) % self.length] = x
        self.head -= 1
        self.head %= self.length",data\repos\Python-DSA\DSA\deque.py,appendleft,49
110,deque.py::pop::43,"    def pop(self):
        if self.is_empty():
            raise IndexError()
        ret = self.buf[(self.tail - 1) % self.length]
        self.tail -= 1
        self.tail %= self.length
        return ret",data\repos\Python-DSA\DSA\deque.py,pop,48
111,deque.py::popleft::51,"    def popleft(self):
        if self.is_empty():
            raise IndexError()
        ret = self.buf[self.head]
        self.head += 1
        self.head %= self.length
        return ret",data\repos\Python-DSA\DSA\deque.py,popleft,41
112,DoublyLinkedList.py::addFront::21,"    def addFront(self, x):
        new_node = Node(x)
        if (self.isEmpty()):
            self.head = self.tail = new_node
            new_node.prev = None
            return
        new_node.next = self.head
        self.head.prev = new_node
        self.head = new_node
        new_node.prev = None",data\repos\Python-DSA\DSA\DoublyLinkedList.py,addFront,70
113,DoublyLinkedList.py::addTail::33,"    def addTail(self, x):
        new_node = Node(x)
        if (self.isEmpty()):
            self.head = self.tail = new_node
            new_node.next = None
            return
        self.tail.next = new_node
        new_node.prev = self.tail
        new_node.next = None
        self.tail = new_node",data\repos\Python-DSA\DSA\DoublyLinkedList.py,addTail,70
114,DoublyLinkedList.py::insert::45,"    def insert(self, x, pos):
        new_node = Node(x)
        temp = self.head
        i = 1
        while i < pos-1:
            temp = temp.next
            i += 1
        new_node.prev = temp
        new_node.next = temp.next
        temp.next.prev = new_node
        temp.next = new_node",data\repos\Python-DSA\DSA\DoublyLinkedList.py,insert,77
115,DoublyLinkedList.py::removeHead::58,"    def removeHead(self):
        temp = self.head
        self.head = temp.next
        temp.next.prev = None
        temp = None",data\repos\Python-DSA\DSA\DoublyLinkedList.py,removeHead,30
116,DoublyLinkedList.py::removeTail::65,"    def removeTail(self):
        temp = self.tail
        self.tail = temp.prev
        temp.prev.next = None
        temp = None",data\repos\Python-DSA\DSA\DoublyLinkedList.py,removeTail,30
117,DoublyLinkedList.py::remove::72,"    def remove(self, pos):
        temp = self.head
        i = 1
        while i < pos:
            temp = temp.next
            i += 1
        temp.prev.next = temp.next
        temp.next.prev = temp.prev
        temp = None",data\repos\Python-DSA\DSA\DoublyLinkedList.py,remove,57
118,DoublyLinkedList.py::display::83,"    def display(self):
        temp = self.head
        if self.isEmpty():
            print(""List is Empty"")
            return
        print(""head -> "", end = "" "")
        while (temp.next != None):
            print(temp.data, end = "" < -- > "")
            temp = temp.next
        print(temp.data, "" <- tail"")",data\repos\Python-DSA\DSA\DoublyLinkedList.py,display,71
119,find_Insert_position.py::find_index::4,"def find_index(arr, n, K):
	
	for i in range(n):
		if arr[i] == K:
			return i
			
		elif arr[i] > K:
			return i
			
	return n",data\repos\Python-DSA\DSA\find_Insert_position.py,find_index,42
120,Queue_using_list.py::Enqueue::3,"def Enqueue():
    if len(q)==size: # check wether the stack is full or not
        print(""Queue is Full!!!!"")
    else:
        element=input(""Enter the element:"")
        q.append(element)
        print(element,""is added to the Queue!"")",data\repos\Python-DSA\DSA\Queue_using_list.py,Enqueue,56
121,Queue_using_list.py::dequeue::10,"def dequeue():
    if not q:# or if len(stack)==0
        print(""Queue is Empty!!!"")
    else:
        e=q.pop(0)
        print(""element removed!!:"",e)",data\repos\Python-DSA\DSA\Queue_using_list.py,dequeue,42
122,Queue_using_list.py::display::16,"def display():
    print(q)
    size=int(input(""Enter the size of Queue:""))
    while True:
        print(""Select the Operation:1.Add 2.Delete 3. Display 4. Quit"")
        choice=int(input())
        if choice==1:
            Enqueue()
        elif choice==2:
            dequeue()
        elif choice==3:
            display()
        elif choice==4:
            break
        else:
            print(""Invalid Option!!!"")",data\repos\Python-DSA\DSA\Queue_using_list.py,display,96
123,SinglyLinkedList.py::count::21,"    def count(self):
        if self.isEmpty():
            return 0
        n = 0
        temp = self.head
        while (temp != None):
            n += 1
            temp = temp.next
        return n",data\repos\Python-DSA\DSA\SinglyLinkedList.py,count,49
124,SinglyLinkedList.py::addFront::32,"    def addFront(self, x):
        new_node = Node(x)
        if (self.isEmpty()):
            self.head = self.tail = new_node
            return
        new_node.next = self.head
        self.head = new_node",data\repos\Python-DSA\DSA\SinglyLinkedList.py,addFront,48
125,SinglyLinkedList.py::addTail::41,"    def addTail(self, x):
        new_node = Node(x)
        if (self.isEmpty()):
            self.head = self.tail = new_node
            return
        self.tail.next = new_node
        self.tail = new_node",data\repos\Python-DSA\DSA\SinglyLinkedList.py,addTail,48
126,SinglyLinkedList.py::insert::50,"    def insert(self, x, pos):
        if pos == 1:
            self.addFront(x)
            return
        if pos == (self.count()+1):
            self.addTail(x)
            return
        new_node = Node(x)
        temp = self.head
        i = 1
        while (temp != None) and (i < pos-1):
            temp = temp.next
            i += 1
        if (temp == None):
            return
        new_node.next = temp.next
        temp.next = new_node",data\repos\Python-DSA\DSA\SinglyLinkedList.py,insert,114
127,SinglyLinkedList.py::removeHead::69,"    def removeHead(self):
        if self.isEmpty():
            return
        temp = self.head
        self.head = temp.next
        temp = None",data\repos\Python-DSA\DSA\SinglyLinkedList.py,removeHead,31
128,SinglyLinkedList.py::removeTail::77,"    def removeTail(self):
        if self.isEmpty():
            return
        temp = self.head
        while (temp != None) and (temp.next != self.tail):
            temp = temp.next
        self.tail = temp
        self.tail.next = None
        temp = None",data\repos\Python-DSA\DSA\SinglyLinkedList.py,removeTail,58
129,SinglyLinkedList.py::delete::88,"    def delete(self, v):
        if self.isEmpty():
            return
        temp = self.head
        if temp.data == v:
            self.head = temp.next
            temp = None
            return
        else:
            while temp.next != None:
                if temp.data == v:
                    break
                temp = temp.next
            if temp.next == None:
                return
            temp.data = None
            if temp.next != None:
                temp.data = temp.next.data
                temp.next = temp.next.next",data\repos\Python-DSA\DSA\SinglyLinkedList.py,delete,107
130,SinglyLinkedList.py::display::109,"    def display(self):
        temp = self.head
        if self.isEmpty():
            print(""List is Empty"")
            return
        print(""head -> "", end = "" "")
        while (temp.next != None):
            print(temp.data, end = "" -> "")
            temp = temp.next
        print(temp.data, "" <- tail"")",data\repos\Python-DSA\DSA\SinglyLinkedList.py,display,69
131,three_sum.py::threeSum::2,"def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i, num1 in enumerate(nums):

            if i > 0 and num1 == nums[i-1]:
                continue

            start, end = i+1, len(nums) - 1

            while start < end:
                sum = num1 + nums[start] + nums[end]

                if sum > 0:
                    end -= 1
                elif sum < 0:
                    start += 1
                else:
                    res.append([num1, nums[start], nums[end]])
                    start += 1
                    while nums[start] == nums[start-1] and start < end:
                        start += 1

        return res",data\repos\Python-DSA\DSA\three_sum.py,threeSum,159
132,Ackermann.py::Ackermann::1,"def Ackermann(m, n):
    if m == 0:
        return n + 1
    elif m > 0 and n == 0:
        return Ackermann(m - 1, 1)
    else:
        return Ackermann(m - 1, Ackermann(m, n - 1))     ",data\repos\Python-DSA\Recursion\Ackermann.py,Ackermann,67
133,Factorial_Recursion.py::fact::1,"def fact(n = 5):
    if n < 2:
        return 1
    else:
        return n * fact(n-1)",data\repos\Python-DSA\Recursion\Factorial_Recursion.py,fact,31
134,Fibonacci_Series.py::fib::1,"def fib(n):
     if n == 0:
          return 0
     elif n == 1:
          return 1
     else:
          return fib(n-1) + fib(n-2)",data\repos\Python-DSA\Recursion\Fibonacci_Series.py,fib,44
135,is_Palindrome.py::isPalindrome::3,"def isPalindrome(s, i):
    if(i > len(s)/2):  #base case
       return True
    ans = False
    if((s[i] is s[len(s) - i - 1]) and isPalindrome(s, i + 1)): #recursive step
      ans = True
    return ans",data\repos\Python-DSA\Recursion\is_Palindrome.py,isPalindrome,69
136,recursive_sum.py::recursiveSum::1,"def recursiveSum(l):
    if len(l) == 1:
        return l[0]
    return l[0] + recursiveSum(l[1:])",data\repos\Python-DSA\Recursion\recursive_sum.py,recursiveSum,33
137,Reversing a string using Recursion.py::reverse::1,"def reverse(word):
  size = len(word)
  if size == 0 :
    return 
  last_char = word[size-1]
  print(last_char,end='')
  return reverse(word[0:size-1])",data\repos\Python-DSA\Recursion\Reversing a string using Recursion.py,reverse,45
138,Tower_of_Honai.py::TowerofHonai::2,"def TowerofHonai(n, src, dest ,hel):
    if(n==0):
        return
    TowerofHonai(n-1,src,hel,dest)
    print(""move from"",src,""to"",dest)
    TowerofHonai(n-1,hel,dest,src)",data\repos\Python-DSA\Recursion\Tower_of_Honai.py,TowerofHonai,64
139,interpolation.py::interpolationSearch::1,"def interpolationSearch(arr, lo, hi, x):

    if (lo <= hi and x >= arr[lo] and x <= arr[hi]):



        pos = lo + ((hi - lo) // (arr[hi] - arr[lo]) *(x - arr[lo]))

 

        if arr[pos] == x:

            return pos

        if arr[pos] < x:

            return interpolationSearch(arr, pos + 1,hi, x)
        if arr[pos] > x:

            return interpolationSearch(arr, lo,pos - 1, x)

    return -1",data\repos\Python-DSA\Search Algorithms\interpolation.py,interpolationSearch,122
140,linear_search.py::linear_Search::1,"def linear_Search(list1, n, key):  
 
    for i in range(0, n):  
        if (list1[i] == key):  
            return i  
    return -1 ",data\repos\Python-DSA\Search Algorithms\linear_search.py,linear_Search,43
141,bubble.py::sortArray::3,"    def sortArray(self, N: List[int]) -> List[int]:
        L, B = len(N), 1
        while B:
            B = 0
            for i in range(L-1):
                if N[i] > N[i+1]: N[i], N[i+1], B = N[i+1], N[i], 1
        return N",data\repos\Python-DSA\Sort-all\bubble.py,sortArray,80
142,bucket.py::sortArray::2,"    def sortArray(self, N: List[int]) -> List[int]:
        def insertion_sort(A):
            for i in range(1,len(A)):
                for j in range(0,i):
                    if A[i] < A[j]:
                        A.insert(j, A.pop(i))
                        break
            return A
        
        def bucketsort(A):
            buckets, m, S = [[] for _ in range(1000)], min(A), []
            R = max(A) - m
            if R == 0: return A
            for a in A: buckets[999*(a-m)//R]
            for b in buckets: S.extend(insertion_sort(b))
            return S
    
        return bucketsort(N)",data\repos\Python-DSA\Sort-all\bucket.py,sortArray,148
143,bucket.py::insertion_sort::3,"        def insertion_sort(A):
            for i in range(1,len(A)):
                for j in range(0,i):
                    if A[i] < A[j]:
                        A.insert(j, A.pop(i))
                        break
            return A",data\repos\Python-DSA\Sort-all\bucket.py,insertion_sort,49
144,bucket.py::bucketsort::11,"        def bucketsort(A):
            buckets, m, S = [[] for _ in range(1000)], min(A), []
            R = max(A) - m
            if R == 0: return A
            for a in A: buckets[999*(a-m)//R]
            for b in buckets: S.extend(insertion_sort(b))
            return S",data\repos\Python-DSA\Sort-all\bucket.py,bucketsort,76
145,counting.py::sortArray::2,"    def sortArray(self, N: List[int]) -> List[int]:
        C, m, M, S = collections.Counter(N), min(N), max(N), []
        for n in range(m,M+1): S.extend([n]*C[n])
        return S",data\repos\Python-DSA\Sort-all\counting.py,sortArray,56
146,insertion.py::sortArray::3,"    def sortArray(self, N: List[int]) -> List[int]:
        L = len(N)
        for i in range(1,L):
            for j in range(0,i):
                if N[i] < N[j]:
                    N.insert(j, N.pop(i))
                    break
        return N",data\repos\Python-DSA\Sort-all\insertion.py,sortArray,63
147,merge.py::sortArray::2,"    def sortArray(self, N: List[int]) -> List[int]:
        def mergesort(A):
            LA = len(A)
            if LA == 1: return A
            LH, RH = mergesort(A[:LA//2]), mergesort(A[LA//2:])
            return merge(LH,RH)

        def merge(LH, RH):
            LLH, LRH = len(LH), len(RH)
            S, i, j = [], 0, 0
            while i < LLH and j < LRH:
                if LH[i] <= RH[j]: i, _ = i + 1, S.append(LH[i])
                else: j, _ = j + 1, S.append(RH[j])
            return S + (RH[j:] if i == LLH else LH[i:])
        
        return mergesort(N)		",data\repos\Python-DSA\Sort-all\merge.py,sortArray,182
148,merge.py::mergesort::3,"        def mergesort(A):
            LA = len(A)
            if LA == 1: return A
            LH, RH = mergesort(A[:LA//2]), mergesort(A[LA//2:])
            return merge(LH,RH)",data\repos\Python-DSA\Sort-all\merge.py,mergesort,51
149,merge.py::merge::9,"        def merge(LH, RH):
            LLH, LRH = len(LH), len(RH)
            S, i, j = [], 0, 0
            while i < LLH and j < LRH:
                if LH[i] <= RH[j]: i, _ = i + 1, S.append(LH[i])
                else: j, _ = j + 1, S.append(RH[j])
            return S + (RH[j:] if i == LLH else LH[i:])",data\repos\Python-DSA\Sort-all\merge.py,merge,108
150,quick.py::sortArray::2,"    def sortArray(self, N: List[int]) -> List[int]:
        def quicksort(A, I, J):
            if J - I <= 1: return
            p = partition(A, I, J)
            quicksort(A, I, p), quicksort(A, p + 1, J)
        
        def partition(A, I, J):
            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I
            for j in range(I,J):
                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1
            A[J-1], A[i] = A[i], A[J-1]
            return i
        
        quicksort(N,0,len(N))
        return N",data\repos\Python-DSA\Sort-all\quick.py,sortArray,185
151,quick.py::quicksort::3,"        def quicksort(A, I, J):
            if J - I <= 1: return
            p = partition(A, I, J)
            quicksort(A, I, p), quicksort(A, p + 1, J)",data\repos\Python-DSA\Sort-all\quick.py,quicksort,51
152,quick.py::partition::8,"        def partition(A, I, J):
            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I
            for j in range(I,J):
                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1
            A[J-1], A[i] = A[i], A[J-1]
            return i",data\repos\Python-DSA\Sort-all\quick.py,partition,105
153,Radix.py::counting_Sort::1,"def counting_Sort(array, exp1):   
    n = len(arr)
    output = [0] * (n)
    count = [0] * (10)
    for i in range(0, n):
        index = (arr[i]/exp1)
        count[int((index)%10)] += 1
    for i in range(1,10):
        count[i] += count[i-1]
    i = n-1
    while i>=0:
        index = (arr[i]/exp1)
        output[ count[ int((index)%10) ] - 1] = arr[i]
        count[int((index)%10)] -= 1
        i -= 1
    i = 0
    for i in range(0,len(arr)):
        arr[i] = output[i]",data\repos\Python-DSA\Sort-all\Radix.py,counting_Sort,173
154,Radix.py::radixSort::19,"def radixSort(arr):
    max1 = max(arr)
    exp = 1
    while max1/exp > 0:
        counting_Sort(arr,exp)
        exp *= 10",data\repos\Python-DSA\Sort-all\Radix.py,radixSort,40
155,selection.py::sortArray::3,"    def sortArray(self, N: List[int]) -> List[int]:
        L = len(N)
        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]",data\repos\Python-DSA\Sort-all\selection.py,sortArray,45
156,bogosort.py::is_sorted::14,"def is_sorted(a):
    n = len(a)
    for i in range(0, n - 1):
        if (a[i] > a[i + 1]):
            return False
    return True",data\repos\Python-DSA\Sorting Algorithms\bogosort.py,is_sorted,44
157,bogosort.py::shuffle::24,"def shuffle(a):
    n = len(a)
    for i in range(0, n):
        r = random.randint(0, n - 1)
        a[i], a[r] = a[r], a[i]",data\repos\Python-DSA\Sorting Algorithms\bogosort.py,shuffle,47
158,bubble_sort.py::bubble_sort::1,"def bubble_sort(array):
    for i in range(len(array)-1, 0, -1):
        for j in range(i):
            if array[j] > array[j+1]:
                temp = array[j]
                array[j] = array[j+1]
                array[j+1] = temp
    return array",data\repos\Python-DSA\Sorting Algorithms\bubble_sort.py,bubble_sort,67
159,bubble_sort.py::bubble_sort_optimized::11,"def bubble_sort_optimized(array):
    for i in range(len(array)):
        swapped = False
        for j in range(len(array)-i-1):
            if array[j] > array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]
                swapped = True

        if not swapped:
            break",data\repos\Python-DSA\Sorting Algorithms\bubble_sort.py,bubble_sort_optimized,73
160,bucket_sort.py::bucketSort::3,"def bucketSort(array):

    bucket = []

    # Create empty buckets

    for i in range(len(array)):

        bucket.append([])

    # Insert elements into their respective buckets

    for j in array:

        index_b = int(10 * j)

        bucket[index_b].append(j)

    # Sort the elements of each bucket

    for i in range(len(array)):

        bucket[i] = sorted(bucket[i])

    # Get the sorted elements

    k = 0

    for i in range(len(array)):

        for j in range(len(bucket[i])):

            array[k] = bucket[i][j]

            k += 1

    return array",data\repos\Python-DSA\Sorting Algorithms\bucket_sort.py,bucketSort,140
161,countSort.py::CountSort::1,"def CountSort(arr):
    res = [0]*len(arr)
    count = [0]*10
    for i in range(len(arr)):
        count[arr[i]] = count[arr[i]] + 1
    for i in range(1, 10):
        count[i] = count[i] + count[i-1]
    i = len(arr) - 1
    while i >= 0:
        res[count[arr[i]] - 1] = arr[i]
        count[arr[i]] -= 1
        i = i - 1
    return res",data\repos\Python-DSA\Sorting Algorithms\countSort.py,CountSort,120
162,heapSort.py::heapify::5,"def heapify(arr, n, i):
    largest = i  #initialize the largest as the root
    l = 2 * i + 1#check child of left = 2*i + 1
    r = 2 * i + 2#check child of right = 2*i + 2
 
    #if left child of root exists and > than root
    if l < n and arr[largest] < arr[l]:
        largest = l
 
     #if right child of root exists and > than root
    if r < n and arr[largest] < arr[r]:
        largest = r
 
    #changing the root to largest
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        #heapify the root.
        heapify(arr, n, largest)",data\repos\Python-DSA\Sorting Algorithms\heapSort.py,heapify,178
163,heapSort.py::heapSort::25,"def heapSort(arr):
    n = len(arr)
 
    #build the maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)
 
    #extracting the elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)",data\repos\Python-DSA\Sorting Algorithms\heapSort.py,heapSort,95
164,insertion_sort.py::insertion_sort::1,"def insertion_sort(array):
    for i in range(1, len(array)):
        temp = array[i]
        j = i-1

        while j >= 0 and temp < array[j]:
            array[j+1] = array[j]
            j = j-1

        array[j+1] = temp",data\repos\Python-DSA\Sorting Algorithms\insertion_sort.py,insertion_sort,66
165,mergesort.py::merge_sort::1,"def merge_sort(listt):
    '''
    list->list
    sort the inputed list in O(o*log n) time with O(n) space complexity
    '''
    mid=len(listt)//2
    if(len(listt)>1): #if less than or equal to one then it is already sorted so return the same list in that case
        left=listt[:mid]
        right=listt[mid:]
        merge_sort(left)
        merge_sort(right)

        i=j=k=0

        while i<len(left) and j<len(right):
            if left[i]>right[j]:
                listt[k]=right[j]
                k+=1
                j+=1
            else:
                listt[k]=left[i]
                i+=1
                k+=1
        while(i<len(left)):
            listt[k]=left[i]
            i+=1
            k+=1
        while(j<len(right)):
            listt[k]=right[j]
            j+=1
            k+=1
        return listt",data\repos\Python-DSA\Sorting Algorithms\mergesort.py,merge_sort,213
166,quick_sort.py::partition::16,"def partition(array, low, high):

	pivot = array[high]

	i = low - 1

	for j in range(low, high):
		if array[j] <= pivot:

			i = i + 1

			array[i], array[j] = array[j], array[i]

	array[i + 1], array[high] = array[high], array[i + 1]

	return i + 1",data\repos\Python-DSA\Sorting Algorithms\quick_sort.py,partition,86
167,quick_sort.py::quickSort::34,"def quickSort(array, low, high):
	if low < high:
		pi = partition(array, low, high)

		quickSort(array, low, pi - 1)

		quickSort(array, pi + 1, high)",data\repos\Python-DSA\Sorting Algorithms\quick_sort.py,quickSort,51
168,radix_sort.py::countingSort::1,"def countingSort(inputArray):
    maxEl = max(inputArray)

    countArrayLength = maxEl+1
    countArray = [0] * countArrayLength

    for el in inputArray: 
        countArray[el] += 1

    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1] 

    outputArray = [0] * len(inputArray)
    i = len(inputArray) - 1
    while i >= 0:
        currentEl = inputArray[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray",data\repos\Python-DSA\Sorting Algorithms\radix_sort.py,countingSort,155
169,shell_sort.py::shellSort::1,"def shellSort(input_list):
   gap = len(input_list) // 2
   while gap > 0:
      for i in range(gap, len(input_list)):
         temp = input_list[i]
         j = i
# Sort the sub list for this gap
   while j >= gap and input_list[j - gap] > temp:
      input_list[j] = input_list[j - gap]
      j = j-gap
      input_list[j] = temp
# Reduce the gap for the next element
   gap = gap//2",data\repos\Python-DSA\Sorting Algorithms\shell_sort.py,shellSort,113
170,tree_sort.py::inorder::23,"def inorder(root, res):
    # Recursive travesal 
    if root:
        inorder(root.left,res)
        res.append(root.val)
        inorder(root.right,res)",data\repos\Python-DSA\Sorting Algorithms\tree_sort.py,inorder,35
171,tree_sort.py::treesort::30,"def treesort(arr):
    # Build BST
    if len(arr) == 0:
        return arr
    root = node(arr[0])
    for i in range(1,len(arr)):
        root.insert(arr[i])
    # Traverse BST in order. 
    res = []
    inorder(root,res)
    return res",data\repos\Python-DSA\Sorting Algorithms\tree_sort.py,treesort,67
172,tree_sort.py::insert::8,"    def insert(self,val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val",data\repos\Python-DSA\Sorting Algorithms\tree_sort.py,insert,79
173,bfs.py::bfs::14,"def bfs(visited, graph, node):
  visited.append(node)
  queue.append(node)

  while queue:
    s = queue.pop(0) 
    print(s, end="" "") 

    for neighbour in graph[s]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)",data\repos\Python-DSA\Tree Data Structure\bfs.py,bfs,66
174,binarytree.py::add::16,"    def add(self, val):
        if self.root is None:
            self.root = Node(val)
        else:
            self._add(val, self.root)",data\repos\Python-DSA\Tree Data Structure\binarytree.py,add,33
175,binarytree.py::find::35,"    def find(self, val):
        if self.root is not None:
            return self._find(val, self.root)
        else:
            return None",data\repos\Python-DSA\Tree Data Structure\binarytree.py,find,31
176,binarytree_maxpath.py::insert::6,"def insert(temp,data):
   que = []
   que.append(temp)
   while (len(que)):
      temp = que[0]
      que.pop(0)
      if (not temp.left):
         if data is not None:
            temp.left = TreeNode(data)
         else:
            temp.left = TreeNode(0)
         break
      else:
         que.append(temp.left)
      if (not temp.right):
         if data is not None:
            temp.right = TreeNode(data)
         else:
            temp.right = TreeNode(0)
         break
      else:
         que.append(temp.right)",data\repos\Python-DSA\Tree Data Structure\binarytree_maxpath.py,insert,122
177,binarytree_maxpath.py::make_tree::28,"def make_tree(elements):
   Tree = TreeNode(elements[0])
   for element in elements[1:]:
      insert(Tree, element)
   return Tree",data\repos\Python-DSA\Tree Data Structure\binarytree_maxpath.py,make_tree,30
178,binarytree_maxpath.py::solve::38,"   def solve(self,node):
      if not node or node.data == 0:
         return 0
      left = max(0,self.solve(node.left))
      right = max(0,self.solve(node.right))
      self.ans = max(self.ans,left+right+node.data)
      return node.data + max(left,right)",data\repos\Python-DSA\Tree Data Structure\binarytree_maxpath.py,solve,69
179,dfs.py::dfs::14,"def dfs(visited, graph, node):
    if node not in visited:
        print (node, end="" "")
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)",data\repos\Python-DSA\Tree Data Structure\dfs.py,dfs,45
180,inorder_traversal.py::insert::6,"def insert(temp,data):
   que = []
   que.append(temp)
   while (len(que)):
      temp = que[0]
      que.pop(0)
      if (not temp.left):
         temp.left = TreeNode(data)
         break
      else:
         que.append(temp.left)
      if (not temp.right):
         temp.right = TreeNode(data)
         break
      else:
         que.append(temp.right)",data\repos\Python-DSA\Tree Data Structure\inorder_traversal.py,insert,86
181,inorder_traversal.py::make_tree::22,"def make_tree(elements):
   Tree = TreeNode(elements[0])
   for element in elements[1:]:
      insert(Tree, element)
   return Tree",data\repos\Python-DSA\Tree Data Structure\inorder_traversal.py,make_tree,30
182,inorder_traversal.py::inorderTraversal::28,"   def inorderTraversal(self, root):
      res, stack = [], []
      current = root
      while True:
         while current:
            stack.append(current)
            current = current.left
         if len(stack) == 0:
            return res
         node = stack[-1]
         stack.pop(len(stack)-1)
         if node.data != None:
            res.append(node.data)
         current = node.right
      return res",data\repos\Python-DSA\Tree Data Structure\inorder_traversal.py,inorderTraversal,89
183,morris_traversal.py::morris_traversal::9,"def morris_traversal(root):

	current = root

	while current is not None:

		if current.left is None:
			yield current.data
			current = current.right
		else:

			# Find the inorder
			# predecessor of current
			pre = current.left
			while pre.right is not None and pre.right is not current:
				pre = pre.right

			if pre.right is None:

				# Make current as right
				# child of its inorder predecessor
				pre.right = current
				current = current.left

			else:
				# Revert the changes made
				pre.right = None
				yield current.data
				current = current.right",data\repos\Python-DSA\Tree Data Structure\morris_traversal.py,morris_traversal,142
184,postorder_traversal.py::insert::6,"def insert(temp,data):
   que = []
   que.append(temp)
   while (len(que)):
      temp = que[0]
      que.pop(0)
      if (not temp.left):
         if data is not None:
            temp.left = TreeNode(data)
         else:
            temp.left = TreeNode(0)
         break
      else:
         que.append(temp.left)
      if (not temp.right):
         if data is not None:
            temp.right = TreeNode(data)
         else:
            temp.right = TreeNode(0)
         break
      else:
         que.append(temp.right)",data\repos\Python-DSA\Tree Data Structure\postorder_traversal.py,insert,122
185,postorder_traversal.py::make_tree::28,"def make_tree(elements):
   Tree = TreeNode(elements[0])
   for element in elements[1:]:
      insert(Tree, element)
   return Tree",data\repos\Python-DSA\Tree Data Structure\postorder_traversal.py,make_tree,30
186,postorder_traversal.py::postorderTraversal::34,"   def postorderTraversal(self, root):
      if not root:
         return []
      res = []
      stack = [[root,0]]
      while stack:
         node = stack[-1]
         stack.pop()
         if node[1]== 0 :
            current = node[0]
            stack.append([current,1])
            if current.right:
               stack.append([current.right,0])
            if current.left:
               stack.append([current.left,0])
         else:
            if node[0].data != 0:
               res.append(node[0].data)
      return res",data\repos\Python-DSA\Tree Data Structure\postorder_traversal.py,postorderTraversal,122
187,exponential_search.py::binary_search::2,"def binary_search(arr, low, high, x):
    while low <= high:
        mid = low + (high - low)/2;

        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1

    return -1",data\repos\Python-DSA\Search Algorithms\Exponential Search\exponential_search.py,binary_search,72
188,exponential_search.py::exponential_search::15,"def exponential_search(arr, low, high, x):
    if arr[low] == x:
        return low

    i = (low + 1) * 2
    while i <= high and arr[i] <= x:
        i *= 2

    return binary_search(arr, i / 2, min(i, high), x)",data\repos\Python-DSA\Search Algorithms\Exponential Search\exponential_search.py,exponential_search,73
189,fibonacci_search.py::fibonacciSearch::3,"def fibonacciSearch(arr,x):

    #fibonacci numbers initialization
    fib2 = 0
    fib1 = 1
    fib = fib2 + fib1

    n = len(arr)
    #find the smallest fibonacci greater than or equal to array length
    while (fib < n):
        fib2 = fib1
        fib1 = fib
        fib = fib2 + fib1

    #the leftout list for the array
    offset = -1

    while (fib > 1):
        #check if fib2 is a valid index
        i = min(offset+fib2, n-1)

        #if x is greater than the value at index fib2,
        #cut the array from offset to i
        if (arr[i] < x):
            fib = fib1
            fib1 = fib2
            fib2 = fib - fib1
            offset = i

        #if x is smaller than the value at index fib2,
        #cut the array after i+1
        elif (arr[i] > x):
            fib = fib2
            fib1 = fib1 - fib2
            fib2 = fib - fib1

        #return i when element is found
        else :
            return i

    #compare last element with x
    if (fib1 and arr[offset+1] == x):
        return offset+1

    #when element not found return -1
    return -1",data\repos\Python-DSA\Search Algorithms\Fibonacci-Search\fibonacci_search.py,fibonacciSearch,309
190,butterworth_filter.py::make_lowpass::13,"def make_lowpass(
    frequency: int,
    samplerate: int,
    q_factor: float = 1 / sqrt(2),
) -> IIRFilter:
    """"""
    Creates a low-pass filter

    >>> filter = make_lowpass(1000, 48000)
    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,
     0.008555138626189618, 0.004277569313094809]
    """"""
    w0 = tau * frequency / samplerate
    _sin = sin(w0)
    _cos = cos(w0)
    alpha = _sin / (2 * q_factor)

    b0 = (1 - _cos) / 2
    b1 = 1 - _cos

    a0 = 1 + alpha
    a1 = -2 * _cos
    a2 = 1 - alpha

    filt = IIRFilter(2)
    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])
    return filt",data\repos\Python\audio_filters\butterworth_filter.py,make_lowpass,272
191,butterworth_filter.py::make_highpass::43,"def make_highpass(
    frequency: int,
    samplerate: int,
    q_factor: float = 1 / sqrt(2),
) -> IIRFilter:
    """"""
    Creates a high-pass filter

    >>> filter = make_highpass(1000, 48000)
    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,
     -1.9914448613738105, 0.9957224306869052]
    """"""
    w0 = tau * frequency / samplerate
    _sin = sin(w0)
    _cos = cos(w0)
    alpha = _sin / (2 * q_factor)

    b0 = (1 + _cos) / 2
    b1 = -1 - _cos

    a0 = 1 + alpha
    a1 = -2 * _cos
    a2 = 1 - alpha

    filt = IIRFilter(2)
    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])
    return filt",data\repos\Python\audio_filters\butterworth_filter.py,make_highpass,272
192,butterworth_filter.py::make_bandpass::73,"def make_bandpass(
    frequency: int,
    samplerate: int,
    q_factor: float = 1 / sqrt(2),
) -> IIRFilter:
    """"""
    Creates a band-pass filter

    >>> filter = make_bandpass(1000, 48000)
    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,
     0, -0.06526309611002579]
    """"""
    w0 = tau * frequency / samplerate
    _sin = sin(w0)
    _cos = cos(w0)
    alpha = _sin / (2 * q_factor)

    b0 = _sin / 2
    b1 = 0
    b2 = -b0

    a0 = 1 + alpha
    a1 = -2 * _cos
    a2 = 1 - alpha

    filt = IIRFilter(2)
    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])
    return filt",data\repos\Python\audio_filters\butterworth_filter.py,make_bandpass,266
193,butterworth_filter.py::make_allpass::104,"def make_allpass(
    frequency: int,
    samplerate: int,
    q_factor: float = 1 / sqrt(2),
) -> IIRFilter:
    """"""
    Creates an all-pass filter

    >>> filter = make_allpass(1000, 48000)
    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,
     -1.9828897227476208, 1.0922959556412573]
    """"""
    w0 = tau * frequency / samplerate
    _sin = sin(w0)
    _cos = cos(w0)
    alpha = _sin / (2 * q_factor)

    b0 = 1 - alpha
    b1 = -2 * _cos
    b2 = 1 + alpha

    filt = IIRFilter(2)
    filt.set_coefficients([b2, b1, b0], [b0, b1, b2])
    return filt",data\repos\Python\audio_filters\butterworth_filter.py,make_allpass,248
194,butterworth_filter.py::make_peak::131,"def make_peak(
    frequency: int,
    samplerate: int,
    gain_db: float,
    q_factor: float = 1 / sqrt(2),
) -> IIRFilter:
    """"""
    Creates a peak filter

    >>> filter = make_peak(1000, 48000, 6)
    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
    [1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,
     -1.9828897227476208, 0.8696284974398878]
    """"""
    w0 = tau * frequency / samplerate
    _sin = sin(w0)
    _cos = cos(w0)
    alpha = _sin / (2 * q_factor)
    big_a = 10 ** (gain_db / 40)

    b0 = 1 + alpha * big_a
    b1 = -2 * _cos
    b2 = 1 - alpha * big_a
    a0 = 1 + alpha / big_a
    a1 = -2 * _cos
    a2 = 1 - alpha / big_a

    filt = IIRFilter(2)
    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])
    return filt",data\repos\Python\audio_filters\butterworth_filter.py,make_peak,308
195,butterworth_filter.py::make_lowshelf::163,"def make_lowshelf(
    frequency: int,
    samplerate: int,
    gain_db: float,
    q_factor: float = 1 / sqrt(2),
) -> IIRFilter:
    """"""
    Creates a low-shelf filter

    >>> filter = make_lowshelf(1000, 48000, 6)
    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
    [3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,
     -5.591841778072785, 2.5201667380627257]
    """"""
    w0 = tau * frequency / samplerate
    _sin = sin(w0)
    _cos = cos(w0)
    alpha = _sin / (2 * q_factor)
    big_a = 10 ** (gain_db / 40)
    pmc = (big_a + 1) - (big_a - 1) * _cos
    ppmc = (big_a + 1) + (big_a - 1) * _cos
    mpc = (big_a - 1) - (big_a + 1) * _cos
    pmpc = (big_a - 1) + (big_a + 1) * _cos
    aa2 = 2 * sqrt(big_a) * alpha

    b0 = big_a * (pmc + aa2)
    b1 = 2 * big_a * mpc
    b2 = big_a * (pmc - aa2)
    a0 = ppmc + aa2
    a1 = -2 * pmpc
    a2 = ppmc - aa2

    filt = IIRFilter(2)
    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])
    return filt",data\repos\Python\audio_filters\butterworth_filter.py,make_lowshelf,419
196,butterworth_filter.py::make_highshelf::200,"def make_highshelf(
    frequency: int,
    samplerate: int,
    gain_db: float,
    q_factor: float = 1 / sqrt(2),
) -> IIRFilter:
    """"""
    Creates a high-shelf filter

    >>> filter = make_highshelf(1000, 48000, 6)
    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
    [2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,
     -7.922740859457287, 3.6756456963725253]
    """"""
    w0 = tau * frequency / samplerate
    _sin = sin(w0)
    _cos = cos(w0)
    alpha = _sin / (2 * q_factor)
    big_a = 10 ** (gain_db / 40)
    pmc = (big_a + 1) - (big_a - 1) * _cos
    ppmc = (big_a + 1) + (big_a - 1) * _cos
    mpc = (big_a - 1) - (big_a + 1) * _cos
    pmpc = (big_a - 1) + (big_a + 1) * _cos
    aa2 = 2 * sqrt(big_a) * alpha

    b0 = big_a * (ppmc + aa2)
    b1 = -2 * big_a * pmpc
    b2 = big_a * (ppmc - aa2)
    a0 = pmc + aa2
    a1 = 2 * mpc
    a2 = pmc - aa2

    filt = IIRFilter(2)
    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])
    return filt",data\repos\Python\audio_filters\butterworth_filter.py,make_highshelf,421
197,iir_filter.py::set_coefficients::39,"    def set_coefficients(self, a_coeffs: list[float], b_coeffs: list[float]) -> None:
        """"""
        Set the coefficients for the IIR filter.
        These should both be of size `order` + 1.
        :math:`a_0` may be left out, and it will use 1.0 as default value.

        This method works well with scipy's filter design functions

        >>> # Make a 2nd-order 1000Hz butterworth lowpass filter
        >>> import scipy.signal
        >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,
        ...                                          btype='lowpass',
        ...                                          fs=48000)
        >>> filt = IIRFilter(2)
        >>> filt.set_coefficients(a_coeffs, b_coeffs)
        """"""
        if len(a_coeffs) < self.order:
            a_coeffs = [1.0, *a_coeffs]

        if len(a_coeffs) != self.order + 1:
            msg = (
                f""Expected a_coeffs to have {self.order + 1} elements ""
                f""for {self.order}-order filter, got {len(a_coeffs)}""
            )
            raise ValueError(msg)

        if len(b_coeffs) != self.order + 1:
            msg = (
                f""Expected b_coeffs to have {self.order + 1} elements ""
                f""for {self.order}-order filter, got {len(a_coeffs)}""
            )
            raise ValueError(msg)

        self.a_coeffs = a_coeffs
        self.b_coeffs = b_coeffs",data\repos\Python\audio_filters\iir_filter.py,set_coefficients,324
198,iir_filter.py::process::75,"    def process(self, sample: float) -> float:
        """"""
        Calculate :math:`y[n]`

        >>> filt = IIRFilter(2)
        >>> filt.process(0)
        0.0
        """"""
        result = 0.0

        # Start at index 1 and do index 0 at the end.
        for i in range(1, self.order + 1):
            result += (
                self.b_coeffs[i] * self.input_history[i - 1]
                - self.a_coeffs[i] * self.output_history[i - 1]
            )

        result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]

        self.input_history[1:] = self.input_history[:-1]
        self.output_history[1:] = self.output_history[:-1]

        self.input_history[0] = sample
        self.output_history[0] = result

        return result",data\repos\Python\audio_filters\iir_filter.py,process,196
199,show_response.py::get_bounds::22,"def get_bounds(
    fft_results: np.ndarray, samplerate: int
) -> tuple[int | float, int | float]:
    """"""
    Get bounds for printing fft results

    >>> import numpy
    >>> array = numpy.linspace(-20.0, 20.0, 1000)
    >>> get_bounds(array, 1000)
    (-20, 20)
    """"""
    lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])
    highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])
    return lowest, highest",data\repos\Python\audio_filters\show_response.py,get_bounds,136
200,show_response.py::show_frequency_response::38,"def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:
    """"""
    Show frequency response of a filter

    >>> from audio_filters.iir_filter import IIRFilter
    >>> filt = IIRFilter(4)
    >>> show_frequency_response(filt, 48000)
    """"""

    size = 512
    inputs = [1] + [0] * (size - 1)
    outputs = [filter_type.process(item) for item in inputs]

    filler = [0] * (samplerate - size)  # zero-padding
    outputs += filler
    fft_out = np.abs(np.fft.fft(outputs))
    fft_db = 20 * np.log10(fft_out)

    # Frequencies on log scale from 24 to nyquist frequency
    plt.xlim(24, samplerate / 2 - 1)
    plt.xlabel(""Frequency (Hz)"")
    plt.xscale(""log"")

    # Display within reasonable bounds
    bounds = get_bounds(fft_db, samplerate)
    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))
    plt.ylabel(""Gain (dB)"")

    plt.plot(fft_db)
    plt.show()",data\repos\Python\audio_filters\show_response.py,show_frequency_response,255
201,show_response.py::show_phase_response::70,"def show_phase_response(filter_type: FilterType, samplerate: int) -> None:
    """"""
    Show phase response of a filter

    >>> from audio_filters.iir_filter import IIRFilter
    >>> filt = IIRFilter(4)
    >>> show_phase_response(filt, 48000)
    """"""

    size = 512
    inputs = [1] + [0] * (size - 1)
    outputs = [filter_type.process(item) for item in inputs]

    filler = [0] * (samplerate - size)  # zero-padding
    outputs += filler
    fft_out = np.angle(np.fft.fft(outputs))

    # Frequencies on log scale from 24 to nyquist frequency
    plt.xlim(24, samplerate / 2 - 1)
    plt.xlabel(""Frequency (Hz)"")
    plt.xscale(""log"")

    plt.ylim(-2 * pi, 2 * pi)
    plt.ylabel(""Phase shift (Radians)"")
    plt.plot(np.unwrap(fft_out, -2 * pi))
    plt.show()",data\repos\Python\audio_filters\show_response.py,show_phase_response,222
202,show_response.py::process::13,"    def process(self, sample: float) -> float:
        """"""
        Calculate y[n]

        >>> issubclass(FilterType, Protocol)
        True
        """"""",data\repos\Python\audio_filters\show_response.py,process,33
203,all_combinations.py::combination_lists::13,"def combination_lists(n: int, k: int) -> list[list[int]]:
    """"""
    Generates all possible combinations of k numbers out of 1 ... n using itertools.

    >>> combination_lists(n=4, k=2)
    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
    """"""
    return [list(x) for x in combinations(range(1, n + 1), k)]",data\repos\Python\backtracking\all_combinations.py,combination_lists,107
204,all_combinations.py::generate_all_combinations::23,"def generate_all_combinations(n: int, k: int) -> list[list[int]]:
    """"""
    Generates all possible combinations of k numbers out of 1 ... n using backtracking.

    >>> generate_all_combinations(n=4, k=2)
    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
    >>> generate_all_combinations(n=0, k=0)
    [[]]
    >>> generate_all_combinations(n=10, k=-1)
    Traceback (most recent call last):
        ...
    ValueError: k must not be negative
    >>> generate_all_combinations(n=-1, k=10)
    Traceback (most recent call last):
        ...
    ValueError: n must not be negative
    >>> generate_all_combinations(n=5, k=4)
    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]
    >>> generate_all_combinations(n=3, k=3)
    [[1, 2, 3]]
    >>> generate_all_combinations(n=3, k=1)
    [[1], [2], [3]]
    >>> generate_all_combinations(n=1, k=0)
    [[]]
    >>> generate_all_combinations(n=1, k=1)
    [[1]]
    >>> from itertools import combinations
    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)
    ...     for n in range(1, 6) for k in range(1, 6))
    True
    """"""
    if k < 0:
        raise ValueError(""k must not be negative"")
    if n < 0:
        raise ValueError(""n must not be negative"")

    result: list[list[int]] = []
    create_all_state(1, n, k, [], result)
    return result",data\repos\Python\backtracking\all_combinations.py,generate_all_combinations,446
205,all_combinations.py::create_all_state::64,"def create_all_state(
    increment: int,
    total_number: int,
    level: int,
    current_list: list[int],
    total_list: list[list[int]],
) -> None:
    """"""
    Helper function to recursively build all combinations.

    >>> create_all_state(1, 4, 2, [], result := [])
    >>> result
    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
    >>> create_all_state(1, 3, 3, [], result := [])
    >>> result
    [[1, 2, 3]]
    >>> create_all_state(2, 2, 1, [1], result := [])
    >>> result
    [[1, 2]]
    >>> create_all_state(1, 0, 0, [], result := [])
    >>> result
    [[]]
    >>> create_all_state(1, 4, 0, [1, 2], result := [])
    >>> result
    [[1, 2]]
    >>> create_all_state(5, 4, 2, [1, 2], result := [])
    >>> result
    []
    """"""
    if level == 0:
        total_list.append(current_list[:])
        return

    for i in range(increment, total_number - level + 2):
        current_list.append(i)
        create_all_state(i + 1, total_number, level - 1, current_list, total_list)
        current_list.pop()",data\repos\Python\backtracking\all_combinations.py,create_all_state,331
206,all_permutations.py::generate_all_permutations::12,"def generate_all_permutations(sequence: list[int | str]) -> None:
    create_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])",data\repos\Python\backtracking\all_permutations.py,generate_all_permutations,36
207,all_permutations.py::create_state_space_tree::16,"def create_state_space_tree(
    sequence: list[int | str],
    current_sequence: list[int | str],
    index: int,
    index_used: list[int],
) -> None:
    """"""
    Creates a state space tree to iterate through each branch using DFS.
    We know that each state has exactly len(sequence) - index children.
    It terminates when it reaches the end of the given sequence.

    :param sequence: The input sequence for which permutations are generated.
    :param current_sequence: The current permutation being built.
    :param index: The current index in the sequence.
    :param index_used: list to track which elements are used in permutation.

    Example 1:
    >>> sequence = [1, 2, 3]
    >>> current_sequence = []
    >>> index_used = [False, False, False]
    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 1, 2]
    [3, 2, 1]

    Example 2:
    >>> sequence = [""A"", ""B"", ""C""]
    >>> current_sequence = []
    >>> index_used = [False, False, False]
    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)
    ['A', 'B', 'C']
    ['A', 'C', 'B']
    ['B', 'A', 'C']
    ['B', 'C', 'A']
    ['C', 'A', 'B']
    ['C', 'B', 'A']

    Example 3:
    >>> sequence = [1]
    >>> current_sequence = []
    >>> index_used = [False]
    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)
    [1]
    """"""

    if index == len(sequence):
        print(current_sequence)
        return

    for i in range(len(sequence)):
        if not index_used[i]:
            current_sequence.append(sequence[i])
            index_used[i] = True
            create_state_space_tree(sequence, current_sequence, index + 1, index_used)
            current_sequence.pop()
            index_used[i] = False",data\repos\Python\backtracking\all_permutations.py,create_state_space_tree,487
208,all_subsequences.py::create_state_space_tree::18,"def create_state_space_tree(
    sequence: list[Any], current_subsequence: list[Any], index: int
) -> None:
    """"""
    Creates a state space tree to iterate through each branch using DFS.
    We know that each state has exactly two children.
    It terminates when it reaches the end of the given sequence.

    :param sequence: The input sequence for which subsequences are generated.
    :param current_subsequence: The current subsequence being built.
    :param index: The current index in the sequence.

    Example:
    >>> sequence = [3, 2, 1]
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []
    [1]
    [2]
    [2, 1]
    [3]
    [3, 1]
    [3, 2]
    [3, 2, 1]

    >>> sequence = [""A"", ""B""]
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []
    ['B']
    ['A']
    ['A', 'B']

    >>> sequence = []
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []

    >>> sequence = [1, 2, 3, 4]
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []
    [4]
    [3]
    [3, 4]
    [2]
    [2, 4]
    [2, 3]
    [2, 3, 4]
    [1]
    [1, 4]
    [1, 3]
    [1, 3, 4]
    [1, 2]
    [1, 2, 4]
    [1, 2, 3]
    [1, 2, 3, 4]
    """"""

    if index == len(sequence):
        print(current_subsequence)
        return

    create_state_space_tree(sequence, current_subsequence, index + 1)
    current_subsequence.append(sequence[index])
    create_state_space_tree(sequence, current_subsequence, index + 1)
    current_subsequence.pop()",data\repos\Python\backtracking\all_subsequences.py,create_state_space_tree,484
209,coloring.py::valid_coloring::10,"def valid_coloring(
    neighbours: list[int], colored_vertices: list[int], color: int
) -> bool:
    """"""
    For each neighbour check if the coloring constraint is satisfied
    If any of the neighbours fail the constraint return False
    If all neighbours validate the constraint return True

    >>> neighbours = [0,1,0,1,0]
    >>> colored_vertices = [0, 2, 1, 2, 0]

    >>> color = 1
    >>> valid_coloring(neighbours, colored_vertices, color)
    True

    >>> color = 2
    >>> valid_coloring(neighbours, colored_vertices, color)
    False
    """"""
    # Does any neighbour not satisfy the constraints
    return not any(
        neighbour == 1 and colored_vertices[i] == color
        for i, neighbour in enumerate(neighbours)
    )",data\repos\Python\backtracking\coloring.py,valid_coloring,184
210,coloring.py::util_color::36,"def util_color(
    graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int
) -> bool:
    """"""
    Pseudo-Code

    Base Case:
    1. Check if coloring is complete
        1.1 If complete return True (meaning that we successfully colored the graph)

    Recursive Step:
    2. Iterates over each color:
        Check if the current coloring is valid:
            2.1. Color given vertex
            2.2. Do recursive call, check if this coloring leads to a solution
            2.4. if current coloring leads to a solution return
            2.5. Uncolor given vertex

    >>> graph = [[0, 1, 0, 0, 0],
    ...          [1, 0, 1, 0, 1],
    ...          [0, 1, 0, 1, 0],
    ...          [0, 1, 1, 0, 0],
    ...          [0, 1, 0, 0, 0]]
    >>> max_colors = 3
    >>> colored_vertices = [0, 1, 0, 0, 0]
    >>> index = 3

    >>> util_color(graph, max_colors, colored_vertices, index)
    True

    >>> max_colors = 2
    >>> util_color(graph, max_colors, colored_vertices, index)
    False
    """"""

    # Base Case
    if index == len(graph):
        return True

    # Recursive Step
    for i in range(max_colors):
        if valid_coloring(graph[index], colored_vertices, i):
            # Color current vertex
            colored_vertices[index] = i
            # Validate coloring
            if util_color(graph, max_colors, colored_vertices, index + 1):
                return True
            # Backtrack
            colored_vertices[index] = -1
    return False",data\repos\Python\backtracking\coloring.py,util_color,417
211,coloring.py::color::88,"def color(graph: list[list[int]], max_colors: int) -> list[int]:
    """"""
    Wrapper function to call subroutine called util_color
    which will either return True or False.
    If True is returned colored_vertices list is filled with correct colorings

    >>> graph = [[0, 1, 0, 0, 0],
    ...          [1, 0, 1, 0, 1],
    ...          [0, 1, 0, 1, 0],
    ...          [0, 1, 1, 0, 0],
    ...          [0, 1, 0, 0, 0]]

    >>> max_colors = 3
    >>> color(graph, max_colors)
    [0, 1, 0, 2, 0]

    >>> max_colors = 2
    >>> color(graph, max_colors)
    []
    """"""
    colored_vertices = [-1] * len(graph)

    if util_color(graph, max_colors, colored_vertices, 0):
        return colored_vertices

    return []",data\repos\Python\backtracking\coloring.py,color,230
212,combination_sum.py::backtrack::16,"def backtrack(
    candidates: list, path: list, answer: list, target: int, previous_index: int
) -> None:
    """"""
    A recursive function that searches for possible combinations. Backtracks in case
    of a bigger current combination value than the target value.

    Parameters
    ----------
    previous_index: Last index from the previous search
    target: The value we need to obtain by summing our integers in the path list.
    answer: A list of possible combinations
    path: Current combination
    candidates: A list of integers we can use.
    """"""
    if target == 0:
        answer.append(path.copy())
    else:
        for index in range(previous_index, len(candidates)):
            if target >= candidates[index]:
                path.append(candidates[index])
                backtrack(candidates, path, answer, target - candidates[index], index)
                path.pop(len(path) - 1)",data\repos\Python\backtracking\combination_sum.py,backtrack,189
213,combination_sum.py::combination_sum::41,"def combination_sum(candidates: list, target: int) -> list:
    """"""
    >>> combination_sum([2, 3, 5], 8)
    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]
    >>> combination_sum([2, 3, 6, 7], 7)
    [[2, 2, 3], [7]]
    >>> combination_sum([-8, 2.3, 0], 1)
    Traceback (most recent call last):
        ...
    ValueError: All elements in candidates must be non-negative
    >>> combination_sum([], 1)
    Traceback (most recent call last):
        ...
    ValueError: Candidates list should not be empty
    """"""
    if not candidates:
        raise ValueError(""Candidates list should not be empty"")

    if any(x < 0 for x in candidates):
        raise ValueError(""All elements in candidates must be non-negative"")

    path = []  # type: list[int]
    answer = []  # type: list[int]
    backtrack(candidates, path, answer, target, 0)
    return answer",data\repos\Python\backtracking\combination_sum.py,combination_sum,245
214,crossword_puzzle_solver.py::is_valid::4,"def is_valid(
    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool
) -> bool:
    """"""
    Check if a word can be placed at the given position.

    >>> puzzle = [
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', '']
    ... ]
    >>> is_valid(puzzle, 'word', 0, 0, True)
    True
    >>> puzzle = [
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', '']
    ... ]
    >>> is_valid(puzzle, 'word', 0, 0, False)
    True
    """"""
    for i in range(len(word)):
        if vertical:
            if row + i >= len(puzzle) or puzzle[row + i][col] != """":
                return False
        elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != """":
            return False
    return True",data\repos\Python\backtracking\crossword_puzzle_solver.py,is_valid,235
215,crossword_puzzle_solver.py::place_word::36,"def place_word(
    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool
) -> None:
    """"""
    Place a word at the given position.

    >>> puzzle = [
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', '']
    ... ]
    >>> place_word(puzzle, 'word', 0, 0, True)
    >>> puzzle
    [['w', '', '', ''], ['o', '', '', ''], ['r', '', '', ''], ['d', '', '', '']]
    """"""
    for i, char in enumerate(word):
        if vertical:
            puzzle[row + i][col] = char
        else:
            puzzle[row][col + i] = char",data\repos\Python\backtracking\crossword_puzzle_solver.py,place_word,172
216,crossword_puzzle_solver.py::remove_word::59,"def remove_word(
    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool
) -> None:
    """"""
    Remove a word from the given position.

    >>> puzzle = [
    ...     ['w', '', '', ''],
    ...     ['o', '', '', ''],
    ...     ['r', '', '', ''],
    ...     ['d', '', '', '']
    ... ]
    >>> remove_word(puzzle, 'word', 0, 0, True)
    >>> puzzle
    [['', '', '', ''], ['', '', '', ''], ['', '', '', ''], ['', '', '', '']]
    """"""
    for i in range(len(word)):
        if vertical:
            puzzle[row + i][col] = """"
        else:
            puzzle[row][col + i] = """"",data\repos\Python\backtracking\crossword_puzzle_solver.py,remove_word,171
217,crossword_puzzle_solver.py::solve_crossword::82,"def solve_crossword(puzzle: list[list[str]], words: list[str]) -> bool:
    """"""
    Solve the crossword puzzle using backtracking.

    >>> puzzle = [
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', '']
    ... ]

    >>> words = ['word', 'four', 'more', 'last']
    >>> solve_crossword(puzzle, words)
    True
    >>> puzzle = [
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', ''],
    ...     ['', '', '', '']
    ... ]
    >>> words = ['word', 'four', 'more', 'paragraphs']
    >>> solve_crossword(puzzle, words)
    False
    """"""
    for row in range(len(puzzle)):
        for col in range(len(puzzle[0])):
            if puzzle[row][col] == """":
                for word in words:
                    for vertical in [True, False]:
                        if is_valid(puzzle, word, row, col, vertical):
                            place_word(puzzle, word, row, col, vertical)
                            words.remove(word)
                            if solve_crossword(puzzle, words):
                                return True
                            words.append(word)
                            remove_word(puzzle, word, row, col, vertical)
                return False
    return True",data\repos\Python\backtracking\crossword_puzzle_solver.py,solve_crossword,289
218,generate_parentheses.py::backtrack::11,"def backtrack(
    partial: str, open_count: int, close_count: int, n: int, result: list[str]
) -> None:
    """"""
    Generate valid combinations of balanced parentheses using recursion.

    :param partial: A string representing the current combination.
    :param open_count: An integer representing the count of open parentheses.
    :param close_count: An integer representing the count of close parentheses.
    :param n: An integer representing the total number of pairs.
    :param result: A list to store valid combinations.
    :return: None

    This function uses recursion to explore all possible combinations,
    ensuring that at each step, the parentheses remain balanced.

    Example:
    >>> result = []
    >>> backtrack("""", 0, 0, 2, result)
    >>> result
    ['(())', '()()']
    """"""
    if len(partial) == 2 * n:
        # When the combination is complete, add it to the result.
        result.append(partial)
        return

    if open_count < n:
        # If we can add an open parenthesis, do so, and recurse.
        backtrack(partial + ""("", open_count + 1, close_count, n, result)

    if close_count < open_count:
        # If we can add a close parenthesis (it won't make the combination invalid),
        # do so, and recurse.
        backtrack(partial + "")"", open_count, close_count + 1, n, result)",data\repos\Python\backtracking\generate_parentheses.py,backtrack,310
219,generate_parentheses.py::generate_parenthesis::48,"def generate_parenthesis(n: int) -> list[str]:
    """"""
    Generate valid combinations of balanced parentheses for a given n.

    :param n: An integer representing the number of pairs of parentheses.
    :return: A list of strings with valid combinations.

    This function uses a recursive approach to generate the combinations.

    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.
    Space Complexity: O(n) - where 'n' is the number of pairs.

    Example 1:
    >>> generate_parenthesis(3)
    ['((()))', '(()())', '(())()', '()(())', '()()()']

    Example 2:
    >>> generate_parenthesis(1)
    ['()']
    """"""

    result: list[str] = []
    backtrack("""", 0, 0, n, result)
    return result",data\repos\Python\backtracking\generate_parentheses.py,generate_parenthesis,190
220,generate_parentheses_iterative.py::generate_parentheses_iterative::1,"def generate_parentheses_iterative(length: int) -> list:
    """"""
    Generate all valid combinations of parentheses (Iterative Approach).

    The algorithm works as follows:
    1. Initialize an empty list to store the combinations.
    2. Initialize a stack to keep track of partial combinations.
    3. Start with empty string and push it onstack along with the counts of '(' and ')'.
    4. While the stack is not empty:
        a. Pop a partial combination and its open and close counts from the stack.
        b. If the combination length is equal to 2*length, add it to the result.
        c. If open count < length, push new combination with added '(' on stack.
        d. If close count < open count, push new combination with added ')' on stack.
    5. Return the result containing all valid combinations.

    Args:
        length: The desired length of the parentheses combinations

    Returns:
        A list of strings representing valid combinations of parentheses

    Time Complexity:
        O(2^(2*length))

    Space Complexity:
        O(2^(2*length))

    >>> generate_parentheses_iterative(3)
    ['()()()', '()(())', '(())()', '(()())', '((()))']
    >>> generate_parentheses_iterative(2)
    ['()()', '(())']
    >>> generate_parentheses_iterative(1)
    ['()']
    >>> generate_parentheses_iterative(0)
    ['']
    """"""
    result = []
    stack = []

    # Each element in stack is a tuple (current_combination, open_count, close_count)
    stack.append(("""", 0, 0))

    while stack:
        current_combination, open_count, close_count = stack.pop()

        if len(current_combination) == 2 * length:
            result.append(current_combination)

        if open_count < length:
            stack.append((current_combination + ""("", open_count + 1, close_count))

        if close_count < open_count:
            stack.append((current_combination + "")"", open_count, close_count + 1))

    return result",data\repos\Python\backtracking\generate_parentheses_iterative.py,generate_parentheses_iterative,448
221,hamiltonian_cycle.py::valid_connection::11,"def valid_connection(
    graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]
) -> bool:
    """"""
    Checks whether it is possible to add next into path by validating 2 statements
    1. There should be path between current and next vertex
    2. Next vertex should not be in path
    If both validations succeed we return True, saying that it is possible to connect
    this vertices, otherwise we return False

    Case 1:Use exact graph as in main function, with initialized values
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> path = [0, -1, -1, -1, -1, 0]
    >>> curr_ind = 1
    >>> next_ver = 1
    >>> valid_connection(graph, next_ver, curr_ind, path)
    True

    Case 2: Same graph, but trying to connect to node that is already in path
    >>> path = [0, 1, 2, 4, -1, 0]
    >>> curr_ind = 4
    >>> next_ver = 1
    >>> valid_connection(graph, next_ver, curr_ind, path)
    False
    """"""

    # 1. Validate that path exists between current and next vertices
    if graph[path[curr_ind - 1]][next_ver] == 0:
        return False

    # 2. Validate that next vertex is not already in path
    return not any(vertex == next_ver for vertex in path)",data\repos\Python\backtracking\hamiltonian_cycle.py,valid_connection,405
222,hamiltonian_cycle.py::util_hamilton_cycle::49,"def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:
    """"""
    Pseudo-Code
    Base Case:
    1. Check if we visited all of vertices
        1.1 If last visited vertex has path to starting vertex return True either
            return False
    Recursive Step:
    2. Iterate over each vertex
        Check if next vertex is valid for transiting from current vertex
            2.1 Remember next vertex as next transition
            2.2 Do recursive call and check if going to this vertex solves problem
            2.3 If next vertex leads to solution return True
            2.4 Else backtrack, delete remembered vertex

    Case 1: Use exact graph as in main function, with initialized values
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> path = [0, -1, -1, -1, -1, 0]
    >>> curr_ind = 1
    >>> util_hamilton_cycle(graph, path, curr_ind)
    True
    >>> path
    [0, 1, 2, 4, 3, 0]

    Case 2: Use exact graph as in previous case, but in the properties taken from
        middle of calculation
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> path = [0, 1, 2, -1, -1, 0]
    >>> curr_ind = 3
    >>> util_hamilton_cycle(graph, path, curr_ind)
    True
    >>> path
    [0, 1, 2, 4, 3, 0]
    """"""

    # Base Case
    if curr_ind == len(graph):
        # return whether path exists between current and starting vertices
        return graph[path[curr_ind - 1]][path[0]] == 1

    # Recursive Step
    for next_ver in range(len(graph)):
        if valid_connection(graph, next_ver, curr_ind, path):
            # Insert current vertex  into path as next transition
            path[curr_ind] = next_ver
            # Validate created path
            if util_hamilton_cycle(graph, path, curr_ind + 1):
                return True
            # Backtrack
            path[curr_ind] = -1
    return False",data\repos\Python\backtracking\hamiltonian_cycle.py,util_hamilton_cycle,656
223,hamiltonian_cycle.py::hamilton_cycle::110,"def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:
    r""""""
    Wrapper function to call subroutine called util_hamilton_cycle,
    which will either return array of vertices indicating hamiltonian cycle
    or an empty list indicating that hamiltonian cycle was not found.
    Case 1:
    Following graph consists of 5 edges.
    If we look closely, we can see that there are multiple Hamiltonian cycles.
    For example one result is when we iterate like:
    (0)->(1)->(2)->(4)->(3)->(0)

    (0)---(1)---(2)
     |   /   \   |
     |  /     \  |
     | /       \ |
     |/         \|
    (3)---------(4)
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> hamilton_cycle(graph)
    [0, 1, 2, 4, 3, 0]

    Case 2:
    Same Graph as it was in Case 1, changed starting index from default to 3

    (0)---(1)---(2)
     |   /   \   |
     |  /     \  |
     | /       \ |
     |/         \|
    (3)---------(4)
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> hamilton_cycle(graph, 3)
    [3, 0, 1, 2, 4, 3]

    Case 3:
    Following Graph is exactly what it was before, but edge 3-4 is removed.
    Result is that there is no Hamiltonian Cycle anymore.

    (0)---(1)---(2)
     |   /   \   |
     |  /     \  |
     | /       \ |
     |/         \|
    (3)         (4)
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 0],
    ...          [0, 1, 1, 0, 0]]
    >>> hamilton_cycle(graph,4)
    []
    """"""

    # Initialize path with -1, indicating that we have not visited them yet
    path = [-1] * (len(graph) + 1)
    # initialize start and end of path with starting index
    path[0] = path[-1] = start_index
    # evaluate and if we find answer return path either return empty array
    return path if util_hamilton_cycle(graph, path, 1) else []",data\repos\Python\backtracking\hamiltonian_cycle.py,hamilton_cycle,762
224,knight_tour.py::get_valid_pos::6,"def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:
    """"""
    Find all the valid positions a knight can move to from the current position.

    >>> get_valid_pos((1, 3), 4)
    [(2, 1), (0, 1), (3, 2)]
    """"""

    y, x = position
    positions = [
        (y + 1, x + 2),
        (y - 1, x + 2),
        (y + 1, x - 2),
        (y - 1, x - 2),
        (y + 2, x + 1),
        (y + 2, x - 1),
        (y - 2, x + 1),
        (y - 2, x - 1),
    ]
    permissible_positions = []

    for inner_position in positions:
        y_test, x_test = inner_position
        if 0 <= y_test < n and 0 <= x_test < n:
            permissible_positions.append(inner_position)

    return permissible_positions",data\repos\Python\backtracking\knight_tour.py,get_valid_pos,236
225,knight_tour.py::is_complete::35,"def is_complete(board: list[list[int]]) -> bool:
    """"""
    Check if the board (matrix) has been completely filled with non-zero values.

    >>> is_complete([[1]])
    True

    >>> is_complete([[1, 2], [3, 0]])
    False
    """"""

    return not any(elem == 0 for row in board for elem in row)",data\repos\Python\backtracking\knight_tour.py,is_complete,79
226,knight_tour.py::open_knight_tour_helper::49,"def open_knight_tour_helper(
    board: list[list[int]], pos: tuple[int, int], curr: int
) -> bool:
    """"""
    Helper function to solve knight tour problem.
    """"""

    if is_complete(board):
        return True

    for position in get_valid_pos(pos, len(board)):
        y, x = position

        if board[y][x] == 0:
            board[y][x] = curr + 1
            if open_knight_tour_helper(board, position, curr + 1):
                return True
            board[y][x] = 0

    return False",data\repos\Python\backtracking\knight_tour.py,open_knight_tour_helper,129
227,knight_tour.py::open_knight_tour::71,"def open_knight_tour(n: int) -> list[list[int]]:
    """"""
    Find the solution for the knight tour problem for a board of size n. Raises
    ValueError if the tour cannot be performed for the given size.

    >>> open_knight_tour(1)
    [[1]]

    >>> open_knight_tour(2)
    Traceback (most recent call last):
        ...
    ValueError: Open Knight Tour cannot be performed on a board of size 2
    """"""

    board = [[0 for i in range(n)] for j in range(n)]

    for i in range(n):
        for j in range(n):
            board[i][j] = 1
            if open_knight_tour_helper(board, (i, j), 1):
                return board
            board[i][j] = 0

    msg = f""Open Knight Tour cannot be performed on a board of size {n}""
    raise ValueError(msg)",data\repos\Python\backtracking\knight_tour.py,open_knight_tour,199
228,match_word_pattern.py::match_word_pattern::1,"def match_word_pattern(pattern: str, input_string: str) -> bool:
    """"""
    Determine if a given pattern matches a string using backtracking.

    pattern: The pattern to match.
    input_string: The string to match against the pattern.
    return: True if the pattern matches the string, False otherwise.

    >>> match_word_pattern(""aba"", ""GraphTreesGraph"")
    True

    >>> match_word_pattern(""xyx"", ""PythonRubyPython"")
    True

    >>> match_word_pattern(""GG"", ""PythonJavaPython"")
    False
    """"""

    def backtrack(pattern_index: int, str_index: int) -> bool:
        """"""
        >>> backtrack(0, 0)
        True

        >>> backtrack(0, 1)
        True

        >>> backtrack(0, 4)
        False
        """"""
        if pattern_index == len(pattern) and str_index == len(input_string):
            return True
        if pattern_index == len(pattern) or str_index == len(input_string):
            return False
        char = pattern[pattern_index]
        if char in pattern_map:
            mapped_str = pattern_map[char]
            if input_string.startswith(mapped_str, str_index):
                return backtrack(pattern_index + 1, str_index + len(mapped_str))
            else:
                return False
        for end in range(str_index + 1, len(input_string) + 1):
            substr = input_string[str_index:end]
            if substr in str_map:
                continue
            pattern_map[char] = substr
            str_map[substr] = char
            if backtrack(pattern_index + 1, end):
                return True
            del pattern_map[char]
            del str_map[substr]
        return False

    pattern_map: dict[str, str] = {}
    str_map: dict[str, str] = {}
    return backtrack(0, 0)",data\repos\Python\backtracking\match_word_pattern.py,match_word_pattern,387
229,match_word_pattern.py::backtrack::19,"    def backtrack(pattern_index: int, str_index: int) -> bool:
        """"""
        >>> backtrack(0, 0)
        True

        >>> backtrack(0, 1)
        True

        >>> backtrack(0, 4)
        False
        """"""
        if pattern_index == len(pattern) and str_index == len(input_string):
            return True
        if pattern_index == len(pattern) or str_index == len(input_string):
            return False
        char = pattern[pattern_index]
        if char in pattern_map:
            mapped_str = pattern_map[char]
            if input_string.startswith(mapped_str, str_index):
                return backtrack(pattern_index + 1, str_index + len(mapped_str))
            else:
                return False
        for end in range(str_index + 1, len(input_string) + 1):
            substr = input_string[str_index:end]
            if substr in str_map:
                continue
            pattern_map[char] = substr
            str_map[substr] = char
            if backtrack(pattern_index + 1, end):
                return True
            del pattern_map[char]
            del str_map[substr]
        return False",data\repos\Python\backtracking\match_word_pattern.py,backtrack,239
230,minimax.py::minimax::16,"def minimax(
    depth: int, node_index: int, is_max: bool, scores: list[int], height: float
) -> int:
    """"""
    This function implements the minimax algorithm, which helps achieve the optimal
    score for a player in a two-player game by checking all possible moves.
    If the player is the maximizer, then the score is maximized.
    If the player is the minimizer, then the score is minimized.

    Parameters:
    - depth: Current depth in the game tree.
    - node_index: Index of the current node in the scores list.
    - is_max: A boolean indicating whether the current move
              is for the maximizer (True) or minimizer (False).
    - scores: A list containing the scores of the leaves of the game tree.
    - height: The maximum height of the game tree.

    Returns:
    - An integer representing the optimal score for the current player.

    >>> import math
    >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]
    >>> height = math.log(len(scores), 2)
    >>> minimax(0, 0, True, scores, height)
    65
    >>> minimax(-1, 0, True, scores, height)
    Traceback (most recent call last):
        ...
    ValueError: Depth cannot be less than 0
    >>> minimax(0, 0, True, [], 2)
    Traceback (most recent call last):
        ...
    ValueError: Scores cannot be empty
    >>> scores = [3, 5, 2, 9, 12, 5, 23, 23]
    >>> height = math.log(len(scores), 2)
    >>> minimax(0, 0, True, scores, height)
    12
    """"""

    if depth < 0:
        raise ValueError(""Depth cannot be less than 0"")
    if len(scores) == 0:
        raise ValueError(""Scores cannot be empty"")

    # Base case: If the current depth equals the height of the tree,
    # return the score of the current node.
    if depth == height:
        return scores[node_index]

    # If it's the maximizer's turn, choose the maximum score
    # between the two possible moves.
    if is_max:
        return max(
            minimax(depth + 1, node_index * 2, False, scores, height),
            minimax(depth + 1, node_index * 2 + 1, False, scores, height),
        )

    # If it's the minimizer's turn, choose the minimum score
    # between the two possible moves.
    return min(
        minimax(depth + 1, node_index * 2, True, scores, height),
        minimax(depth + 1, node_index * 2 + 1, True, scores, height),
    )",data\repos\Python\backtracking\minimax.py,minimax,625
231,minimax.py::main::81,"def main() -> None:
    # Sample scores and height calculation
    scores = [90, 23, 6, 33, 21, 65, 123, 34423]
    height = math.log(len(scores), 2)

    # Calculate and print the optimal value using the minimax algorithm
    print(""Optimal value : "", end="""")
    print(minimax(0, 0, True, scores, height))",data\repos\Python\backtracking\minimax.py,main,93
232,n_queens.py::is_safe::16,"def is_safe(board: list[list[int]], row: int, column: int) -> bool:
    """"""
    This function returns a boolean value True if it is safe to place a queen there
    considering the current state of the board.

    Parameters:
    board (2D matrix): The chessboard
    row, column: Coordinates of the cell on the board

    Returns:
    Boolean Value

    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)
    True
    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)
    False
    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)
    False
    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)
    False
    """"""

    n = len(board)  # Size of the board

    # Check if there is any queen in the same upper column,
    # left upper diagonal and right upper diagonal
    return (
        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))
        and all(
            board[i][j] != 1
            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))
        )
        and all(
            board[i][j] != 1
            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))
        )
    )",data\repos\Python\backtracking\n_queens.py,is_safe,402
233,n_queens.py::solve::55,"def solve(board: list[list[int]], row: int) -> bool:
    """"""
    This function creates a state space tree and calls the safe function until it
    receives a False Boolean and terminates that branch and backtracks to the next
    possible solution branch.
    """"""
    if row >= len(board):
        """"""
        If the row number exceeds N, we have a board with a successful combination
        and that combination is appended to the solution list and the board is printed.
        """"""
        solution.append(board)
        printboard(board)
        print()
        return True
    for i in range(len(board)):
        """"""
        For every row, it iterates through each column to check if it is feasible to
        place a queen there.
        If all the combinations for that particular branch are successful, the board is
        reinitialized for the next possible combination.
        """"""
        if is_safe(board, row, i):
            board[row][i] = 1
            solve(board, row + 1)
            board[row][i] = 0
    return False",data\repos\Python\backtracking\n_queens.py,solve,221
234,n_queens.py::printboard::84,"def printboard(board: list[list[int]]) -> None:
    """"""
    Prints the boards that have a successful combination.
    """"""
    for i in range(len(board)):
        for j in range(len(board)):
            if board[i][j] == 1:
                print(""Q"", end="" "")  # Queen is present
            else:
                print(""."", end="" "")  # Empty cell
        print()",data\repos\Python\backtracking\n_queens.py,printboard,84
235,n_queens_math.py::depth_first_search::82,"def depth_first_search(
    possible_board: list[int],
    diagonal_right_collisions: list[int],
    diagonal_left_collisions: list[int],
    boards: list[list[str]],
    n: int,
) -> None:
    """"""
    >>> boards = []
    >>> depth_first_search([], [], [], boards, 4)
    >>> for board in boards:
    ...     print(board)
    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']
    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']
    """"""

    # Get next row in the current board (possible_board) to fill it with a queen
    row = len(possible_board)

    # If row is equal to the size of the board it means there are a queen in each row in
    # the current board (possible_board)
    if row == n:
        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to
        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']
        boards.append(["". "" * i + ""Q "" + "". "" * (n - 1 - i) for i in possible_board])
        return

    # We iterate each column in the row to find all possible results in each row
    for col in range(n):
        # We apply that we learned previously. First we check that in the current board
        # (possible_board) there are not other same value because if there is it means
        # that there are a collision in vertical. Then we apply the two formulas we
        # learned before:
        #
        # 45: y - x = b or 45: row - col = b
        # 135: y + x = b or row + col = b.
        #
        # And we verify if the results of this two formulas not exist in their variables
        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)
        #
        # If any or these are True it means there is a collision so we continue to the
        # next value in the for loop.
        if (
            col in possible_board
            or row - col in diagonal_right_collisions
            or row + col in diagonal_left_collisions
        ):
            continue

        # If it is False we call dfs function again and we update the inputs
        depth_first_search(
            [*possible_board, col],
            [*diagonal_right_collisions, row - col],
            [*diagonal_left_collisions, row + col],
            boards,
            n,
        )",data\repos\Python\backtracking\n_queens_math.py,depth_first_search,570
236,n_queens_math.py::n_queens_solution::141,"def n_queens_solution(n: int) -> None:
    boards: list[list[str]] = []
    depth_first_search([], [], [], boards, n)

    # Print all the boards
    for board in boards:
        for column in board:
            print(column)
        print("""")

    print(len(boards), ""solutions were found."")",data\repos\Python\backtracking\n_queens_math.py,n_queens_solution,71
237,power_sum.py::backtrack::10,"def backtrack(
    needed_sum: int,
    power: int,
    current_number: int,
    current_sum: int,
    solutions_count: int,
) -> tuple[int, int]:
    """"""
    >>> backtrack(13, 2, 1, 0, 0)
    (0, 1)
    >>> backtrack(10, 2, 1, 0, 0)
    (0, 1)
    >>> backtrack(10, 3, 1, 0, 0)
    (0, 0)
    >>> backtrack(20, 2, 1, 0, 0)
    (0, 1)
    >>> backtrack(15, 10, 1, 0, 0)
    (0, 0)
    >>> backtrack(16, 2, 1, 0, 0)
    (0, 1)
    >>> backtrack(20, 1, 1, 0, 0)
    (0, 64)
    """"""
    if current_sum == needed_sum:
        # If the sum of the powers is equal to needed_sum, then we have a solution.
        solutions_count += 1
        return current_sum, solutions_count

    i_to_n = current_number**power
    if current_sum + i_to_n <= needed_sum:
        # If the sum of the powers is less than needed_sum, then continue adding powers.
        current_sum += i_to_n
        current_sum, solutions_count = backtrack(
            needed_sum, power, current_number + 1, current_sum, solutions_count
        )
        current_sum -= i_to_n
    if i_to_n < needed_sum:
        # If the power of i is less than needed_sum, then try with the next power.
        current_sum, solutions_count = backtrack(
            needed_sum, power, current_number + 1, current_sum, solutions_count
        )
    return current_sum, solutions_count",data\repos\Python\backtracking\power_sum.py,backtrack,412
238,power_sum.py::solve::54,"def solve(needed_sum: int, power: int) -> int:
    """"""
    >>> solve(13, 2)
    1
    >>> solve(10, 2)
    1
    >>> solve(10, 3)
    0
    >>> solve(20, 2)
    1
    >>> solve(15, 10)
    0
    >>> solve(16, 2)
    1
    >>> solve(20, 1)
    Traceback (most recent call last):
        ...
    ValueError: Invalid input
    needed_sum must be between 1 and 1000, power between 2 and 10.
    >>> solve(-10, 5)
    Traceback (most recent call last):
        ...
    ValueError: Invalid input
    needed_sum must be between 1 and 1000, power between 2 and 10.
    """"""
    if not (1 <= needed_sum <= 1000 and 2 <= power <= 10):
        raise ValueError(
            ""Invalid input\n""
            ""needed_sum must be between 1 and 1000, power between 2 and 10.""
        )

    return backtrack(needed_sum, power, 1, 0, 0)[1]  # Return the solutions_count",data\repos\Python\backtracking\power_sum.py,solve,272
239,rat_in_maze.py::solve_maze::4,"def solve_maze(
    maze: list[list[int]],
    source_row: int,
    source_column: int,
    destination_row: int,
    destination_column: int,
) -> list[list[int]]:
    """"""
    This method solves the ""rat in maze"" problem.
    Parameters :
        - maze: A two dimensional matrix of zeros and ones.
        - source_row: The row index of the starting point.
        - source_column: The column index of the starting point.
        - destination_row: The row index of the destination point.
        - destination_column: The column index of the destination point.
    Returns:
        - solution: A 2D matrix representing the solution path if it exists.
    Raises:
        - ValueError: If no solution exists or if the source or
            destination coordinates are invalid.
    Description:
        This method navigates through a maze represented as an n by n matrix,
        starting from a specified source cell and
        aiming to reach a destination cell.
        The maze consists of walls (1s) and open paths (0s).
        By providing custom row and column values, the source and destination
        cells can be adjusted.
    >>> maze = [[0, 1, 0, 1, 1],
    ...         [0, 0, 0, 0, 0],
    ...         [1, 0, 1, 0, 1],
    ...         [0, 0, 1, 0, 0],
    ...         [1, 0, 0, 1, 0]]
    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
    [[0, 1, 1, 1, 1],
    [0, 0, 0, 0, 1],
    [1, 1, 1, 0, 1],
    [1, 1, 1, 0, 0],
    [1, 1, 1, 1, 0]]

    Note:
        In the output maze, the zeros (0s) represent one of the possible
        paths from the source to the destination.

    >>> maze = [[0, 1, 0, 1, 1],
    ...         [0, 0, 0, 0, 0],
    ...         [0, 0, 0, 0, 1],
    ...         [0, 0, 0, 0, 0],
    ...         [0, 0, 0, 0, 0]]
    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
    [[0, 1, 1, 1, 1],
    [0, 1, 1, 1, 1],
    [0, 1, 1, 1, 1],
    [0, 1, 1, 1, 1],
    [0, 0, 0, 0, 0]]

    >>> maze = [[0, 0, 0],
    ...         [0, 1, 0],
    ...         [1, 0, 0]]
    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
    [[0, 0, 0],
    [1, 1, 0],
    [1, 1, 0]]

    >>> maze = [[1, 0, 0],
    ...         [0, 1, 0],
    ...         [1, 0, 0]]
    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
    [[1, 0, 0],
    [1, 1, 0],
    [1, 1, 0]]

    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],
    ...         [1, 0, 1, 0, 0, 1, 1, 1],
    ...         [0, 1, 0, 1, 0, 0, 1, 0],
    ...         [1, 1, 1, 0, 0, 1, 0, 1],
    ...         [0, 1, 0, 0, 1, 0, 1, 1],
    ...         [0, 0, 0, 1, 1, 1, 0, 1],
    ...         [0, 1, 0, 1, 0, 1, 1, 1],
    ...         [1, 1, 0, 0, 0, 0, 0, 1]]
    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE
    [[1, 1, 0, 0, 1, 1, 1, 1],
    [1, 1, 1, 0, 0, 1, 1, 1],
    [1, 1, 1, 1, 0, 1, 1, 1],
    [1, 1, 1, 0, 0, 1, 1, 1],
    [1, 1, 0, 0, 1, 1, 1, 1],
    [1, 1, 0, 1, 1, 1, 1, 1],
    [1, 1, 0, 1, 1, 1, 1, 1],
    [1, 1, 0, 1, 1, 1, 1, 1]]
    >>> maze = [[1, 0, 0],
    ...         [0, 1, 1],
    ...         [1, 0, 1]]
    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)
    Traceback (most recent call last):
        ...
    ValueError: No solution exists!

    >>> maze = [[0, 0],
    ...         [1, 1]]
    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)
    Traceback (most recent call last):
        ...
    ValueError: No solution exists!

    >>> maze = [[0, 1],
    ...         [1, 0]]
    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)
    Traceback (most recent call last):
        ...
    ValueError: Invalid source or destination coordinates

    >>> maze = [[1, 0, 0],
    ...         [0, 1, 0],
    ...         [1, 0, 0]]
    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)
    Traceback (most recent call last):
        ...
    ValueError: Invalid source or destination coordinates
    """"""
    size = len(maze)
    # Check if source and destination coordinates are Invalid.
    if not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or (
        not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)
    ):
        raise ValueError(""Invalid source or destination coordinates"")
    # We need to create solution object to save path.
    solutions = [[1 for _ in range(size)] for _ in range(size)]
    solved = run_maze(
        maze, source_row, source_column, destination_row, destination_column, solutions
    )
    if solved:
        return solutions
    else:
        raise ValueError(""No solution exists!"")",data\repos\Python\backtracking\rat_in_maze.py,solve_maze,1762
240,rat_in_maze.py::run_maze::139,"def run_maze(
    maze: list[list[int]],
    i: int,
    j: int,
    destination_row: int,
    destination_column: int,
    solutions: list[list[int]],
) -> bool:
    """"""
    This method is recursive starting from (i, j) and going in one of four directions:
    up, down, left, right.
    If a path is found to destination it returns True otherwise it returns False.
    Parameters
        maze: A two dimensional matrix of zeros and ones.
        i, j : coordinates of matrix
        solutions: A two dimensional matrix of solutions.
    Returns:
        Boolean if path is found True, Otherwise False.
    """"""
    size = len(maze)
    # Final check point.
    if i == destination_row and j == destination_column and maze[i][j] == 0:
        solutions[i][j] = 0
        return True

    lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds
    upper_flag = (i < size) and (j < size)  # Check upper bounds

    if lower_flag and upper_flag:
        # check for already visited and block points.
        block_flag = (solutions[i][j]) and (not maze[i][j])
        if block_flag:
            # check visited
            solutions[i][j] = 0

            # check for directions
            if (
                run_maze(maze, i + 1, j, destination_row, destination_column, solutions)
                or run_maze(
                    maze, i, j + 1, destination_row, destination_column, solutions
                )
                or run_maze(
                    maze, i - 1, j, destination_row, destination_column, solutions
                )
                or run_maze(
                    maze, i, j - 1, destination_row, destination_column, solutions
                )
            ):
                return True

            solutions[i][j] = 1
            return False
    return False",data\repos\Python\backtracking\rat_in_maze.py,run_maze,425
241,sudoku.py::is_safe::44,"def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:
    """"""
    This function checks the grid to see if each row,
    column, and the 3x3 subgrids contain the digit 'n'.
    It returns False if it is not 'safe' (a duplicate digit
    is found) else returns True if it is 'safe'
    """"""
    for i in range(9):
        if n in {grid[row][i], grid[i][column]}:
            return False

    for i in range(3):
        for j in range(3):
            if grid[(row - row % 3) + i][(column - column % 3) + j] == n:
                return False

    return True",data\repos\Python\backtracking\sudoku.py,is_safe,163
242,sudoku.py::find_empty_location::63,"def find_empty_location(grid: Matrix) -> tuple[int, int] | None:
    """"""
    This function finds an empty location so that we can assign a number
    for that particular row and column.
    """"""
    for i in range(9):
        for j in range(9):
            if grid[i][j] == 0:
                return i, j
    return None",data\repos\Python\backtracking\sudoku.py,find_empty_location,80
243,sudoku.py::sudoku::75,"def sudoku(grid: Matrix) -> Matrix | None:
    """"""
    Takes a partially filled-in grid and attempts to assign values to
    all unassigned locations in such a way to meet the requirements
    for Sudoku solution (non-duplication across rows, columns, and boxes)

    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE
    [[3, 1, 6, 5, 7, 8, 4, 9, 2],
     [5, 2, 9, 1, 3, 4, 7, 6, 8],
     [4, 8, 7, 6, 2, 9, 5, 3, 1],
     [2, 6, 3, 4, 1, 5, 9, 8, 7],
     [9, 7, 4, 8, 6, 3, 1, 2, 5],
     [8, 5, 1, 7, 9, 2, 6, 4, 3],
     [1, 3, 8, 9, 4, 7, 2, 5, 6],
     [6, 9, 2, 3, 5, 1, 8, 7, 4],
     [7, 4, 5, 2, 8, 6, 3, 1, 9]]
     >>> sudoku(no_solution) is None
     True
    """"""
    if location := find_empty_location(grid):
        row, column = location
    else:
        # If the location is ``None``, then the grid is solved.
        return grid

    for digit in range(1, 10):
        if is_safe(grid, row, column, digit):
            grid[row][column] = digit

            if sudoku(grid) is not None:
                return grid

            grid[row][column] = 0

    return None",data\repos\Python\backtracking\sudoku.py,sudoku,438
244,sudoku.py::print_solution::112,"def print_solution(grid: Matrix) -> None:
    """"""
    A function to print the solution in the form
    of a 9x9 grid
    """"""
    for row in grid:
        for cell in row:
            print(cell, end="" "")
        print()",data\repos\Python\backtracking\sudoku.py,print_solution,56
245,sum_of_subsets.py::generate_sum_of_subsets_solutions::11,"def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:
    """"""
    The main function. For list of numbers 'nums' find the subsets with sum
    equal to 'max_sum'

    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=9)
    [[3, 4, 2], [4, 5]]
    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=3)
    [[3]]
    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=1)
    []
    """"""

    result: list[list[int]] = []
    path: list[int] = []
    num_index = 0
    remaining_nums_sum = sum(nums)
    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)
    return result",data\repos\Python\backtracking\sum_of_subsets.py,generate_sum_of_subsets_solutions,229
246,sum_of_subsets.py::create_state_space_tree::32,"def create_state_space_tree(
    nums: list[int],
    max_sum: int,
    num_index: int,
    path: list[int],
    result: list[list[int]],
    remaining_nums_sum: int,
) -> None:
    """"""
    Creates a state space tree to iterate through each branch using DFS.
    It terminates the branching of a node when any of the two conditions
    given below satisfy.
    This algorithm follows depth-fist-search and backtracks when the node is not
    branchable.

    >>> path = []
    >>> result = []
    >>> create_state_space_tree(
    ...     nums=[1],
    ...     max_sum=1,
    ...     num_index=0,
    ...     path=path,
    ...     result=result,
    ...     remaining_nums_sum=1)
    >>> path
    []
    >>> result
    [[1]]
    """"""

    if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:
        return
    if sum(path) == max_sum:
        result.append(path)
        return
    for index in range(num_index, len(nums)):
        create_state_space_tree(
            nums,
            max_sum,
            index + 1,
            [*path, nums[index]],
            result,
            remaining_nums_sum - nums[index],
        )",data\repos\Python\backtracking\sum_of_subsets.py,create_state_space_tree,273
247,word_break.py::backtrack::10,"def backtrack(input_string: str, word_dict: set[str], start: int) -> bool:
    """"""
    Helper function that uses backtracking to determine if a valid
    word segmentation is possible starting from index 'start'.

    Parameters:
    input_string (str): The input string to be segmented.
    word_dict (set[str]): A set of valid dictionary words.
    start (int): The starting index of the substring to be checked.

    Returns:
    bool: True if a valid segmentation is possible, otherwise False.

    Example:
    >>> backtrack(""leetcode"", {""leet"", ""code""}, 0)
    True

    >>> backtrack(""applepenapple"", {""apple"", ""pen""}, 0)
    True

    >>> backtrack(""catsandog"", {""cats"", ""dog"", ""sand"", ""and"", ""cat""}, 0)
    False
    """"""

    # Base case: if the starting index has reached the end of the string
    if start == len(input_string):
        return True

    # Try every possible substring from 'start' to 'end'
    for end in range(start + 1, len(input_string) + 1):
        if input_string[start:end] in word_dict and backtrack(
            input_string, word_dict, end
        ):
            return True

    return False",data\repos\Python\backtracking\word_break.py,backtrack,272
248,word_break.py::word_break::48,"def word_break(input_string: str, word_dict: set[str]) -> bool:
    """"""
    Determines if the input string can be segmented into a sequence of
    valid dictionary words using backtracking.

    Parameters:
    input_string (str): The input string to segment.
    word_dict (set[str]): The set of valid words.

    Returns:
    bool: True if the string can be segmented into valid words, otherwise False.

    Example:
    >>> word_break(""leetcode"", {""leet"", ""code""})
    True

    >>> word_break(""applepenapple"", {""apple"", ""pen""})
    True

    >>> word_break(""catsandog"", {""cats"", ""dog"", ""sand"", ""and"", ""cat""})
    False
    """"""

    return backtrack(input_string, word_dict, 0)",data\repos\Python\backtracking\word_break.py,word_break,167
249,word_ladder.py::backtrack::15,"def backtrack(
    current_word: str, path: list[str], end_word: str, word_set: set[str]
) -> list[str]:
    """"""
    Helper function to perform backtracking to find the transformation
    from the current_word to the end_word.

    Parameters:
    current_word (str): The current word in the transformation sequence.
    path (list[str]): The list of transformations from begin_word to current_word.
    end_word (str): The target word for transformation.
    word_set (set[str]): The set of valid words for transformation.

    Returns:
    list[str]: The list of transformations from begin_word to end_word.
               Returns an empty list if there is no valid
                transformation from current_word to end_word.

    Example:
    >>> backtrack(""hit"", [""hit""], ""cog"", {""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""})
    ['hit', 'hot', 'dot', 'lot', 'log', 'cog']

    >>> backtrack(""hit"", [""hit""], ""cog"", {""hot"", ""dot"", ""dog"", ""lot"", ""log""})
    []

    >>> backtrack(""lead"", [""lead""], ""gold"", {""load"", ""goad"", ""gold"", ""lead"", ""lord""})
    ['lead', 'lead', 'load', 'goad', 'gold']

    >>> backtrack(""game"", [""game""], ""code"", {""came"", ""cage"", ""code"", ""cade"", ""gave""})
    ['game', 'came', 'cade', 'code']
    """"""

    # Base case: If the current word is the end word, return the path
    if current_word == end_word:
        return path

    # Try all possible single-letter transformations
    for i in range(len(current_word)):
        for c in string.ascii_lowercase:  # Try changing each letter
            transformed_word = current_word[:i] + c + current_word[i + 1 :]
            if transformed_word in word_set:
                word_set.remove(transformed_word)
                # Recur with the new word added to the path
                result = backtrack(
                    transformed_word, [*path, transformed_word], end_word, word_set
                )
                if result:  # valid transformation found
                    return result
                word_set.add(transformed_word)  # backtrack

    return []  # No valid transformation found",data\repos\Python\backtracking\word_ladder.py,backtrack,496
250,word_ladder.py::word_ladder::68,"def word_ladder(begin_word: str, end_word: str, word_set: set[str]) -> list[str]:
    """"""
    Solve the Word Ladder problem using Backtracking and return
    the list of transformations from begin_word to end_word.

    Parameters:
    begin_word (str): The word from which the transformation starts.
    end_word (str): The target word for transformation.
    word_list (list[str]): The list of valid words for transformation.

    Returns:
    list[str]: The list of transformations from begin_word to end_word.
               Returns an empty list if there is no valid transformation.

    Example:
    >>> word_ladder(""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""])
    ['hit', 'hot', 'dot', 'lot', 'log', 'cog']

    >>> word_ladder(""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log""])
    []

    >>> word_ladder(""lead"", ""gold"", [""load"", ""goad"", ""gold"", ""lead"", ""lord""])
    ['lead', 'lead', 'load', 'goad', 'gold']

    >>> word_ladder(""game"", ""code"", [""came"", ""cage"", ""code"", ""cade"", ""gave""])
    ['game', 'came', 'cade', 'code']
    """"""

    if end_word not in word_set:  # no valid transformation possible
        return []

    # Perform backtracking starting from the begin_word
    return backtrack(begin_word, [begin_word], end_word, word_set)",data\repos\Python\backtracking\word_ladder.py,word_ladder,341
251,word_search.py::get_point_key::36,"def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:
    """"""
    Returns the hash key of matrix indexes.

    >>> get_point_key(10, 20, 1, 0)
    200
    """"""

    return len_board * len_board_column * row + column",data\repos\Python\backtracking\word_search.py,get_point_key,72
252,word_search.py::exits_word::47,"def exits_word(
    board: list[list[str]],
    word: str,
    row: int,
    column: int,
    word_index: int,
    visited_points_set: set[int],
) -> bool:
    """"""
    Return True if it's possible to search the word suffix
    starting from the word_index.

    >>> exits_word([[""A""]], ""B"", 0, 0, 0, set())
    False
    """"""

    if board[row][column] != word[word_index]:
        return False

    if word_index == len(word) - 1:
        return True

    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]
    len_board = len(board)
    len_board_column = len(board[0])
    for direction in traverts_directions:
        next_i = row + direction[0]
        next_j = column + direction[1]
        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):
            continue

        key = get_point_key(len_board, len_board_column, next_i, next_j)
        if key in visited_points_set:
            continue

        visited_points_set.add(key)
        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):
            return True

        visited_points_set.remove(key)

    return False",data\repos\Python\backtracking\word_search.py,exits_word,302
253,word_search.py::word_exists::91,"def word_exists(board: list[list[str]], word: str) -> bool:
    """"""
    >>> word_exists([[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], ""ABCCED"")
    True
    >>> word_exists([[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], ""SEE"")
    True
    >>> word_exists([[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], ""ABCB"")
    False
    >>> word_exists([[""A""]], ""A"")
    True
    >>> word_exists([[""B"", ""A"", ""A""], [""A"", ""A"", ""A""], [""A"", ""B"", ""A""]], ""ABB"")
    False
    >>> word_exists([[""A""]], 123)
    Traceback (most recent call last):
        ...
    ValueError: The word parameter should be a string of length greater than 0.
    >>> word_exists([[""A""]], """")
    Traceback (most recent call last):
        ...
    ValueError: The word parameter should be a string of length greater than 0.
    >>> word_exists([[]], ""AB"")
    Traceback (most recent call last):
        ...
    ValueError: The board should be a non empty matrix of single chars strings.
    >>> word_exists([], ""AB"")
    Traceback (most recent call last):
        ...
    ValueError: The board should be a non empty matrix of single chars strings.
    >>> word_exists([[""A""], [21]], ""AB"")
    Traceback (most recent call last):
        ...
    ValueError: The board should be a non empty matrix of single chars strings.
    """"""

    # Validate board
    board_error_message = (
        ""The board should be a non empty matrix of single chars strings.""
    )

    len_board = len(board)
    if not isinstance(board, list) or len(board) == 0:
        raise ValueError(board_error_message)

    for row in board:
        if not isinstance(row, list) or len(row) == 0:
            raise ValueError(board_error_message)

        for item in row:
            if not isinstance(item, str) or len(item) != 1:
                raise ValueError(board_error_message)

    # Validate word
    if not isinstance(word, str) or len(word) == 0:
        raise ValueError(
            ""The word parameter should be a string of length greater than 0.""
        )

    len_board_column = len(board[0])
    for i in range(len_board):
        for j in range(len_board_column):
            if exits_word(
                board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)}
            ):
                return True

    return False",data\repos\Python\backtracking\word_search.py,word_exists,606
254,binary_and_operator.py::binary_and::4,"def binary_and(a: int, b: int) -> str:
    """"""
    Take in 2 integers, convert them to binary,
    return a binary number that is the
    result of a binary and operation on the integers provided.

    >>> binary_and(25, 32)
    '0b000000'
    >>> binary_and(37, 50)
    '0b100000'
    >>> binary_and(21, 30)
    '0b10100'
    >>> binary_and(58, 73)
    '0b0001000'
    >>> binary_and(0, 255)
    '0b00000000'
    >>> binary_and(256, 256)
    '0b100000000'
    >>> binary_and(0, -1)
    Traceback (most recent call last):
        ...
    ValueError: the value of both inputs must be positive
    >>> binary_and(0, 1.1)
    Traceback (most recent call last):
        ...
    ValueError: Unknown format code 'b' for object of type 'float'
    >>> binary_and(""0"", ""1"")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """"""
    if a < 0 or b < 0:
        raise ValueError(""the value of both inputs must be positive"")

    a_binary = format(a, ""b"")
    b_binary = format(b, ""b"")

    max_len = max(len(a_binary), len(b_binary))

    return ""0b"" + """".join(
        str(int(char_a == ""1"" and char_b == ""1""))
        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))
    )",data\repos\Python\bit_manipulation\binary_and_operator.py,binary_and,375
255,binary_coded_decimal.py::binary_coded_decimal::1,"def binary_coded_decimal(number: int) -> str:
    """"""
    Find binary coded decimal (bcd) of integer base 10.
    Each digit of the number is represented by a 4-bit binary.
    Example:
    >>> binary_coded_decimal(-2)
    '0b0000'
    >>> binary_coded_decimal(-1)
    '0b0000'
    >>> binary_coded_decimal(0)
    '0b0000'
    >>> binary_coded_decimal(3)
    '0b0011'
    >>> binary_coded_decimal(2)
    '0b0010'
    >>> binary_coded_decimal(12)
    '0b00010010'
    >>> binary_coded_decimal(987)
    '0b100110000111'
    """"""
    return ""0b"" + """".join(
        str(bin(int(digit)))[2:].zfill(4) for digit in str(max(0, number))
    )",data\repos\Python\bit_manipulation\binary_coded_decimal.py,binary_coded_decimal,200
256,binary_count_setbits.py::binary_count_setbits::1,"def binary_count_setbits(a: int) -> int:
    """"""
    Take in 1 integer, return a number that is
    the number of 1's in binary representation of that number.

    >>> binary_count_setbits(25)
    3
    >>> binary_count_setbits(36)
    2
    >>> binary_count_setbits(16)
    1
    >>> binary_count_setbits(58)
    4
    >>> binary_count_setbits(4294967295)
    32
    >>> binary_count_setbits(0)
    0
    >>> binary_count_setbits(-10)
    Traceback (most recent call last):
        ...
    ValueError: Input value must be a positive integer
    >>> binary_count_setbits(0.8)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a 'int' type
    >>> binary_count_setbits(""0"")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """"""
    if a < 0:
        raise ValueError(""Input value must be a positive integer"")
    elif isinstance(a, float):
        raise TypeError(""Input value must be a 'int' type"")
    return bin(a).count(""1"")",data\repos\Python\bit_manipulation\binary_count_setbits.py,binary_count_setbits,276
257,binary_count_trailing_zeros.py::binary_count_trailing_zeros::4,"def binary_count_trailing_zeros(a: int) -> int:
    """"""
    Take in 1 integer, return a number that is
    the number of trailing zeros in binary representation of that number.

    >>> binary_count_trailing_zeros(25)
    0
    >>> binary_count_trailing_zeros(36)
    2
    >>> binary_count_trailing_zeros(16)
    4
    >>> binary_count_trailing_zeros(58)
    1
    >>> binary_count_trailing_zeros(4294967296)
    32
    >>> binary_count_trailing_zeros(0)
    0
    >>> binary_count_trailing_zeros(-10)
    Traceback (most recent call last):
        ...
    ValueError: Input value must be a positive integer
    >>> binary_count_trailing_zeros(0.8)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a 'int' type
    >>> binary_count_trailing_zeros(""0"")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """"""
    if a < 0:
        raise ValueError(""Input value must be a positive integer"")
    elif isinstance(a, float):
        raise TypeError(""Input value must be a 'int' type"")
    return 0 if (a == 0) else int(log2(a & -a))",data\repos\Python\bit_manipulation\binary_count_trailing_zeros.py,binary_count_trailing_zeros,296
258,binary_or_operator.py::binary_or::4,"def binary_or(a: int, b: int) -> str:
    """"""
    Take in 2 integers, convert them to binary, and return a binary number that is the
    result of a binary or operation on the integers provided.

    >>> binary_or(25, 32)
    '0b111001'
    >>> binary_or(37, 50)
    '0b110111'
    >>> binary_or(21, 30)
    '0b11111'
    >>> binary_or(58, 73)
    '0b1111011'
    >>> binary_or(0, 255)
    '0b11111111'
    >>> binary_or(0, 256)
    '0b100000000'
    >>> binary_or(0, -1)
    Traceback (most recent call last):
        ...
    ValueError: the value of both inputs must be positive
    >>> binary_or(0, 1.1)
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> binary_or(""0"", ""1"")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """"""
    if a < 0 or b < 0:
        raise ValueError(""the value of both inputs must be positive"")
    a_binary = str(bin(a))[2:]  # remove the leading ""0b""
    b_binary = str(bin(b))[2:]
    max_len = max(len(a_binary), len(b_binary))
    return ""0b"" + """".join(
        str(int(""1"" in (char_a, char_b)))
        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))
    )",data\repos\Python\bit_manipulation\binary_or_operator.py,binary_or,380
259,binary_shifts.py::logical_left_shift::6,"def logical_left_shift(number: int, shift_amount: int) -> str:
    """"""
    Take in 2 positive integers.
    'number' is the integer to be logically left shifted 'shift_amount' times.
    i.e. (number << shift_amount)
    Return the shifted binary representation.

    >>> logical_left_shift(0, 1)
    '0b00'
    >>> logical_left_shift(1, 1)
    '0b10'
    >>> logical_left_shift(1, 5)
    '0b100000'
    >>> logical_left_shift(17, 2)
    '0b1000100'
    >>> logical_left_shift(1983, 4)
    '0b111101111110000'
    >>> logical_left_shift(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: both inputs must be positive integers
    """"""
    if number < 0 or shift_amount < 0:
        raise ValueError(""both inputs must be positive integers"")

    binary_number = str(bin(number))
    binary_number += ""0"" * shift_amount
    return binary_number",data\repos\Python\bit_manipulation\binary_shifts.py,logical_left_shift,235
260,binary_shifts.py::logical_right_shift::36,"def logical_right_shift(number: int, shift_amount: int) -> str:
    """"""
    Take in positive 2 integers.
    'number' is the integer to be logically right shifted 'shift_amount' times.
    i.e. (number >>> shift_amount)
    Return the shifted binary representation.

    >>> logical_right_shift(0, 1)
    '0b0'
    >>> logical_right_shift(1, 1)
    '0b0'
    >>> logical_right_shift(1, 5)
    '0b0'
    >>> logical_right_shift(17, 2)
    '0b100'
    >>> logical_right_shift(1983, 4)
    '0b1111011'
    >>> logical_right_shift(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: both inputs must be positive integers
    """"""
    if number < 0 or shift_amount < 0:
        raise ValueError(""both inputs must be positive integers"")

    binary_number = str(bin(number))[2:]
    if shift_amount >= len(binary_number):
        return ""0b0""
    shifted_binary_number = binary_number[: len(binary_number) - shift_amount]
    return ""0b"" + shifted_binary_number",data\repos\Python\bit_manipulation\binary_shifts.py,logical_right_shift,259
261,binary_shifts.py::arithmetic_right_shift::68,"def arithmetic_right_shift(number: int, shift_amount: int) -> str:
    """"""
    Take in 2 integers.
    'number' is the integer to be arithmetically right shifted 'shift_amount' times.
    i.e. (number >> shift_amount)
    Return the shifted binary representation.

    >>> arithmetic_right_shift(0, 1)
    '0b00'
    >>> arithmetic_right_shift(1, 1)
    '0b00'
    >>> arithmetic_right_shift(-1, 1)
    '0b11'
    >>> arithmetic_right_shift(17, 2)
    '0b000100'
    >>> arithmetic_right_shift(-17, 2)
    '0b111011'
    >>> arithmetic_right_shift(-1983, 4)
    '0b111110000100'
    """"""
    if number >= 0:  # Get binary representation of positive number
        binary_number = ""0"" + str(bin(number)).strip(""-"")[2:]
    else:  # Get binary (2's complement) representation of negative number
        binary_number_length = len(bin(number)[3:])  # Find 2's complement of number
        binary_number = bin(abs(number) - (1 << binary_number_length))[3:]
        binary_number = (
            ""1"" + ""0"" * (binary_number_length - len(binary_number)) + binary_number
        )

    if shift_amount >= len(binary_number):
        return ""0b"" + binary_number[0] * len(binary_number)
    return (
        ""0b""
        + binary_number[0] * shift_amount
        + binary_number[: len(binary_number) - shift_amount]
    )",data\repos\Python\bit_manipulation\binary_shifts.py,arithmetic_right_shift,351
262,binary_twos_complement.py::twos_complement::4,"def twos_complement(number: int) -> str:
    """"""
    Take in a negative integer 'number'.
    Return the two's complement representation of 'number'.

    >>> twos_complement(0)
    '0b0'
    >>> twos_complement(-1)
    '0b11'
    >>> twos_complement(-5)
    '0b1011'
    >>> twos_complement(-17)
    '0b101111'
    >>> twos_complement(-207)
    '0b100110001'
    >>> twos_complement(1)
    Traceback (most recent call last):
        ...
    ValueError: input must be a negative integer
    """"""
    if number > 0:
        raise ValueError(""input must be a negative integer"")
    binary_number_length = len(bin(number)[3:])
    twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]
    twos_complement_number = (
        (
            ""1""
            + ""0"" * (binary_number_length - len(twos_complement_number))
            + twos_complement_number
        )
        if number < 0
        else ""0""
    )
    return ""0b"" + twos_complement_number",data\repos\Python\bit_manipulation\binary_twos_complement.py,twos_complement,264
263,binary_xor_operator.py::binary_xor::4,"def binary_xor(a: int, b: int) -> str:
    """"""
    Take in 2 integers, convert them to binary,
    return a binary number that is the
    result of a binary xor operation on the integers provided.

    >>> binary_xor(25, 32)
    '0b111001'
    >>> binary_xor(37, 50)
    '0b010111'
    >>> binary_xor(21, 30)
    '0b01011'
    >>> binary_xor(58, 73)
    '0b1110011'
    >>> binary_xor(0, 255)
    '0b11111111'
    >>> binary_xor(256, 256)
    '0b000000000'
    >>> binary_xor(0, -1)
    Traceback (most recent call last):
        ...
    ValueError: the value of both inputs must be positive
    >>> binary_xor(0, 1.1)
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> binary_xor(""0"", ""1"")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """"""
    if a < 0 or b < 0:
        raise ValueError(""the value of both inputs must be positive"")

    a_binary = str(bin(a))[2:]  # remove the leading ""0b""
    b_binary = str(bin(b))[2:]  # remove the leading ""0b""

    max_len = max(len(a_binary), len(b_binary))

    return ""0b"" + """".join(
        str(int(char_a != char_b))
        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))
    )",data\repos\Python\bit_manipulation\binary_xor_operator.py,binary_xor,384
264,bitwise_addition_recursive.py::bitwise_addition_recursive::7,"def bitwise_addition_recursive(number: int, other_number: int) -> int:
    """"""
    >>> bitwise_addition_recursive(4, 5)
    9
    >>> bitwise_addition_recursive(8, 9)
    17
    >>> bitwise_addition_recursive(0, 4)
    4
    >>> bitwise_addition_recursive(4.5, 9)
    Traceback (most recent call last):
        ...
    TypeError: Both arguments MUST be integers!
    >>> bitwise_addition_recursive('4', 9)
    Traceback (most recent call last):
        ...
    TypeError: Both arguments MUST be integers!
    >>> bitwise_addition_recursive('4.5', 9)
    Traceback (most recent call last):
        ...
    TypeError: Both arguments MUST be integers!
    >>> bitwise_addition_recursive(-1, 9)
    Traceback (most recent call last):
        ...
    ValueError: Both arguments MUST be non-negative!
    >>> bitwise_addition_recursive(1, -9)
    Traceback (most recent call last):
        ...
    ValueError: Both arguments MUST be non-negative!
    """"""

    if not isinstance(number, int) or not isinstance(other_number, int):
        raise TypeError(""Both arguments MUST be integers!"")

    if number < 0 or other_number < 0:
        raise ValueError(""Both arguments MUST be non-negative!"")

    bitwise_sum = number ^ other_number
    carry = number & other_number

    if carry == 0:
        return bitwise_sum

    return bitwise_addition_recursive(bitwise_sum, carry << 1)",data\repos\Python\bit_manipulation\bitwise_addition_recursive.py,bitwise_addition_recursive,329
265,count_1s_brian_kernighan_method.py::get_1s_count::1,"def get_1s_count(number: int) -> int:
    """"""
    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.
    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
    >>> get_1s_count(25)
    3
    >>> get_1s_count(37)
    3
    >>> get_1s_count(21)
    3
    >>> get_1s_count(58)
    4
    >>> get_1s_count(0)
    0
    >>> get_1s_count(256)
    1
    >>> get_1s_count(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    >>> get_1s_count(0.8)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    >>> get_1s_count(""25"")
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    """"""
    if not isinstance(number, int) or number < 0:
        raise ValueError(""Input must be a non-negative integer"")

    count = 0
    while number:
        # This way we arrive at next set bit (next 1) instead of looping
        # through each bit and checking for 1s hence the
        # loop won't run 32 times it will only run the number of `1` times
        number &= number - 1
        count += 1
    return count",data\repos\Python\bit_manipulation\count_1s_brian_kernighan_method.py,get_1s_count,352
266,count_number_of_one_bits.py::get_set_bits_count_using_brian_kernighans_algorithm::4,"def get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:
    """"""
    Count the number of set bits in a 32 bit integer
    >>> get_set_bits_count_using_brian_kernighans_algorithm(25)
    3
    >>> get_set_bits_count_using_brian_kernighans_algorithm(37)
    3
    >>> get_set_bits_count_using_brian_kernighans_algorithm(21)
    3
    >>> get_set_bits_count_using_brian_kernighans_algorithm(58)
    4
    >>> get_set_bits_count_using_brian_kernighans_algorithm(0)
    0
    >>> get_set_bits_count_using_brian_kernighans_algorithm(256)
    1
    >>> get_set_bits_count_using_brian_kernighans_algorithm(-1)
    Traceback (most recent call last):
        ...
    ValueError: the value of input must not be negative
    """"""
    if number < 0:
        raise ValueError(""the value of input must not be negative"")
    result = 0
    while number:
        number &= number - 1
        result += 1
    return result",data\repos\Python\bit_manipulation\count_number_of_one_bits.py,get_set_bits_count_using_brian_kernighans_algorithm,251
267,count_number_of_one_bits.py::get_set_bits_count_using_modulo_operator::33,"def get_set_bits_count_using_modulo_operator(number: int) -> int:
    """"""
    Count the number of set bits in a 32 bit integer
    >>> get_set_bits_count_using_modulo_operator(25)
    3
    >>> get_set_bits_count_using_modulo_operator(37)
    3
    >>> get_set_bits_count_using_modulo_operator(21)
    3
    >>> get_set_bits_count_using_modulo_operator(58)
    4
    >>> get_set_bits_count_using_modulo_operator(0)
    0
    >>> get_set_bits_count_using_modulo_operator(256)
    1
    >>> get_set_bits_count_using_modulo_operator(-1)
    Traceback (most recent call last):
        ...
    ValueError: the value of input must not be negative
    """"""
    if number < 0:
        raise ValueError(""the value of input must not be negative"")
    result = 0
    while number:
        if number % 2 == 1:
            result += 1
        number >>= 1
    return result",data\repos\Python\bit_manipulation\count_number_of_one_bits.py,get_set_bits_count_using_modulo_operator,227
268,count_number_of_one_bits.py::benchmark::63,"def benchmark() -> None:
    """"""
    Benchmark code for comparing 2 functions, with different length int values.
    Brian Kernighan's algorithm is consistently faster than using modulo_operator.
    """"""

    def do_benchmark(number: int) -> None:
        setup = ""import __main__ as z""
        print(f""Benchmark when {number = }:"")
        print(f""{get_set_bits_count_using_modulo_operator(number) = }"")
        timing = timeit(
            f""z.get_set_bits_count_using_modulo_operator({number})"", setup=setup
        )
        print(f""timeit() runs in {timing} seconds"")
        print(f""{get_set_bits_count_using_brian_kernighans_algorithm(number) = }"")
        timing = timeit(
            f""z.get_set_bits_count_using_brian_kernighans_algorithm({number})"",
            setup=setup,
        )
        print(f""timeit() runs in {timing} seconds"")

    for number in (25, 37, 58, 0):
        do_benchmark(number)
        print()",data\repos\Python\bit_manipulation\count_number_of_one_bits.py,benchmark,223
269,count_number_of_one_bits.py::do_benchmark::69,"    def do_benchmark(number: int) -> None:
        setup = ""import __main__ as z""
        print(f""Benchmark when {number = }:"")
        print(f""{get_set_bits_count_using_modulo_operator(number) = }"")
        timing = timeit(
            f""z.get_set_bits_count_using_modulo_operator({number})"", setup=setup
        )
        print(f""timeit() runs in {timing} seconds"")
        print(f""{get_set_bits_count_using_brian_kernighans_algorithm(number) = }"")
        timing = timeit(
            f""z.get_set_bits_count_using_brian_kernighans_algorithm({number})"",
            setup=setup,
        )
        print(f""timeit() runs in {timing} seconds"")",data\repos\Python\bit_manipulation\count_number_of_one_bits.py,do_benchmark,158
270,excess_3_code.py::excess_3_code::1,"def excess_3_code(number: int) -> str:
    """"""
    Find excess-3 code of integer base 10.
    Add 3 to all digits in a decimal number then convert to a binary-coded decimal.
    https://en.wikipedia.org/wiki/Excess-3

    >>> excess_3_code(0)
    '0b0011'
    >>> excess_3_code(3)
    '0b0110'
    >>> excess_3_code(2)
    '0b0101'
    >>> excess_3_code(20)
    '0b01010011'
    >>> excess_3_code(120)
    '0b010001010011'
    """"""
    num = """"
    for digit in str(max(0, number)):
        num += str(bin(int(digit) + 3))[2:].zfill(4)
    return ""0b"" + num",data\repos\Python\bit_manipulation\excess_3_code.py,excess_3_code,186
271,find_previous_power_of_two.py::find_previous_power_of_two::1,"def find_previous_power_of_two(number: int) -> int:
    """"""
    Find the largest power of two that is less than or equal to a given integer.
    https://stackoverflow.com/questions/1322510

    >>> [find_previous_power_of_two(i) for i in range(18)]
    [0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16]
    >>> find_previous_power_of_two(-5)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    >>> find_previous_power_of_two(10.5)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    """"""
    if not isinstance(number, int) or number < 0:
        raise ValueError(""Input must be a non-negative integer"")
    if number == 0:
        return 0
    power = 1
    while power <= number:
        power <<= 1  # Equivalent to multiplying by 2
    return power >> 1 if number > 1 else 1",data\repos\Python\bit_manipulation\find_previous_power_of_two.py,find_previous_power_of_two,262
272,find_unique_number.py::find_unique_number::1,"def find_unique_number(arr: list[int]) -> int:
    """"""
    Given a list of integers where every element appears twice except for one,
    this function returns the element that appears only once using bitwise XOR.

    >>> find_unique_number([1, 1, 2, 2, 3])
    3
    >>> find_unique_number([4, 5, 4, 6, 6])
    5
    >>> find_unique_number([7])
    7
    >>> find_unique_number([10, 20, 10])
    20
    >>> find_unique_number([])
    Traceback (most recent call last):
        ...
    ValueError: input list must not be empty
    >>> find_unique_number([1, 'a', 1])
    Traceback (most recent call last):
        ...
    TypeError: all elements must be integers
    """"""
    if not arr:
        raise ValueError(""input list must not be empty"")
    if not all(isinstance(x, int) for x in arr):
        raise TypeError(""all elements must be integers"")

    result = 0
    for num in arr:
        result ^= num
    return result",data\repos\Python\bit_manipulation\find_unique_number.py,find_unique_number,244
273,gray_code_sequence.py::gray_code::1,"def gray_code(bit_count: int) -> list:
    """"""
    Takes in an integer n and returns a n-bit
    gray code sequence
    An n-bit gray code sequence is a sequence of 2^n
    integers where:

    a) Every integer is between [0,2^n -1] inclusive
    b) The sequence begins with 0
    c) An integer appears at most one times in the sequence
    d)The binary representation of every pair of integers differ
       by exactly one bit
    e) The binary representation of first and last bit also
       differ by exactly one bit

    >>> gray_code(2)
    [0, 1, 3, 2]

    >>> gray_code(1)
    [0, 1]

    >>> gray_code(3)
    [0, 1, 3, 2, 6, 7, 5, 4]

    >>> gray_code(-1)
    Traceback (most recent call last):
        ...
    ValueError: The given input must be positive

    >>> gray_code(10.6)
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for <<: 'int' and 'float'
    """"""

    # bit count represents no. of bits in the gray code
    if bit_count < 0:
        raise ValueError(""The given input must be positive"")

    # get the generated string sequence
    sequence = gray_code_sequence_string(bit_count)
    #
    # convert them to integers
    for i in range(len(sequence)):
        sequence[i] = int(sequence[i], 2)

    return sequence",data\repos\Python\bit_manipulation\gray_code_sequence.py,gray_code,346
274,gray_code_sequence.py::gray_code_sequence_string::50,"def gray_code_sequence_string(bit_count: int) -> list:
    """"""
    Will output the n-bit grey sequence as a
    string of bits

    >>> gray_code_sequence_string(2)
    ['00', '01', '11', '10']

    >>> gray_code_sequence_string(1)
    ['0', '1']
    """"""

    # The approach is a recursive one
    # Base case achieved when either n = 0 or n=1
    if bit_count == 0:
        return [""0""]

    if bit_count == 1:
        return [""0"", ""1""]

    seq_len = 1 << bit_count  # defines the length of the sequence
    # 1<< n is equivalent to 2^n

    # recursive answer will generate answer for n-1 bits
    smaller_sequence = gray_code_sequence_string(bit_count - 1)

    sequence = []

    # append 0 to first half of the smaller sequence generated
    for i in range(seq_len // 2):
        generated_no = ""0"" + smaller_sequence[i]
        sequence.append(generated_no)

    # append 1 to second half ... start from the end of the list
    for i in reversed(range(seq_len // 2)):
        generated_no = ""1"" + smaller_sequence[i]
        sequence.append(generated_no)

    return sequence",data\repos\Python\bit_manipulation\gray_code_sequence.py,gray_code_sequence_string,282
275,highest_set_bit.py::get_highest_set_bit_position::1,"def get_highest_set_bit_position(number: int) -> int:
    """"""
    Returns position of the highest set bit of a number.
    Ref - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious
    >>> get_highest_set_bit_position(25)
    5
    >>> get_highest_set_bit_position(37)
    6
    >>> get_highest_set_bit_position(1)
    1
    >>> get_highest_set_bit_position(4)
    3
    >>> get_highest_set_bit_position(0)
    0
    >>> get_highest_set_bit_position(0.8)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be an 'int' type
    """"""
    if not isinstance(number, int):
        raise TypeError(""Input value must be an 'int' type"")

    position = 0
    while number:
        position += 1
        number >>= 1

    return position",data\repos\Python\bit_manipulation\highest_set_bit.py,get_highest_set_bit_position,211
276,index_of_rightmost_set_bit.py::get_index_of_rightmost_set_bit::4,"def get_index_of_rightmost_set_bit(number: int) -> int:
    """"""
    Take in a positive integer 'number'.
    Returns the zero-based index of first set bit in that 'number' from right.
    Returns -1, If no set bit found.

    >>> get_index_of_rightmost_set_bit(0)
    -1
    >>> get_index_of_rightmost_set_bit(5)
    0
    >>> get_index_of_rightmost_set_bit(36)
    2
    >>> get_index_of_rightmost_set_bit(8)
    3
    >>> get_index_of_rightmost_set_bit(-18)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    >>> get_index_of_rightmost_set_bit('test')
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    >>> get_index_of_rightmost_set_bit(1.25)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    """"""

    if not isinstance(number, int) or number < 0:
        raise ValueError(""Input must be a non-negative integer"")

    intermediate = number & ~(number - 1)
    index = 0
    while intermediate:
        intermediate >>= 1
        index += 1
    return index - 1",data\repos\Python\bit_manipulation\index_of_rightmost_set_bit.py,get_index_of_rightmost_set_bit,290
277,is_even.py::is_even::1,"def is_even(number: int) -> bool:
    """"""
    return true if the input integer is even
    Explanation: Lets take a look at the following decimal to binary conversions
    2 => 10
    14 => 1110
    100 => 1100100
    3 => 11
    13 => 1101
    101 => 1100101
    from the above examples we can observe that
    for all the odd integers there is always 1 set bit at the end
    also, 1 in binary can be represented as 001, 00001, or 0000001
    so for any odd integer n => n&1 is always equals 1 else the integer is even

    >>> is_even(1)
    False
    >>> is_even(4)
    True
    >>> is_even(9)
    False
    >>> is_even(15)
    False
    >>> is_even(40)
    True
    >>> is_even(100)
    True
    >>> is_even(101)
    False
    """"""
    return number & 1 == 0",data\repos\Python\bit_manipulation\is_even.py,is_even,239
278,is_power_of_two.py::is_power_of_two::18,"def is_power_of_two(number: int) -> bool:
    """"""
    Return True if this number is power of 2 or False otherwise.

    >>> is_power_of_two(0)
    True
    >>> is_power_of_two(1)
    True
    >>> is_power_of_two(2)
    True
    >>> is_power_of_two(4)
    True
    >>> is_power_of_two(6)
    False
    >>> is_power_of_two(8)
    True
    >>> is_power_of_two(17)
    False
    >>> is_power_of_two(-1)
    Traceback (most recent call last):
        ...
    ValueError: number must not be negative
    >>> is_power_of_two(1.2)
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for &: 'float' and 'float'

    # Test all powers of 2 from 0 to 10,000
    >>> all(is_power_of_two(int(2 ** i)) for i in range(10000))
    True
    """"""
    if number < 0:
        raise ValueError(""number must not be negative"")
    return number & (number - 1) == 0",data\repos\Python\bit_manipulation\is_power_of_two.py,is_power_of_two,254
279,largest_pow_of_two_le_num.py::largest_pow_of_two_le_num::22,"def largest_pow_of_two_le_num(number: int) -> int:
    """"""
    Return the largest power of two less than or equal to a number.

    >>> largest_pow_of_two_le_num(0)
    0
    >>> largest_pow_of_two_le_num(1)
    1
    >>> largest_pow_of_two_le_num(-1)
    0
    >>> largest_pow_of_two_le_num(3)
    2
    >>> largest_pow_of_two_le_num(15)
    8
    >>> largest_pow_of_two_le_num(99)
    64
    >>> largest_pow_of_two_le_num(178)
    128
    >>> largest_pow_of_two_le_num(999999)
    524288
    >>> largest_pow_of_two_le_num(99.9)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a 'int' type
    """"""
    if isinstance(number, float):
        raise TypeError(""Input value must be a 'int' type"")
    if number <= 0:
        return 0
    res = 1
    while (res << 1) <= number:
        res <<= 1
    return res",data\repos\Python\bit_manipulation\largest_pow_of_two_le_num.py,largest_pow_of_two_le_num,251
280,missing_number.py::find_missing_number::1,"def find_missing_number(nums: list[int]) -> int:
    """"""
    Finds the missing number in a list of consecutive integers.

    Args:
        nums: A list of integers.

    Returns:
        The missing number.

    Example:
        >>> find_missing_number([0, 1, 3, 4])
        2
        >>> find_missing_number([4, 3, 1, 0])
        2
        >>> find_missing_number([-4, -3, -1, 0])
        -2
        >>> find_missing_number([-2, 2, 1, 3, 0])
        -1
        >>> find_missing_number([1, 3, 4, 5, 6])
        2
        >>> find_missing_number([6, 5, 4, 2, 1])
        3
        >>> find_missing_number([6, 1, 5, 3, 4])
        2
    """"""
    low = min(nums)
    high = max(nums)
    missing_number = high

    for i in range(low, high):
        missing_number ^= i ^ nums[i - low]

    return missing_number",data\repos\Python\bit_manipulation\missing_number.py,find_missing_number,251
281,numbers_different_signs.py::different_signs::14,"def different_signs(num1: int, num2: int) -> bool:
    """"""
    Return True if numbers have opposite signs False otherwise.

    >>> different_signs(1, -1)
    True
    >>> different_signs(1, 1)
    False
    >>> different_signs(1000000000000000000000000000, -1000000000000000000000000000)
    True
    >>> different_signs(-1000000000000000000000000000, 1000000000000000000000000000)
    True
    >>> different_signs(50, 278)
    False
    >>> different_signs(0, 2)
    False
    >>> different_signs(2, 0)
    False
    """"""
    return num1 ^ num2 < 0",data\repos\Python\bit_manipulation\numbers_different_signs.py,different_signs,176
282,power_of_4.py::power_of_4::18,"def power_of_4(number: int) -> bool:
    """"""
    Return True if this number is power of 4 or False otherwise.

    >>> power_of_4(0)
    Traceback (most recent call last):
        ...
    ValueError: number must be positive
    >>> power_of_4(1)
    True
    >>> power_of_4(2)
    False
    >>> power_of_4(4)
    True
    >>> power_of_4(6)
    False
    >>> power_of_4(8)
    False
    >>> power_of_4(17)
    False
    >>> power_of_4(64)
    True
    >>> power_of_4(-1)
    Traceback (most recent call last):
        ...
    ValueError: number must be positive
    >>> power_of_4(1.2)
    Traceback (most recent call last):
        ...
    TypeError: number must be an integer

    """"""
    if not isinstance(number, int):
        raise TypeError(""number must be an integer"")
    if number <= 0:
        raise ValueError(""number must be positive"")
    if number & (number - 1) == 0:
        c = 0
        while number:
            c += 1
            number >>= 1
        return c % 2 == 1
    else:
        return False",data\repos\Python\bit_manipulation\power_of_4.py,power_of_4,288
283,reverse_bits.py::get_reverse_bit_string::1,"def get_reverse_bit_string(number: int) -> str:
    """"""
    Return the reverse bit string of a 32 bit integer

    >>> get_reverse_bit_string(9)
    '10010000000000000000000000000000'
    >>> get_reverse_bit_string(43)
    '11010100000000000000000000000000'
    >>> get_reverse_bit_string(2873)
    '10011100110100000000000000000000'
    >>> get_reverse_bit_string(2550136832)
    '00000000000000000000000000011001'
    >>> get_reverse_bit_string(""this is not a number"")
    Traceback (most recent call last):
        ...
    TypeError: operation can not be conducted on an object of type str
    """"""
    if not isinstance(number, int):
        msg = (
            ""operation can not be conducted on an object of type ""
            f""{type(number).__name__}""
        )
        raise TypeError(msg)
    bit_string = """"
    for _ in range(32):
        bit_string += str(number % 2)
        number >>= 1
    return bit_string",data\repos\Python\bit_manipulation\reverse_bits.py,get_reverse_bit_string,238
284,reverse_bits.py::reverse_bit::31,"def reverse_bit(number: int) -> int:
    """"""
    Take in a 32 bit integer, reverse its bits, return a 32 bit integer result

    >>> reverse_bit(25)
    2550136832
    >>> reverse_bit(37)
    2751463424
    >>> reverse_bit(21)
    2818572288
    >>> reverse_bit(58)
    1543503872
    >>> reverse_bit(0)
    0
    >>> reverse_bit(256)
    8388608
    >>> reverse_bit(2550136832)
    25
    >>> reverse_bit(-1)
    Traceback (most recent call last):
        ...
    ValueError: The value of input must be non-negative

    >>> reverse_bit(1.1)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be an 'int' type

    >>> reverse_bit(""0"")
    Traceback (most recent call last):
        ...
    TypeError: Input value must be an 'int' type
    """"""
    if not isinstance(number, int):
        raise TypeError(""Input value must be an 'int' type"")
    if number < 0:
        raise ValueError(""The value of input must be non-negative"")

    result = 0
    # iterator over [0 to 31], since we are dealing with a 32 bit integer
    for _ in range(32):
        # left shift the bits by unity
        result <<= 1
        # get the end bit
        end_bit = number & 1
        # right shift the bits by unity
        number >>= 1
        # add that bit to our answer
        result |= end_bit
    return result",data\repos\Python\bit_manipulation\reverse_bits.py,reverse_bit,364
285,single_bit_manipulation_operations.py::set_bit::6,"def set_bit(number: int, position: int) -> int:
    """"""
    Set the bit at position to 1.

    Details: perform bitwise or for given number and X.
    Where X is a number with all the bits - zeroes and bit on given
    position - one.

    >>> set_bit(0b1101, 1) # 0b1111
    15
    >>> set_bit(0b0, 5) # 0b100000
    32
    >>> set_bit(0b1111, 1) # 0b1111
    15
    """"""
    return number | (1 << position)",data\repos\Python\bit_manipulation\single_bit_manipulation_operations.py,set_bit,142
286,single_bit_manipulation_operations.py::clear_bit::24,"def clear_bit(number: int, position: int) -> int:
    """"""
    Set the bit at position to 0.

    Details: perform bitwise and for given number and X.
    Where X is a number with all the bits - ones and bit on given
    position - zero.

    >>> clear_bit(0b10010, 1) # 0b10000
    16
    >>> clear_bit(0b0, 5) # 0b0
    0
    """"""
    return number & ~(1 << position)",data\repos\Python\bit_manipulation\single_bit_manipulation_operations.py,clear_bit,117
287,single_bit_manipulation_operations.py::flip_bit::40,"def flip_bit(number: int, position: int) -> int:
    """"""
    Flip the bit at position.

    Details: perform bitwise xor for given number and X.
    Where X is a number with all the bits - zeroes and bit on given
    position - one.

    >>> flip_bit(0b101, 1) # 0b111
    7
    >>> flip_bit(0b101, 0) # 0b100
    4
    """"""
    return number ^ (1 << position)",data\repos\Python\bit_manipulation\single_bit_manipulation_operations.py,flip_bit,112
288,single_bit_manipulation_operations.py::is_bit_set::56,"def is_bit_set(number: int, position: int) -> bool:
    """"""
    Is the bit at position set?

    Details: Shift the bit at position to be the first (smallest) bit.
    Then check if the first bit is set by anding the shifted number with 1.

    >>> is_bit_set(0b1010, 0)
    False
    >>> is_bit_set(0b1010, 1)
    True
    >>> is_bit_set(0b1010, 2)
    False
    >>> is_bit_set(0b1010, 3)
    True
    >>> is_bit_set(0b0, 17)
    False
    """"""
    return ((number >> position) & 1) == 1",data\repos\Python\bit_manipulation\single_bit_manipulation_operations.py,is_bit_set,162
289,single_bit_manipulation_operations.py::get_bit::77,"def get_bit(number: int, position: int) -> int:
    """"""
    Get the bit at the given position

    Details: perform bitwise and for the given number and X,
    Where X is a number with all the bits - zeroes and bit on given position - one.
    If the result is not equal to 0, then the bit on the given position is 1, else 0.

    >>> get_bit(0b1010, 0)
    0
    >>> get_bit(0b1010, 1)
    1
    >>> get_bit(0b1010, 2)
    0
    >>> get_bit(0b1010, 3)
    1
    """"""
    return int((number & (1 << position)) != 0)",data\repos\Python\bit_manipulation\single_bit_manipulation_operations.py,get_bit,169
290,swap_all_odd_and_even_bits.py::show_bits::1,"def show_bits(before: int, after: int) -> str:
    """"""
    >>> print(show_bits(0, 0xFFFF))
        0: 00000000
    65535: 1111111111111111
    """"""
    return f""{before:>5}: {before:08b}\n{after:>5}: {after:08b}""",data\repos\Python\bit_manipulation\swap_all_odd_and_even_bits.py,show_bits,78
291,swap_all_odd_and_even_bits.py::swap_odd_even_bits::10,"def swap_odd_even_bits(num: int) -> int:
    """"""
    1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and
       odd bits (1, 3, 5, 7, etc.) in the input number.
    2. We then right-shift the even bits by 1 position and left-shift the odd bits by
       1 position to swap them.
    3. Finally, we combine the swapped even and odd bits using a bitwise OR operation
       to obtain the final result.
    >>> print(show_bits(0, swap_odd_even_bits(0)))
        0: 00000000
        0: 00000000
    >>> print(show_bits(1, swap_odd_even_bits(1)))
        1: 00000001
        2: 00000010
    >>> print(show_bits(2, swap_odd_even_bits(2)))
        2: 00000010
        1: 00000001
    >>> print(show_bits(3, swap_odd_even_bits(3)))
        3: 00000011
        3: 00000011
    >>> print(show_bits(4, swap_odd_even_bits(4)))
        4: 00000100
        8: 00001000
    >>> print(show_bits(5, swap_odd_even_bits(5)))
        5: 00000101
       10: 00001010
    >>> print(show_bits(6, swap_odd_even_bits(6)))
        6: 00000110
        9: 00001001
    >>> print(show_bits(23, swap_odd_even_bits(23)))
       23: 00010111
       43: 00101011
    """"""
    # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1
    even_bits = num & 0xAAAAAAAA

    # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1
    odd_bits = num & 0x55555555

    # Right shift even bits and left shift odd bits and swap them
    return even_bits >> 1 | odd_bits << 1",data\repos\Python\bit_manipulation\swap_all_odd_and_even_bits.py,swap_odd_even_bits,496
292,diophantine_equation.py::diophantine::6,"def diophantine(a: int, b: int, c: int) -> tuple[float, float]:
    """"""
    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the
    diophantine equation a*x + b*y = c has a solution (where x and y are integers)
    iff greatest_common_divisor(a,b) divides c.

    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )

    >>> diophantine(10,6,14)
    (-7.0, 14.0)

    >>> diophantine(391,299,-69)
    (9.0, -12.0)

    But above equation has one more solution i.e., x = -4, y = 5.
    That's why we need diophantine all solution function.

    """"""

    assert (
        c % greatest_common_divisor(a, b) == 0
    )  # greatest_common_divisor(a,b) is in maths directory
    (d, x, y) = extended_gcd(a, b)  # extended_gcd(a,b) function implemented below
    r = c / d
    return (r * x, r * y)",data\repos\Python\blockchain\diophantine_equation.py,diophantine,263
293,diophantine_equation.py::diophantine_all_soln::33,"def diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:
    """"""
    Lemma : if n|ab and gcd(a,n) = 1, then n|b.

    Finding All solutions of Diophantine Equations:

    Theorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of
    Diophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the
    solutions have the form a(x0 + t*q) + b(y0 - t*p) = c,
    where t is an arbitrary integer.

    n is the number of solution you want, n = 2 by default

    >>> diophantine_all_soln(10, 6, 14)
    -7.0 14.0
    -4.0 9.0

    >>> diophantine_all_soln(10, 6, 14, 4)
    -7.0 14.0
    -4.0 9.0
    -1.0 4.0
    2.0 -1.0

    >>> diophantine_all_soln(391, 299, -69, n = 4)
    9.0 -12.0
    22.0 -29.0
    35.0 -46.0
    48.0 -63.0

    """"""
    (x0, y0) = diophantine(a, b, c)  # Initial value
    d = greatest_common_divisor(a, b)
    p = a // d
    q = b // d

    for i in range(n):
        x = x0 + i * q
        y = y0 - i * p
        print(x, y)",data\repos\Python\blockchain\diophantine_equation.py,diophantine_all_soln,415
294,diophantine_equation.py::extended_gcd::74,"def extended_gcd(a: int, b: int) -> tuple[int, int, int]:
    """"""
    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers
    x and y, then d = gcd(a,b)

    >>> extended_gcd(10, 6)
    (2, -1, 2)

    >>> extended_gcd(7, 5)
    (1, -2, 3)

    """"""
    assert a >= 0
    assert b >= 0

    if b == 0:
        d, x, y = a, 1, 0
    else:
        (d, p, q) = extended_gcd(b, a % b)
        x = q
        y = p - q * (a // b)

    assert a % d == 0
    assert b % d == 0
    assert d == a * x + b * y

    return (d, x, y)",data\repos\Python\blockchain\diophantine_equation.py,extended_gcd,215
295,and_gate.py::and_gate::19,"def and_gate(input_1: int, input_2: int) -> int:
    """"""
    Calculate AND of the input values

    >>> and_gate(0, 0)
    0
    >>> and_gate(0, 1)
    0
    >>> and_gate(1, 0)
    0
    >>> and_gate(1, 1)
    1
    """"""
    return int(input_1 and input_2)",data\repos\Python\boolean_algebra\and_gate.py,and_gate,97
296,and_gate.py::n_input_and_gate::35,"def n_input_and_gate(inputs: list[int]) -> int:
    """"""
    Calculate AND of a list of input values

    >>> n_input_and_gate([1, 0, 1, 1, 0])
    0
    >>> n_input_and_gate([1, 1, 1, 1, 1])
    1
    """"""
    return int(all(inputs))",data\repos\Python\boolean_algebra\and_gate.py,n_input_and_gate,83
297,imply_gate.py::imply_gate::20,"def imply_gate(input_1: int, input_2: int) -> int:
    """"""
    Calculate IMPLY of the input values

    >>> imply_gate(0, 0)
    1
    >>> imply_gate(0, 1)
    1
    >>> imply_gate(1, 0)
    0
    >>> imply_gate(1, 1)
    1
    """"""
    return int(input_1 == 0 or input_2 == 1)",data\repos\Python\boolean_algebra\imply_gate.py,imply_gate,104
298,imply_gate.py::recursive_imply_list::36,"def recursive_imply_list(input_list: list[int]) -> int:
    """"""
    Recursively calculates the implication of a list.
    Strictly the implication is applied consecutively left to right:
    ( (a -> b) -> c ) -> d ...

    >>> recursive_imply_list([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must contain at least two elements
    >>> recursive_imply_list([0])
    Traceback (most recent call last):
        ...
    ValueError: Input list must contain at least two elements
    >>> recursive_imply_list([1])
    Traceback (most recent call last):
        ...
    ValueError: Input list must contain at least two elements
    >>> recursive_imply_list([0, 0])
    1
    >>> recursive_imply_list([0, 1])
    1
    >>> recursive_imply_list([1, 0])
    0
    >>> recursive_imply_list([1, 1])
    1
    >>> recursive_imply_list([0, 0, 0])
    0
    >>> recursive_imply_list([0, 0, 1])
    1
    >>> recursive_imply_list([0, 1, 0])
    0
    >>> recursive_imply_list([0, 1, 1])
    1
    >>> recursive_imply_list([1, 0, 0])
    1
    >>> recursive_imply_list([1, 0, 1])
    1
    >>> recursive_imply_list([1, 1, 0])
    0
    >>> recursive_imply_list([1, 1, 1])
    1
    """"""
    if len(input_list) < 2:
        raise ValueError(""Input list must contain at least two elements"")
    first_implication = imply_gate(input_list[0], input_list[1])
    if len(input_list) == 2:
        return first_implication
    new_list = [first_implication, *input_list[2:]]
    return recursive_imply_list(new_list)",data\repos\Python\boolean_algebra\imply_gate.py,recursive_imply_list,446
299,karnaugh_map_simplification.py::simplify_kmap::7,"def simplify_kmap(kmap: list[list[int]]) -> str:
    """"""
    Simplify the Karnaugh map.
    >>> simplify_kmap(kmap=[[0, 1], [1, 1]])
    ""A'B + AB' + AB""
    >>> simplify_kmap(kmap=[[0, 0], [0, 0]])
    ''
    >>> simplify_kmap(kmap=[[0, 1], [1, -1]])
    ""A'B + AB' + AB""
    >>> simplify_kmap(kmap=[[0, 1], [1, 2]])
    ""A'B + AB' + AB""
    >>> simplify_kmap(kmap=[[0, 1], [1, 1.1]])
    ""A'B + AB' + AB""
    >>> simplify_kmap(kmap=[[0, 1], [1, 'a']])
    ""A'B + AB' + AB""
    """"""
    simplified_f = []
    for a, row in enumerate(kmap):
        for b, item in enumerate(row):
            if item:
                term = (""A"" if a else ""A'"") + (""B"" if b else ""B'"")
                simplified_f.append(term)
    return "" + "".join(simplified_f)",data\repos\Python\boolean_algebra\karnaugh_map_simplification.py,simplify_kmap,262
300,karnaugh_map_simplification.py::main::32,"def main() -> None:
    """"""
    Main function to create and simplify a K-Map.

    >>> main()
    [0, 1]
    [1, 1]
    Simplified Expression:
    A'B + AB' + AB
    """"""
    kmap = [[0, 1], [1, 1]]

    # Manually generate the product of [0, 1] and [0, 1]

    for row in kmap:
        print(row)

    print(""Simplified Expression:"")
    print(simplify_kmap(kmap))",data\repos\Python\boolean_algebra\karnaugh_map_simplification.py,main,118
301,multiplexer.py::mux::1,"def mux(input0: int, input1: int, select: int) -> int:
    """"""
    Implement a 2-to-1 Multiplexer.

    :param input0: The first input value (0 or 1).
    :param input1: The second input value (0 or 1).
    :param select: The select signal (0 or 1) to choose between input0 and input1.
    :return: The output based on the select signal.  input1 if select else input0.

    https://www.electrically4u.com/solved-problems-on-multiplexer
    https://en.wikipedia.org/wiki/Multiplexer

    >>> mux(0, 1, 0)
    0
    >>> mux(0, 1, 1)
    1
    >>> mux(1, 0, 0)
    1
    >>> mux(1, 0, 1)
    0
    >>> mux(2, 1, 0)
    Traceback (most recent call last):
        ...
    ValueError: Inputs and select signal must be 0 or 1
    >>> mux(0, -1, 0)
    Traceback (most recent call last):
        ...
    ValueError: Inputs and select signal must be 0 or 1
    >>> mux(0, 1, 1.1)
    Traceback (most recent call last):
        ...
    ValueError: Inputs and select signal must be 0 or 1
    """"""
    if all(i in (0, 1) for i in (input0, input1, select)):
        return input1 if select else input0
    raise ValueError(""Inputs and select signal must be 0 or 1"")",data\repos\Python\boolean_algebra\multiplexer.py,mux,369
302,nand_gate.py::nand_gate::18,"def nand_gate(input_1: int, input_2: int) -> int:
    """"""
    Calculate NAND of the input values
    >>> nand_gate(0, 0)
    1
    >>> nand_gate(0, 1)
    1
    >>> nand_gate(1, 0)
    1
    >>> nand_gate(1, 1)
    0
    """"""
    return int(not (input_1 and input_2))",data\repos\Python\boolean_algebra\nand_gate.py,nand_gate,104
303,nimply_gate.py::nimply_gate::20,"def nimply_gate(input_1: int, input_2: int) -> int:
    """"""
    Calculate NIMPLY of the input values

    >>> nimply_gate(0, 0)
    0
    >>> nimply_gate(0, 1)
    0
    >>> nimply_gate(1, 0)
    1
    >>> nimply_gate(1, 1)
    0
    """"""
    return int(input_1 == 1 and input_2 == 0)",data\repos\Python\boolean_algebra\nimply_gate.py,nimply_gate,110
304,nor_gate.py::nor_gate::19,"def nor_gate(input_1: int, input_2: int) -> int:
    """"""
    >>> nor_gate(0, 0)
    1
    >>> nor_gate(0, 1)
    0
    >>> nor_gate(1, 0)
    0
    >>> nor_gate(1, 1)
    0
    >>> nor_gate(0.0, 0.0)
    1
    >>> nor_gate(0, -7)
    0
    """"""
    return int(input_1 == input_2 == 0)",data\repos\Python\boolean_algebra\nor_gate.py,nor_gate,124
305,nor_gate.py::truth_table::37,"def truth_table(func: Callable) -> str:
    """"""
    >>> print(truth_table(nor_gate))
    Truth Table of NOR Gate:
    | Input 1  | Input 2  |  Output  |
    |    0     |    0     |    1     |
    |    0     |    1     |    0     |
    |    1     |    0     |    0     |
    |    1     |    1     |    0     |
    """"""

    def make_table_row(items: list | tuple) -> str:
        """"""
        >>> make_table_row((""One"", ""Two"", ""Three""))
        '|   One    |   Two    |  Three   |'
        """"""
        return f""| {' | '.join(f'{item:^8}' for item in items)} |""

    return ""\n"".join(
        (
            ""Truth Table of NOR Gate:"",
            make_table_row((""Input 1"", ""Input 2"", ""Output"")),
            *[make_table_row((i, j, func(i, j))) for i in (0, 1) for j in (0, 1)],
        )
    )",data\repos\Python\boolean_algebra\nor_gate.py,truth_table,254
306,nor_gate.py::make_table_row::48,"    def make_table_row(items: list | tuple) -> str:
        """"""
        >>> make_table_row((""One"", ""Two"", ""Three""))
        '|   One    |   Two    |  Three   |'
        """"""
        return f""| {' | '.join(f'{item:^8}' for item in items)} |""",data\repos\Python\boolean_algebra\nor_gate.py,make_table_row,68
307,not_gate.py::not_gate::15,"def not_gate(input_1: int) -> int:
    """"""
    Calculate NOT of the input values
    >>> not_gate(0)
    1
    >>> not_gate(1)
    0
    """"""

    return 1 if input_1 == 0 else 0",data\repos\Python\boolean_algebra\not_gate.py,not_gate,60
308,or_gate.py::or_gate::17,"def or_gate(input_1: int, input_2: int) -> int:
    """"""
    Calculate OR of the input values
    >>> or_gate(0, 0)
    0
    >>> or_gate(0, 1)
    1
    >>> or_gate(1, 0)
    1
    >>> or_gate(1, 1)
    1
    """"""
    return int((input_1, input_2).count(1) != 0)",data\repos\Python\boolean_algebra\or_gate.py,or_gate,106
309,quine_mc_cluskey.py::compare_string::7,"def compare_string(string1: str, string2: str) -> str | Literal[False]:
    """"""
    >>> compare_string('0010','0110')
    '0_10'

    >>> compare_string('0110','1101')
    False
    """"""
    list1 = list(string1)
    list2 = list(string2)
    count = 0
    for i in range(len(list1)):
        if list1[i] != list2[i]:
            count += 1
            list1[i] = ""_""
    if count > 1:
        return False
    else:
        return """".join(list1)",data\repos\Python\boolean_algebra\quine_mc_cluskey.py,compare_string,132
310,quine_mc_cluskey.py::check::28,"def check(binary: list[str]) -> list[str]:
    """"""
    >>> check(['0.00.01.5'])
    ['0.00.01.5']
    """"""
    pi = []
    while True:
        check1 = [""$""] * len(binary)
        temp = []
        for i in range(len(binary)):
            for j in range(i + 1, len(binary)):
                k = compare_string(binary[i], binary[j])
                if k is False:
                    check1[i] = ""*""
                    check1[j] = ""*""
                    temp.append(""X"")
        for i in range(len(binary)):
            if check1[i] == ""$"":
                pi.append(binary[i])
        if len(temp) == 0:
            return pi
        binary = list(set(temp))",data\repos\Python\boolean_algebra\quine_mc_cluskey.py,check,163
311,quine_mc_cluskey.py::decimal_to_binary::52,"def decimal_to_binary(no_of_variable: int, minterms: Sequence[float]) -> list[str]:
    """"""
    >>> decimal_to_binary(3,[1.5])
    ['0.00.01.5']
    """"""
    temp = []
    for minterm in minterms:
        string = """"
        for _ in range(no_of_variable):
            string = str(minterm % 2) + string
            minterm //= 2
        temp.append(string)
    return temp",data\repos\Python\boolean_algebra\quine_mc_cluskey.py,decimal_to_binary,104
312,quine_mc_cluskey.py::is_for_table::67,"def is_for_table(string1: str, string2: str, count: int) -> bool:
    """"""
    >>> is_for_table('__1','011',2)
    True

    >>> is_for_table('01_','001',1)
    False
    """"""
    list1 = list(string1)
    list2 = list(string2)
    count_n = sum(item1 != item2 for item1, item2 in zip(list1, list2))
    return count_n == count",data\repos\Python\boolean_algebra\quine_mc_cluskey.py,is_for_table,102
313,quine_mc_cluskey.py::selection::81,"def selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:
    """"""
    >>> selection([[1]],['0.00.01.5'])
    ['0.00.01.5']

    >>> selection([[1]],['0.00.01.5'])
    ['0.00.01.5']
    """"""
    temp = []
    select = [0] * len(chart)
    for i in range(len(chart[0])):
        count = sum(row[i] == 1 for row in chart)
        if count == 1:
            rem = max(j for j, row in enumerate(chart) if row[i] == 1)
            select[rem] = 1
    for i, item in enumerate(select):
        if item != 1:
            continue
        for j in range(len(chart[0])):
            if chart[i][j] != 1:
                continue
            for row in chart:
                row[j] = 0
        temp.append(prime_implicants[i])
    while True:
        counts = [chart[i].count(1) for i in range(len(chart))]
        max_n = max(counts)
        rem = counts.index(max_n)

        if max_n == 0:
            return temp

        temp.append(prime_implicants[rem])

        for j in range(len(chart[0])):
            if chart[rem][j] != 1:
                continue
            for i in range(len(chart)):
                chart[i][j] = 0",data\repos\Python\boolean_algebra\quine_mc_cluskey.py,selection,317
314,quine_mc_cluskey.py::prime_implicant_chart::122,"def prime_implicant_chart(
    prime_implicants: list[str], binary: list[str]
) -> list[list[int]]:
    """"""
    >>> prime_implicant_chart(['0.00.01.5'],['0.00.01.5'])
    [[1]]
    """"""
    chart = [[0 for x in range(len(binary))] for x in range(len(prime_implicants))]
    for i in range(len(prime_implicants)):
        count = prime_implicants[i].count(""_"")
        for j in range(len(binary)):
            if is_for_table(prime_implicants[i], binary[j], count):
                chart[i][j] = 1

    return chart",data\repos\Python\boolean_algebra\quine_mc_cluskey.py,prime_implicant_chart,137
315,quine_mc_cluskey.py::main::139,"def main() -> None:
    no_of_variable = int(input(""Enter the no. of variables\n""))
    minterms = [
        float(x)
        for x in input(
            ""Enter the decimal representation of Minterms 'Spaces Separated'\n""
        ).split()
    ]
    binary = decimal_to_binary(no_of_variable, minterms)

    prime_implicants = check(binary)
    print(""Prime Implicants are:"")
    print(prime_implicants)
    chart = prime_implicant_chart(prime_implicants, binary)

    essential_prime_implicants = selection(chart, prime_implicants)
    print(""Essential Prime Implicants are:"")
    print(essential_prime_implicants)",data\repos\Python\boolean_algebra\quine_mc_cluskey.py,main,143
316,xnor_gate.py::xnor_gate::19,"def xnor_gate(input_1: int, input_2: int) -> int:
    """"""
    Calculate XOR of the input values
    >>> xnor_gate(0, 0)
    1
    >>> xnor_gate(0, 1)
    0
    >>> xnor_gate(1, 0)
    0
    >>> xnor_gate(1, 1)
    1
    """"""
    return 1 if input_1 == input_2 else 0",data\repos\Python\boolean_algebra\xnor_gate.py,xnor_gate,106
317,xor_gate.py::xor_gate::18,"def xor_gate(input_1: int, input_2: int) -> int:
    """"""
    calculate xor of the input values

    >>> xor_gate(0, 0)
    0
    >>> xor_gate(0, 1)
    1
    >>> xor_gate(1, 0)
    1
    >>> xor_gate(1, 1)
    0
    """"""
    return (input_1, input_2).count(0) % 2",data\repos\Python\boolean_algebra\xor_gate.py,xor_gate,104
318,conways_game_of_life.py::new_generation::26,"def new_generation(cells: list[list[int]]) -> list[list[int]]:
    """"""
    Generates the next generation for a given state of Conway's Game of Life.
    >>> new_generation(BLINKER)
    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
    """"""
    next_generation = []
    for i in range(len(cells)):
        next_generation_row = []
        for j in range(len(cells[i])):
            # Get the number of live neighbours
            neighbour_count = 0
            if i > 0 and j > 0:
                neighbour_count += cells[i - 1][j - 1]
            if i > 0:
                neighbour_count += cells[i - 1][j]
            if i > 0 and j < len(cells[i]) - 1:
                neighbour_count += cells[i - 1][j + 1]
            if j > 0:
                neighbour_count += cells[i][j - 1]
            if j < len(cells[i]) - 1:
                neighbour_count += cells[i][j + 1]
            if i < len(cells) - 1 and j > 0:
                neighbour_count += cells[i + 1][j - 1]
            if i < len(cells) - 1:
                neighbour_count += cells[i + 1][j]
            if i < len(cells) - 1 and j < len(cells[i]) - 1:
                neighbour_count += cells[i + 1][j + 1]

            # Rules of the game of life (excerpt from Wikipedia):
            # 1. Any live cell with two or three live neighbours survives.
            # 2. Any dead cell with three live neighbours becomes a live cell.
            # 3. All other live cells die in the next generation.
            #    Similarly, all other dead cells stay dead.
            alive = cells[i][j] == 1
            if (alive and 2 <= neighbour_count <= 3) or (
                not alive and neighbour_count == 3
            ):
                next_generation_row.append(1)
            else:
                next_generation_row.append(0)

        next_generation.append(next_generation_row)
    return next_generation",data\repos\Python\cellular_automata\conways_game_of_life.py,new_generation,469
319,conways_game_of_life.py::generate_images::72,"def generate_images(cells: list[list[int]], frames: int) -> list[Image.Image]:
    """"""
    Generates a list of images of subsequent Game of Life states.
    """"""
    images = []
    for _ in range(frames):
        # Create output image
        img = Image.new(""RGB"", (len(cells[0]), len(cells)))
        pixels = img.load()

        # Save cells to image
        for x in range(len(cells)):
            for y in range(len(cells[0])):
                colour = 255 - cells[y][x] * 255
                pixels[x, y] = (colour, colour, colour)

        # Save image
        images.append(img)
        cells = new_generation(cells)
    return images",data\repos\Python\cellular_automata\conways_game_of_life.py,generate_images,150
320,game_of_life.py::create_canvas::44,"def create_canvas(size: int) -> list[list[bool]]:
    canvas = [[False for i in range(size)] for j in range(size)]
    return canvas",data\repos\Python\cellular_automata\game_of_life.py,create_canvas,33
321,game_of_life.py::seed::49,"def seed(canvas: list[list[bool]]) -> None:
    for i, row in enumerate(canvas):
        for j, _ in enumerate(row):
            canvas[i][j] = bool(random.getrandbits(1))",data\repos\Python\cellular_automata\game_of_life.py,seed,45
322,game_of_life.py::run::55,"def run(canvas: list[list[bool]]) -> list[list[bool]]:
    """"""
    This function runs the rules of game through all points, and changes their
    status accordingly.(in the same canvas)
    @Args:
    --
    canvas : canvas of population to run the rules on.

    @returns:
    --
    canvas of population after one step
    """"""
    current_canvas = np.array(canvas)
    next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))
    for r, row in enumerate(current_canvas):
        for c, pt in enumerate(row):
            next_gen_canvas[r][c] = __judge_point(
                pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]
            )

    return next_gen_canvas.tolist()",data\repos\Python\cellular_automata\game_of_life.py,run,165
323,langtons_ant.py::move_ant::37,"    def move_ant(self, axes: plt.Axes | None, display: bool, _frame: int) -> None:
        """"""
        Performs three tasks:
            1. The ant turns either clockwise or anti-clockwise according to the colour
            of the square that it is currently on. If the square is white, the ant
            turns clockwise, and if the square is black the ant turns anti-clockwise
            2. The ant moves one square in the direction that it is currently facing
            3. The square the ant was previously on is inverted (White -> Black and
            Black -> White)

        If display is True, the board will also be displayed on the axes

        >>> la = LangtonsAnt(2, 2)
        >>> la.move_ant(None, True, 0)
        >>> la.board
        [[True, True], [True, False]]
        >>> la.move_ant(None, True, 0)
        >>> la.board
        [[True, False], [True, False]]
        """"""
        directions = {
            0: (-1, 0),  # 0
            1: (0, 1),  # 90
            2: (1, 0),  # 180
            3: (0, -1),  # 270
        }
        x, y = self.ant_position

        # Turn clockwise or anti-clockwise according to colour of square
        if self.board[x][y] is True:
            # The square is white so turn 90 clockwise
            self.ant_direction = (self.ant_direction + 1) % 4
        else:
            # The square is black so turn 90 anti-clockwise
            self.ant_direction = (self.ant_direction - 1) % 4

        # Move ant
        move_x, move_y = directions[self.ant_direction]
        self.ant_position = (x + move_x, y + move_y)

        # Flip colour of square
        self.board[x][y] = not self.board[x][y]

        if display and axes:
            # Display the board on the axes
            axes.get_xaxis().set_ticks([])
            axes.get_yaxis().set_ticks([])
            axes.imshow(self.board, cmap=""gray"", interpolation=""nearest"")",data\repos\Python\cellular_automata\langtons_ant.py,move_ant,487
324,langtons_ant.py::display::86,"    def display(self, frames: int = 100_000) -> None:
        """"""
        Displays the board without delay in a matplotlib plot
        to visually understand and track the ant.

        >>> _ = LangtonsAnt(WIDTH, HEIGHT)
        """"""
        fig, ax = plt.subplots()
        # Assign animation to a variable to prevent it from getting garbage collected
        self.animation = FuncAnimation(
            fig, partial(self.move_ant, ax, True), frames=frames, interval=1
        )
        plt.show()",data\repos\Python\cellular_automata\langtons_ant.py,display,109
325,nagel_schrekenberg.py::construct_highway::31,"def construct_highway(
    number_of_cells: int,
    frequency: int,
    initial_speed: int,
    random_frequency: bool = False,
    random_speed: bool = False,
    max_speed: int = 5,
) -> list:
    """"""
    Build the highway following the parameters given
    >>> construct_highway(10, 2, 6)
    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]
    >>> construct_highway(10, 10, 2)
    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]
    """"""

    highway = [[-1] * number_of_cells]  # Create a highway without any car
    i = 0
    initial_speed = max(initial_speed, 0)
    while i < number_of_cells:
        highway[0][i] = (
            randint(0, max_speed) if random_speed else initial_speed
        )  # Place the cars
        i += (
            randint(1, max_speed * 2) if random_frequency else frequency
        )  # Arbitrary number, may need tuning
    return highway",data\repos\Python\cellular_automata\nagel_schrekenberg.py,construct_highway,268
326,nagel_schrekenberg.py::get_distance::60,"def get_distance(highway_now: list, car_index: int) -> int:
    """"""
    Get the distance between a car (at index car_index) and the next car
    >>> get_distance([6, -1, 6, -1, 6], 2)
    1
    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)
    3
    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)
    4
    """"""

    distance = 0
    cells = highway_now[car_index + 1 :]
    for cell in range(len(cells)):  # May need a better name for this
        if cells[cell] != -1:  # If the cell is not empty then
            return distance  # we have the distance we wanted
        distance += 1
    # Here if the car is near the end of the highway
    return distance + get_distance(highway_now, -1)",data\repos\Python\cellular_automata\nagel_schrekenberg.py,get_distance,244
327,nagel_schrekenberg.py::update::81,"def update(highway_now: list, probability: float, max_speed: int) -> list:
    """"""
    Update the speed of the cars
    >>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)
    [-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4]
    >>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)
    [-1, -1, 3, -1, -1, -1, -1, 1]
    """"""

    number_of_cells = len(highway_now)
    # Beforce calculations, the highway is empty
    next_highway = [-1] * number_of_cells

    for car_index in range(number_of_cells):
        if highway_now[car_index] != -1:
            # Add 1 to the current speed of the car and cap the speed
            next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)
            # Number of empty cell before the next car
            dn = get_distance(highway_now, car_index) - 1
            # We can't have the car causing an accident
            next_highway[car_index] = min(next_highway[car_index], dn)
            if random() < probability:
                # Randomly, a driver will slow down
                next_highway[car_index] = max(next_highway[car_index] - 1, 0)
    return next_highway",data\repos\Python\cellular_automata\nagel_schrekenberg.py,update,373
328,nagel_schrekenberg.py::simulate::108,"def simulate(
    highway: list, number_of_update: int, probability: float, max_speed: int
) -> list:
    """"""
    The main function, it will simulate the evolution of the highway
    >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3)
    [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]]
    >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3)
    [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]
    """"""

    number_of_cells = len(highway[0])

    for i in range(number_of_update):
        next_speeds_calculated = update(highway[i], probability, max_speed)
        real_next_speeds = [-1] * number_of_cells

        for car_index in range(number_of_cells):
            speed = next_speeds_calculated[car_index]
            if speed != -1:
                # Change the position based on the speed (with % to create the loop)
                index = (car_index + speed) % number_of_cells
                # Commit the change of position
                real_next_speeds[index] = speed
        highway.append(real_next_speeds)

    return highway",data\repos\Python\cellular_automata\nagel_schrekenberg.py,simulate,363
329,one_dimensional.py::format_ruleset::18,"def format_ruleset(ruleset: int) -> list[int]:
    """"""
    >>> format_ruleset(11100)
    [0, 0, 0, 1, 1, 1, 0, 0]
    >>> format_ruleset(0)
    [0, 0, 0, 0, 0, 0, 0, 0]
    >>> format_ruleset(11111111)
    [1, 1, 1, 1, 1, 1, 1, 1]
    """"""
    return [int(c) for c in f""{ruleset:08}""[:8]]",data\repos\Python\cellular_automata\one_dimensional.py,format_ruleset,138
330,one_dimensional.py::new_generation::30,"def new_generation(cells: list[list[int]], rule: list[int], time: int) -> list[int]:
    population = len(cells[0])  # 31
    next_generation = []
    for i in range(population):
        # Get the neighbors of each cell
        # Handle neighbours outside bounds by using 0 as their value
        left_neighbor = 0 if i == 0 else cells[time][i - 1]
        right_neighbor = 0 if i == population - 1 else cells[time][i + 1]
        # Define a new cell and add it to the new generation
        situation = 7 - int(f""{left_neighbor}{cells[time][i]}{right_neighbor}"", 2)
        next_generation.append(rule[situation])
    return next_generation",data\repos\Python\cellular_automata\one_dimensional.py,new_generation,167
331,one_dimensional.py::generate_image::44,"def generate_image(cells: list[list[int]]) -> Image.Image:
    """"""
    Convert the cells into a greyscale PIL.Image.Image and return it to the caller.
    >>> from random import random
    >>> cells = [[random() for w in range(31)] for h in range(16)]
    >>> img = generate_image(cells)
    >>> isinstance(img, Image.Image)
    True
    >>> img.width, img.height
    (31, 16)
    """"""
    # Create the output image
    img = Image.new(""RGB"", (len(cells[0]), len(cells)))
    pixels = img.load()
    # Generates image
    for w in range(img.width):
        for h in range(img.height):
            color = 255 - int(255 * cells[h][w])
            pixels[w, h] = (color, color, color)
    return img",data\repos\Python\cellular_automata\one_dimensional.py,generate_image,180
332,wa_tor.py::visualise::481,"def visualise(wt: WaTor, iter_number: int, *, colour: bool = True) -> None:
    """"""
    Visually displays the Wa-Tor planet using
    an ascii code in terminal to clear and re-print
    the Wa-Tor planet at intervals.

    Uses ascii colour codes to colourfully display the predators and prey:
        * (0x60f197) Prey = ``#``
        * (0xfffff) Predator = ``x``

    >>> wt = WaTor(30, 30)
    >>> wt.set_planet([
    ... [Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1)), None],
    ... [Entity(False, coords=(1, 0)), None, Entity(False, coords=(1, 2))],
    ... [None, Entity(True, coords=(2, 1)), None]
    ... ])
    >>> visualise(wt, 0, colour=False)  # doctest: +NORMALIZE_WHITESPACE
    #  x  .
    x  .  x
    .  #  .
    <BLANKLINE>
    Iteration: 0 | Prey count: 2 | Predator count: 3 |
    """"""
    if colour:
        __import__(""os"").system("""")
        print(""\x1b[0;0H\x1b[2J\x1b[?25l"")

    reprint = ""\x1b[0;0H"" if colour else """"
    ansi_colour_end = ""\x1b[0m "" if colour else "" ""

    planet = wt.planet
    output = """"

    # Iterate over every entity in the planet
    for row in planet:
        for entity in row:
            if entity is None:
                output += "" . ""
            else:
                if colour is True:
                    output += (
                        ""\x1b[38;2;96;241;151m""
                        if entity.prey
                        else ""\x1b[38;2;255;255;15m""
                    )
                output += f"" {'#' if entity.prey else 'x'}{ansi_colour_end}""

        output += ""\n""

    entities = wt.get_entities()
    prey_count = sum(entity.prey for entity in entities)

    print(
        f""{output}\n Iteration: {iter_number} | Prey count: {prey_count} | ""
        f""Predator count: {len(entities) - prey_count} | {reprint}""
    )
    # Block the thread to be able to visualise seeing the algorithm
    sleep(0.05)",data\repos\Python\cellular_automata\wa_tor.py,visualise,554
333,wa_tor.py::reset_reproduction_time::62,"    def reset_reproduction_time(self) -> None:
        """"""
        >>> e = Entity(True, coords=(0, 0))
        >>> e.reset_reproduction_time()
        >>> e.remaining_reproduction_time == PREY_REPRODUCTION_TIME
        True
        >>> e = Entity(False, coords=(0, 0))
        >>> e.reset_reproduction_time()
        >>> e.remaining_reproduction_time == PREDATOR_REPRODUCTION_TIME
        True
        """"""
        self.remaining_reproduction_time = (
            PREY_REPRODUCTION_TIME if self.prey is True else PREDATOR_REPRODUCTION_TIME
        )",data\repos\Python\cellular_automata\wa_tor.py,reset_reproduction_time,128
334,wa_tor.py::set_planet::132,"    def set_planet(self, planet: list[list[Entity | None]]) -> None:
        """"""
        Ease of access for testing

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> planet = [
        ... [None, None, None],
        ... [None, Entity(True, coords=(1, 1)), None]
        ... ]
        >>> wt.set_planet(planet)
        >>> wt.planet == planet
        True
        >>> wt.width
        3
        >>> wt.height
        2
        """"""
        self.planet = planet
        self.width = len(planet[0])
        self.height = len(planet)",data\repos\Python\cellular_automata\wa_tor.py,set_planet,138
335,wa_tor.py::add_entity::153,"    def add_entity(self, prey: bool) -> None:
        """"""
        Adds an entity, making sure the entity does
        not override another entity

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> wt.set_planet([[None, None], [None, None]])
        >>> wt.add_entity(True)
        >>> len(wt.get_entities())
        1
        >>> wt.add_entity(False)
        >>> len(wt.get_entities())
        2
        """"""
        while True:
            row, col = randint(0, self.height - 1), randint(0, self.width - 1)
            if self.planet[row][col] is None:
                self.planet[row][col] = Entity(prey=prey, coords=(row, col))
                return",data\repos\Python\cellular_automata\wa_tor.py,add_entity,164
336,wa_tor.py::get_entities::173,"    def get_entities(self) -> list[Entity]:
        """"""
        Returns a list of all the entities within the planet.

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> len(wt.get_entities()) == PREDATOR_INITIAL_COUNT + PREY_INITIAL_COUNT
        True
        """"""
        return [entity for column in self.planet for entity in column if entity]",data\repos\Python\cellular_automata\wa_tor.py,get_entities,78
337,wa_tor.py::balance_predators_and_prey::183,"    def balance_predators_and_prey(self) -> None:
        """"""
        Balances predators and preys so that prey
        can not dominate the predators, blocking up
        space for them to reproduce.

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> for i in range(2000):
        ...     row, col = i // HEIGHT, i % WIDTH
        ...     wt.planet[row][col] = Entity(True, coords=(row, col))
        >>> entities = len(wt.get_entities())
        >>> wt.balance_predators_and_prey()
        >>> len(wt.get_entities()) == entities
        False
        """"""
        entities = self.get_entities()
        shuffle(entities)

        if len(entities) >= MAX_ENTITIES - MAX_ENTITIES / 10:
            prey = [entity for entity in entities if entity.prey]
            predators = [entity for entity in entities if not entity.prey]

            prey_count, predator_count = len(prey), len(predators)

            entities_to_purge = (
                prey[:DELETE_UNBALANCED_ENTITIES]
                if prey_count > predator_count
                else predators[:DELETE_UNBALANCED_ENTITIES]
            )
            for entity in entities_to_purge:
                self.planet[entity.coords[0]][entity.coords[1]] = None",data\repos\Python\cellular_automata\wa_tor.py,balance_predators_and_prey,271
338,wa_tor.py::get_surrounding_prey::215,"    def get_surrounding_prey(self, entity: Entity) -> list[Entity]:
        """"""
        Returns all the prey entities around (N, S, E, W) a predator entity.

        Subtly different to the `move_and_reproduce`.

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> wt.set_planet([
        ... [None, Entity(True, (0, 1)), None],
        ... [None, Entity(False, (1, 1)), None],
        ... [None, Entity(True, (2, 1)), None]])
        >>> wt.get_surrounding_prey(
        ... Entity(False, (1, 1)))  # doctest: +NORMALIZE_WHITESPACE
        [Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5),
        Entity(prey=True, coords=(2, 1), remaining_reproduction_time=5)]
        >>> wt.set_planet([[Entity(False, (0, 0))]])
        >>> wt.get_surrounding_prey(Entity(False, (0, 0)))
        []
        >>> wt.set_planet([
        ... [Entity(True, (0, 0)), Entity(False, (1, 0)), Entity(False, (2, 0))],
        ... [None, Entity(False, (1, 1)), Entity(True, (2, 1))],
        ... [None, None, None]])
        >>> wt.get_surrounding_prey(Entity(False, (1, 0)))
        [Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5)]
        """"""
        row, col = entity.coords
        adjacent: list[tuple[int, int]] = [
            (row - 1, col),  # North
            (row + 1, col),  # South
            (row, col - 1),  # West
            (row, col + 1),  # East
        ]

        return [
            ent
            for r, c in adjacent
            if 0 <= r < self.height
            and 0 <= c < self.width
            and (ent := self.planet[r][c]) is not None
            and ent.prey
        ]",data\repos\Python\cellular_automata\wa_tor.py,get_surrounding_prey,475
339,wa_tor.py::move_and_reproduce::257,"    def move_and_reproduce(
        self, entity: Entity, direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]]
    ) -> None:
        """"""
        Attempts to move to an unoccupied neighbouring square
        in either of the four directions (North, South, East, West).
        If the move was successful and the `remaining_reproduction_time` is
        equal to 0, then a new prey or predator can also be created
        in the previous square.

        :param direction_orders: Ordered list (like priority queue) depicting
                            order to attempt to move. Removes any systematic
                            approach of checking neighbouring squares.

        >>> planet = [
        ... [None, None, None],
        ... [None, Entity(True, coords=(1, 1)), None],
        ... [None, None, None]
        ... ]
        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> wt.set_planet(planet)
        >>> wt.move_and_reproduce(Entity(True, coords=(1, 1)), direction_orders=[""N""])
        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
        [[None, Entity(prey=True, coords=(0, 1), remaining_reproduction_time=4), None],
        [None, None, None],
        [None, None, None]]
        >>> wt.planet[0][0] = Entity(True, coords=(0, 0))
        >>> wt.move_and_reproduce(Entity(True, coords=(0, 1)),
        ... direction_orders=[""N"", ""W"", ""E"", ""S""])
        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
        [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None,
        Entity(prey=True, coords=(0, 2), remaining_reproduction_time=4)],
        [None, None, None],
        [None, None, None]]
        >>> wt.planet[0][1] = wt.planet[0][2]
        >>> wt.planet[0][2] = None
        >>> wt.move_and_reproduce(Entity(True, coords=(0, 1)),
        ... direction_orders=[""N"", ""W"", ""S"", ""E""])
        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
        [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None, None],
        [None, Entity(prey=True, coords=(1, 1), remaining_reproduction_time=4), None],
        [None, None, None]]

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> reproducable_entity = Entity(False, coords=(0, 1))
        >>> reproducable_entity.remaining_reproduction_time = 0
        >>> wt.planet = [[None, reproducable_entity]]
        >>> wt.move_and_reproduce(reproducable_entity,
        ... direction_orders=[""N"", ""W"", ""S"", ""E""])
        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
        [[Entity(prey=False, coords=(0, 0),
        remaining_reproduction_time=20, energy_value=15),
        Entity(prey=False, coords=(0, 1), remaining_reproduction_time=20,
        energy_value=15)]]
        """"""
        row, col = coords = entity.coords

        adjacent_squares: dict[Literal[""N"", ""E"", ""S"", ""W""], tuple[int, int]] = {
            ""N"": (row - 1, col),  # North
            ""S"": (row + 1, col),  # South
            ""W"": (row, col - 1),  # West
            ""E"": (row, col + 1),  # East
        }
        # Weight adjacent locations
        adjacent: list[tuple[int, int]] = []
        for order in direction_orders:
            adjacent.append(adjacent_squares[order])

        for r, c in adjacent:
            if (
                0 <= r < self.height
                and 0 <= c < self.width
                and self.planet[r][c] is None
            ):
                # Move entity to empty adjacent square
                self.planet[r][c] = entity
                self.planet[row][col] = None
                entity.coords = (r, c)
                break

        # (2.) See if it possible to reproduce in previous square
        if coords != entity.coords and entity.remaining_reproduction_time <= 0:
            # Check if the entities on the planet is less than the max limit
            if len(self.get_entities()) < MAX_ENTITIES:
                # Reproduce in previous square
                self.planet[row][col] = Entity(prey=entity.prey, coords=coords)
                entity.reset_reproduction_time()
        else:
            entity.remaining_reproduction_time -= 1",data\repos\Python\cellular_automata\wa_tor.py,move_and_reproduce,1041
340,wa_tor.py::perform_prey_actions::347,"    def perform_prey_actions(
        self, entity: Entity, direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]]
    ) -> None:
        """"""
        Performs the actions for a prey entity

        For prey the rules are:
            1. At each chronon, a prey moves randomly to one of the adjacent unoccupied
               squares. If there are no free squares, no movement takes place.
            2. Once a prey has survived a certain number of chronons it may reproduce.
               This is done as it moves to a neighbouring square,
               leaving behind a new prey in its old position.
               Its reproduction time is also reset to zero.

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> reproducable_entity = Entity(True, coords=(0, 1))
        >>> reproducable_entity.remaining_reproduction_time = 0
        >>> wt.planet = [[None, reproducable_entity]]
        >>> wt.perform_prey_actions(reproducable_entity,
        ... direction_orders=[""N"", ""W"", ""S"", ""E""])
        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
        [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5),
        Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5)]]
        """"""
        self.move_and_reproduce(entity, direction_orders)",data\repos\Python\cellular_automata\wa_tor.py,perform_prey_actions,300
341,wa_tor.py::perform_predator_actions::373,"    def perform_predator_actions(
        self,
        entity: Entity,
        occupied_by_prey_coords: tuple[int, int] | None,
        direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]],
    ) -> None:
        """"""
        Performs the actions for a predator entity

        :param occupied_by_prey_coords: Move to this location if there is prey there

        For predators the rules are:
            1. At each chronon, a predator moves randomly to an adjacent square occupied
               by a prey. If there is none, the predator moves to a random adjacent
               unoccupied square. If there are no free squares, no movement takes place.
            2. At each chronon, each predator is deprived of a unit of energy.
            3. Upon reaching zero energy, a predator dies.
            4. If a predator moves to a square occupied by a prey,
               it eats the prey and earns a certain amount of energy.
            5. Once a predator has survived a certain number of chronons
               it may reproduce in exactly the same way as the prey.

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> wt.set_planet([[Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1))]])
        >>> wt.perform_predator_actions(Entity(False, coords=(0, 1)), (0, 0), [])
        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
        [[Entity(prey=False, coords=(0, 0),
        remaining_reproduction_time=20, energy_value=19), None]]
        """"""
        assert entity.energy_value is not None  # [type checking]

        # (3.) If the entity has 0 energy, it will die
        if entity.energy_value == 0:
            self.planet[entity.coords[0]][entity.coords[1]] = None
            return

        # (1.) Move to entity if possible
        if occupied_by_prey_coords is not None:
            # Kill the prey
            prey = self.planet[occupied_by_prey_coords[0]][occupied_by_prey_coords[1]]
            assert prey is not None
            prey.alive = False

            # Move onto prey
            self.planet[occupied_by_prey_coords[0]][occupied_by_prey_coords[1]] = entity
            self.planet[entity.coords[0]][entity.coords[1]] = None

            entity.coords = occupied_by_prey_coords
            # (4.) Eats the prey and earns energy
            entity.energy_value += PREDATOR_FOOD_VALUE
        else:
            # (5.) If it has survived the certain number of chronons it will also
            # reproduce in this function
            self.move_and_reproduce(entity, direction_orders)

        # (2.) Each chronon, the predator is deprived of a unit of energy
        entity.energy_value -= 1",data\repos\Python\cellular_automata\wa_tor.py,perform_predator_actions,621
342,wa_tor.py::run::431,"    def run(self, *, iteration_count: int) -> None:
        """"""
        Emulate time passing by looping `iteration_count` times

        >>> wt = WaTor(WIDTH, HEIGHT)
        >>> wt.run(iteration_count=PREDATOR_INITIAL_ENERGY_VALUE - 1)
        >>> len(list(filter(lambda entity: entity.prey is False,
        ... wt.get_entities()))) >= PREDATOR_INITIAL_COUNT
        True
        """"""
        for iter_num in range(iteration_count):
            # Generate list of all entities in order to randomly
            # pop an entity at a time to simulate true randomness
            # This removes the systematic approach of iterating
            # through each entity width by height
            all_entities = self.get_entities()

            for __ in range(len(all_entities)):
                entity = all_entities.pop(randint(0, len(all_entities) - 1))
                if entity.alive is False:
                    continue

                directions: list[Literal[""N"", ""E"", ""S"", ""W""]] = [""N"", ""E"", ""S"", ""W""]
                shuffle(directions)  # Randomly shuffle directions

                if entity.prey:
                    self.perform_prey_actions(entity, directions)
                else:
                    # Create list of surrounding prey
                    surrounding_prey = self.get_surrounding_prey(entity)
                    surrounding_prey_coords = None

                    if surrounding_prey:
                        # Again, randomly shuffle directions
                        shuffle(surrounding_prey)
                        surrounding_prey_coords = surrounding_prey[0].coords

                    self.perform_predator_actions(
                        entity, surrounding_prey_coords, directions
                    )

            # Balance out the predators and prey
            self.balance_predators_and_prey()

            if self.time_passed is not None:
                # Call time_passed function for Wa-Tor planet
                # visualisation in a terminal or a graph.
                self.time_passed(self, iter_num)",data\repos\Python\cellular_automata\wa_tor.py,run,398
343,a1z26.py::encode::12,"def encode(plain: str) -> list[int]:
    """"""
    >>> encode(""myname"")
    [13, 25, 14, 1, 13, 5]
    """"""
    return [ord(elem) - 96 for elem in plain]",data\repos\Python\ciphers\a1z26.py,encode,55
344,a1z26.py::decode::20,"def decode(encoded: list[int]) -> str:
    """"""
    >>> decode([13, 25, 14, 1, 13, 5])
    'myname'
    """"""
    return """".join(chr(elem + 96) for elem in encoded)",data\repos\Python\ciphers\a1z26.py,decode,55
345,a1z26.py::main::28,"def main() -> None:
    encoded = encode(input(""-> "").strip().lower())
    print(""Encoded: "", encoded)
    print(""Decoded:"", decode(encoded))",data\repos\Python\ciphers\a1z26.py,main,35
346,affine_cipher.py::check_keys::14,"def check_keys(key_a: int, key_b: int, mode: str) -> None:
    if mode == ""encrypt"":
        if key_a == 1:
            sys.exit(
                ""The affine cipher becomes weak when key ""
                ""A is set to 1. Choose different key""
            )
        if key_b == 0:
            sys.exit(
                ""The affine cipher becomes weak when key ""
                ""B is set to 0. Choose different key""
            )
    if key_a < 0 or key_b < 0 or key_b > len(SYMBOLS) - 1:
        sys.exit(
            ""Key A must be greater than 0 and key B must ""
            f""be between 0 and {len(SYMBOLS) - 1}.""
        )
    if gcd_by_iterative(key_a, len(SYMBOLS)) != 1:
        sys.exit(
            f""Key A {key_a} and the symbol set size {len(SYMBOLS)} ""
            ""are not relatively prime. Choose a different key.""
        )",data\repos\Python\ciphers\affine_cipher.py,check_keys,228
347,affine_cipher.py::encrypt_message::38,"def encrypt_message(key: int, message: str) -> str:
    """"""
    >>> encrypt_message(4545, 'The affine cipher is a type of monoalphabetic '
    ...                       'substitution cipher.')
    'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'
    """"""
    key_a, key_b = divmod(key, len(SYMBOLS))
    check_keys(key_a, key_b, ""encrypt"")
    cipher_text = """"
    for symbol in message:
        if symbol in SYMBOLS:
            sym_index = SYMBOLS.find(symbol)
            cipher_text += SYMBOLS[(sym_index * key_a + key_b) % len(SYMBOLS)]
        else:
            cipher_text += symbol
    return cipher_text",data\repos\Python\ciphers\affine_cipher.py,encrypt_message,186
348,affine_cipher.py::decrypt_message::56,"def decrypt_message(key: int, message: str) -> str:
    """"""
    >>> decrypt_message(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF'
    ...                       '{xIp~{HL}Gi')
    'The affine cipher is a type of monoalphabetic substitution cipher.'
    """"""
    key_a, key_b = divmod(key, len(SYMBOLS))
    check_keys(key_a, key_b, ""decrypt"")
    plain_text = """"
    mod_inverse_of_key_a = cryptomath.find_mod_inverse(key_a, len(SYMBOLS))
    for symbol in message:
        if symbol in SYMBOLS:
            sym_index = SYMBOLS.find(symbol)
            plain_text += SYMBOLS[
                (sym_index - key_b) * mod_inverse_of_key_a % len(SYMBOLS)
            ]
        else:
            plain_text += symbol
    return plain_text",data\repos\Python\ciphers\affine_cipher.py,decrypt_message,214
349,affine_cipher.py::get_random_key::77,"def get_random_key() -> int:
    while True:
        key_b = random.randint(2, len(SYMBOLS))
        key_b = random.randint(2, len(SYMBOLS))
        if gcd_by_iterative(key_b, len(SYMBOLS)) == 1 and key_b % len(SYMBOLS) != 0:
            return key_b * len(SYMBOLS) + key_b",data\repos\Python\ciphers\affine_cipher.py,get_random_key,88
350,affine_cipher.py::main::85,"def main() -> None:
    """"""
    >>> key = get_random_key()
    >>> msg = ""This is a test!""
    >>> decrypt_message(key, encrypt_message(key, msg)) == msg
    True
    """"""
    message = input(""Enter message: "").strip()
    key = int(input(""Enter key [2000 - 9000]: "").strip())
    mode = input(""Encrypt/Decrypt [E/D]: "").strip().lower()

    if mode.startswith(""e""):
        mode = ""encrypt""
        translated = encrypt_message(key, message)
    elif mode.startswith(""d""):
        mode = ""decrypt""
        translated = decrypt_message(key, message)
    print(f""\n{mode.title()}ed text: \n{translated}"")",data\repos\Python\ciphers\affine_cipher.py,main,154
351,atbash.py::atbash_slow::6,"def atbash_slow(sequence: str) -> str:
    """"""
    >>> atbash_slow(""ABCDEFG"")
    'ZYXWVUT'

    >>> atbash_slow(""aW;;123BX"")
    'zD;;123YC'
    """"""
    output = """"
    for i in sequence:
        extract = ord(i)
        if 65 <= extract <= 90:
            output += chr(155 - extract)
        elif 97 <= extract <= 122:
            output += chr(219 - extract)
        else:
            output += i
    return output",data\repos\Python\ciphers\atbash.py,atbash_slow,116
352,atbash.py::atbash::26,"def atbash(sequence: str) -> str:
    """"""
    >>> atbash(""ABCDEFG"")
    'ZYXWVUT'

    >>> atbash(""aW;;123BX"")
    'zD;;123YC'
    """"""
    letters = string.ascii_letters
    letters_reversed = string.ascii_lowercase[::-1] + string.ascii_uppercase[::-1]
    return """".join(
        letters_reversed[letters.index(c)] if c in letters else c for c in sequence
    )",data\repos\Python\ciphers\atbash.py,atbash,101
353,atbash.py::benchmark::41,"def benchmark() -> None:
    """"""Let's benchmark our functions side-by-side...""""""
    from timeit import timeit

    print(""Running performance benchmarks..."")
    setup = ""from string import printable ; from __main__ import atbash, atbash_slow""
    print(f""> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds"")
    print(f"">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds"")",data\repos\Python\ciphers\atbash.py,benchmark,101
354,autokey.py::encrypt::12,"def encrypt(plaintext: str, key: str) -> str:
    """"""
    Encrypt a given `plaintext` (string) and `key` (string), returning the
    encrypted ciphertext.

    >>> encrypt(""hello world"", ""coffee"")
    'jsqqs avvwo'
    >>> encrypt(""coffee is good as python"", ""TheAlgorithms"")
    'vvjfpk wj ohvp su ddylsv'
    >>> encrypt(""coffee is good as python"", 2)
    Traceback (most recent call last):
        ...
    TypeError: key must be a string
    >>> encrypt("""", ""TheAlgorithms"")
    Traceback (most recent call last):
        ...
    ValueError: plaintext is empty
    >>> encrypt(""coffee is good as python"", """")
    Traceback (most recent call last):
        ...
    ValueError: key is empty
    >>> encrypt(527.26, ""TheAlgorithms"")
    Traceback (most recent call last):
        ...
    TypeError: plaintext must be a string
    """"""
    if not isinstance(plaintext, str):
        raise TypeError(""plaintext must be a string"")
    if not isinstance(key, str):
        raise TypeError(""key must be a string"")

    if not plaintext:
        raise ValueError(""plaintext is empty"")
    if not key:
        raise ValueError(""key is empty"")

    key += plaintext
    plaintext = plaintext.lower()
    key = key.lower()
    plaintext_iterator = 0
    key_iterator = 0
    ciphertext = """"
    while plaintext_iterator < len(plaintext):
        if (
            ord(plaintext[plaintext_iterator]) < 97
            or ord(plaintext[plaintext_iterator]) > 122
        ):
            ciphertext += plaintext[plaintext_iterator]
            plaintext_iterator += 1
        elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:
            key_iterator += 1
        else:
            ciphertext += chr(
                (
                    (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))
                    - 97
                )
                % 26
                + 97
            )
            key_iterator += 1
            plaintext_iterator += 1
    return ciphertext",data\repos\Python\ciphers\autokey.py,encrypt,456
355,autokey.py::decrypt::77,"def decrypt(ciphertext: str, key: str) -> str:
    """"""
    Decrypt a given `ciphertext` (string) and `key` (string), returning the decrypted
    ciphertext.

    >>> decrypt(""jsqqs avvwo"", ""coffee"")
    'hello world'
    >>> decrypt(""vvjfpk wj ohvp su ddylsv"", ""TheAlgorithms"")
    'coffee is good as python'
    >>> decrypt(""vvjfpk wj ohvp su ddylsv"", """")
    Traceback (most recent call last):
        ...
    ValueError: key is empty
    >>> decrypt(527.26, ""TheAlgorithms"")
    Traceback (most recent call last):
        ...
    TypeError: ciphertext must be a string
    >>> decrypt("""", ""TheAlgorithms"")
    Traceback (most recent call last):
        ...
    ValueError: ciphertext is empty
    >>> decrypt(""vvjfpk wj ohvp su ddylsv"", 2)
    Traceback (most recent call last):
        ...
    TypeError: key must be a string
    """"""
    if not isinstance(ciphertext, str):
        raise TypeError(""ciphertext must be a string"")
    if not isinstance(key, str):
        raise TypeError(""key must be a string"")

    if not ciphertext:
        raise ValueError(""ciphertext is empty"")
    if not key:
        raise ValueError(""key is empty"")

    key = key.lower()
    ciphertext_iterator = 0
    key_iterator = 0
    plaintext = """"
    while ciphertext_iterator < len(ciphertext):
        if (
            ord(ciphertext[ciphertext_iterator]) < 97
            or ord(ciphertext[ciphertext_iterator]) > 122
        ):
            plaintext += ciphertext[ciphertext_iterator]
        else:
            plaintext += chr(
                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26
                + 97
            )
            key += chr(
                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26
                + 97
            )
            key_iterator += 1
        ciphertext_iterator += 1
    return plaintext",data\repos\Python\ciphers\autokey.py,decrypt,446
356,baconian_cipher.py::encode::40,"def encode(word: str) -> str:
    """"""
    Encodes to Baconian cipher

    >>> encode(""hello"")
    'AABBBAABAAABABAABABAABBAB'
    >>> encode(""hello world"")
    'AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB'
    >>> encode(""hello world!"")
    Traceback (most recent call last):
        ...
    Exception: encode() accepts only letters of the alphabet and spaces
    """"""
    encoded = """"
    for letter in word.lower():
        if letter.isalpha() or letter == "" "":
            encoded += encode_dict[letter]
        else:
            raise Exception(""encode() accepts only letters of the alphabet and spaces"")
    return encoded",data\repos\Python\ciphers\baconian_cipher.py,encode,155
357,baconian_cipher.py::decode::62,"def decode(coded: str) -> str:
    """"""
    Decodes from Baconian cipher

    >>> decode(""AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB"")
    'hello world'
    >>> decode(""AABBBAABAAABABAABABAABBAB"")
    'hello'
    >>> decode(""AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB!"")
    Traceback (most recent call last):
        ...
    Exception: decode() accepts only 'A', 'B' and spaces
    """"""
    if set(coded) - {""A"", ""B"", "" ""} != set():
        raise Exception(""decode() accepts only 'A', 'B' and spaces"")
    decoded = """"
    for word in coded.split():
        while len(word) != 0:
            decoded += decode_dict[word[:5]]
            word = word[5:]
        decoded += "" ""
    return decoded.strip()",data\repos\Python\ciphers\baconian_cipher.py,decode,205
358,base16.py::base16_encode::1,"def base16_encode(data: bytes) -> str:
    """"""
    Encodes the given bytes into base16.

    >>> base16_encode(b'Hello World!')
    '48656C6C6F20576F726C6421'
    >>> base16_encode(b'HELLO WORLD!')
    '48454C4C4F20574F524C4421'
    >>> base16_encode(b'')
    ''
    """"""
    # Turn the data into a list of integers (where each integer is a byte),
    # Then turn each byte into its hexadecimal representation, make sure
    # it is uppercase, and then join everything together and return it.
    return """".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])",data\repos\Python\ciphers\base16.py,base16_encode,160
359,base16.py::base16_decode::18,"def base16_decode(data: str) -> bytes:
    """"""
    Decodes the given base16 encoded data into bytes.

    >>> base16_decode('48656C6C6F20576F726C6421')
    b'Hello World!'
    >>> base16_decode('48454C4C4F20574F524C4421')
    b'HELLO WORLD!'
    >>> base16_decode('')
    b''
    >>> base16_decode('486')
    Traceback (most recent call last):
      ...
    ValueError: Base16 encoded data is invalid:
    Data does not have an even number of hex digits.
    >>> base16_decode('48656c6c6f20576f726c6421')
    Traceback (most recent call last):
      ...
    ValueError: Base16 encoded data is invalid:
    Data is not uppercase hex or it contains invalid characters.
    >>> base16_decode('This is not base64 encoded data.')
    Traceback (most recent call last):
      ...
    ValueError: Base16 encoded data is invalid:
    Data is not uppercase hex or it contains invalid characters.
    """"""
    # Check data validity, following RFC3548
    # https://www.ietf.org/rfc/rfc3548.txt
    if (len(data) % 2) != 0:
        raise ValueError(
            """"""Base16 encoded data is invalid:
Data does not have an even number of hex digits.""""""
        )
    # Check the character set - the standard base16 alphabet
    # is uppercase according to RFC3548 section 6
    if not set(data) <= set(""0123456789ABCDEF""):
        raise ValueError(
            """"""Base16 encoded data is invalid:
Data is not uppercase hex or it contains invalid characters.""""""
        )
    # For every two hexadecimal digits (= a byte), turn it into an integer.
    # Then, string the result together into bytes, and return it.
    return bytes(int(data[i] + data[i + 1], 16) for i in range(0, len(data), 2))",data\repos\Python\ciphers\base16.py,base16_decode,428
360,base32.py::base32_encode::10,"def base32_encode(data: bytes) -> bytes:
    """"""
    >>> base32_encode(b""Hello World!"")
    b'JBSWY3DPEBLW64TMMQQQ===='
    >>> base32_encode(b""123456"")
    b'GEZDGNBVGY======'
    >>> base32_encode(b""some long complex string"")
    b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY='
    """"""
    binary_data = """".join(bin(ord(d))[2:].zfill(8) for d in data.decode(""utf-8""))
    binary_data = binary_data.ljust(5 * ((len(binary_data) // 5) + 1), ""0"")
    b32_chunks = map("""".join, zip(*[iter(binary_data)] * 5))
    b32_result = """".join(B32_CHARSET[int(chunk, 2)] for chunk in b32_chunks)
    return bytes(b32_result.ljust(8 * ((len(b32_result) // 8) + 1), ""=""), ""utf-8"")",data\repos\Python\ciphers\base32.py,base32_encode,240
361,base32.py::base32_decode::26,"def base32_decode(data: bytes) -> bytes:
    """"""
    >>> base32_decode(b'JBSWY3DPEBLW64TMMQQQ====')
    b'Hello World!'
    >>> base32_decode(b'GEZDGNBVGY======')
    b'123456'
    >>> base32_decode(b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY=')
    b'some long complex string'
    """"""
    binary_chunks = """".join(
        bin(B32_CHARSET.index(_d))[2:].zfill(5)
        for _d in data.decode(""utf-8"").strip(""="")
    )
    binary_data = list(map("""".join, zip(*[iter(binary_chunks)] * 8)))
    return bytes("""".join([chr(int(_d, 2)) for _d in binary_data]), ""utf-8"")",data\repos\Python\ciphers\base32.py,base32_decode,198
362,base64_cipher.py::base64_encode::4,"def base64_encode(data: bytes) -> bytes:
    """"""Encodes data according to RFC4648.

    The data is first transformed to binary and appended with binary digits so that its
    length becomes a multiple of 6, then each 6 binary digits will match a character in
    the B64_CHARSET string. The number of appended binary digits would later determine
    how many ""="" signs should be added, the padding.
    For every 2 binary digits added, a ""="" sign is added in the output.
    We can add any binary digits to make it a multiple of 6, for instance, consider the
    following example:
    ""AA"" -> 0010100100101001 -> 001010 010010 1001
    As can be seen above, 2 more binary digits should be added, so there's 4
    possibilities here: 00, 01, 10 or 11.
    That being said, Base64 encoding can be used in Steganography to hide data in these
    appended digits.

    >>> from base64 import b64encode
    >>> a = b""This pull request is part of Hacktoberfest20!""
    >>> b = b""https://tools.ietf.org/html/rfc4648""
    >>> c = b""A""
    >>> base64_encode(a) == b64encode(a)
    True
    >>> base64_encode(b) == b64encode(b)
    True
    >>> base64_encode(c) == b64encode(c)
    True
    >>> base64_encode(""abc"")
    Traceback (most recent call last):
      ...
    TypeError: a bytes-like object is required, not 'str'
    """"""
    # Make sure the supplied data is a bytes-like object
    if not isinstance(data, bytes):
        msg = f""a bytes-like object is required, not '{data.__class__.__name__}'""
        raise TypeError(msg)

    binary_stream = """".join(bin(byte)[2:].zfill(8) for byte in data)

    padding_needed = len(binary_stream) % 6 != 0

    if padding_needed:
        # The padding that will be added later
        padding = b""="" * ((6 - len(binary_stream) % 6) // 2)

        # Append binary_stream with arbitrary binary digits (0's by default) to make its
        # length a multiple of 6.
        binary_stream += ""0"" * (6 - len(binary_stream) % 6)
    else:
        padding = b""""

    # Encode every 6 binary digits to their corresponding Base64 character
    return (
        """".join(
            B64_CHARSET[int(binary_stream[index : index + 6], 2)]
            for index in range(0, len(binary_stream), 6)
        ).encode()
        + padding
    )",data\repos\Python\ciphers\base64_cipher.py,base64_encode,591
363,base64_cipher.py::base64_decode::64,"def base64_decode(encoded_data: str) -> bytes:
    """"""Decodes data according to RFC4648.

    This does the reverse operation of base64_encode.
    We first transform the encoded data back to a binary stream, take off the
    previously appended binary digits according to the padding, at this point we
    would have a binary stream whose length is multiple of 8, the last step is
    to convert every 8 bits to a byte.

    >>> from base64 import b64decode
    >>> a = ""VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh""
    >>> b = ""aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=""
    >>> c = ""QQ==""
    >>> base64_decode(a) == b64decode(a)
    True
    >>> base64_decode(b) == b64decode(b)
    True
    >>> base64_decode(c) == b64decode(c)
    True
    >>> base64_decode(""abc"")
    Traceback (most recent call last):
      ...
    AssertionError: Incorrect padding
    """"""
    # Make sure encoded_data is either a string or a bytes-like object
    if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):
        msg = (
            ""argument should be a bytes-like object or ASCII string, ""
            f""not '{encoded_data.__class__.__name__}'""
        )
        raise TypeError(msg)

    # In case encoded_data is a bytes-like object, make sure it contains only
    # ASCII characters so we convert it to a string object
    if isinstance(encoded_data, bytes):
        try:
            encoded_data = encoded_data.decode(""utf-8"")
        except UnicodeDecodeError:
            raise ValueError(""base64 encoded data should only contain ASCII characters"")

    padding = encoded_data.count(""="")

    # Check if the encoded string contains non base64 characters
    if padding:
        assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (
            ""Invalid base64 character(s) found.""
        )
    else:
        assert all(char in B64_CHARSET for char in encoded_data), (
            ""Invalid base64 character(s) found.""
        )

    # Check the padding
    assert len(encoded_data) % 4 == 0 and padding < 3, ""Incorrect padding""

    if padding:
        # Remove padding if there is one
        encoded_data = encoded_data[:-padding]

        binary_stream = """".join(
            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data
        )[: -padding * 2]
    else:
        binary_stream = """".join(
            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data
        )

    data = [
        int(binary_stream[index : index + 8], 2)
        for index in range(0, len(binary_stream), 8)
    ]

    return bytes(data)",data\repos\Python\ciphers\base64_cipher.py,base64_decode,670
364,base85.py::ascii85_encode::16,"def ascii85_encode(data: bytes) -> bytes:
    """"""
    >>> ascii85_encode(b"""")
    b''
    >>> ascii85_encode(b""12345"")
    b'0etOA2#'
    >>> ascii85_encode(b""base 85"")
    b'@UX=h+?24'
    """"""
    binary_data = """".join(bin(ord(d))[2:].zfill(8) for d in data.decode(""utf-8""))
    null_values = (32 * ((len(binary_data) // 32) + 1) - len(binary_data)) // 8
    binary_data = binary_data.ljust(32 * ((len(binary_data) // 32) + 1), ""0"")
    b85_chunks = [int(_s, 2) for _s in map("""".join, zip(*[iter(binary_data)] * 32))]
    result = """".join(_base10_to_85(chunk)[::-1] for chunk in b85_chunks)
    return bytes(result[:-null_values] if null_values % 4 != 0 else result, ""utf-8"")",data\repos\Python\ciphers\base85.py,ascii85_encode,230
365,base85.py::ascii85_decode::33,"def ascii85_decode(data: bytes) -> bytes:
    """"""
    >>> ascii85_decode(b"""")
    b''
    >>> ascii85_decode(b""0etOA2#"")
    b'12345'
    >>> ascii85_decode(b""@UX=h+?24"")
    b'base 85'
    """"""
    null_values = 5 * ((len(data) // 5) + 1) - len(data)
    binary_data = data.decode(""utf-8"") + ""u"" * null_values
    b85_chunks = map("""".join, zip(*[iter(binary_data)] * 5))
    b85_segments = [[ord(_s) - 33 for _s in chunk] for chunk in b85_chunks]
    results = [bin(_base85_to_10(chunk))[2::].zfill(32) for chunk in b85_segments]
    char_chunks = [
        [chr(int(_s, 2)) for _s in map("""".join, zip(*[iter(r)] * 8))] for r in results
    ]
    result = """".join("""".join(char) for char in char_chunks)
    offset = int(null_values % 5 == 0)
    return bytes(result[: offset - null_values], ""utf-8"")",data\repos\Python\ciphers\base85.py,ascii85_decode,267
366,beaufort_cipher.py::generate_key::14,"def generate_key(message: str, key: str) -> str:
    """"""
    >>> generate_key(""THE GERMAN ATTACK"",""SECRET"")
    'SECRETSECRETSECRE'
    """"""
    x = len(message)
    i = 0
    while True:
        if x == i:
            i = 0
        if len(key) == len(message):
            break
        key += key[i]
        i += 1
    return key",data\repos\Python\ciphers\beaufort_cipher.py,generate_key,92
367,beaufort_cipher.py::cipher_text::33,"def cipher_text(message: str, key_new: str) -> str:
    """"""
    >>> cipher_text(""THE GERMAN ATTACK"",""SECRETSECRETSECRE"")
    'BDC PAYUWL JPAIYI'
    """"""
    cipher_text = """"
    i = 0
    for letter in message:
        if letter == "" "":
            cipher_text += "" ""
        else:
            x = (dict1[letter] - dict1[key_new[i]]) % 26
            i += 1
            cipher_text += dict2[x]
    return cipher_text",data\repos\Python\ciphers\beaufort_cipher.py,cipher_text,118
368,beaufort_cipher.py::original_text::52,"def original_text(cipher_text: str, key_new: str) -> str:
    """"""
    >>> original_text(""BDC PAYUWL JPAIYI"",""SECRETSECRETSECRE"")
    'THE GERMAN ATTACK'
    """"""
    or_txt = """"
    i = 0
    for letter in cipher_text:
        if letter == "" "":
            or_txt += "" ""
        else:
            x = (dict1[letter] + dict1[key_new[i]] + 26) % 26
            i += 1
            or_txt += dict2[x]
    return or_txt",data\repos\Python\ciphers\beaufort_cipher.py,original_text,125
369,beaufort_cipher.py::main::69,"def main() -> None:
    message = ""THE GERMAN ATTACK""
    key = ""SECRET""
    key_new = generate_key(message, key)
    s = cipher_text(message, key_new)
    print(f""Encrypted Text = {s}"")
    print(f""Original Text = {original_text(s, key_new)}"")",data\repos\Python\ciphers\beaufort_cipher.py,main,68
370,bifid.py::letter_to_numbers::25,"    def letter_to_numbers(self, letter: str) -> np.ndarray:
        """"""
        Return the pair of numbers that represents the given letter in the
        polybius square

        >>> np.array_equal(BifidCipher().letter_to_numbers('a'), [1,1])
        True

        >>> np.array_equal(BifidCipher().letter_to_numbers('u'), [4,5])
        True
        """"""
        index1, index2 = np.where(letter == self.SQUARE)
        indexes = np.concatenate([index1 + 1, index2 + 1])
        return indexes",data\repos\Python\ciphers\bifid.py,letter_to_numbers,123
371,bifid.py::numbers_to_letter::40,"    def numbers_to_letter(self, index1: int, index2: int) -> str:
        """"""
        Return the letter corresponding to the position [index1, index2] in
        the polybius square

        >>> BifidCipher().numbers_to_letter(4, 5) == ""u""
        True

        >>> BifidCipher().numbers_to_letter(1, 1) == ""a""
        True
        """"""
        letter = self.SQUARE[index1 - 1, index2 - 1]
        return letter",data\repos\Python\ciphers\bifid.py,numbers_to_letter,115
372,bifid.py::encode::54,"    def encode(self, message: str) -> str:
        """"""
        Return the encoded version of message according to the polybius cipher

        >>> BifidCipher().encode('testmessage') == 'qtltbdxrxlk'
        True

        >>> BifidCipher().encode('Test Message') == 'qtltbdxrxlk'
        True

        >>> BifidCipher().encode('test j') == BifidCipher().encode('test i')
        True
        """"""
        message = message.lower()
        message = message.replace("" "", """")
        message = message.replace(""j"", ""i"")

        first_step = np.empty((2, len(message)))
        for letter_index in range(len(message)):
            numbers = self.letter_to_numbers(message[letter_index])

            first_step[0, letter_index] = numbers[0]
            first_step[1, letter_index] = numbers[1]

        second_step = first_step.reshape(2 * len(message))
        encoded_message = """"
        for numbers_index in range(len(message)):
            index1 = int(second_step[numbers_index * 2])
            index2 = int(second_step[(numbers_index * 2) + 1])
            letter = self.numbers_to_letter(index1, index2)
            encoded_message = encoded_message + letter

        return encoded_message",data\repos\Python\ciphers\bifid.py,encode,278
373,bifid.py::decode::88,"    def decode(self, message: str) -> str:
        """"""
        Return the decoded version of message according to the polybius cipher

        >>> BifidCipher().decode('qtltbdxrxlk') == 'testmessage'
        True
        """"""
        message = message.lower()
        message.replace("" "", """")
        first_step = np.empty(2 * len(message))
        for letter_index in range(len(message)):
            numbers = self.letter_to_numbers(message[letter_index])
            first_step[letter_index * 2] = numbers[0]
            first_step[letter_index * 2 + 1] = numbers[1]

        second_step = first_step.reshape((2, len(message)))
        decoded_message = """"
        for numbers_index in range(len(message)):
            index1 = int(second_step[0, numbers_index])
            index2 = int(second_step[1, numbers_index])
            letter = self.numbers_to_letter(index1, index2)
            decoded_message = decoded_message + letter

        return decoded_message",data\repos\Python\ciphers\bifid.py,decode,214
374,brute_force_caesar_cipher.py::decrypt::4,"def decrypt(message: str) -> None:
    """"""
    >>> decrypt('TMDETUX PMDVU')
    Decryption using Key #0: TMDETUX PMDVU
    Decryption using Key #1: SLCDSTW OLCUT
    Decryption using Key #2: RKBCRSV NKBTS
    Decryption using Key #3: QJABQRU MJASR
    Decryption using Key #4: PIZAPQT LIZRQ
    Decryption using Key #5: OHYZOPS KHYQP
    Decryption using Key #6: NGXYNOR JGXPO
    Decryption using Key #7: MFWXMNQ IFWON
    Decryption using Key #8: LEVWLMP HEVNM
    Decryption using Key #9: KDUVKLO GDUML
    Decryption using Key #10: JCTUJKN FCTLK
    Decryption using Key #11: IBSTIJM EBSKJ
    Decryption using Key #12: HARSHIL DARJI
    Decryption using Key #13: GZQRGHK CZQIH
    Decryption using Key #14: FYPQFGJ BYPHG
    Decryption using Key #15: EXOPEFI AXOGF
    Decryption using Key #16: DWNODEH ZWNFE
    Decryption using Key #17: CVMNCDG YVMED
    Decryption using Key #18: BULMBCF XULDC
    Decryption using Key #19: ATKLABE WTKCB
    Decryption using Key #20: ZSJKZAD VSJBA
    Decryption using Key #21: YRIJYZC URIAZ
    Decryption using Key #22: XQHIXYB TQHZY
    Decryption using Key #23: WPGHWXA SPGYX
    Decryption using Key #24: VOFGVWZ ROFXW
    Decryption using Key #25: UNEFUVY QNEWV
    """"""
    for key in range(len(string.ascii_uppercase)):
        translated = """"
        for symbol in message:
            if symbol in string.ascii_uppercase:
                num = string.ascii_uppercase.find(symbol)
                num = num - key
                if num < 0:
                    num = num + len(string.ascii_uppercase)
                translated = translated + string.ascii_uppercase[num]
            else:
                translated = translated + symbol
        print(f""Decryption using Key #{key}: {translated}"")",data\repos\Python\ciphers\brute_force_caesar_cipher.py,decrypt,550
375,caesar_cipher.py::encrypt::6,"def encrypt(input_string: str, key: int, alphabet: str | None = None) -> str:
    """"""
    encrypt
    =======

    Encodes a given string with the caesar cipher and returns the encoded
    message

    Parameters:
    -----------

    *   `input_string`: the plain-text that needs to be encoded
    *   `key`: the number of letters to shift the message by

    Optional:

    *   `alphabet` (``None``): the alphabet used to encode the cipher, if not
        specified, the standard english alphabet with upper and lowercase
        letters is used

    Returns:

    *   A string containing the encoded cipher-text

    More on the caesar cipher
    =========================

    The caesar cipher is named after Julius Caesar who used it when sending
    secret military messages to his troops. This is a simple substitution cipher
    where every character in the plain-text is shifted by a certain number known
    as the ""key"" or ""shift"".

    Example:
    Say we have the following message:
    ``Hello, captain``

    And our alphabet is made up of lower and uppercase letters:
    ``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``

    And our shift is ``2``

    We can then encode the message, one letter at a time. ``H`` would become ``J``,
    since ``J`` is two letters away, and so on. If the shift is ever two large, or
    our letter is at the end of the alphabet, we just start at the beginning
    (``Z`` would shift to ``a`` then ``b`` and so on).

    Our final message would be ``Jgnnq, ecrvckp``

    Further reading
    ===============

    *   https://en.m.wikipedia.org/wiki/Caesar_cipher

    Doctests
    ========

    >>> encrypt('The quick brown fox jumps over the lazy dog', 8)
    'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'

    >>> encrypt('A very large key', 8000)
    's nWjq dSjYW cWq'

    >>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz')
    'f qtbjwhfxj fqumfgjy'
    """"""
    # Set default alphabet to lower and upper case english chars
    alpha = alphabet or ascii_letters

    # The final result string
    result = """"

    for character in input_string:
        if character not in alpha:
            # Append without encryption if character is not in the alphabet
            result += character
        else:
            # Get the index of the new key and make sure it isn't too large
            new_key = (alpha.index(character) + key) % len(alpha)

            # Append the encoded character to the alphabet
            result += alpha[new_key]

    return result",data\repos\Python\ciphers\caesar_cipher.py,encrypt,617
376,caesar_cipher.py::decrypt::91,"def decrypt(input_string: str, key: int, alphabet: str | None = None) -> str:
    """"""
    decrypt
    =======

    Decodes a given string of cipher-text and returns the decoded plain-text

    Parameters:
    -----------

    *   `input_string`: the cipher-text that needs to be decoded
    *   `key`: the number of letters to shift the message backwards by to decode

    Optional:

    *   `alphabet` (``None``): the alphabet used to decode the cipher, if not
        specified, the standard english alphabet with upper and lowercase
        letters is used

    Returns:

    *   A string containing the decoded plain-text

    More on the caesar cipher
    =========================

    The caesar cipher is named after Julius Caesar who used it when sending
    secret military messages to his troops. This is a simple substitution cipher
    where very character in the plain-text is shifted by a certain number known
    as the ""key"" or ""shift"". Please keep in mind, here we will be focused on
    decryption.

    Example:
    Say we have the following cipher-text:
    ``Jgnnq, ecrvckp``

    And our alphabet is made up of lower and uppercase letters:
    ``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``

    And our shift is ``2``

    To decode the message, we would do the same thing as encoding, but in
    reverse. The first letter, ``J`` would become ``H`` (remember: we are decoding)
    because ``H`` is two letters in reverse (to the left) of ``J``. We would
    continue doing this. A letter like ``a`` would shift back to the end of
    the alphabet, and would become ``Z`` or ``Y`` and so on.

    Our final message would be ``Hello, captain``

    Further reading
    ===============

    *   https://en.m.wikipedia.org/wiki/Caesar_cipher

    Doctests
    ========

    >>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8)
    'The quick brown fox jumps over the lazy dog'

    >>> decrypt('s nWjq dSjYW cWq', 8000)
    'A very large key'

    >>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz')
    'a lowercase alphabet'
    """"""
    # Turn on decode mode by making the key negative
    key *= -1

    return encrypt(input_string, key, alphabet)",data\repos\Python\ciphers\caesar_cipher.py,decrypt,556
377,caesar_cipher.py::brute_force::163,"def brute_force(input_string: str, alphabet: str | None = None) -> dict[int, str]:
    """"""
    brute_force
    ===========

    Returns all the possible combinations of keys and the decoded strings in the
    form of a dictionary

    Parameters:
    -----------

    *   `input_string`: the cipher-text that needs to be used during brute-force

    Optional:

    *   `alphabet` (``None``): the alphabet used to decode the cipher, if not
        specified, the standard english alphabet with upper and lowercase
        letters is used

    More about brute force
    ======================

    Brute force is when a person intercepts a message or password, not knowing
    the key and tries every single combination. This is easy with the caesar
    cipher since there are only all the letters in the alphabet. The more
    complex the cipher, the larger amount of time it will take to do brute force

    Ex:
    Say we have a ``5`` letter alphabet (``abcde``), for simplicity and we intercepted
    the following message: ``dbc``,
    we could then just write out every combination:
    ``ecd``... and so on, until we reach a combination that makes sense:
    ``cab``

    Further reading
    ===============

    *   https://en.wikipedia.org/wiki/Brute_force

    Doctests
    ========

    >>> brute_force(""jFyuMy xIH'N vLONy zILwy Gy!"")[20]
    ""Please don't brute force me!""

    >>> brute_force(1)
    Traceback (most recent call last):
    TypeError: 'int' object is not iterable
    """"""
    # Set default alphabet to lower and upper case english chars
    alpha = alphabet or ascii_letters

    # To store data on all the combinations
    brute_force_data = {}

    # Cycle through each combination
    for key in range(1, len(alpha) + 1):
        # Decrypt the message and store the result in the data
        brute_force_data[key] = decrypt(input_string, key, alpha)

    return brute_force_data",data\repos\Python\ciphers\caesar_cipher.py,brute_force,452
378,cryptomath_module.py::find_mod_inverse::4,"def find_mod_inverse(a: int, m: int) -> int:
    if gcd_by_iterative(a, m) != 1:
        msg = f""mod inverse of {a!r} and {m!r} does not exist""
        raise ValueError(msg)
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m",data\repos\Python\ciphers\cryptomath_module.py,find_mod_inverse,171
379,decrypt_caesar_with_chi_squared.py::decrypt_caesar_with_chi_squared::5,"def decrypt_caesar_with_chi_squared(
    ciphertext: str,
    cipher_alphabet: list[str] | None = None,
    frequencies_dict: dict[str, float] | None = None,
    case_sensitive: bool = False,
) -> tuple[int, float, str]:
    """"""
    Basic Usage
    ===========

    Arguments:
      * `ciphertext` (str): the text to decode (encoded with the caesar cipher)

    Optional Arguments:
      * `cipher_alphabet` (list): the alphabet used for the cipher (each letter is
        a string separated by commas)
      * `frequencies_dict` (dict): a dictionary of word frequencies where keys are
        the letters and values are a percentage representation of the frequency as
        a decimal/float
      * `case_sensitive` (bool): a boolean value: ``True`` if the case matters during
        decryption, ``False`` if it doesn't

    Returns:
      * A tuple in the form of:
        (`most_likely_cipher`, `most_likely_cipher_chi_squared_value`,
        `decoded_most_likely_cipher`)

        where...
          - `most_likely_cipher` is an integer representing the shift of the smallest
            chi-squared statistic (most likely key)
          - `most_likely_cipher_chi_squared_value` is a float representing the
            chi-squared statistic of the most likely shift
          - `decoded_most_likely_cipher` is a string with the decoded cipher
            (decoded by the most_likely_cipher key)


    The Chi-squared test
    ====================

    The caesar cipher
    -----------------

    The caesar cipher is a very insecure encryption algorithm, however it has
    been used since Julius Caesar. The cipher is a simple substitution cipher
    where each character in the plain text is replaced by a character in the
    alphabet a certain number of characters after the original character. The
    number of characters away is called the shift or key. For example:

    | Plain text: ``hello``
    | Key: ``1``
    | Cipher text: ``ifmmp``
    | (each letter in ``hello`` has been shifted one to the right in the eng. alphabet)

    As you can imagine, this doesn't provide lots of security. In fact
    decrypting ciphertext by brute-force is extremely easy even by hand. However
    one way to do that is the chi-squared test.

    The chi-squared test
    --------------------

    Each letter in the english alphabet has a frequency, or the amount of times
    it shows up compared to other letters (usually expressed as a decimal
    representing the percentage likelihood). The most common letter in the
    english language is ``e`` with a frequency of ``0.11162`` or ``11.162%``.
    The test is completed in the following fashion.

    1. The ciphertext is decoded in a brute force way (every combination of the
       ``26`` possible combinations)
    2. For every combination, for each letter in the combination, the average
       amount of times the letter should appear the message is calculated by
       multiplying the total number of characters by the frequency of the letter.

       | For example:
       | In a message of ``100`` characters, ``e`` should appear around ``11.162``
         times.

    3. Then, to calculate the margin of error (the amount of times the letter
       SHOULD appear with the amount of times the letter DOES appear), we use
       the chi-squared test. The following formula is used:

       Let:
         - n be the number of times the letter actually appears
         - p be the predicted value of the number of times the letter should
           appear (see item ``2``)
         - let v be the chi-squared test result (referred to here as chi-squared
           value/statistic)

         ::

           (n - p)^2
           --------- = v
              p

    4. Each chi squared value for each letter is then added up to the total.
       The total is the chi-squared statistic for that encryption key.
    5. The encryption key with the lowest chi-squared value is the most likely
       to be the decoded answer.

    Further Reading
    ===============

    * http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-statistic/
    * https://en.wikipedia.org/wiki/Letter_frequency
    * https://en.wikipedia.org/wiki/Chi-squared_test
    * https://en.m.wikipedia.org/wiki/Caesar_cipher

    Doctests
    ========

    >>> decrypt_caesar_with_chi_squared(
    ...    'dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!'
    ... )  # doctest: +NORMALIZE_WHITESPACE
    (7, 3129.228005747531,
     'why is the caesar cipher so popular? it is too easy to crack!')

    >>> decrypt_caesar_with_chi_squared('crybd cdbsxq')
    (10, 233.35343938980898, 'short string')

    >>> decrypt_caesar_with_chi_squared('Crybd Cdbsxq', case_sensitive=True)
    (10, 233.35343938980898, 'Short String')

    >>> decrypt_caesar_with_chi_squared(12)
    Traceback (most recent call last):
    AttributeError: 'int' object has no attribute 'lower'
    """"""
    alphabet_letters = cipher_alphabet or [chr(i) for i in range(97, 123)]

    # If the argument is None or the user provided an empty dictionary
    if not frequencies_dict:
        # Frequencies of letters in the english language (how much they show up)
        frequencies = {
            ""a"": 0.08497,
            ""b"": 0.01492,
            ""c"": 0.02202,
            ""d"": 0.04253,
            ""e"": 0.11162,
            ""f"": 0.02228,
            ""g"": 0.02015,
            ""h"": 0.06094,
            ""i"": 0.07546,
            ""j"": 0.00153,
            ""k"": 0.01292,
            ""l"": 0.04025,
            ""m"": 0.02406,
            ""n"": 0.06749,
            ""o"": 0.07507,
            ""p"": 0.01929,
            ""q"": 0.00095,
            ""r"": 0.07587,
            ""s"": 0.06327,
            ""t"": 0.09356,
            ""u"": 0.02758,
            ""v"": 0.00978,
            ""w"": 0.02560,
            ""x"": 0.00150,
            ""y"": 0.01994,
            ""z"": 0.00077,
        }
    else:
        # Custom frequencies dictionary
        frequencies = frequencies_dict

    if not case_sensitive:
        ciphertext = ciphertext.lower()

    # Chi squared statistic values
    chi_squared_statistic_values: dict[int, tuple[float, str]] = {}

    # cycle through all of the shifts
    for shift in range(len(alphabet_letters)):
        decrypted_with_shift = """"

        # decrypt the message with the shift
        for letter in ciphertext:
            try:
                # Try to index the letter in the alphabet
                new_key = (alphabet_letters.index(letter.lower()) - shift) % len(
                    alphabet_letters
                )
                decrypted_with_shift += (
                    alphabet_letters[new_key].upper()
                    if case_sensitive and letter.isupper()
                    else alphabet_letters[new_key]
                )
            except ValueError:
                # Append the character if it isn't in the alphabet
                decrypted_with_shift += letter

        chi_squared_statistic = 0.0

        # Loop through each letter in the decoded message with the shift
        for letter in decrypted_with_shift:
            if case_sensitive:
                letter = letter.lower()
                if letter in frequencies:
                    # Get the amount of times the letter occurs in the message
                    occurrences = decrypted_with_shift.lower().count(letter)

                    # Get the excepcted amount of times the letter should appear based
                    # on letter frequencies
                    expected = frequencies[letter] * occurrences

                    # Complete the chi squared statistic formula
                    chi_letter_value = ((occurrences - expected) ** 2) / expected

                    # Add the margin of error to the total chi squared statistic
                    chi_squared_statistic += chi_letter_value
            elif letter.lower() in frequencies:
                # Get the amount of times the letter occurs in the message
                occurrences = decrypted_with_shift.count(letter)

                # Get the excepcted amount of times the letter should appear based
                # on letter frequencies
                expected = frequencies[letter] * occurrences

                # Complete the chi squared statistic formula
                chi_letter_value = ((occurrences - expected) ** 2) / expected

                # Add the margin of error to the total chi squared statistic
                chi_squared_statistic += chi_letter_value

        # Add the data to the chi_squared_statistic_values dictionary
        chi_squared_statistic_values[shift] = (
            chi_squared_statistic,
            decrypted_with_shift,
        )

    # Get the most likely cipher by finding the cipher with the smallest chi squared
    # statistic
    def chi_squared_statistic_values_sorting_key(key: int) -> tuple[float, str]:
        return chi_squared_statistic_values[key]

    most_likely_cipher: int = min(
        chi_squared_statistic_values,
        key=chi_squared_statistic_values_sorting_key,
    )

    # Get all the data from the most likely cipher (key, decoded message)
    (
        most_likely_cipher_chi_squared_value,
        decoded_most_likely_cipher,
    ) = chi_squared_statistic_values[most_likely_cipher]

    # Return the data on the most likely shift
    return (
        most_likely_cipher,
        most_likely_cipher_chi_squared_value,
        decoded_most_likely_cipher,
    )",data\repos\Python\ciphers\decrypt_caesar_with_chi_squared.py,decrypt_caesar_with_chi_squared,2160
380,deterministic_miller_rabin.py::miller_rabin::6,"def miller_rabin(n: int, allow_probable: bool = False) -> bool:
    """"""Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.

    Uses numerical analysis results to return whether or not the passed number
    is prime. If the passed number is above the upper limit, and
    allow_probable is True, then a return value of True indicates that n is
    probably prime. This test does not allow False negatives- a return value
    of False is ALWAYS composite.

    Parameters
    ----------
    n : int
        The integer to be tested. Since we usually care if a number is prime,
        n < 2 returns False instead of raising a ValueError.
    allow_probable: bool, default False
        Whether or not to test n above the upper bound of the deterministic test.

    Raises
    ------
    ValueError

    Reference
    ---------
    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test
    """"""
    if n == 2:
        return True
    if not n % 2 or n < 2:
        return False
    if n > 5 and n % 10 not in (1, 3, 7, 9):  # can quickly check last digit
        return False
    if n > 3_317_044_064_679_887_385_961_981 and not allow_probable:
        raise ValueError(
            ""Warning: upper bound of deterministic test is exceeded. ""
            ""Pass allow_probable=True to allow probabilistic test. ""
            ""A return value of True indicates a probable prime.""
        )
    # array bounds provided by analysis
    bounds = [
        2_047,
        1_373_653,
        25_326_001,
        3_215_031_751,
        2_152_302_898_747,
        3_474_749_660_383,
        341_550_071_728_321,
        1,
        3_825_123_056_546_413_051,
        1,
        1,
        318_665_857_834_031_151_167_461,
        3_317_044_064_679_887_385_961_981,
    ]

    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]
    for idx, _p in enumerate(bounds, 1):
        if n < _p:
            # then we have our last prime to check
            plist = primes[:idx]
            break
    d, s = n - 1, 0
    # break up n -1 into a power of 2 (s) and
    # remaining odd component
    # essentially, solve for d * 2 ** s == n - 1
    while d % 2 == 0:
        d //= 2
        s += 1
    for prime in plist:
        pr = False
        for r in range(s):
            m = pow(prime, d * 2**r, n)
            # see article for analysis explanation for m
            if (r == 0 and m == 1) or ((m + 1) % n == 0):
                pr = True
                # this loop will not determine compositeness
                break
        if pr:
            continue
        # if pr is False, then the above loop never evaluated to true,
        # and the n MUST be composite
        return False
    return True",data\repos\Python\ciphers\deterministic_miller_rabin.py,miller_rabin,788
381,deterministic_miller_rabin.py::test_miller_rabin::90,"def test_miller_rabin() -> None:
    """"""Testing a nontrivial (ends in 1, 3, 7, 9) composite
    and a prime in each range.
    """"""
    assert not miller_rabin(561)
    assert miller_rabin(563)
    # 2047

    assert not miller_rabin(838_201)
    assert miller_rabin(838_207)
    # 1_373_653

    assert not miller_rabin(17_316_001)
    assert miller_rabin(17_316_017)
    # 25_326_001

    assert not miller_rabin(3_078_386_641)
    assert miller_rabin(3_078_386_653)
    # 3_215_031_751

    assert not miller_rabin(1_713_045_574_801)
    assert miller_rabin(1_713_045_574_819)
    # 2_152_302_898_747

    assert not miller_rabin(2_779_799_728_307)
    assert miller_rabin(2_779_799_728_327)
    # 3_474_749_660_383

    assert not miller_rabin(113_850_023_909_441)
    assert miller_rabin(113_850_023_909_527)
    # 341_550_071_728_321

    assert not miller_rabin(1_275_041_018_848_804_351)
    assert miller_rabin(1_275_041_018_848_804_391)
    # 3_825_123_056_546_413_051

    assert not miller_rabin(79_666_464_458_507_787_791_867)
    assert miller_rabin(79_666_464_458_507_787_791_951)
    # 318_665_857_834_031_151_167_461

    assert not miller_rabin(552_840_677_446_647_897_660_333)
    assert miller_rabin(552_840_677_446_647_897_660_359)",data\repos\Python\ciphers\deterministic_miller_rabin.py,test_miller_rabin,496
382,diffie.py::find_primitive::4,"def find_primitive(modulus: int) -> int | None:
    """"""
    Find a primitive root modulo modulus, if one exists.

    Args:
        modulus : The modulus for which to find a primitive root.

    Returns:
        The primitive root if one exists, or None if there is none.

    Examples:
    >>> find_primitive(7)  # Modulo 7 has primitive root 3
    3
    >>> find_primitive(11)  # Modulo 11 has primitive root 2
    2
    >>> find_primitive(8) == None # Modulo 8 has no primitive root
    True
    """"""
    for r in range(1, modulus):
        li = []
        for x in range(modulus - 1):
            val = pow(r, x, modulus)
            if val in li:
                break
            li.append(val)
        else:
            return r
    return None",data\repos\Python\ciphers\diffie.py,find_primitive,193
383,diffie_hellman.py::generate_public_key::225,"    def generate_public_key(self) -> str:
        public_key = pow(self.generator, self.__private_key, self.prime)
        return hex(public_key)[2:]",data\repos\Python\ciphers\diffie_hellman.py,generate_public_key,35
384,diffie_hellman.py::is_valid_public_key::229,"    def is_valid_public_key(self, key: int) -> bool:
        # check if the other public key is valid based on NIST SP800-56
        return (
            2 <= key <= self.prime - 2
            and pow(key, (self.prime - 1) // 2, self.prime) == 1
        )",data\repos\Python\ciphers\diffie_hellman.py,is_valid_public_key,77
385,diffie_hellman.py::generate_shared_key::236,"    def generate_shared_key(self, other_key_str: str) -> str:
        other_key = int(other_key_str, base=16)
        if not self.is_valid_public_key(other_key):
            raise ValueError(""Invalid public key"")
        shared_key = pow(other_key, self.__private_key, self.prime)
        return sha256(str(shared_key).encode()).hexdigest()",data\repos\Python\ciphers\diffie_hellman.py,generate_shared_key,77
386,diffie_hellman.py::is_valid_public_key_static::244,"    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:
        # check if the other public key is valid based on NIST SP800-56
        return (
            2 <= remote_public_key_str <= prime - 2
            and pow(remote_public_key_str, (prime - 1) // 2, prime) == 1
        )",data\repos\Python\ciphers\diffie_hellman.py,is_valid_public_key_static,83
387,diffie_hellman.py::generate_shared_key_static::252,"    def generate_shared_key_static(
        local_private_key_str: str, remote_public_key_str: str, group: int = 14
    ) -> str:
        local_private_key = int(local_private_key_str, base=16)
        remote_public_key = int(remote_public_key_str, base=16)
        prime = primes[group][""prime""]
        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):
            raise ValueError(""Invalid public key"")
        shared_key = pow(remote_public_key, local_private_key, prime)
        return sha256(str(shared_key).encode()).hexdigest()",data\repos\Python\ciphers\diffie_hellman.py,generate_shared_key_static,125
388,elgamal_key_generator.py::primitive_root::16,"def primitive_root(p_val: int) -> int:
    print(""Generating primitive root of p"")
    while True:
        g = random.randrange(3, p_val)
        if pow(g, 2, p_val) == 1:
            continue
        if pow(g, p_val, p_val) == 1:
            continue
        return g",data\repos\Python\ciphers\elgamal_key_generator.py,primitive_root,74
389,elgamal_key_generator.py::generate_key::27,"def generate_key(key_size: int) -> tuple[tuple[int, int, int, int], tuple[int, int]]:
    print(""Generating prime p..."")
    p = rabin_miller.generate_large_prime(key_size)  # select large prime number.
    e_1 = primitive_root(p)  # one primitive root on modulo p.
    d = random.randrange(3, p)  # private_key -> have to be greater than 2 for safety.
    e_2 = cryptomath.find_mod_inverse(pow(e_1, d, p), p)

    public_key = (key_size, e_1, e_2, p)
    private_key = (key_size, d)

    return public_key, private_key",data\repos\Python\ciphers\elgamal_key_generator.py,generate_key,152
390,elgamal_key_generator.py::make_key_files::40,"def make_key_files(name: str, key_size: int) -> None:
    if os.path.exists(f""{name}_pubkey.txt"") or os.path.exists(f""{name}_privkey.txt""):
        print(""\nWARNING:"")
        print(
            f'""{name}_pubkey.txt"" or ""{name}_privkey.txt"" already exists. \n'
            ""Use a different name or delete these files and re-run this program.""
        )
        sys.exit()

    public_key, private_key = generate_key(key_size)
    print(f""\nWriting public key to file {name}_pubkey.txt..."")
    with open(f""{name}_pubkey.txt"", ""w"") as fo:
        fo.write(f""{public_key[0]},{public_key[1]},{public_key[2]},{public_key[3]}"")

    print(f""Writing private key to file {name}_privkey.txt..."")
    with open(f""{name}_privkey.txt"", ""w"") as fo:
        fo.write(f""{private_key[0]},{private_key[1]}"")",data\repos\Python\ciphers\elgamal_key_generator.py,make_key_files,221
391,elgamal_key_generator.py::main::59,"def main() -> None:
    print(""Making key files..."")
    make_key_files(""elgamal"", 2048)
    print(""Key files generation successful"")",data\repos\Python\ciphers\elgamal_key_generator.py,main,34
392,enigma_machine2.py::enigma::167,"def enigma(
    text: str,
    rotor_position: RotorPositionT,
    rotor_selection: RotorSelectionT = (rotor1, rotor2, rotor3),
    plugb: str = """",
) -> str:
    """"""
    The only difference with real-world enigma is that ``I`` allowed string input.
    All characters are converted to uppercase. (non-letter symbol are ignored)

    | How it works:
    | (for every letter in the message)

    - Input letter goes into the plugboard.
      If it is connected to another one, switch it.

    - Letter goes through ``3`` rotors.
      Each rotor can be represented as ``2`` sets of symbol, where one is shuffled.
      Each symbol from the first set has corresponding symbol in
      the second set and vice versa.

      example::

      | ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F
      | VKLEPDBGRNWTFCJOHQAMUZYIXS |

    - Symbol then goes through reflector (static rotor).
      There it is switched with paired symbol.
      The reflector can be represented as ``2`` sets, each with half of the alphanet.
      There are usually ``10`` pairs of letters.

      Example::

      | ABCDEFGHIJKLM | e.g. E is paired to X
      | ZYXWVUTSRQPON | so when E goes in X goes out and vice versa

    - Letter then goes through the rotors again

    - If the letter is connected to plugboard, it is switched.

    - Return the letter

    >>> enigma('Hello World!', (1, 2, 1), plugb='pictures')
    'KORYH JUHHI!'
    >>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')
    'HELLO, WORLD!'
    >>> enigma('hello world!', (1, 1, 1), plugb='pictures')
    'FPNCZ QWOBU!'
    >>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')
    'HELLO WORLD'


    :param text: input message
    :param rotor_position: tuple with ``3`` values in range ``1``.. ``26``
    :param rotor_selection: tuple with ``3`` rotors
    :param plugb: string containing plugboard configuration (default ``''``)
    :return: en/decrypted string
    """"""

    text = text.upper()
    rotor_position, rotor_selection, plugboard = _validator(
        rotor_position, rotor_selection, plugb.upper()
    )

    rotorpos1, rotorpos2, rotorpos3 = rotor_position
    rotor1, rotor2, rotor3 = rotor_selection
    rotorpos1 -= 1
    rotorpos2 -= 1
    rotorpos3 -= 1

    result = []

    # encryption/decryption process --------------------------
    for symbol in text:
        if symbol in abc:
            # 1st plugboard --------------------------
            if symbol in plugboard:
                symbol = plugboard[symbol]

            # rotor ra --------------------------
            index = abc.index(symbol) + rotorpos1
            symbol = rotor1[index % len(abc)]

            # rotor rb --------------------------
            index = abc.index(symbol) + rotorpos2
            symbol = rotor2[index % len(abc)]

            # rotor rc --------------------------
            index = abc.index(symbol) + rotorpos3
            symbol = rotor3[index % len(abc)]

            # reflector --------------------------
            # this is the reason you don't need another machine to decipher

            symbol = reflector[symbol]

            # 2nd rotors
            symbol = abc[rotor3.index(symbol) - rotorpos3]
            symbol = abc[rotor2.index(symbol) - rotorpos2]
            symbol = abc[rotor1.index(symbol) - rotorpos1]

            # 2nd plugboard
            if symbol in plugboard:
                symbol = plugboard[symbol]

            # moves/resets rotor positions
            rotorpos1 += 1
            if rotorpos1 >= len(abc):
                rotorpos1 = 0
                rotorpos2 += 1
            if rotorpos2 >= len(abc):
                rotorpos2 = 0
                rotorpos3 += 1
            if rotorpos3 >= len(abc):
                rotorpos3 = 0

        # else:
        #    pass
        #    Error could be also raised
        #    raise ValueError(
        #       'Invalid symbol('+repr(symbol)+')')
        result.append(symbol)

    return """".join(result)",data\repos\Python\ciphers\enigma_machine2.py,enigma,1004
393,fractionated_morse_cipher.py::encode_to_morse::79,"def encode_to_morse(plaintext: str) -> str:
    """"""Encode a plaintext message into Morse code.

    Args:
        plaintext: The plaintext message to encode.

    Returns:
        The Morse code representation of the plaintext message.

    Example:
        >>> encode_to_morse(""defend the east"")
        '-..x.x..-.x.x-.x-..xx-x....x.xx.x.-x...x-'
    """"""
    return ""x"".join([MORSE_CODE_DICT.get(letter.upper(), """") for letter in plaintext])",data\repos\Python\ciphers\fractionated_morse_cipher.py,encode_to_morse,112
394,fractionated_morse_cipher.py::encrypt_fractionated_morse::95,"def encrypt_fractionated_morse(plaintext: str, key: str) -> str:
    """"""Encrypt a plaintext message using Fractionated Morse Cipher.

    Args:
        plaintext: The plaintext message to encrypt.
        key: The encryption key.

    Returns:
        The encrypted ciphertext.

    Example:
        >>> encrypt_fractionated_morse(""defend the east"",""Roundtable"")
        'ESOAVVLJRSSTRX'

    """"""
    morse_code = encode_to_morse(plaintext)
    key = key.upper() + string.ascii_uppercase
    key = """".join(sorted(set(key), key=key.find))

    # Ensure morse_code length is a multiple of 3
    padding_length = 3 - (len(morse_code) % 3)
    morse_code += ""x"" * padding_length

    fractionated_morse_dict = {v: k for k, v in zip(key, MORSE_COMBINATIONS)}
    fractionated_morse_dict[""xxx""] = """"
    encrypted_text = """".join(
        [
            fractionated_morse_dict[morse_code[i : i + 3]]
            for i in range(0, len(morse_code), 3)
        ]
    )
    return encrypted_text",data\repos\Python\ciphers\fractionated_morse_cipher.py,encrypt_fractionated_morse,254
395,fractionated_morse_cipher.py::decrypt_fractionated_morse::129,"def decrypt_fractionated_morse(ciphertext: str, key: str) -> str:
    """"""Decrypt a ciphertext message encrypted with Fractionated Morse Cipher.

    Args:
        ciphertext: The ciphertext message to decrypt.
        key: The decryption key.

    Returns:
        The decrypted plaintext message.

    Example:
        >>> decrypt_fractionated_morse(""ESOAVVLJRSSTRX"",""Roundtable"")
        'DEFEND THE EAST'
    """"""
    key = key.upper() + string.ascii_uppercase
    key = """".join(sorted(set(key), key=key.find))

    inverse_fractionated_morse_dict = dict(zip(key, MORSE_COMBINATIONS))
    morse_code = """".join(
        [inverse_fractionated_morse_dict.get(letter, """") for letter in ciphertext]
    )
    decrypted_text = """".join(
        [REVERSE_DICT[code] for code in morse_code.split(""x"")]
    ).strip()
    return decrypted_text",data\repos\Python\ciphers\fractionated_morse_cipher.py,decrypt_fractionated_morse,193
396,gronsfeld_cipher.py::gronsfeld::4,"def gronsfeld(text: str, key: str) -> str:
    """"""
    Encrypt plaintext with the Gronsfeld cipher

    >>> gronsfeld('hello', '412')
    'LFNPP'
    >>> gronsfeld('hello', '123')
    'IGOMQ'
    >>> gronsfeld('', '123')
    ''
    >>> gronsfeld('yes, $ - _!@#%?', '0')
    'YES, $ - _!@#%?'
    >>> gronsfeld('yes, $ - _!@#%?', '01')
    'YFS, $ - _!@#%?'
    >>> gronsfeld('yes, $ - _!@#%?', '012')
    'YFU, $ - _!@#%?'
    >>> gronsfeld('yes, $ - _!@#%?', '')
    Traceback (most recent call last):
      ...
    ZeroDivisionError: division by zero
    """"""
    ascii_len = len(ascii_uppercase)
    key_len = len(key)
    encrypted_text = """"
    keys = [int(char) for char in key]
    upper_case_text = text.upper()

    for i, char in enumerate(upper_case_text):
        if char in ascii_uppercase:
            new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len
            shifted_letter = ascii_uppercase[new_position]
            encrypted_text += shifted_letter
        else:
            encrypted_text += char

    return encrypted_text",data\repos\Python\ciphers\gronsfeld_cipher.py,gronsfeld,337
397,hill_cipher.py::main::193,"def main() -> None:
    n = int(input(""Enter the order of the encryption key: ""))
    hill_matrix = []

    print(""Enter each row of the encryption key with space separated integers"")
    for _ in range(n):
        row = [int(x) for x in input().split()]
        hill_matrix.append(row)

    hc = HillCipher(np.array(hill_matrix))

    print(""Would you like to encrypt or decrypt some text? (1 or 2)"")
    option = input(""\n1. Encrypt\n2. Decrypt\n"")
    if option == ""1"":
        text_e = input(""What text would you like to encrypt?: "")
        print(""Your encrypted text is:"")
        print(hc.encrypt(text_e))
    elif option == ""2"":
        text_d = input(""What text would you like to decrypt?: "")
        print(""Your decrypted text is:"")
        print(hc.decrypt(text_d))",data\repos\Python\ciphers\hill_cipher.py,main,189
398,hill_cipher.py::replace_letters::64,"    def replace_letters(self, letter: str) -> int:
        """"""
        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
        >>> hill_cipher.replace_letters('T')
        19
        >>> hill_cipher.replace_letters('0')
        26
        """"""
        return self.key_string.index(letter)",data\repos\Python\ciphers\hill_cipher.py,replace_letters,73
399,hill_cipher.py::replace_digits::74,"    def replace_digits(self, num: int) -> str:
        """"""
        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
        >>> hill_cipher.replace_digits(19)
        'T'
        >>> hill_cipher.replace_digits(26)
        '0'
        >>> hill_cipher.replace_digits(26.1)
        '0'
        """"""
        return self.key_string[int(num)]",data\repos\Python\ciphers\hill_cipher.py,replace_digits,88
400,hill_cipher.py::check_determinant::86,"    def check_determinant(self) -> None:
        """"""
        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
        >>> hill_cipher.check_determinant()
        """"""
        det = round(np.linalg.det(self.encrypt_key))

        if det < 0:
            det = det % len(self.key_string)

        req_l = len(self.key_string)
        if greatest_common_divisor(det, len(self.key_string)) != 1:
            msg = (
                f""determinant modular {req_l} of encryption key({det}) ""
                f""is not co prime w.r.t {req_l}.\nTry another key.""
            )
            raise ValueError(msg)",data\repos\Python\ciphers\hill_cipher.py,check_determinant,147
401,hill_cipher.py::process_text::104,"    def process_text(self, text: str) -> str:
        """"""
        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
        >>> hill_cipher.process_text('Testing Hill Cipher')
        'TESTINGHILLCIPHERR'
        >>> hill_cipher.process_text('hello')
        'HELLOO'
        """"""
        chars = [char for char in text.upper() if char in self.key_string]

        last = chars[-1]
        while len(chars) % self.break_key != 0:
            chars.append(last)

        return """".join(chars)",data\repos\Python\ciphers\hill_cipher.py,process_text,124
402,hill_cipher.py::encrypt::120,"    def encrypt(self, text: str) -> str:
        """"""
        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
        >>> hill_cipher.encrypt('testing hill cipher')
        'WHXYJOLM9C6XT085LL'
        >>> hill_cipher.encrypt('hello')
        '85FF00'
        """"""
        text = self.process_text(text.upper())
        encrypted = """"

        for i in range(0, len(text) - self.break_key + 1, self.break_key):
            batch = text[i : i + self.break_key]
            vec = [self.replace_letters(char) for char in batch]
            batch_vec = np.array([vec]).T
            batch_encrypted = self.modulus(self.encrypt_key.dot(batch_vec)).T.tolist()[
                0
            ]
            encrypted_batch = """".join(
                self.replace_digits(num) for num in batch_encrypted
            )
            encrypted += encrypted_batch

        return encrypted",data\repos\Python\ciphers\hill_cipher.py,encrypt,205
403,hill_cipher.py::make_decrypt_key::145,"    def make_decrypt_key(self) -> np.ndarray:
        """"""
        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
        >>> hill_cipher.make_decrypt_key()
        array([[ 6, 25],
               [ 5, 26]])
        """"""
        det = round(np.linalg.det(self.encrypt_key))

        if det < 0:
            det = det % len(self.key_string)
        det_inv = None
        for i in range(len(self.key_string)):
            if (det * i) % len(self.key_string) == 1:
                det_inv = i
                break

        inv_key = (
            det_inv * np.linalg.det(self.encrypt_key) * np.linalg.inv(self.encrypt_key)
        )

        return self.to_int(self.modulus(inv_key))",data\repos\Python\ciphers\hill_cipher.py,make_decrypt_key,169
404,hill_cipher.py::decrypt::168,"    def decrypt(self, text: str) -> str:
        """"""
        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
        >>> hill_cipher.decrypt('WHXYJOLM9C6XT085LL')
        'TESTINGHILLCIPHERR'
        >>> hill_cipher.decrypt('85FF00')
        'HELLOO'
        """"""
        decrypt_key = self.make_decrypt_key()
        text = self.process_text(text.upper())
        decrypted = """"

        for i in range(0, len(text) - self.break_key + 1, self.break_key):
            batch = text[i : i + self.break_key]
            vec = [self.replace_letters(char) for char in batch]
            batch_vec = np.array([vec]).T
            batch_decrypted = self.modulus(decrypt_key.dot(batch_vec)).T.tolist()[0]
            decrypted_batch = """".join(
                self.replace_digits(num) for num in batch_decrypted
            )
            decrypted += decrypted_batch

        return decrypted",data\repos\Python\ciphers\hill_cipher.py,decrypt,215
405,mixed_keyword_cypher.py::mixed_keyword::4,"def mixed_keyword(
    keyword: str, plaintext: str, verbose: bool = False, alphabet: str = ascii_uppercase
) -> str:
    """"""
    For keyword: hello

    H E L O
    A B C D
    F G I J
    K M N P
    Q R S T
    U V W X
    Y Z
    and map vertically

    >>> mixed_keyword(""college"", ""UNIVERSITY"", True)  # doctest: +NORMALIZE_WHITESPACE
    {'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',
     'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',
     'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',
     'Y': 'T', 'Z': 'Y'}
    'XKJGUFMJST'

    >>> mixed_keyword(""college"", ""UNIVERSITY"", False)  # doctest: +NORMALIZE_WHITESPACE
    'XKJGUFMJST'
    """"""
    keyword = keyword.upper()
    plaintext = plaintext.upper()
    alphabet_set = set(alphabet)

    # create a list of unique characters in the keyword - their order matters
    # it determines how we will map plaintext characters to the ciphertext
    unique_chars = []
    for char in keyword:
        if char in alphabet_set and char not in unique_chars:
            unique_chars.append(char)
    # the number of those unique characters will determine the number of rows
    num_unique_chars_in_keyword = len(unique_chars)

    # create a shifted version of the alphabet
    shifted_alphabet = unique_chars + [
        char for char in alphabet if char not in unique_chars
    ]

    # create a modified alphabet by splitting the shifted alphabet into rows
    modified_alphabet = [
        shifted_alphabet[k : k + num_unique_chars_in_keyword]
        for k in range(0, 26, num_unique_chars_in_keyword)
    ]

    # map the alphabet characters to the modified alphabet characters
    # going 'vertically' through the modified alphabet - consider columns first
    mapping = {}
    letter_index = 0
    for column in range(num_unique_chars_in_keyword):
        for row in modified_alphabet:
            # if current row (the last one) is too short, break out of loop
            if len(row) <= column:
                break

            # map current letter to letter in modified alphabet
            mapping[alphabet[letter_index]] = row[column]
            letter_index += 1

    if verbose:
        print(mapping)
    # create the encrypted text by mapping the plaintext to the modified alphabet
    return """".join(mapping.get(char, char) for char in plaintext)",data\repos\Python\ciphers\mixed_keyword_cypher.py,mixed_keyword,667
406,mono_alphabetic_ciphers.py::translate_message::6,"def translate_message(
    key: str, message: str, mode: Literal[""encrypt"", ""decrypt""]
) -> str:
    """"""
    >>> translate_message(""QWERTYUIOPASDFGHJKLZXCVBNM"",""Hello World"",""encrypt"")
    'Pcssi Bidsm'
    """"""
    chars_a = LETTERS if mode == ""decrypt"" else key
    chars_b = key if mode == ""decrypt"" else LETTERS
    translated = """"
    # loop through each symbol in the message
    for symbol in message:
        if symbol.upper() in chars_a:
            # encrypt/decrypt the symbol
            sym_index = chars_a.find(symbol.upper())
            if symbol.isupper():
                translated += chars_b[sym_index].upper()
            else:
                translated += chars_b[sym_index].lower()
        else:
            # symbol is not in LETTERS, just add it
            translated += symbol
    return translated",data\repos\Python\ciphers\mono_alphabetic_ciphers.py,translate_message,197
407,mono_alphabetic_ciphers.py::encrypt_message::31,"def encrypt_message(key: str, message: str) -> str:
    """"""
    >>> encrypt_message(""QWERTYUIOPASDFGHJKLZXCVBNM"", ""Hello World"")
    'Pcssi Bidsm'
    """"""
    return translate_message(key, message, ""encrypt"")",data\repos\Python\ciphers\mono_alphabetic_ciphers.py,encrypt_message,63
408,mono_alphabetic_ciphers.py::decrypt_message::39,"def decrypt_message(key: str, message: str) -> str:
    """"""
    >>> decrypt_message(""QWERTYUIOPASDFGHJKLZXCVBNM"", ""Hello World"")
    'Itssg Vgksr'
    """"""
    return translate_message(key, message, ""decrypt"")",data\repos\Python\ciphers\mono_alphabetic_ciphers.py,decrypt_message,64
409,mono_alphabetic_ciphers.py::main::47,"def main() -> None:
    message = ""Hello World""
    key = ""QWERTYUIOPASDFGHJKLZXCVBNM""
    mode = ""decrypt""  # set to 'encrypt' or 'decrypt'

    if mode == ""encrypt"":
        translated = encrypt_message(key, message)
    elif mode == ""decrypt"":
        translated = decrypt_message(key, message)
    print(f""Using the key {key}, the {mode}ed message is: {translated}"")",data\repos\Python\ciphers\mono_alphabetic_ciphers.py,main,103
410,morse_code.py::encrypt::25,"def encrypt(message: str) -> str:
    """"""
    >>> encrypt(""Sos!"")
    '... --- ... -.-.--'
    >>> encrypt(""SOS!"") == encrypt(""sos!"")
    True
    """"""
    return "" "".join(MORSE_CODE_DICT[char] for char in message.upper())",data\repos\Python\ciphers\morse_code.py,encrypt,63
411,morse_code.py::decrypt::35,"def decrypt(message: str) -> str:
    """"""
    >>> decrypt('... --- ... -.-.--')
    'SOS!'
    """"""
    return """".join(REVERSE_DICT[char] for char in message.split())",data\repos\Python\ciphers\morse_code.py,decrypt,44
412,morse_code.py::main::43,"def main() -> None:
    """"""
    >>> s = """".join(MORSE_CODE_DICT)
    >>> decrypt(encrypt(s)) == s
    True
    """"""
    message = ""Morse code here!""
    print(message)
    message = encrypt(message)
    print(message)
    message = decrypt(message)
    print(message)",data\repos\Python\ciphers\morse_code.py,main,68
413,onepad_cipher.py::encrypt::6,"    def encrypt(text: str) -> tuple[list[int], list[int]]:
        """"""
        Function to encrypt text using pseudo-random numbers
        >>> Onepad().encrypt("""")
        ([], [])
        >>> Onepad().encrypt([])
        ([], [])
        >>> random.seed(1)
        >>> Onepad().encrypt("" "")
        ([6969], [69])
        >>> random.seed(1)
        >>> Onepad().encrypt(""Hello"")
        ([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61])
        >>> Onepad().encrypt(1)
        Traceback (most recent call last):
        ...
        TypeError: 'int' object is not iterable
        >>> Onepad().encrypt(1.1)
        Traceback (most recent call last):
        ...
        TypeError: 'float' object is not iterable
        """"""
        plain = [ord(i) for i in text]
        key = []
        cipher = []
        for i in plain:
            k = random.randint(1, 300)
            c = (i + k) * k
            cipher.append(c)
            key.append(k)
        return cipher, key",data\repos\Python\ciphers\onepad_cipher.py,encrypt,253
414,onepad_cipher.py::decrypt::39,"    def decrypt(cipher: list[int], key: list[int]) -> str:
        """"""
        Function to decrypt text using pseudo-random numbers.
        >>> Onepad().decrypt([], [])
        ''
        >>> Onepad().decrypt([35], [])
        ''
        >>> Onepad().decrypt([], [35])
        Traceback (most recent call last):
        ...
        IndexError: list index out of range
        >>> random.seed(1)
        >>> Onepad().decrypt([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61])
        'Hello'
        """"""
        plain = []
        for i in range(len(key)):
            p = int((cipher[i] - (key[i]) ** 2) / key[i])
            plain.append(chr(p))
        return """".join(plain)",data\repos\Python\ciphers\onepad_cipher.py,decrypt,181
415,permutation_cipher.py::generate_valid_block_size::14,"def generate_valid_block_size(message_length: int) -> int:
    """"""
    Generate a valid block size that is a factor of the message length.

    Args:
        message_length (int): The length of the message.

    Returns:
        int: A valid block size.

    Example:
        >>> random.seed(1)
        >>> generate_valid_block_size(12)
        3
    """"""
    block_sizes = [
        block_size
        for block_size in range(2, message_length + 1)
        if message_length % block_size == 0
    ]
    return random.choice(block_sizes)",data\repos\Python\ciphers\permutation_cipher.py,generate_valid_block_size,125
416,permutation_cipher.py::generate_permutation_key::37,"def generate_permutation_key(block_size: int) -> list[int]:
    """"""
    Generate a random permutation key of a specified block size.

    Args:
        block_size (int): The size of each permutation block.

    Returns:
        list[int]: A list containing a random permutation of digits.

    Example:
        >>> random.seed(0)
        >>> generate_permutation_key(4)
        [2, 0, 1, 3]
    """"""
    digits = list(range(block_size))
    random.shuffle(digits)
    return digits",data\repos\Python\ciphers\permutation_cipher.py,generate_permutation_key,110
417,permutation_cipher.py::encrypt::57,"def encrypt(
    message: str, key: list[int] | None = None, block_size: int | None = None
) -> tuple[str, list[int]]:
    """"""
    Encrypt a message using a permutation cipher with block rearrangement using a key.

    Args:
        message (str): The plaintext message to be encrypted.
        key (list[int]): The permutation key for decryption.
        block_size (int): The size of each permutation block.

    Returns:
        tuple: A tuple containing the encrypted message and the encryption key.

    Example:
        >>> encrypted_message, key = encrypt(""HELLO WORLD"")
        >>> decrypted_message = decrypt(encrypted_message, key)
        >>> decrypted_message
        'HELLO WORLD'
    """"""
    message = message.upper()
    message_length = len(message)

    if key is None or block_size is None:
        block_size = generate_valid_block_size(message_length)
        key = generate_permutation_key(block_size)

    encrypted_message = """"

    for i in range(0, message_length, block_size):
        block = message[i : i + block_size]
        rearranged_block = [block[digit] for digit in key]
        encrypted_message += """".join(rearranged_block)

    return encrypted_message, key",data\repos\Python\ciphers\permutation_cipher.py,encrypt,258
418,permutation_cipher.py::decrypt::94,"def decrypt(encrypted_message: str, key: list[int]) -> str:
    """"""
    Decrypt an encrypted message using a permutation cipher with block rearrangement.

    Args:
        encrypted_message (str): The encrypted message.
        key (list[int]): The permutation key for decryption.

    Returns:
        str: The decrypted plaintext message.

    Example:
        >>> encrypted_message, key = encrypt(""HELLO WORLD"")
        >>> decrypted_message = decrypt(encrypted_message, key)
        >>> decrypted_message
        'HELLO WORLD'
    """"""
    key_length = len(key)
    decrypted_message = """"

    for i in range(0, len(encrypted_message), key_length):
        block = encrypted_message[i : i + key_length]
        original_block = [""""] * key_length
        for j, digit in enumerate(key):
            original_block[digit] = block[j]
        decrypted_message += """".join(original_block)

    return decrypted_message",data\repos\Python\ciphers\permutation_cipher.py,decrypt,191
419,permutation_cipher.py::main::124,"def main() -> None:
    """"""
    Driver function to pass message to get encrypted, then decrypted.

    Example:
    >>> main()
    Decrypted message: HELLO WORLD
    """"""
    message = ""HELLO WORLD""
    encrypted_message, key = encrypt(message)

    decrypted_message = decrypt(encrypted_message, key)
    print(f""Decrypted message: {decrypted_message}"")",data\repos\Python\ciphers\permutation_cipher.py,main,80
420,playfair_cipher.py::chunker::27,"def chunker(seq: Iterable[str], size: int) -> Generator[tuple[str, ...]]:
    it = iter(seq)
    while True:
        chunk = tuple(itertools.islice(it, size))
        if not chunk:
            return
        yield chunk",data\repos\Python\ciphers\playfair_cipher.py,chunker,53
421,playfair_cipher.py::prepare_input::36,"def prepare_input(dirty: str) -> str:
    """"""
    Prepare the plaintext by up-casing it
    and separating repeated letters with X's
    """"""

    dirty = """".join([c.upper() for c in dirty if c in string.ascii_letters])
    clean = """"

    if len(dirty) < 2:
        return dirty

    for i in range(len(dirty) - 1):
        clean += dirty[i]

        if dirty[i] == dirty[i + 1]:
            clean += ""X""

    clean += dirty[-1]

    if len(clean) & 1:
        clean += ""X""

    return clean",data\repos\Python\ciphers\playfair_cipher.py,prepare_input,134
422,playfair_cipher.py::generate_table::62,"def generate_table(key: str) -> list[str]:
    # I and J are used interchangeably to allow
    # us to use a 5x5 table (25 letters)
    alphabet = ""ABCDEFGHIKLMNOPQRSTUVWXYZ""
    # we're using a list instead of a '2d' array because it makes the math
    # for setting up the table and doing the actual encoding/decoding simpler
    table = []

    # copy key chars into the table if they are in `alphabet` ignoring duplicates
    for char in key.upper():
        if char not in table and char in alphabet:
            table.append(char)

    # fill the rest of the table in with the remaining alphabet chars
    for char in alphabet:
        if char not in table:
            table.append(char)

    return table",data\repos\Python\ciphers\playfair_cipher.py,generate_table,167
423,playfair_cipher.py::encode::83,"def encode(plaintext: str, key: str) -> str:
    """"""
    Encode the given plaintext using the Playfair cipher.
    Takes the plaintext and the key as input and returns the encoded string.

    >>> encode(""Hello"", ""MONARCHY"")
    'CFSUPM'
    >>> encode(""attack on the left flank"", ""EMERGENCY"")
    'DQZSBYFSDZFMFNLOHFDRSG'
    >>> encode(""Sorry!"", ""SPECIAL"")
    'AVXETX'
    >>> encode(""Number 1"", ""NUMBER"")
    'UMBENF'
    >>> encode(""Photosynthesis!"", ""THE SUN"")
    'OEMHQHVCHESUKE'
    """"""

    table = generate_table(key)
    plaintext = prepare_input(plaintext)
    ciphertext = """"

    for char1, char2 in chunker(plaintext, 2):
        row1, col1 = divmod(table.index(char1), 5)
        row2, col2 = divmod(table.index(char2), 5)

        if row1 == row2:
            ciphertext += table[row1 * 5 + (col1 + 1) % 5]
            ciphertext += table[row2 * 5 + (col2 + 1) % 5]
        elif col1 == col2:
            ciphertext += table[((row1 + 1) % 5) * 5 + col1]
            ciphertext += table[((row2 + 1) % 5) * 5 + col2]
        else:  # rectangle
            ciphertext += table[row1 * 5 + col2]
            ciphertext += table[row2 * 5 + col1]

    return ciphertext",data\repos\Python\ciphers\playfair_cipher.py,encode,357
424,playfair_cipher.py::decode::121,"def decode(ciphertext: str, key: str) -> str:
    """"""
    Decode the input string using the provided key.

    >>> decode(""BMZFAZRZDH"", ""HAZARD"")
    'FIREHAZARD'
    >>> decode(""HNBWBPQT"", ""AUTOMOBILE"")
    'DRIVINGX'
    >>> decode(""SLYSSAQS"", ""CASTLE"")
    'ATXTACKX'
    """"""

    table = generate_table(key)
    plaintext = """"

    for char1, char2 in chunker(ciphertext, 2):
        row1, col1 = divmod(table.index(char1), 5)
        row2, col2 = divmod(table.index(char2), 5)

        if row1 == row2:
            plaintext += table[row1 * 5 + (col1 - 1) % 5]
            plaintext += table[row2 * 5 + (col2 - 1) % 5]
        elif col1 == col2:
            plaintext += table[((row1 - 1) % 5) * 5 + col1]
            plaintext += table[((row2 - 1) % 5) * 5 + col2]
        else:  # rectangle
            plaintext += table[row1 * 5 + col2]
            plaintext += table[row2 * 5 + col1]

    return plaintext",data\repos\Python\ciphers\playfair_cipher.py,decode,294
425,polybius.py::letter_to_numbers::24,"    def letter_to_numbers(self, letter: str) -> np.ndarray:
        """"""
        Return the pair of numbers that represents the given letter in the
        polybius square
        >>> np.array_equal(PolybiusCipher().letter_to_numbers('a'), [1,1])
        True

        >>> np.array_equal(PolybiusCipher().letter_to_numbers('u'), [4,5])
        True
        """"""
        index1, index2 = np.where(letter == self.SQUARE)
        indexes = np.concatenate([index1 + 1, index2 + 1])
        return indexes",data\repos\Python\ciphers\polybius.py,letter_to_numbers,125
426,polybius.py::numbers_to_letter::38,"    def numbers_to_letter(self, index1: int, index2: int) -> str:
        """"""
        Return the letter corresponding to the position [index1, index2] in
        the polybius square

        >>> PolybiusCipher().numbers_to_letter(4, 5) == ""u""
        True

        >>> PolybiusCipher().numbers_to_letter(1, 1) == ""a""
        True
        """"""
        return self.SQUARE[index1 - 1, index2 - 1]",data\repos\Python\ciphers\polybius.py,numbers_to_letter,111
427,polybius.py::encode::51,"    def encode(self, message: str) -> str:
        """"""
        Return the encoded version of message according to the polybius cipher

        >>> PolybiusCipher().encode(""test message"") == ""44154344 32154343112215""
        True

        >>> PolybiusCipher().encode(""Test Message"") == ""44154344 32154343112215""
        True
        """"""
        message = message.lower()
        message = message.replace(""j"", ""i"")

        encoded_message = """"
        for letter_index in range(len(message)):
            if message[letter_index] != "" "":
                numbers = self.letter_to_numbers(message[letter_index])
                encoded_message = encoded_message + str(numbers[0]) + str(numbers[1])
            elif message[letter_index] == "" "":
                encoded_message = encoded_message + "" ""

        return encoded_message",data\repos\Python\ciphers\polybius.py,encode,182
428,polybius.py::decode::74,"    def decode(self, message: str) -> str:
        """"""
        Return the decoded version of message according to the polybius cipher

        >>> PolybiusCipher().decode(""44154344 32154343112215"") == ""test message""
        True

        >>> PolybiusCipher().decode(""4415434432154343112215"") == ""testmessage""
        True
        """"""
        message = message.replace("" "", ""  "")
        decoded_message = """"
        for numbers_index in range(int(len(message) / 2)):
            if message[numbers_index * 2] != "" "":
                index1 = message[numbers_index * 2]
                index2 = message[numbers_index * 2 + 1]

                letter = self.numbers_to_letter(int(index1), int(index2))
                decoded_message = decoded_message + letter
            elif message[numbers_index * 2] == "" "":
                decoded_message = decoded_message + "" ""

        return decoded_message",data\repos\Python\ciphers\polybius.py,decode,206
429,porta_cipher.py::generate_table::31,"def generate_table(key: str) -> list[tuple[str, str]]:
    """"""
    >>> generate_table('marvin')  # doctest: +NORMALIZE_WHITESPACE
    [('ABCDEFGHIJKLM', 'UVWXYZNOPQRST'), ('ABCDEFGHIJKLM', 'NOPQRSTUVWXYZ'),
     ('ABCDEFGHIJKLM', 'STUVWXYZNOPQR'), ('ABCDEFGHIJKLM', 'QRSTUVWXYZNOP'),
     ('ABCDEFGHIJKLM', 'WXYZNOPQRSTUV'), ('ABCDEFGHIJKLM', 'UVWXYZNOPQRST')]
    """"""
    return [alphabet[char] for char in key.upper()]",data\repos\Python\ciphers\porta_cipher.py,generate_table,109
430,porta_cipher.py::encrypt::41,"def encrypt(key: str, words: str) -> str:
    """"""
    >>> encrypt('marvin', 'jessica')
    'QRACRWU'
    """"""
    cipher = """"
    count = 0
    table = generate_table(key)
    for char in words.upper():
        cipher += get_opponent(table[count], char)
        count = (count + 1) % len(table)
    return cipher",data\repos\Python\ciphers\porta_cipher.py,encrypt,86
431,porta_cipher.py::decrypt::55,"def decrypt(key: str, words: str) -> str:
    """"""
    >>> decrypt('marvin', 'QRACRWU')
    'JESSICA'
    """"""
    return encrypt(key, words)",data\repos\Python\ciphers\porta_cipher.py,decrypt,42
432,porta_cipher.py::get_position::63,"def get_position(table: tuple[str, str], char: str) -> tuple[int, int]:
    """"""
    >>> get_position(generate_table('marvin')[0], 'M')
    (0, 12)
    """"""
    # `char` is either in the 0th row or the 1st row
    row = 0 if char in table[0] else 1
    col = table[row].index(char)
    return row, col",data\repos\Python\ciphers\porta_cipher.py,get_position,96
433,porta_cipher.py::get_opponent::74,"def get_opponent(table: tuple[str, str], char: str) -> str:
    """"""
    >>> get_opponent(generate_table('marvin')[0], 'M')
    'T'
    """"""
    row, col = get_position(table, char.upper())
    if row == 1:
        return table[0][col]
    else:
        return table[1][col] if row == 0 else char",data\repos\Python\ciphers\porta_cipher.py,get_opponent,87
434,rabin_miller.py::rabin_miller::6,"def rabin_miller(num: int) -> bool:
    s = num - 1
    t = 0

    while s % 2 == 0:
        s = s // 2
        t += 1

    for _ in range(5):
        a = random.randrange(2, num - 1)
        v = pow(a, s, num)
        if v != 1:
            i = 0
            while v != (num - 1):
                if i == t - 1:
                    return False
                else:
                    i = i + 1
                    v = (v**2) % num
    return True",data\repos\Python\ciphers\rabin_miller.py,rabin_miller,142
435,rabin_miller.py::is_prime_low_num::28,"def is_prime_low_num(num: int) -> bool:
    if num < 2:
        return False

    low_primes = [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97,
        101,
        103,
        107,
        109,
        113,
        127,
        131,
        137,
        139,
        149,
        151,
        157,
        163,
        167,
        173,
        179,
        181,
        191,
        193,
        197,
        199,
        211,
        223,
        227,
        229,
        233,
        239,
        241,
        251,
        257,
        263,
        269,
        271,
        277,
        281,
        283,
        293,
        307,
        311,
        313,
        317,
        331,
        337,
        347,
        349,
        353,
        359,
        367,
        373,
        379,
        383,
        389,
        397,
        401,
        409,
        419,
        421,
        431,
        433,
        439,
        443,
        449,
        457,
        461,
        463,
        467,
        479,
        487,
        491,
        499,
        503,
        509,
        521,
        523,
        541,
        547,
        557,
        563,
        569,
        571,
        577,
        587,
        593,
        599,
        601,
        607,
        613,
        617,
        619,
        631,
        641,
        643,
        647,
        653,
        659,
        661,
        673,
        677,
        683,
        691,
        701,
        709,
        719,
        727,
        733,
        739,
        743,
        751,
        757,
        761,
        769,
        773,
        787,
        797,
        809,
        811,
        821,
        823,
        827,
        829,
        839,
        853,
        857,
        859,
        863,
        877,
        881,
        883,
        887,
        907,
        911,
        919,
        929,
        937,
        941,
        947,
        953,
        967,
        971,
        977,
        983,
        991,
        997,
    ]

    if num in low_primes:
        return True

    for prime in low_primes:
        if (num % prime) == 0:
            return False

    return rabin_miller(num)",data\repos\Python\ciphers\rabin_miller.py,is_prime_low_num,746
436,rabin_miller.py::generate_large_prime::213,"def generate_large_prime(keysize: int = 1024) -> int:
    while True:
        num = random.randrange(2 ** (keysize - 1), 2 ** (keysize))
        if is_prime_low_num(num):
            return num",data\repos\Python\ciphers\rabin_miller.py,generate_large_prime,53
437,rail_fence_cipher.py::encrypt::4,"def encrypt(input_string: str, key: int) -> str:
    """"""
    Shuffles the character of a string by placing each of them
    in a grid (the height is dependent on the key) in a zigzag
    formation and reading it left to right.

    >>> encrypt(""Hello World"", 4)
    'HWe olordll'

    >>> encrypt(""This is a message"", 0)
    Traceback (most recent call last):
        ...
    ValueError: Height of grid can't be 0 or negative

    >>> encrypt(b""This is a byte string"", 5)
    Traceback (most recent call last):
        ...
    TypeError: sequence item 0: expected str instance, int found
    """"""
    temp_grid: list[list[str]] = [[] for _ in range(key)]
    lowest = key - 1

    if key <= 0:
        raise ValueError(""Height of grid can't be 0 or negative"")
    if key == 1 or len(input_string) <= key:
        return input_string

    for position, character in enumerate(input_string):
        num = position % (lowest * 2)  # puts it in bounds
        num = min(num, lowest * 2 - num)  # creates zigzag pattern
        temp_grid[num].append(character)
    grid = ["""".join(row) for row in temp_grid]
    output_string = """".join(grid)

    return output_string",data\repos\Python\ciphers\rail_fence_cipher.py,encrypt,300
438,rail_fence_cipher.py::decrypt::41,"def decrypt(input_string: str, key: int) -> str:
    """"""
    Generates a template based on the key and fills it in with
    the characters of the input string and then reading it in
    a zigzag formation.

    >>> decrypt(""HWe olordll"", 4)
    'Hello World'

    >>> decrypt(""This is a message"", -10)
    Traceback (most recent call last):
        ...
    ValueError: Height of grid can't be 0 or negative

    >>> decrypt(""My key is very big"", 100)
    'My key is very big'
    """"""
    grid = []
    lowest = key - 1

    if key <= 0:
        raise ValueError(""Height of grid can't be 0 or negative"")
    if key == 1:
        return input_string

    temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template
    for position in range(len(input_string)):
        num = position % (lowest * 2)  # puts it in bounds
        num = min(num, lowest * 2 - num)  # creates zigzag pattern
        temp_grid[num].append(""*"")

    counter = 0
    for row in temp_grid:  # fills in the characters
        splice = input_string[counter : counter + len(row)]
        grid.append(list(splice))
        counter += len(row)

    output_string = """"  # reads as zigzag
    for position in range(len(input_string)):
        num = position % (lowest * 2)  # puts it in bounds
        num = min(num, lowest * 2 - num)  # creates zigzag pattern
        output_string += grid[num][0]
        grid[num].pop(0)
    return output_string",data\repos\Python\ciphers\rail_fence_cipher.py,decrypt,374
439,rail_fence_cipher.py::bruteforce::87,"def bruteforce(input_string: str) -> dict[int, str]:
    """"""Uses decrypt function by guessing every key

    >>> bruteforce(""HWe olordll"")[4]
    'Hello World'
    """"""
    results = {}
    for key_guess in range(1, len(input_string)):  # tries every key
        results[key_guess] = decrypt(input_string, key_guess)
    return results",data\repos\Python\ciphers\rail_fence_cipher.py,bruteforce,85
440,rot13.py::dencrypt::1,"def dencrypt(s: str, n: int = 13) -> str:
    """"""
    https://en.wikipedia.org/wiki/ROT13

    >>> msg = ""My secret bank account number is 173-52946 so don't tell anyone!!""
    >>> s = dencrypt(msg)
    >>> s
    ""Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!""
    >>> dencrypt(s) == msg
    True
    """"""
    out = """"
    for c in s:
        if ""A"" <= c <= ""Z"":
            out += chr(ord(""A"") + (ord(c) - ord(""A"") + n) % 26)
        elif ""a"" <= c <= ""z"":
            out += chr(ord(""a"") + (ord(c) - ord(""a"") + n) % 26)
        else:
            out += c
    return out",data\repos\Python\ciphers\rot13.py,dencrypt,206
441,rot13.py::main::23,"def main() -> None:
    s0 = input(""Enter message: "")

    s1 = dencrypt(s0, 13)
    print(""Encryption:"", s1)

    s2 = dencrypt(s1, 13)
    print(""Decryption: "", s2)",data\repos\Python\ciphers\rot13.py,main,58
442,rsa_cipher.py::get_blocks_from_text::10,"def get_blocks_from_text(
    message: str, block_size: int = DEFAULT_BLOCK_SIZE
) -> list[int]:
    message_bytes = message.encode(""ascii"")

    block_ints = []
    for block_start in range(0, len(message_bytes), block_size):
        block_int = 0
        for i in range(block_start, min(block_start + block_size, len(message_bytes))):
            block_int += message_bytes[i] * (BYTE_SIZE ** (i % block_size))
        block_ints.append(block_int)
    return block_ints",data\repos\Python\ciphers\rsa_cipher.py,get_blocks_from_text,114
443,rsa_cipher.py::get_text_from_blocks::24,"def get_text_from_blocks(
    block_ints: list[int], message_length: int, block_size: int = DEFAULT_BLOCK_SIZE
) -> str:
    message: list[str] = []
    for block_int in block_ints:
        block_message: list[str] = []
        for i in range(block_size - 1, -1, -1):
            if len(message) + i < message_length:
                ascii_number = block_int // (BYTE_SIZE**i)
                block_int = block_int % (BYTE_SIZE**i)
                block_message.insert(0, chr(ascii_number))
        message.extend(block_message)
    return """".join(message)",data\repos\Python\ciphers\rsa_cipher.py,get_text_from_blocks,136
444,rsa_cipher.py::encrypt_message::39,"def encrypt_message(
    message: str, key: tuple[int, int], block_size: int = DEFAULT_BLOCK_SIZE
) -> list[int]:
    encrypted_blocks = []
    n, e = key

    for block in get_blocks_from_text(message, block_size):
        encrypted_blocks.append(pow(block, e, n))
    return encrypted_blocks",data\repos\Python\ciphers\rsa_cipher.py,encrypt_message,70
445,rsa_cipher.py::decrypt_message::50,"def decrypt_message(
    encrypted_blocks: list[int],
    message_length: int,
    key: tuple[int, int],
    block_size: int = DEFAULT_BLOCK_SIZE,
) -> str:
    decrypted_blocks = []
    n, d = key
    for block in encrypted_blocks:
        decrypted_blocks.append(pow(block, d, n))
    return get_text_from_blocks(decrypted_blocks, message_length, block_size)",data\repos\Python\ciphers\rsa_cipher.py,decrypt_message,85
446,rsa_cipher.py::read_key_file::63,"def read_key_file(key_filename: str) -> tuple[int, int, int]:
    with open(key_filename) as fo:
        content = fo.read()
    key_size, n, eor_d = content.split("","")
    return (int(key_size), int(n), int(eor_d))",data\repos\Python\ciphers\rsa_cipher.py,read_key_file,60
447,rsa_cipher.py::encrypt_and_write_to_file::70,"def encrypt_and_write_to_file(
    message_filename: str,
    key_filename: str,
    message: str,
    block_size: int = DEFAULT_BLOCK_SIZE,
) -> str:
    key_size, n, e = read_key_file(key_filename)
    if key_size < block_size * 8:
        sys.exit(
            f""ERROR: Block size is {block_size * 8} bits and key size is {key_size} ""
            ""bits. The RSA cipher requires the block size to be equal to or greater ""
            ""than the key size. Either decrease the block size or use different keys.""
        )

    encrypted_blocks = [str(i) for i in encrypt_message(message, (n, e), block_size)]

    encrypted_content = "","".join(encrypted_blocks)
    encrypted_content = f""{len(message)}_{block_size}_{encrypted_content}""
    with open(message_filename, ""w"") as fo:
        fo.write(encrypted_content)
    return encrypted_content",data\repos\Python\ciphers\rsa_cipher.py,encrypt_and_write_to_file,202
448,rsa_cipher.py::read_from_file_and_decrypt::93,"def read_from_file_and_decrypt(message_filename: str, key_filename: str) -> str:
    key_size, n, d = read_key_file(key_filename)
    with open(message_filename) as fo:
        content = fo.read()
    message_length_str, block_size_str, encrypted_message = content.split(""_"")
    message_length = int(message_length_str)
    block_size = int(block_size_str)

    if key_size < block_size * 8:
        sys.exit(
            f""ERROR: Block size is {block_size * 8} bits and key size is {key_size} ""
            ""bits. The RSA cipher requires the block size to be equal to or greater ""
            ""than the key size. Were the correct key file and encrypted file specified?""
        )

    encrypted_blocks = []
    for block in encrypted_message.split("",""):
        encrypted_blocks.append(int(block))

    return decrypt_message(encrypted_blocks, message_length, (n, d), block_size)",data\repos\Python\ciphers\rsa_cipher.py,read_from_file_and_decrypt,199
449,rsa_cipher.py::main::115,"def main() -> None:
    filename = ""encrypted_file.txt""
    response = input(r""Encrypt\Decrypt [e\d]: "")

    if response.lower().startswith(""e""):
        mode = ""encrypt""
    elif response.lower().startswith(""d""):
        mode = ""decrypt""

    if mode == ""encrypt"":
        if not os.path.exists(""rsa_pubkey.txt""):
            rkg.make_key_files(""rsa"", 1024)

        message = input(""\nEnter message: "")
        pubkey_filename = ""rsa_pubkey.txt""
        print(f""Encrypting and writing to {filename}..."")
        encrypted_text = encrypt_and_write_to_file(filename, pubkey_filename, message)

        print(""\nEncrypted text:"")
        print(encrypted_text)

    elif mode == ""decrypt"":
        privkey_filename = ""rsa_privkey.txt""
        print(f""Reading from {filename} and decrypting..."")
        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)
        print(""writing decryption to rsa_decryption.txt..."")
        with open(""rsa_decryption.txt"", ""w"") as dec:
            dec.write(decrypted_text)

        print(""\nDecryption:"")
        print(decrypted_text)",data\repos\Python\ciphers\rsa_cipher.py,main,244
450,rsa_factorization.py::rsafactor::19,"def rsafactor(d: int, e: int, n: int) -> list[int]:
    """"""
    This function returns the factors of N, where p*q=N

    Return: [p, q]

    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.
    The pair (N, e) is the public key. As its name suggests, it is public and is used to
    encrypt messages.
    The pair (N, d) is the secret key or private key and is known only to the recipient
    of encrypted messages.

    >>> rsafactor(3, 16971, 25777)
    [149, 173]
    >>> rsafactor(7331, 11, 27233)
    [113, 241]
    >>> rsafactor(4021, 13, 17711)
    [89, 199]
    """"""
    k = d * e - 1
    p = 0
    q = 0
    while p == 0:
        g = random.randint(2, n - 1)
        t = k
        while True:
            if t % 2 == 0:
                t = t // 2
                x = (g**t) % n
                y = math.gcd(x - 1, n)
                if x > 1 and y > 1:
                    p = y
                    q = n // y
                    break  # find the correct factors
            else:
                break  # t is not divisible by 2, break and choose another g
    return sorted([p, q])",data\repos\Python\ciphers\rsa_factorization.py,rsafactor,347
451,rsa_key_generator.py::main::10,"def main() -> None:
    print(""Making key files..."")
    make_key_files(""rsa"", 1024)
    print(""Key files generation successful."")",data\repos\Python\ciphers\rsa_key_generator.py,main,32
452,rsa_key_generator.py::generate_key::16,"def generate_key(key_size: int) -> tuple[tuple[int, int], tuple[int, int]]:
    """"""
    >>> random.seed(0) # for repeatability
    >>> public_key, private_key = generate_key(8)
    >>> public_key
    (26569, 239)
    >>> private_key
    (26569, 2855)
    """"""
    p = rabin_miller.generate_large_prime(key_size)
    q = rabin_miller.generate_large_prime(key_size)
    n = p * q

    # Generate e that is relatively prime to (p - 1) * (q - 1)
    while True:
        e = random.randrange(2 ** (key_size - 1), 2 ** (key_size))
        if gcd_by_iterative(e, (p - 1) * (q - 1)) == 1:
            break

    # Calculate d that is mod inverse of e
    d = cryptomath_module.find_mod_inverse(e, (p - 1) * (q - 1))

    public_key = (n, e)
    private_key = (n, d)
    return (public_key, private_key)",data\repos\Python\ciphers\rsa_key_generator.py,generate_key,250
453,rsa_key_generator.py::make_key_files::43,"def make_key_files(name: str, key_size: int) -> None:
    if os.path.exists(f""{name}_pubkey.txt"") or os.path.exists(f""{name}_privkey.txt""):
        print(""\nWARNING:"")
        print(
            f'""{name}_pubkey.txt"" or ""{name}_privkey.txt"" already exists. \n'
            ""Use a different name or delete these files and re-run this program.""
        )
        sys.exit()

    public_key, private_key = generate_key(key_size)
    print(f""\nWriting public key to file {name}_pubkey.txt..."")
    with open(f""{name}_pubkey.txt"", ""w"") as out_file:
        out_file.write(f""{key_size},{public_key[0]},{public_key[1]}"")

    print(f""Writing private key to file {name}_privkey.txt..."")
    with open(f""{name}_privkey.txt"", ""w"") as out_file:
        out_file.write(f""{key_size},{private_key[0]},{private_key[1]}"")",data\repos\Python\ciphers\rsa_key_generator.py,make_key_files,219
454,running_key_cipher.py::running_key_encrypt::6,"def running_key_encrypt(key: str, plaintext: str) -> str:
    """"""
    Encrypts the plaintext using the Running Key Cipher.

    :param key: The running key (long piece of text).
    :param plaintext: The plaintext to be encrypted.
    :return: The ciphertext.
    """"""
    plaintext = plaintext.replace("" "", """").upper()
    key = key.replace("" "", """").upper()
    key_length = len(key)
    ciphertext = []
    ord_a = ord(""A"")

    for i, char in enumerate(plaintext):
        p = ord(char) - ord_a
        k = ord(key[i % key_length]) - ord_a
        c = (p + k) % 26
        ciphertext.append(chr(c + ord_a))

    return """".join(ciphertext)",data\repos\Python\ciphers\running_key_cipher.py,running_key_encrypt,163
455,running_key_cipher.py::running_key_decrypt::29,"def running_key_decrypt(key: str, ciphertext: str) -> str:
    """"""
    Decrypts the ciphertext using the Running Key Cipher.

    :param key: The running key (long piece of text).
    :param ciphertext: The ciphertext to be decrypted.
    :return: The plaintext.
    """"""
    ciphertext = ciphertext.replace("" "", """").upper()
    key = key.replace("" "", """").upper()
    key_length = len(key)
    plaintext = []
    ord_a = ord(""A"")

    for i, char in enumerate(ciphertext):
        c = ord(char) - ord_a
        k = ord(key[i % key_length]) - ord_a
        p = (c - k) % 26
        plaintext.append(chr(p + ord_a))

    return """".join(plaintext)",data\repos\Python\ciphers\running_key_cipher.py,running_key_decrypt,163
456,running_key_cipher.py::test_running_key_encrypt::52,"def test_running_key_encrypt() -> None:
    """"""
    >>> key = ""How does the duck know that? said Victor""
    >>> ciphertext = running_key_encrypt(key, ""DEFEND THIS"")
    >>> running_key_decrypt(key, ciphertext) == ""DEFENDTHIS""
    True
    """"""",data\repos\Python\ciphers\running_key_cipher.py,test_running_key_encrypt,60
457,shuffled_shift_cipher.py::test_end_to_end::172,"def test_end_to_end(msg: str = ""Hello, this is a modified Caesar cipher"") -> str:
    """"""
    >>> test_end_to_end()
    'Hello, this is a modified Caesar cipher'
    """"""
    cip1 = ShuffledShiftCipher()
    return cip1.decrypt(cip1.encrypt(msg))",data\repos\Python\ciphers\shuffled_shift_cipher.py,test_end_to_end,66
458,shuffled_shift_cipher.py::decrypt::127,"    def decrypt(self, encoded_message: str) -> str:
        """"""
        Performs shifting of the encoded_message w.r.t. the shuffled __key_list
        to create the decoded_message

        >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')
        >>> ssc.decrypt(""d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#"")
        'Hello, this is a modified Caesar cipher'

        """"""
        decoded_message = """"

        # decoding shift like Caesar cipher algorithm implementing negative shift or
        # reverse shift or left shift
        for i in encoded_message:
            position = self.__key_list.index(i)
            decoded_message += self.__key_list[
                (position - self.__shift_key) % -len(self.__key_list)
            ]

        return decoded_message",data\repos\Python\ciphers\shuffled_shift_cipher.py,decrypt,183
459,shuffled_shift_cipher.py::encrypt::149,"    def encrypt(self, plaintext: str) -> str:
        """"""
        Performs shifting of the plaintext w.r.t. the shuffled __key_list
        to create the encoded_message

        >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')
        >>> ssc.encrypt('Hello, this is a modified Caesar cipher')
        ""d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#""

        """"""
        encoded_message = """"

        # encoding shift like Caesar cipher algorithm implementing positive shift or
        # forward shift or right shift
        for i in plaintext:
            position = self.__key_list.index(i)
            encoded_message += self.__key_list[
                (position + self.__shift_key) % len(self.__key_list)
            ]

        return encoded_message",data\repos\Python\ciphers\shuffled_shift_cipher.py,encrypt,179
460,simple_keyword_cypher.py::remove_duplicates::1,"def remove_duplicates(key: str) -> str:
    """"""
    Removes duplicate alphabetic characters in a keyword (letter is ignored after its
    first appearance).

    :param key: Keyword to use
    :return: String with duplicates removed

    >>> remove_duplicates('Hello World!!')
    'Helo Wrd'
    """"""

    key_no_dups = """"
    for ch in key:
        if ch == "" "" or (ch not in key_no_dups and ch.isalpha()):
            key_no_dups += ch
    return key_no_dups",data\repos\Python\ciphers\simple_keyword_cypher.py,remove_duplicates,115
461,simple_keyword_cypher.py::create_cipher_map::20,"def create_cipher_map(key: str) -> dict[str, str]:
    """"""
    Returns a cipher map given a keyword.

    :param key: keyword to use
    :return: dictionary cipher map
    """"""
    # Create a list of the letters in the alphabet
    alphabet = [chr(i + 65) for i in range(26)]
    # Remove duplicate characters from key
    key = remove_duplicates(key.upper())
    offset = len(key)
    # First fill cipher with key characters
    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}
    # Then map remaining characters in alphabet to
    # the alphabet from the beginning
    for i in range(len(cipher_alphabet), 26):
        char = alphabet[i - offset]
        # Ensure we are not mapping letters to letters previously mapped
        while char in key:
            offset -= 1
            char = alphabet[i - offset]
        cipher_alphabet[alphabet[i]] = char
    return cipher_alphabet",data\repos\Python\ciphers\simple_keyword_cypher.py,create_cipher_map,211
462,simple_keyword_cypher.py::encipher::46,"def encipher(message: str, cipher_map: dict[str, str]) -> str:
    """"""
    Enciphers a message given a cipher map.

    :param message: Message to encipher
    :param cipher_map: Cipher map
    :return: enciphered string

    >>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))
    'CYJJM VMQJB!!'
    """"""
    return """".join(cipher_map.get(ch, ch) for ch in message.upper())",data\repos\Python\ciphers\simple_keyword_cypher.py,encipher,105
463,simple_keyword_cypher.py::decipher::60,"def decipher(message: str, cipher_map: dict[str, str]) -> str:
    """"""
    Deciphers a message given a cipher map

    :param message: Message to decipher
    :param cipher_map: Dictionary mapping to use
    :return: Deciphered string

    >>> cipher_map = create_cipher_map('Goodbye!!')
    >>> decipher(encipher('Hello World!!', cipher_map), cipher_map)
    'HELLO WORLD!!'
    """"""
    # Reverse our cipher mappings
    rev_cipher_map = {v: k for k, v in cipher_map.items()}
    return """".join(rev_cipher_map.get(ch, ch) for ch in message.upper())",data\repos\Python\ciphers\simple_keyword_cypher.py,decipher,140
464,simple_keyword_cypher.py::main::77,"def main() -> None:
    """"""
    Handles I/O

    :return: void
    """"""
    message = input(""Enter message to encode or decode: "").strip()
    key = input(""Enter keyword: "").strip()
    option = input(""Encipher or decipher? E/D:"").strip()[0].lower()
    try:
        func = {""e"": encipher, ""d"": decipher}[option]
    except KeyError:
        raise KeyError(""invalid input option"")
    cipher_map = create_cipher_map(key)
    print(func(message, cipher_map))",data\repos\Python\ciphers\simple_keyword_cypher.py,main,115
465,simple_substitution_cipher.py::main::7,"def main() -> None:
    message = input(""Enter message: "")
    key = ""LFWOAYUISVKMNXPBDCRJTQEGHZ""
    resp = input(""Encrypt/Decrypt [e/d]: "")

    check_valid_key(key)

    if resp.lower().startswith(""e""):
        mode = ""encrypt""
        translated = encrypt_message(key, message)
    elif resp.lower().startswith(""d""):
        mode = ""decrypt""
        translated = decrypt_message(key, message)

    print(f""\n{mode.title()}ion: \n{translated}"")",data\repos\Python\ciphers\simple_substitution_cipher.py,main,118
466,simple_substitution_cipher.py::check_valid_key::24,"def check_valid_key(key: str) -> None:
    key_list = list(key)
    letters_list = list(LETTERS)
    key_list.sort()
    letters_list.sort()

    if key_list != letters_list:
        sys.exit(""Error in the key or symbol set."")",data\repos\Python\ciphers\simple_substitution_cipher.py,check_valid_key,57
467,simple_substitution_cipher.py::encrypt_message::34,"def encrypt_message(key: str, message: str) -> str:
    """"""
    >>> encrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')
    'Ilcrism Olcvs'
    """"""
    return translate_message(key, message, ""encrypt"")",data\repos\Python\ciphers\simple_substitution_cipher.py,encrypt_message,66
468,simple_substitution_cipher.py::decrypt_message::42,"def decrypt_message(key: str, message: str) -> str:
    """"""
    >>> decrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')
    'Harshil Darji'
    """"""
    return translate_message(key, message, ""decrypt"")",data\repos\Python\ciphers\simple_substitution_cipher.py,decrypt_message,66
469,simple_substitution_cipher.py::translate_message::50,"def translate_message(key: str, message: str, mode: str) -> str:
    translated = """"
    chars_a = LETTERS
    chars_b = key

    if mode == ""decrypt"":
        chars_a, chars_b = chars_b, chars_a

    for symbol in message:
        if symbol.upper() in chars_a:
            sym_index = chars_a.find(symbol.upper())
            if symbol.isupper():
                translated += chars_b[sym_index].upper()
            else:
                translated += chars_b[sym_index].lower()
        else:
            translated += symbol

    return translated",data\repos\Python\ciphers\simple_substitution_cipher.py,translate_message,122
470,transposition_cipher.py::main::11,"def main() -> None:
    message = input(""Enter message: "")
    key = int(input(f""Enter key [2-{len(message) - 1}]: ""))
    mode = input(""Encryption/Decryption [e/d]: "")

    if mode.lower().startswith(""e""):
        text = encrypt_message(key, message)
    elif mode.lower().startswith(""d""):
        text = decrypt_message(key, message)

    # Append pipe symbol (vertical bar) to identify spaces at the end.
    print(f""Output:\n{text + '|'}"")",data\repos\Python\ciphers\transposition_cipher.py,main,114
471,transposition_cipher.py::encrypt_message::25,"def encrypt_message(key: int, message: str) -> str:
    """"""
    >>> encrypt_message(6, 'Harshil Darji')
    'Hlia rDsahrij'
    """"""
    cipher_text = [""""] * key
    for col in range(key):
        pointer = col
        while pointer < len(message):
            cipher_text[col] += message[pointer]
            pointer += key
    return """".join(cipher_text)",data\repos\Python\ciphers\transposition_cipher.py,encrypt_message,92
472,transposition_cipher.py::decrypt_message::39,"def decrypt_message(key: int, message: str) -> str:
    """"""
    >>> decrypt_message(6, 'Hlia rDsahrij')
    'Harshil Darji'
    """"""
    num_cols = math.ceil(len(message) / key)
    num_rows = key
    num_shaded_boxes = (num_cols * num_rows) - len(message)
    plain_text = [""""] * num_cols
    col = 0
    row = 0

    for symbol in message:
        plain_text[col] += symbol
        col += 1

        if (col == num_cols) or (
            (col == num_cols - 1) and (row >= num_rows - num_shaded_boxes)
        ):
            col = 0
            row += 1

    return """".join(plain_text)",data\repos\Python\ciphers\transposition_cipher.py,decrypt_message,172
473,transposition_cipher_encrypt_decrypt_file.py::main::8,"def main() -> None:
    input_file = ""./prehistoric_men.txt""
    output_file = ""./Output.txt""
    key = int(input(""Enter key: ""))
    mode = input(""Encrypt/Decrypt [e/d]: "")

    if not os.path.exists(input_file):
        print(f""File {input_file} does not exist. Quitting..."")
        sys.exit()
    if os.path.exists(output_file):
        print(f""Overwrite {output_file}? [y/n]"")
        response = input(""> "")
        if not response.lower().startswith(""y""):
            sys.exit()

    start_time = time.time()
    if mode.lower().startswith(""e""):
        with open(input_file) as f:
            content = f.read()
        translated = trans_cipher.encrypt_message(key, content)
    elif mode.lower().startswith(""d""):
        with open(output_file) as f:
            content = f.read()
        translated = trans_cipher.decrypt_message(key, content)

    with open(output_file, ""w"") as output_obj:
        output_obj.write(translated)

    total_time = round(time.time() - start_time, 2)
    print((""Done ("", total_time, ""seconds )""))",data\repos\Python\ciphers\transposition_cipher_encrypt_decrypt_file.py,main,245
474,trifid_cipher.py::encrypt_message::124,"def encrypt_message(
    message: str, alphabet: str = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ."", period: int = 5
) -> str:
    """"""
    encrypt_message
    ===============

    Encrypts a message using the trifid_cipher. Any punctuatuion chars that
    would be used should be added to the alphabet.

    PARAMETERS
    ----------

    *   `message`: The message you want to encrypt.
    *   `alphabet` (optional): The characters to be used for the cipher .
    *   `period` (optional): The number of characters you want in a group whilst
        encrypting.

    >>> encrypt_message('I am a boy')
    'BCDGBQY'

    >>> encrypt_message(' ')
    ''

    >>> encrypt_message('   aide toi le c  iel      ta id  era    ',
    ... 'FELIXMARDSTBCGHJKNOPQUVWYZ+',5)
    'FMJFVOISSUFTFPUFEQQC'

    """"""
    message, alphabet, character_to_number, number_to_character = __prepare(
        message, alphabet
    )

    encrypted_numeric = """"
    for i in range(0, len(message) + 1, period):
        encrypted_numeric += __encrypt_part(
            message[i : i + period], character_to_number
        )

    encrypted = """"
    for i in range(0, len(encrypted_numeric), 3):
        encrypted += number_to_character[encrypted_numeric[i : i + 3]]
    return encrypted",data\repos\Python\ciphers\trifid_cipher.py,encrypt_message,318
475,trifid_cipher.py::decrypt_message::169,"def decrypt_message(
    message: str, alphabet: str = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ."", period: int = 5
) -> str:
    """"""
    decrypt_message
    ===============

    Decrypts a trifid_cipher encrypted message.

    PARAMETERS
    ----------

    *   `message`: The message you want to decrypt.
    *   `alphabet` (optional): The characters used for the cipher.
    *   `period` (optional): The number of characters used in grouping when it
        was encrypted.

    >>> decrypt_message('BCDGBQY')
    'IAMABOY'

    Decrypting with your own alphabet and period

    >>> decrypt_message('FMJFVOISSUFTFPUFEQQC','FELIXMARDSTBCGHJKNOPQUVWYZ+',5)
    'AIDETOILECIELTAIDERA'
    """"""
    message, alphabet, character_to_number, number_to_character = __prepare(
        message, alphabet
    )

    decrypted_numeric = []
    for i in range(0, len(message), period):
        a, b, c = __decrypt_part(message[i : i + period], character_to_number)

        for j in range(len(a)):
            decrypted_numeric.append(a[j] + b[j] + c[j])

    return """".join(number_to_character[each] for each in decrypted_numeric)",data\repos\Python\ciphers\trifid_cipher.py,decrypt_message,284
476,vernam_cipher.py::vernam_encrypt::1,"def vernam_encrypt(plaintext: str, key: str) -> str:
    """"""
    >>> vernam_encrypt(""HELLO"",""KEY"")
    'RIJVS'
    """"""
    ciphertext = """"
    for i in range(len(plaintext)):
        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65
        while ct > 25:
            ct = ct - 26
        ciphertext += chr(65 + ct)
    return ciphertext",data\repos\Python\ciphers\vernam_cipher.py,vernam_encrypt,100
477,vernam_cipher.py::vernam_decrypt::15,"def vernam_decrypt(ciphertext: str, key: str) -> str:
    """"""
    >>> vernam_decrypt(""RIJVS"",""KEY"")
    'HELLO'
    """"""
    decrypted_text = """"
    for i in range(len(ciphertext)):
        ct = ord(ciphertext[i]) - ord(key[i % len(key)])
        while ct < 0:
            ct = 26 + ct
        decrypted_text += chr(65 + ct)
    return decrypted_text",data\repos\Python\ciphers\vernam_cipher.py,vernam_decrypt,96
478,vigenere_cipher.py::main::4,"def main() -> None:
    message = input(""Enter message: "")
    key = input(""Enter key [alphanumeric]: "")
    mode = input(""Encrypt/Decrypt [e/d]: "")

    if mode.lower().startswith(""e""):
        mode = ""encrypt""
        translated = encrypt_message(key, message)
    elif mode.lower().startswith(""d""):
        mode = ""decrypt""
        translated = decrypt_message(key, message)

    print(f""\n{mode.title()}ed message:"")
    print(translated)",data\repos\Python\ciphers\vigenere_cipher.py,main,105
479,vigenere_cipher.py::encrypt_message::20,"def encrypt_message(key: str, message: str) -> str:
    """"""
    >>> encrypt_message('HDarji', 'This is Harshil Darji from Dharmaj.')
    'Akij ra Odrjqqs Gaisq muod Mphumrs.'
    """"""
    return translate_message(key, message, ""encrypt"")",data\repos\Python\ciphers\vigenere_cipher.py,encrypt_message,70
480,vigenere_cipher.py::decrypt_message::28,"def decrypt_message(key: str, message: str) -> str:
    """"""
    >>> decrypt_message('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.')
    'This is Harshil Darji from Dharmaj.'
    """"""
    return translate_message(key, message, ""decrypt"")",data\repos\Python\ciphers\vigenere_cipher.py,decrypt_message,70
481,vigenere_cipher.py::translate_message::36,"def translate_message(key: str, message: str, mode: str) -> str:
    translated = []
    key_index = 0
    key = key.upper()

    for symbol in message:
        num = LETTERS.find(symbol.upper())
        if num != -1:
            if mode == ""encrypt"":
                num += LETTERS.find(key[key_index])
            elif mode == ""decrypt"":
                num -= LETTERS.find(key[key_index])

            num %= len(LETTERS)

            if symbol.isupper():
                translated.append(LETTERS[num])
            elif symbol.islower():
                translated.append(LETTERS[num].lower())

            key_index += 1
            if key_index == len(key):
                key_index = 0
        else:
            translated.append(symbol)
    return """".join(translated)",data\repos\Python\ciphers\vigenere_cipher.py,translate_message,166
482,xor_cipher.py::encrypt::33,"    def encrypt(self, content: str, key: int) -> list[str]:
        """"""
        input: 'content' of type string and 'key' of type int
        output: encrypted string 'content' as a list of chars
        if key not passed the method uses the key by the constructor.
        otherwise key = 1

        Empty list
        >>> XORCipher().encrypt("""", 5)
        []

        One key
        >>> XORCipher().encrypt(""hallo welt"", 1)
        ['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']

        Normal key
        >>> XORCipher().encrypt(""HALLO WELT"", 32)
        ['h', 'a', 'l', 'l', 'o', '\\x00', 'w', 'e', 'l', 't']

        Key greater than 255
        >>> XORCipher().encrypt(""hallo welt"", 256)
        ['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']
        """"""

        # precondition
        assert isinstance(key, int)
        assert isinstance(content, str)

        key = key or self.__key or 1

        # make sure key is an appropriate size
        key %= 256

        return [chr(ord(ch) ^ key) for ch in content]",data\repos\Python\ciphers\xor_cipher.py,encrypt,300
483,xor_cipher.py::decrypt::68,"    def decrypt(self, content: str, key: int) -> list[str]:
        """"""
        input: 'content' of type list and 'key' of type int
        output: decrypted string 'content' as a list of chars
        if key not passed the method uses the key by the constructor.
        otherwise key = 1

        Empty list
        >>> XORCipher().decrypt("""", 5)
        []

        One key
        >>> XORCipher().decrypt(""hallo welt"", 1)
        ['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']

        Normal key
        >>> XORCipher().decrypt(""HALLO WELT"", 32)
        ['h', 'a', 'l', 'l', 'o', '\\x00', 'w', 'e', 'l', 't']

        Key greater than 255
        >>> XORCipher().decrypt(""hallo welt"", 256)
        ['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']
        """"""

        # precondition
        assert isinstance(key, int)
        assert isinstance(content, str)

        key = key or self.__key or 1

        # make sure key is an appropriate size
        key %= 256

        return [chr(ord(ch) ^ key) for ch in content]",data\repos\Python\ciphers\xor_cipher.py,decrypt,300
484,xor_cipher.py::encrypt_string::103,"    def encrypt_string(self, content: str, key: int = 0) -> str:
        """"""
        input: 'content' of type string and 'key' of type int
        output: encrypted string 'content'
        if key not passed the method uses the key by the constructor.
        otherwise key = 1

        Empty list
        >>> XORCipher().encrypt_string("""", 5)
        ''

        One key
        >>> XORCipher().encrypt_string(""hallo welt"", 1)
        'i`mmn!vdmu'

        Normal key
        >>> XORCipher().encrypt_string(""HALLO WELT"", 32)
        'hallo\\x00welt'

        Key greater than 255
        >>> XORCipher().encrypt_string(""hallo welt"", 256)
        'hallo welt'
        """"""

        # precondition
        assert isinstance(key, int)
        assert isinstance(content, str)

        key = key or self.__key or 1

        # make sure key is an appropriate size
        key %= 256

        # This will be returned
        ans = """"

        for ch in content:
            ans += chr(ord(ch) ^ key)

        return ans",data\repos\Python\ciphers\xor_cipher.py,encrypt_string,252
485,xor_cipher.py::decrypt_string::144,"    def decrypt_string(self, content: str, key: int = 0) -> str:
        """"""
        input: 'content' of type string and 'key' of type int
        output: decrypted string 'content'
        if key not passed the method uses the key by the constructor.
        otherwise key = 1

        Empty list
        >>> XORCipher().decrypt_string("""", 5)
        ''

        One key
        >>> XORCipher().decrypt_string(""hallo welt"", 1)
        'i`mmn!vdmu'

        Normal key
        >>> XORCipher().decrypt_string(""HALLO WELT"", 32)
        'hallo\\x00welt'

        Key greater than 255
        >>> XORCipher().decrypt_string(""hallo welt"", 256)
        'hallo welt'
        """"""

        # precondition
        assert isinstance(key, int)
        assert isinstance(content, str)

        key = key or self.__key or 1

        # make sure key is an appropriate size
        key %= 256

        # This will be returned
        ans = """"

        for ch in content:
            ans += chr(ord(ch) ^ key)

        return ans",data\repos\Python\ciphers\xor_cipher.py,decrypt_string,252
486,xor_cipher.py::encrypt_file::185,"    def encrypt_file(self, file: str, key: int = 0) -> bool:
        """"""
        input: filename (str) and a key (int)
        output: returns true if encrypt process was
        successful otherwise false
        if key not passed the method uses the key by the constructor.
        otherwise key = 1
        """"""

        # precondition
        assert isinstance(file, str)
        assert isinstance(key, int)

        # make sure key is an appropriate size
        key %= 256

        try:
            with open(file) as fin, open(""encrypt.out"", ""w+"") as fout:
                # actual encrypt-process
                for line in fin:
                    fout.write(self.encrypt_string(line, key))

        except OSError:
            return False

        return True",data\repos\Python\ciphers\xor_cipher.py,encrypt_file,162
487,xor_cipher.py::decrypt_file::212,"    def decrypt_file(self, file: str, key: int) -> bool:
        """"""
        input: filename (str) and a key (int)
        output: returns true if decrypt process was
        successful otherwise false
        if key not passed the method uses the key by the constructor.
        otherwise key = 1
        """"""

        # precondition
        assert isinstance(file, str)
        assert isinstance(key, int)

        # make sure key is an appropriate size
        key %= 256

        try:
            with open(file) as fin, open(""decrypt.out"", ""w+"") as fout:
                # actual encrypt-process
                for line in fin:
                    fout.write(self.decrypt_string(line, key))

        except OSError:
            return False

        return True",data\repos\Python\ciphers\xor_cipher.py,decrypt_file,159
488,flip_augmentation.py::main::20,"def main() -> None:
    """"""
    Get images list and annotations list from input dir.
    Update new images and annotations.
    Save images and annotations in output dir.
    """"""
    img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)
    print(""Processing..."")
    new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)

    for index, image in enumerate(new_images):
        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'
        letter_code = random_chars(32)
        file_name = paths[index].split(os.sep)[-1].rsplit(""."", 1)[0]
        file_root = f""{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}""
        cv2.imwrite(f""{file_root}.jpg"", image, [cv2.IMWRITE_JPEG_QUALITY, 85])
        print(f""Success {index + 1}/{len(new_images)} with {file_name}"")
        annos_list = []
        for anno in new_annos[index]:
            obj = f""{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}""
            annos_list.append(obj)
        with open(f""{file_root}.txt"", ""w"") as outfile:
            outfile.write(""\n"".join(line for line in annos_list))",data\repos\Python\computer_vision\flip_augmentation.py,main,295
489,flip_augmentation.py::get_dataset::45,"def get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:
    """"""
    - label_dir <type: str>: Path to label include annotation of images
    - img_dir <type: str>: Path to folder contain images
    Return <type: list>: List of images path and labels
    """"""
    img_paths = []
    labels = []
    for label_file in glob.glob(os.path.join(label_dir, ""*.txt"")):
        label_name = label_file.split(os.sep)[-1].rsplit(""."", 1)[0]
        with open(label_file) as in_file:
            obj_lists = in_file.readlines()
        img_path = os.path.join(img_dir, f""{label_name}.jpg"")

        boxes = []
        for obj_list in obj_lists:
            obj = obj_list.rstrip(""\n"").split("" "")
            boxes.append(
                [
                    int(obj[0]),
                    float(obj[1]),
                    float(obj[2]),
                    float(obj[3]),
                    float(obj[4]),
                ]
            )
        if not boxes:
            continue
        img_paths.append(img_path)
        labels.append(boxes)
    return img_paths, labels",data\repos\Python\computer_vision\flip_augmentation.py,get_dataset,241
490,flip_augmentation.py::update_image_and_anno::78,"def update_image_and_anno(
    img_list: list, anno_list: list, flip_type: int = 1
) -> tuple[list, list, list]:
    """"""
    - img_list <type: list>: list of all images
    - anno_list <type: list>: list of all annotations of specific image
    - flip_type <type: int>: 0 is vertical, 1 is horizontal
    Return:
        - new_imgs_list <type: narray>: image after resize
        - new_annos_lists <type: list>: list of new annotation after scale
        - path_list <type: list>: list the name of image file
    """"""
    new_annos_lists = []
    path_list = []
    new_imgs_list = []
    for idx in range(len(img_list)):
        new_annos = []
        path = img_list[idx]
        path_list.append(path)
        img_annos = anno_list[idx]
        img = cv2.imread(path)
        if flip_type == 1:
            new_img = cv2.flip(img, flip_type)
            for bbox in img_annos:
                x_center_new = 1 - bbox[1]
                new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])
        elif flip_type == 0:
            new_img = cv2.flip(img, flip_type)
            for bbox in img_annos:
                y_center_new = 1 - bbox[2]
                new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])
        new_annos_lists.append(new_annos)
        new_imgs_list.append(new_img)
    return new_imgs_list, new_annos_lists, path_list",data\repos\Python\computer_vision\flip_augmentation.py,update_image_and_anno,367
491,flip_augmentation.py::random_chars::114,"def random_chars(number_char: int = 32) -> str:
    """"""
    Automatic generate random 32 characters.
    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'
    >>> len(random_chars(32))
    32
    """"""
    assert number_char > 1, ""The number of character should greater than 1""
    letter_code = ascii_lowercase + digits
    return """".join(random.choice(letter_code) for _ in range(number_char))",data\repos\Python\computer_vision\flip_augmentation.py,random_chars,107
492,haralick_descriptors.py::root_mean_square_error::10,"def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:
    """"""Simple implementation of Root Mean Squared Error
    for two N dimensional numpy arrays.

    Examples:
        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([1, 2, 3]))
        0.0
        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([2, 2, 2]))
        0.816496580927726
        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([6, 4, 2]))
        3.1622776601683795
    """"""
    return float(np.sqrt(((original - reference) ** 2).mean()))",data\repos\Python\computer_vision\haralick_descriptors.py,root_mean_square_error,169
493,haralick_descriptors.py::normalize_image::25,"def normalize_image(
    image: np.ndarray, cap: float = 255.0, data_type: np.dtype = np.uint8
) -> np.ndarray:
    """"""
    Normalizes image in Numpy 2D array format, between ranges 0-cap,
    as to fit uint8 type.

    Args:
        image: 2D numpy array representing image as matrix, with values in any range
        cap: Maximum cap amount for normalization
        data_type: numpy data type to set output variable to
    Returns:
        return 2D numpy array of type uint8, corresponding to limited range matrix

    Examples:
        >>> normalize_image(np.array([[1, 2, 3], [4, 5, 10]]),
        ...                 cap=1.0, data_type=np.float64)
        array([[0.        , 0.11111111, 0.22222222],
               [0.33333333, 0.44444444, 1.        ]])
        >>> normalize_image(np.array([[4, 4, 3], [1, 7, 2]]))
        array([[127, 127,  85],
               [  0, 255,  42]], dtype=uint8)
    """"""
    normalized = (image - np.min(image)) / (np.max(image) - np.min(image)) * cap
    return normalized.astype(data_type)",data\repos\Python\computer_vision\haralick_descriptors.py,normalize_image,301
494,haralick_descriptors.py::normalize_array::52,"def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:
    """"""Normalizes a 1D array, between ranges 0-cap.

    Args:
        array: List containing values to be normalized between cap range.
        cap: Maximum cap amount for normalization.
    Returns:
        return 1D numpy array, corresponding to limited range array

    Examples:
        >>> normalize_array(np.array([2, 3, 5, 7]))
        array([0. , 0.2, 0.6, 1. ])
        >>> normalize_array(np.array([[5], [7], [11], [13]]))
        array([[0.  ],
               [0.25],
               [0.75],
               [1.  ]])
    """"""
    diff = np.max(array) - np.min(array)
    return (array - np.min(array)) / (1 if diff == 0 else diff) * cap",data\repos\Python\computer_vision\haralick_descriptors.py,normalize_array,199
495,haralick_descriptors.py::grayscale::74,"def grayscale(image: np.ndarray) -> np.ndarray:
    """"""
    Uses luminance weights to transform RGB channel to greyscale, by
    taking the dot product between the channel and the weights.

    Example:
        >>> grayscale(np.array([[[108, 201, 72], [255, 11,  127]],
        ...                     [[56,  56,  56], [128, 255, 107]]]))
        array([[158,  97],
               [ 56, 200]], dtype=uint8)
    """"""
    return np.dot(image[:, :, 0:3], [0.299, 0.587, 0.114]).astype(np.uint8)",data\repos\Python\computer_vision\haralick_descriptors.py,grayscale,148
496,haralick_descriptors.py::binarize::88,"def binarize(image: np.ndarray, threshold: float = 127.0) -> np.ndarray:
    """"""
    Binarizes a grayscale image based on a given threshold value,
    setting values to 1 or 0 accordingly.

    Examples:
        >>> binarize(np.array([[128, 255], [101, 156]]))
        array([[1, 1],
               [0, 1]])
        >>> binarize(np.array([[0.07, 1], [0.51, 0.3]]), threshold=0.5)
        array([[0, 1],
               [1, 0]])
    """"""
    return np.where(image > threshold, 1, 0)",data\repos\Python\computer_vision\haralick_descriptors.py,binarize,150
497,haralick_descriptors.py::transform::104,"def transform(
    image: np.ndarray, kind: str, kernel: np.ndarray | None = None
) -> np.ndarray:
    """"""
    Simple image transformation using one of two available filter functions:
    Erosion and Dilation.

    Args:
        image: binarized input image, onto which to apply transformation
        kind: Can be either 'erosion', in which case the :func:np.max
              function is called, or 'dilation', when :func:np.min is used instead.
        kernel: n x n kernel with shape < :attr:image.shape,
              to be used when applying convolution to original image

    Returns:
        returns a numpy array with same shape as input image,
        corresponding to applied binary transformation.

    Examples:
        >>> img = np.array([[1, 0.5], [0.2, 0.7]])
        >>> img = binarize(img, threshold=0.5)
        >>> transform(img, 'erosion')
        array([[1, 1],
               [1, 1]], dtype=uint8)
        >>> transform(img, 'dilation')
        array([[0, 0],
               [0, 0]], dtype=uint8)
    """"""
    if kernel is None:
        kernel = np.ones((3, 3))

    if kind == ""erosion"":
        constant = 1
        apply = np.max
    else:
        constant = 0
        apply = np.min

    center_x, center_y = (x // 2 for x in kernel.shape)

    # Use padded image when applying convolution
    # to not go out of bounds of the original the image
    transformed = np.zeros(image.shape, dtype=np.uint8)
    padded = np.pad(image, 1, ""constant"", constant_values=constant)

    for x in range(center_x, padded.shape[0] - center_x):
        for y in range(center_y, padded.shape[1] - center_y):
            center = padded[
                x - center_x : x + center_x + 1, y - center_y : y + center_y + 1
            ]
            # Apply transformation method to the centered section of the image
            transformed[x - center_x, y - center_y] = apply(center[kernel == 1])

    return transformed",data\repos\Python\computer_vision\haralick_descriptors.py,transform,486
498,haralick_descriptors.py::opening_filter::160,"def opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:
    """"""
    Opening filter, defined as the sequence of
    erosion and then a dilation filter on the same image.

    Examples:
        >>> img = np.array([[1, 0.5], [0.2, 0.7]])
        >>> img = binarize(img, threshold=0.5)
        >>> opening_filter(img)
        array([[1, 1],
               [1, 1]], dtype=uint8)
    """"""
    if kernel is None:
        np.ones((3, 3))

    return transform(transform(image, ""dilation"", kernel), ""erosion"", kernel)",data\repos\Python\computer_vision\haralick_descriptors.py,opening_filter,148
499,haralick_descriptors.py::closing_filter::178,"def closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:
    """"""
    Opening filter, defined as the sequence of
    dilation and then erosion filter on the same image.

    Examples:
        >>> img = np.array([[1, 0.5], [0.2, 0.7]])
        >>> img = binarize(img, threshold=0.5)
        >>> closing_filter(img)
        array([[0, 0],
               [0, 0]], dtype=uint8)
    """"""
    if kernel is None:
        kernel = np.ones((3, 3))
    return transform(transform(image, ""erosion"", kernel), ""dilation"", kernel)",data\repos\Python\computer_vision\haralick_descriptors.py,closing_filter,149
500,haralick_descriptors.py::binary_mask::195,"def binary_mask(
    image_gray: np.ndarray, image_map: np.ndarray
) -> tuple[np.ndarray, np.ndarray]:
    """"""
    Apply binary mask, or thresholding based
    on bit mask value (mapping mask is binary).

    Returns the mapped true value mask and its complementary false value mask.

    Example:
        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
        ...                 [[56,  56,  56], [128, 255, 107]]])
        >>> gray = grayscale(img)
        >>> binary = binarize(gray)
        >>> morphological = opening_filter(binary)
        >>> binary_mask(gray, morphological)
        (array([[1, 1],
               [1, 1]], dtype=uint8), array([[158,  97],
               [ 56, 200]], dtype=uint8))
    """"""
    true_mask, false_mask = image_gray.copy(), image_gray.copy()
    true_mask[image_map == 1] = 1
    false_mask[image_map == 0] = 0

    return true_mask, false_mask",data\repos\Python\computer_vision\haralick_descriptors.py,binary_mask,242
501,haralick_descriptors.py::matrix_concurrency::222,"def matrix_concurrency(image: np.ndarray, coordinate: tuple[int, int]) -> np.ndarray:
    """"""
    Calculate sample co-occurrence matrix based on input image
    as well as selected coordinates on image.

    Implementation is made using basic iteration,
    as function to be performed (np.max) is non-linear and therefore
    not callable on the frequency domain.

    Example:
        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
        ...                 [[56,  56,  56], [128, 255, 107]]])
        >>> gray = grayscale(img)
        >>> binary = binarize(gray)
        >>> morphological = opening_filter(binary)
        >>> mask_1 = binary_mask(gray, morphological)[0]
        >>> matrix_concurrency(mask_1, (0, 1))
        array([[0., 0.],
               [0., 0.]])
    """"""
    matrix = np.zeros([np.max(image) + 1, np.max(image) + 1])

    offset_x, offset_y = coordinate

    for x in range(1, image.shape[0] - 1):
        for y in range(1, image.shape[1] - 1):
            base_pixel = image[x, y]
            offset_pixel = image[x + offset_x, y + offset_y]

            matrix[base_pixel, offset_pixel] += 1
    matrix_sum = np.sum(matrix)
    return matrix / (1 if matrix_sum == 0 else matrix_sum)",data\repos\Python\computer_vision\haralick_descriptors.py,matrix_concurrency,329
502,haralick_descriptors.py::haralick_descriptors::256,"def haralick_descriptors(matrix: np.ndarray) -> list[float]:
    """"""Calculates all 8 Haralick descriptors based on co-occurrence input matrix.
    All descriptors are as follows:
    Maximum probability, Inverse Difference, Homogeneity, Entropy,
    Energy, Dissimilarity, Contrast and Correlation

    Args:
        matrix: Co-occurrence matrix to use as base for calculating descriptors.

    Returns:
        Reverse ordered list of resulting descriptors

    Example:
        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
        ...                 [[56,  56,  56], [128, 255, 107]]])
        >>> gray = grayscale(img)
        >>> binary = binarize(gray)
        >>> morphological = opening_filter(binary)
        >>> mask_1 = binary_mask(gray, morphological)[0]
        >>> concurrency = matrix_concurrency(mask_1, (0, 1))
        >>> [float(f) for f in haralick_descriptors(concurrency)]
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    """"""
    # Function np.indices could be used for bigger input types,
    # but np.ogrid works just fine
    i, j = np.ogrid[0 : matrix.shape[0], 0 : matrix.shape[1]]  # np.indices()

    # Pre-calculate frequent multiplication and subtraction
    prod = np.multiply(i, j)
    sub = np.subtract(i, j)

    # Calculate numerical value of Maximum Probability
    maximum_prob = np.max(matrix)
    # Using the definition for each descriptor individually to calculate its matrix
    correlation = prod * matrix
    energy = np.power(matrix, 2)
    contrast = matrix * np.power(sub, 2)

    dissimilarity = matrix * np.abs(sub)
    inverse_difference = matrix / (1 + np.abs(sub))
    homogeneity = matrix / (1 + np.power(sub, 2))
    entropy = -(matrix[matrix > 0] * np.log(matrix[matrix > 0]))

    # Sum values for descriptors ranging from the first one to the last,
    # as all are their respective origin matrix and not the resulting value yet.
    return [
        maximum_prob,
        correlation.sum(),
        energy.sum(),
        contrast.sum(),
        dissimilarity.sum(),
        inverse_difference.sum(),
        homogeneity.sum(),
        entropy.sum(),
    ]",data\repos\Python\computer_vision\haralick_descriptors.py,haralick_descriptors,543
503,haralick_descriptors.py::get_descriptors::313,"def get_descriptors(
    masks: tuple[np.ndarray, np.ndarray], coordinate: tuple[int, int]
) -> np.ndarray:
    """"""
    Calculate all Haralick descriptors for a sequence of
    different co-occurrence matrices, given input masks and coordinates.

    Example:
        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
        ...                 [[56,  56,  56], [128, 255, 107]]])
        >>> gray = grayscale(img)
        >>> binary = binarize(gray)
        >>> morphological = opening_filter(binary)
        >>> get_descriptors(binary_mask(gray, morphological), (0, 1))
        array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
    """"""
    descriptors = np.array(
        [haralick_descriptors(matrix_concurrency(mask, coordinate)) for mask in masks]
    )

    # Concatenate each individual descriptor into
    # one single list containing sequence of descriptors
    return np.concatenate(descriptors, axis=None)",data\repos\Python\computer_vision\haralick_descriptors.py,get_descriptors,260
504,haralick_descriptors.py::euclidean::338,"def euclidean(point_1: np.ndarray, point_2: np.ndarray) -> float:
    """"""
    Simple method for calculating the euclidean distance between two points,
    with type np.ndarray.

    Example:
        >>> a = np.array([1, 0, -2])
        >>> b = np.array([2, -1, 1])
        >>> euclidean(a, b)
        3.3166247903554
    """"""
    return float(np.sqrt(np.sum(np.square(point_1 - point_2))))",data\repos\Python\computer_vision\haralick_descriptors.py,euclidean,111
505,haralick_descriptors.py::get_distances::352,"def get_distances(descriptors: np.ndarray, base: int) -> list[tuple[int, float]]:
    """"""
    Calculate all Euclidean distances between a selected base descriptor
    and all other Haralick descriptors
    The resulting comparison is return in decreasing order,
    showing which descriptor is the most similar to the selected base.

    Args:
        descriptors: Haralick descriptors to compare with base index
        base: Haralick descriptor index to use as base when calculating respective
        euclidean distance to other descriptors.

    Returns:
        Ordered distances between descriptors

    Example:
        >>> index = 1
        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
        ...                 [[56,  56,  56], [128, 255, 107]]])
        >>> gray = grayscale(img)
        >>> binary = binarize(gray)
        >>> morphological = opening_filter(binary)
        >>> get_distances(get_descriptors(
        ...                 binary_mask(gray, morphological), (0, 1)),
        ...               index)
        [(0, 0.0), (1, 0.0), (2, 0.0), (3, 0.0), (4, 0.0), (5, 0.0), \
(6, 0.0), (7, 0.0), (8, 0.0), (9, 0.0), (10, 0.0), (11, 0.0), (12, 0.0), \
(13, 0.0), (14, 0.0), (15, 0.0)]
    """"""
    distances = np.array(
        [euclidean(descriptor, descriptors[base]) for descriptor in descriptors]
    )
    # Normalize distances between range [0, 1]
    normalized_distances: list[float] = normalize_array(distances, 1).tolist()
    enum_distances = list(enumerate(normalized_distances))
    enum_distances.sort(key=lambda tup: tup[1], reverse=True)
    return enum_distances",data\repos\Python\computer_vision\haralick_descriptors.py,get_distances,446
506,harris_corner.py::detect::26,"    def detect(self, img_path: str) -> tuple[cv2.Mat, list[list[int]]]:
        """"""
        Returns the image with corners identified
        img_path  : path of the image
        output : list of the corner positions, image
        """"""

        img = cv2.imread(img_path, 0)
        h, w = img.shape
        corner_list: list[list[int]] = []
        color_img = img.copy()
        color_img = cv2.cvtColor(color_img, cv2.COLOR_GRAY2RGB)
        dy, dx = np.gradient(img)
        ixx = dx**2
        iyy = dy**2
        ixy = dx * dy
        k = 0.04
        offset = self.window_size // 2
        for y in range(offset, h - offset):
            for x in range(offset, w - offset):
                wxx = ixx[
                    y - offset : y + offset + 1, x - offset : x + offset + 1
                ].sum()
                wyy = iyy[
                    y - offset : y + offset + 1, x - offset : x + offset + 1
                ].sum()
                wxy = ixy[
                    y - offset : y + offset + 1, x - offset : x + offset + 1
                ].sum()

                det = (wxx * wyy) - (wxy**2)
                trace = wxx + wyy
                r = det - k * (trace**2)
                # Can change the value
                if r > 0.5:
                    corner_list.append([x, y, r])
                    color_img.itemset((y, x, 0), 0)
                    color_img.itemset((y, x, 1), 0)
                    color_img.itemset((y, x, 2), 255)
        return color_img, corner_list",data\repos\Python\computer_vision\harris_corner.py,detect,405
507,horn_schunck.py::warp::18,"def warp(
    image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray
) -> np.ndarray:
    """"""
    Warps the pixels of an image into a new image using the horizontal and vertical
    flows.
    Pixels that are warped from an invalid location are set to 0.

    Parameters:
        image: Grayscale image
        horizontal_flow: Horizontal flow
        vertical_flow: Vertical flow

    Returns: Warped image

    >>> warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]), \
    np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]), \
    np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]]))
    array([[0, 0, 0],
           [3, 1, 0],
           [0, 2, 3]])
    """"""
    flow = np.stack((horizontal_flow, vertical_flow), 2)

    # Create a grid of all pixel coordinates and subtract the flow to get the
    # target pixels coordinates
    grid = np.stack(
        np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2
    )
    grid = np.round(grid - flow).astype(np.int32)

    # Find the locations outside of the original image
    invalid = (grid < 0) | (grid >= np.array([image.shape[1], image.shape[0]]))
    grid[invalid] = 0

    warped = image[grid[:, :, 1], grid[:, :, 0]]

    # Set pixels at invalid locations to 0
    warped[invalid[:, :, 0] | invalid[:, :, 1]] = 0

    return warped",data\repos\Python\computer_vision\horn_schunck.py,warp,410
508,horn_schunck.py::horn_schunck::61,"def horn_schunck(
    image0: np.ndarray,
    image1: np.ndarray,
    num_iter: SupportsIndex,
    alpha: float | None = None,
) -> tuple[np.ndarray, np.ndarray]:
    """"""
    This function performs the Horn-Schunck algorithm and returns the estimated
    optical flow. It is assumed that the input images are grayscale and
    normalized to be in [0, 1].

    Parameters:
        image0: First image of the sequence
        image1: Second image of the sequence
        alpha: Regularization constant
        num_iter: Number of iterations performed

    Returns: estimated horizontal & vertical flow

    >>> np.round(horn_schunck(np.array([[0, 0, 2], [0, 0, 2]]), \
    np.array([[0, 2, 0], [0, 2, 0]]), alpha=0.1, num_iter=110)).\
    astype(np.int32)
    array([[[ 0, -1, -1],
            [ 0, -1, -1]],
    <BLANKLINE>
           [[ 0,  0,  0],
            [ 0,  0,  0]]], dtype=int32)
    """"""
    if alpha is None:
        alpha = 0.1

    # Initialize flow
    horizontal_flow = np.zeros_like(image0)
    vertical_flow = np.zeros_like(image0)

    # Prepare kernels for the calculation of the derivatives and the average velocity
    kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25
    kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25
    kernel_t = np.array([[1, 1], [1, 1]]) * 0.25
    kernel_laplacian = np.array(
        [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]
    )

    # Iteratively refine the flow
    for _ in range(num_iter):
        warped_image = warp(image0, horizontal_flow, vertical_flow)
        derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)
        derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)
        derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)

        avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)
        avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)

        # This updates the flow as proposed in the paper (Step 12)
        update = (
            derivative_x * avg_horizontal_velocity
            + derivative_y * avg_vertical_velocity
            + derivative_t
        )
        update = update / (alpha**2 + derivative_x**2 + derivative_y**2)

        horizontal_flow = avg_horizontal_velocity - derivative_x * update
        vertical_flow = avg_vertical_velocity - derivative_y * update

    return horizontal_flow, vertical_flow",data\repos\Python\computer_vision\horn_schunck.py,horn_schunck,695
509,intensity_based_segmentation.py::segment_image::9,"def segment_image(image: np.ndarray, thresholds: list[int]) -> np.ndarray:
    """"""
    Performs image segmentation based on intensity thresholds.

    Args:
        image: Input grayscale image as a 2D array.
        thresholds: Intensity thresholds to define segments.

    Returns:
        A labeled 2D array where each region corresponds to a threshold range.

    Example:
        >>> img = np.array([[80, 120, 180], [40, 90, 150], [20, 60, 100]])
        >>> segment_image(img, [50, 100, 150])
        array([[1, 2, 3],
               [0, 1, 2],
               [0, 1, 1]], dtype=int32)
    """"""
    # Initialize segmented array with zeros
    segmented = np.zeros_like(image, dtype=np.int32)

    # Assign labels based on thresholds
    for i, threshold in enumerate(thresholds):
        segmented[image > threshold] = i + 1

    return segmented",data\repos\Python\computer_vision\intensity_based_segmentation.py,segment_image,216
510,mean_threshold.py::mean_threshold::9,"def mean_threshold(image: Image) -> Image:
    """"""
    image: is a grayscale PIL image object
    """"""
    height, width = image.size
    mean = 0
    pixels = image.load()
    for i in range(width):
        for j in range(height):
            pixel = pixels[j, i]
            mean += pixel
    mean //= width * height

    for j in range(width):
        for i in range(height):
            pixels[i, j] = 255 if pixels[i, j] > mean else 0
    return image",data\repos\Python\computer_vision\mean_threshold.py,mean_threshold,116
511,mosaic_augmentation.py::main::21,"def main() -> None:
    """"""
    Get images list and annotations list from input dir.
    Update new images and annotations.
    Save images and annotations in output dir.
    """"""
    img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)
    for index in range(NUMBER_IMAGES):
        idxs = random.sample(range(len(annos)), 4)
        new_image, new_annos, path = update_image_and_anno(
            img_paths,
            annos,
            idxs,
            OUTPUT_SIZE,
            SCALE_RANGE,
            filter_scale=FILTER_TINY_SCALE,
        )

        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'
        letter_code = random_chars(32)
        file_name = path.split(os.sep)[-1].rsplit(""."", 1)[0]
        file_root = f""{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}""
        cv2.imwrite(f""{file_root}.jpg"", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])
        print(f""Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}"")
        annos_list = []
        for anno in new_annos:
            width = anno[3] - anno[1]
            height = anno[4] - anno[2]
            x_center = anno[1] + width / 2
            y_center = anno[2] + height / 2
            obj = f""{anno[0]} {x_center} {y_center} {width} {height}""
            annos_list.append(obj)
        with open(f""{file_root}.txt"", ""w"") as outfile:
            outfile.write(""\n"".join(line for line in annos_list))",data\repos\Python\computer_vision\mosaic_augmentation.py,main,371
512,mosaic_augmentation.py::get_dataset::57,"def get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:
    """"""
    - label_dir <type: str>: Path to label include annotation of images
    - img_dir <type: str>: Path to folder contain images
    Return <type: list>: List of images path and labels
    """"""
    img_paths = []
    labels = []
    for label_file in glob.glob(os.path.join(label_dir, ""*.txt"")):
        label_name = label_file.split(os.sep)[-1].rsplit(""."", 1)[0]
        with open(label_file) as in_file:
            obj_lists = in_file.readlines()
        img_path = os.path.join(img_dir, f""{label_name}.jpg"")

        boxes = []
        for obj_list in obj_lists:
            obj = obj_list.rstrip(""\n"").split("" "")
            xmin = float(obj[1]) - float(obj[3]) / 2
            ymin = float(obj[2]) - float(obj[4]) / 2
            xmax = float(obj[1]) + float(obj[3]) / 2
            ymax = float(obj[2]) + float(obj[4]) / 2

            boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])
        if not boxes:
            continue
        img_paths.append(img_path)
        labels.append(boxes)
    return img_paths, labels",data\repos\Python\computer_vision\mosaic_augmentation.py,get_dataset,290
513,mosaic_augmentation.py::update_image_and_anno::87,"def update_image_and_anno(
    all_img_list: list,
    all_annos: list,
    idxs: list[int],
    output_size: tuple[int, int],
    scale_range: tuple[float, float],
    filter_scale: float = 0.0,
) -> tuple[list, list, str]:
    """"""
    - all_img_list <type: list>: list of all images
    - all_annos <type: list>: list of all annotations of specific image
    - idxs <type: list>: index of image in list
    - output_size <type: tuple>: size of output image (Height, Width)
    - scale_range <type: tuple>: range of scale image
    - filter_scale <type: float>: the condition of downscale image and bounding box
    Return:
        - output_img <type: narray>: image after resize
        - new_anno <type: list>: list of new annotation after scale
        - path[0] <type: string>: get the name of image file
    """"""
    output_img = np.zeros([output_size[0], output_size[1], 3], dtype=np.uint8)
    scale_x = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])
    scale_y = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])
    divid_point_x = int(scale_x * output_size[1])
    divid_point_y = int(scale_y * output_size[0])

    new_anno = []
    path_list = []
    for i, index in enumerate(idxs):
        path = all_img_list[index]
        path_list.append(path)
        img_annos = all_annos[index]
        img = cv2.imread(path)
        if i == 0:  # top-left
            img = cv2.resize(img, (divid_point_x, divid_point_y))
            output_img[:divid_point_y, :divid_point_x, :] = img
            for bbox in img_annos:
                xmin = bbox[1] * scale_x
                ymin = bbox[2] * scale_y
                xmax = bbox[3] * scale_x
                ymax = bbox[4] * scale_y
                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])
        elif i == 1:  # top-right
            img = cv2.resize(img, (output_size[1] - divid_point_x, divid_point_y))
            output_img[:divid_point_y, divid_point_x : output_size[1], :] = img
            for bbox in img_annos:
                xmin = scale_x + bbox[1] * (1 - scale_x)
                ymin = bbox[2] * scale_y
                xmax = scale_x + bbox[3] * (1 - scale_x)
                ymax = bbox[4] * scale_y
                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])
        elif i == 2:  # bottom-left
            img = cv2.resize(img, (divid_point_x, output_size[0] - divid_point_y))
            output_img[divid_point_y : output_size[0], :divid_point_x, :] = img
            for bbox in img_annos:
                xmin = bbox[1] * scale_x
                ymin = scale_y + bbox[2] * (1 - scale_y)
                xmax = bbox[3] * scale_x
                ymax = scale_y + bbox[4] * (1 - scale_y)
                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])
        else:  # bottom-right
            img = cv2.resize(
                img, (output_size[1] - divid_point_x, output_size[0] - divid_point_y)
            )
            output_img[
                divid_point_y : output_size[0], divid_point_x : output_size[1], :
            ] = img
            for bbox in img_annos:
                xmin = scale_x + bbox[1] * (1 - scale_x)
                ymin = scale_y + bbox[2] * (1 - scale_y)
                xmax = scale_x + bbox[3] * (1 - scale_x)
                ymax = scale_y + bbox[4] * (1 - scale_y)
                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])

    # Remove bounding box small than scale of filter
    if filter_scale > 0:
        new_anno = [
            anno
            for anno in new_anno
            if filter_scale < (anno[3] - anno[1]) and filter_scale < (anno[4] - anno[2])
        ]

    return output_img, new_anno, path_list[0]",data\repos\Python\computer_vision\mosaic_augmentation.py,update_image_and_anno,1024
514,mosaic_augmentation.py::random_chars::172,"def random_chars(number_char: int) -> str:
    """"""
    Automatic generate random 32 characters.
    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'
    >>> len(random_chars(32))
    32
    """"""
    assert number_char > 1, ""The number of character should greater than 1""
    letter_code = ascii_lowercase + digits
    return """".join(random.choice(letter_code) for _ in range(number_char))",data\repos\Python\computer_vision\mosaic_augmentation.py,random_chars,104
515,pooling_functions.py::maxpooling::8,"def maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:
    """"""
    This function is used to perform maxpooling on the input array of 2D matrix(image)
    Args:
        arr: numpy array
        size: size of pooling matrix
        stride: the number of pixels shifts over the input matrix
    Returns:
        numpy array of maxpooled matrix
    Sample Input Output:
    >>> maxpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)
    array([[ 6.,  8.],
           [14., 16.]])
    >>> maxpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)
    array([[241., 180.],
           [241., 157.]])
    """"""
    arr = np.array(arr)
    if arr.shape[0] != arr.shape[1]:
        raise ValueError(""The input array is not a square matrix"")
    i = 0
    j = 0
    mat_i = 0
    mat_j = 0

    # compute the shape of the output matrix
    maxpool_shape = (arr.shape[0] - size) // stride + 1
    # initialize the output matrix with zeros of shape maxpool_shape
    updated_arr = np.zeros((maxpool_shape, maxpool_shape))

    while i < arr.shape[0]:
        if i + size > arr.shape[0]:
            # if the end of the matrix is reached, break
            break
        while j < arr.shape[1]:
            # if the end of the matrix is reached, break
            if j + size > arr.shape[1]:
                break
            # compute the maximum of the pooling matrix
            updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])
            # shift the pooling matrix by stride of column pixels
            j += stride
            mat_j += 1

        # shift the pooling matrix by stride of row pixels
        i += stride
        mat_i += 1

        # reset the column index to 0
        j = 0
        mat_j = 0

    return updated_arr",data\repos\Python\computer_vision\pooling_functions.py,maxpooling,510
516,pooling_functions.py::avgpooling::64,"def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:
    """"""
    This function is used to perform avgpooling on the input array of 2D matrix(image)
    Args:
        arr: numpy array
        size: size of pooling matrix
        stride: the number of pixels shifts over the input matrix
    Returns:
        numpy array of avgpooled matrix
    Sample Input Output:
    >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)
    array([[ 3.,  5.],
           [11., 13.]])
    >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)
    array([[161., 102.],
           [114.,  69.]])
    """"""
    arr = np.array(arr)
    if arr.shape[0] != arr.shape[1]:
        raise ValueError(""The input array is not a square matrix"")
    i = 0
    j = 0
    mat_i = 0
    mat_j = 0

    # compute the shape of the output matrix
    avgpool_shape = (arr.shape[0] - size) // stride + 1
    # initialize the output matrix with zeros of shape avgpool_shape
    updated_arr = np.zeros((avgpool_shape, avgpool_shape))

    while i < arr.shape[0]:
        # if the end of the matrix is reached, break
        if i + size > arr.shape[0]:
            break
        while j < arr.shape[1]:
            # if the end of the matrix is reached, break
            if j + size > arr.shape[1]:
                break
            # compute the average of the pooling matrix
            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))
            # shift the pooling matrix by stride of column pixels
            j += stride
            mat_j += 1

        # shift the pooling matrix by stride of row pixels
        i += stride
        mat_i += 1
        # reset the column index to 0
        j = 0
        mat_j = 0

    return updated_arr",data\repos\Python\computer_vision\pooling_functions.py,avgpooling,512
517,astronomical_length_scale_conversion.py::length_conversion::46,"def length_conversion(value: float, from_type: str, to_type: str) -> float:
    """"""
    Conversion between astronomical length units.

    >>> length_conversion(1, ""meter"", ""kilometer"")
    0.001
    >>> length_conversion(1, ""meter"", ""megametre"")
    1e-06
    >>> length_conversion(1, ""gigametre"", ""meter"")
    1000000000
    >>> length_conversion(1, ""gigametre"", ""terametre"")
    0.001
    >>> length_conversion(1, ""petametre"", ""terametre"")
    1000
    >>> length_conversion(1, ""petametre"", ""exametre"")
    0.001
    >>> length_conversion(1, ""terametre"", ""zettametre"")
    1e-09
    >>> length_conversion(1, ""yottametre"", ""zettametre"")
    1000
    >>> length_conversion(4, ""wrongUnit"", ""inch"")
    Traceback (most recent call last):
      ...
    ValueError: Invalid 'from_type' value: 'wrongUnit'.
    Conversion abbreviations are: m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym
    """"""

    from_sanitized = from_type.lower().strip(""s"")
    to_sanitized = to_type.lower().strip(""s"")

    from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)
    to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)

    if from_sanitized not in METRIC_CONVERSION:
        msg = (
            f""Invalid 'from_type' value: {from_type!r}.\n""
            f""Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}""
        )
        raise ValueError(msg)
    if to_sanitized not in METRIC_CONVERSION:
        msg = (
            f""Invalid 'to_type' value: {to_type!r}.\n""
            f""Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}""
        )
        raise ValueError(msg)
    from_exponent = METRIC_CONVERSION[from_sanitized]
    to_exponent = METRIC_CONVERSION[to_sanitized]
    exponent = 1

    if from_exponent > to_exponent:
        exponent = from_exponent - to_exponent
    else:
        exponent = -(to_exponent - from_exponent)

    return value * pow(10, exponent)",data\repos\Python\conversions\astronomical_length_scale_conversion.py,length_conversion,538
518,binary_to_decimal.py::bin_to_decimal::1,"def bin_to_decimal(bin_string: str) -> int:
    """"""
    Convert a binary value to its decimal equivalent

    >>> bin_to_decimal(""101"")
    5
    >>> bin_to_decimal("" 1010   "")
    10
    >>> bin_to_decimal(""-11101"")
    -29
    >>> bin_to_decimal(""0"")
    0
    >>> bin_to_decimal(""a"")
    Traceback (most recent call last):
        ...
    ValueError: Non-binary value was passed to the function
    >>> bin_to_decimal("""")
    Traceback (most recent call last):
        ...
    ValueError: Empty string was passed to the function
    >>> bin_to_decimal(""39"")
    Traceback (most recent call last):
        ...
    ValueError: Non-binary value was passed to the function
    """"""
    bin_string = str(bin_string).strip()
    if not bin_string:
        raise ValueError(""Empty string was passed to the function"")
    is_negative = bin_string[0] == ""-""
    if is_negative:
        bin_string = bin_string[1:]
    if not all(char in ""01"" for char in bin_string):
        raise ValueError(""Non-binary value was passed to the function"")
    decimal_number = 0
    for char in bin_string:
        decimal_number = 2 * decimal_number + int(char)
    return -decimal_number if is_negative else decimal_number",data\repos\Python\conversions\binary_to_decimal.py,bin_to_decimal,287
519,binary_to_hexadecimal.py::bin_to_hexadecimal::21,"def bin_to_hexadecimal(binary_str: str) -> str:
    """"""
    Converting a binary string into hexadecimal using Grouping Method

    >>> bin_to_hexadecimal('101011111')
    '0x15f'
    >>> bin_to_hexadecimal(' 1010   ')
    '0x0a'
    >>> bin_to_hexadecimal('-11101')
    '-0x1d'
    >>> bin_to_hexadecimal('a')
    Traceback (most recent call last):
        ...
    ValueError: Non-binary value was passed to the function
    >>> bin_to_hexadecimal('')
    Traceback (most recent call last):
        ...
    ValueError: Empty string was passed to the function
    """"""
    # Sanitising parameter
    binary_str = str(binary_str).strip()

    # Exceptions
    if not binary_str:
        raise ValueError(""Empty string was passed to the function"")
    is_negative = binary_str[0] == ""-""
    binary_str = binary_str[1:] if is_negative else binary_str
    if not all(char in ""01"" for char in binary_str):
        raise ValueError(""Non-binary value was passed to the function"")

    binary_str = (
        ""0"" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str
    )

    hexadecimal = []
    for x in range(0, len(binary_str), 4):
        hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])
    hexadecimal_str = ""0x"" + """".join(hexadecimal)

    return ""-"" + hexadecimal_str if is_negative else hexadecimal_str",data\repos\Python\conversions\binary_to_hexadecimal.py,bin_to_hexadecimal,341
520,binary_to_octal.py::bin_to_octal::21,"def bin_to_octal(bin_string: str) -> str:
    if not all(char in ""01"" for char in bin_string):
        raise ValueError(""Non-binary value was passed to the function"")
    if not bin_string:
        raise ValueError(""Empty string was passed to the function"")
    oct_string = """"
    while len(bin_string) % 3 != 0:
        bin_string = ""0"" + bin_string
    bin_string_in_3_list = [
        bin_string[index : index + 3]
        for index in range(len(bin_string))
        if index % 3 == 0
    ]
    for bin_group in bin_string_in_3_list:
        oct_val = 0
        for index, val in enumerate(bin_group):
            oct_val += int(2 ** (2 - index) * int(val))
        oct_string += str(oct_val)
    return oct_string",data\repos\Python\conversions\binary_to_octal.py,bin_to_octal,187
521,convert_number_to_words.py::convert_small_number::95,"def convert_small_number(num: int) -> str:
    """"""
    Converts small, non-negative integers with irregular constructions in English (i.e.,
    numbers under 100) into words.

    >>> convert_small_number(0)
    'zero'
    >>> convert_small_number(5)
    'five'
    >>> convert_small_number(10)
    'ten'
    >>> convert_small_number(15)
    'fifteen'
    >>> convert_small_number(20)
    'twenty'
    >>> convert_small_number(25)
    'twenty-five'
    >>> convert_small_number(-1)
    Traceback (most recent call last):
    ...
    ValueError: This function only accepts non-negative integers
    >>> convert_small_number(123)
    Traceback (most recent call last):
    ...
    ValueError: This function only converts numbers less than 100
    """"""
    if num < 0:
        raise ValueError(""This function only accepts non-negative integers"")
    if num >= 100:
        raise ValueError(""This function only converts numbers less than 100"")
    tens, ones = divmod(num, 10)
    if tens == 0:
        return NumberWords.ONES.value[ones] or ""zero""
    if tens == 1:
        return NumberWords.TEENS.value[ones]
    return (
        NumberWords.TENS.value[tens]
        + (""-"" if NumberWords.ONES.value[ones] else """")
        + NumberWords.ONES.value[ones]
    )",data\repos\Python\conversions\convert_number_to_words.py,convert_small_number,307
522,convert_number_to_words.py::convert_number::137,"def convert_number(
    num: int, system: Literal[""short"", ""long"", ""indian""] = ""short""
) -> str:
    """"""
    Converts an integer to English words.

    :param num: The integer to be converted
    :param system: The numbering system (short, long, or Indian)

    >>> convert_number(0)
    'zero'
    >>> convert_number(1)
    'one'
    >>> convert_number(100)
    'one hundred'
    >>> convert_number(-100)
    'negative one hundred'
    >>> convert_number(123_456_789_012_345) # doctest: +NORMALIZE_WHITESPACE
    'one hundred twenty-three trillion four hundred fifty-six billion
    seven hundred eighty-nine million twelve thousand three hundred forty-five'
    >>> convert_number(123_456_789_012_345, ""long"") # doctest: +NORMALIZE_WHITESPACE
    'one hundred twenty-three thousand four hundred fifty-six milliard
    seven hundred eighty-nine million twelve thousand three hundred forty-five'
    >>> convert_number(12_34_56_78_90_12_345, ""indian"") # doctest: +NORMALIZE_WHITESPACE
    'one crore crore twenty-three lakh crore
    forty-five thousand six hundred seventy-eight crore
    ninety lakh twelve thousand three hundred forty-five'
    >>> convert_number(10**18)
    Traceback (most recent call last):
    ...
    ValueError: Input number is too large
    >>> convert_number(10**21, ""long"")
    Traceback (most recent call last):
    ...
    ValueError: Input number is too large
    >>> convert_number(10**19, ""indian"")
    Traceback (most recent call last):
    ...
    ValueError: Input number is too large
    """"""
    word_groups = []

    if num < 0:
        word_groups.append(""negative"")
        num *= -1

    if num > NumberingSystem.max_value(system):
        raise ValueError(""Input number is too large"")

    for power, unit in NumberingSystem[system.upper()].value:
        digit_group, num = divmod(num, 10**power)
        if digit_group > 0:
            word_group = (
                convert_number(digit_group, system)
                if digit_group >= 100
                else convert_small_number(digit_group)
            )
            word_groups.append(f""{word_group} {unit}"")
    if num > 0 or not word_groups:  # word_groups is only empty if input num was 0
        word_groups.append(convert_small_number(num))
    return "" "".join(word_groups)",data\repos\Python\conversions\convert_number_to_words.py,convert_number,553
523,convert_number_to_words.py::max_value::33,"    def max_value(cls, system: str) -> int:
        """"""
        Gets the max value supported by the given number system.

        >>> NumberingSystem.max_value(""short"") == 10**18 - 1
        True
        >>> NumberingSystem.max_value(""long"") == 10**21 - 1
        True
        >>> NumberingSystem.max_value(""indian"") == 10**19 - 1
        True
        """"""
        match system_enum := cls[system.upper()]:
            case cls.SHORT:
                max_exp = system_enum.value[0][0] + 3
            case cls.LONG:
                max_exp = system_enum.value[0][0] + 6
            case cls.INDIAN:
                max_exp = 19
            case _:
                raise ValueError(""Invalid numbering system"")
        return 10**max_exp - 1",data\repos\Python\conversions\convert_number_to_words.py,max_value,187
524,decimal_to_any.py::decimal_to_any::8,"def decimal_to_any(num: int, base: int) -> str:
    """"""
    Convert a positive integer to another base as str.
    >>> decimal_to_any(0, 2)
    '0'
    >>> decimal_to_any(5, 4)
    '11'
    >>> decimal_to_any(20, 3)
    '202'
    >>> decimal_to_any(58, 16)
    '3A'
    >>> decimal_to_any(243, 17)
    'E5'
    >>> decimal_to_any(34923, 36)
    'QY3'
    >>> decimal_to_any(10, 11)
    'A'
    >>> decimal_to_any(16, 16)
    '10'
    >>> decimal_to_any(36, 36)
    '10'
    >>> # negatives will error
    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValueError: parameter must be positive int
    >>> # floats will error
    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: int() can't convert non-string with explicit base
    >>> # a float base will error
    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> # a str base will error
    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: 'str' object cannot be interpreted as an integer
    >>> # a base less than 2 will error
    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValueError: base must be >= 2
    >>> # a base greater than 36 will error
    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValueError: base must be <= 36
    """"""
    if isinstance(num, float):
        raise TypeError(""int() can't convert non-string with explicit base"")
    if num < 0:
        raise ValueError(""parameter must be positive int"")
    if isinstance(base, str):
        raise TypeError(""'str' object cannot be interpreted as an integer"")
    if isinstance(base, float):
        raise TypeError(""'float' object cannot be interpreted as an integer"")
    if base in (0, 1):
        raise ValueError(""base must be >= 2"")
    if base > 36:
        raise ValueError(""base must be <= 36"")
    new_value = """"
    mod = 0
    div = 0
    while div != 1:
        div, mod = divmod(num, base)
        if base >= 11 and 9 < mod < 36:
            actual_value = ALPHABET_VALUES[str(mod)]
        else:
            actual_value = str(mod)
        new_value += actual_value
        div = num // base
        num = div
        if div == 0:
            return str(new_value[::-1])
        elif div == 1:
            new_value += str(div)
            return str(new_value[::-1])

    return new_value[::-1]",data\repos\Python\conversions\decimal_to_any.py,decimal_to_any,743
525,decimal_to_binary.py::decimal_to_binary_iterative::4,"def decimal_to_binary_iterative(num: int) -> str:
    """"""
    Convert an Integer Decimal Number to a Binary Number as str.
    >>> decimal_to_binary_iterative(0)
    '0b0'
    >>> decimal_to_binary_iterative(2)
    '0b10'
    >>> decimal_to_binary_iterative(7)
    '0b111'
    >>> decimal_to_binary_iterative(35)
    '0b100011'
    >>> # negatives work too
    >>> decimal_to_binary_iterative(-2)
    '-0b10'
    >>> # other floats will error
    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> # strings will error as well
    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: 'str' object cannot be interpreted as an integer
    """"""

    if isinstance(num, float):
        raise TypeError(""'float' object cannot be interpreted as an integer"")
    if isinstance(num, str):
        raise TypeError(""'str' object cannot be interpreted as an integer"")

    if num == 0:
        return ""0b0""

    negative = False

    if num < 0:
        negative = True
        num = -num

    binary: list[int] = []
    while num > 0:
        binary.insert(0, num % 2)
        num >>= 1

    if negative:
        return ""-0b"" + """".join(str(e) for e in binary)

    return ""0b"" + """".join(str(e) for e in binary)",data\repos\Python\conversions\decimal_to_binary.py,decimal_to_binary_iterative,376
526,decimal_to_binary.py::decimal_to_binary_recursive_helper::55,"def decimal_to_binary_recursive_helper(decimal: int) -> str:
    """"""
    Take a positive integer value and return its binary equivalent.
    >>> decimal_to_binary_recursive_helper(1000)
    '1111101000'
    >>> decimal_to_binary_recursive_helper(""72"")
    '1001000'
    >>> decimal_to_binary_recursive_helper(""number"")
    Traceback (most recent call last):
        ...
    ValueError: invalid literal for int() with base 10: 'number'
    """"""
    decimal = int(decimal)
    if decimal in (0, 1):  # Exit cases for the recursion
        return str(decimal)
    div, mod = divmod(decimal, 2)
    return decimal_to_binary_recursive_helper(div) + str(mod)",data\repos\Python\conversions\decimal_to_binary.py,decimal_to_binary_recursive_helper,154
527,decimal_to_binary.py::decimal_to_binary_recursive::74,"def decimal_to_binary_recursive(number: str) -> str:
    """"""
    Take an integer value and raise ValueError for wrong inputs,
    call the function above and return the output with prefix ""0b"" & ""-0b""
    for positive and negative integers respectively.
    >>> decimal_to_binary_recursive(0)
    '0b0'
    >>> decimal_to_binary_recursive(40)
    '0b101000'
    >>> decimal_to_binary_recursive(-40)
    '-0b101000'
    >>> decimal_to_binary_recursive(40.8)
    Traceback (most recent call last):
        ...
    ValueError: Input value is not an integer
    >>> decimal_to_binary_recursive(""forty"")
    Traceback (most recent call last):
        ...
    ValueError: Input value is not an integer
    """"""
    number = str(number).strip()
    if not number:
        raise ValueError(""No input value was provided"")
    negative = ""-"" if number.startswith(""-"") else """"
    number = number.lstrip(""-"")
    if not number.isnumeric():
        raise ValueError(""Input value is not an integer"")
    return f""{negative}0b{decimal_to_binary_recursive_helper(int(number))}""",data\repos\Python\conversions\decimal_to_binary.py,decimal_to_binary_recursive,244
528,decimal_to_hexadecimal.py::decimal_to_hexadecimal::24,"def decimal_to_hexadecimal(decimal: float) -> str:
    """"""
    take integer decimal value, return hexadecimal representation as str beginning
    with 0x
    >>> decimal_to_hexadecimal(5)
    '0x5'
    >>> decimal_to_hexadecimal(15)
    '0xf'
    >>> decimal_to_hexadecimal(37)
    '0x25'
    >>> decimal_to_hexadecimal(255)
    '0xff'
    >>> decimal_to_hexadecimal(4096)
    '0x1000'
    >>> decimal_to_hexadecimal(999098)
    '0xf3eba'
    >>> # negatives work too
    >>> decimal_to_hexadecimal(-256)
    '-0x100'
    >>> # floats are acceptable if equivalent to an int
    >>> decimal_to_hexadecimal(17.0)
    '0x11'
    >>> # other floats will error
    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    AssertionError
    >>> # strings will error as well
    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    AssertionError
    >>> # results are the same when compared to Python's default hex function
    >>> decimal_to_hexadecimal(-256) == hex(-256)
    True
    """"""
    assert isinstance(decimal, (int, float))
    assert decimal == int(decimal)
    decimal = int(decimal)
    hexadecimal = """"
    negative = False
    if decimal < 0:
        negative = True
        decimal *= -1
    while decimal > 0:
        decimal, remainder = divmod(decimal, 16)
        hexadecimal = values[remainder] + hexadecimal
    hexadecimal = ""0x"" + hexadecimal
    if negative:
        hexadecimal = ""-"" + hexadecimal
    return hexadecimal",data\repos\Python\conversions\decimal_to_hexadecimal.py,decimal_to_hexadecimal,399
529,decimal_to_octal.py::decimal_to_octal::9,"def decimal_to_octal(num: int) -> str:
    """"""Convert a Decimal Number to an Octal Number.

    >>> all(decimal_to_octal(i) == oct(i) for i
    ...     in (0, 2, 8, 64, 65, 216, 255, 256, 512))
    True
    """"""
    octal = 0
    counter = 0
    while num > 0:
        remainder = num % 8
        octal = octal + (remainder * math.floor(math.pow(10, counter)))
        counter += 1
        num = math.floor(num / 8)  # basically /= 8 without remainder if any
        # This formatting removes trailing '.0' from `octal`.
    return f""0o{int(octal)}""",data\repos\Python\conversions\decimal_to_octal.py,decimal_to_octal,176
530,decimal_to_octal.py::main::27,"def main() -> None:
    """"""Print octal equivalents of decimal numbers.""""""
    print(""\n2 in octal is:"")
    print(decimal_to_octal(2))  # = 2
    print(""\n8 in octal is:"")
    print(decimal_to_octal(8))  # = 10
    print(""\n65 in octal is:"")
    print(decimal_to_octal(65))  # = 101
    print(""\n216 in octal is:"")
    print(decimal_to_octal(216))  # = 330
    print(""\n512 in octal is:"")
    print(decimal_to_octal(512))  # = 1000
    print(""\n"")",data\repos\Python\conversions\decimal_to_octal.py,main,147
531,energy_conversions.py::energy_conversion::45,"def energy_conversion(from_type: str, to_type: str, value: float) -> float:
    """"""
    Conversion of energy units.
    >>> energy_conversion(""joule"", ""joule"", 1)
    1.0
    >>> energy_conversion(""joule"", ""kilojoule"", 1)
    0.001
    >>> energy_conversion(""joule"", ""megajoule"", 1)
    1e-06
    >>> energy_conversion(""joule"", ""gigajoule"", 1)
    1e-09
    >>> energy_conversion(""joule"", ""wattsecond"", 1)
    1.0
    >>> energy_conversion(""joule"", ""watthour"", 1)
    0.0002777777777777778
    >>> energy_conversion(""joule"", ""kilowatthour"", 1)
    2.7777777777777776e-07
    >>> energy_conversion(""joule"", ""newtonmeter"", 1)
    1.0
    >>> energy_conversion(""joule"", ""calorie_nutr"", 1)
    0.00023884589662749592
    >>> energy_conversion(""joule"", ""kilocalorie_nutr"", 1)
    2.388458966274959e-07
    >>> energy_conversion(""joule"", ""electronvolt"", 1)
    6.241509074460763e+18
    >>> energy_conversion(""joule"", ""britishthermalunit_it"", 1)
    0.0009478171226670134
    >>> energy_conversion(""joule"", ""footpound"", 1)
    0.7375621211696556
    >>> energy_conversion(""joule"", ""megajoule"", 1000)
    0.001
    >>> energy_conversion(""calorie_nutr"", ""kilocalorie_nutr"", 1000)
    1.0
    >>> energy_conversion(""kilowatthour"", ""joule"", 10)
    36000000.0
    >>> energy_conversion(""britishthermalunit_it"", ""footpound"", 1)
    778.1692306784539
    >>> energy_conversion(""watthour"", ""joule"", ""a"") # doctest: +ELLIPSIS
    Traceback (most recent call last):
      ...
    TypeError: unsupported operand type(s) for /: 'str' and 'float'
    >>> energy_conversion(""wrongunit"", ""joule"", 1) # doctest: +ELLIPSIS
    Traceback (most recent call last):
      ...
    ValueError: Incorrect 'from_type' or 'to_type' value: 'wrongunit', 'joule'
    Valid values are: joule, ... footpound
    >>> energy_conversion(""joule"", ""wrongunit"", 1) # doctest: +ELLIPSIS
    Traceback (most recent call last):
      ...
    ValueError: Incorrect 'from_type' or 'to_type' value: 'joule', 'wrongunit'
    Valid values are: joule, ... footpound
    >>> energy_conversion(""123"", ""abc"", 1) # doctest: +ELLIPSIS
    Traceback (most recent call last):
      ...
    ValueError: Incorrect 'from_type' or 'to_type' value: '123', 'abc'
    Valid values are: joule, ... footpound
    """"""
    if to_type not in ENERGY_CONVERSION or from_type not in ENERGY_CONVERSION:
        msg = (
            f""Incorrect 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\n""
            f""Valid values are: {', '.join(ENERGY_CONVERSION)}""
        )
        raise ValueError(msg)
    return value * ENERGY_CONVERSION[from_type] / ENERGY_CONVERSION[to_type]",data\repos\Python\conversions\energy_conversions.py,energy_conversion,855
532,excel_title_to_column.py::excel_title_to_column::1,"def excel_title_to_column(column_title: str) -> int:
    """"""
    Given a string column_title that represents
    the column title in an Excel sheet, return
    its corresponding column number.

    >>> excel_title_to_column(""A"")
    1
    >>> excel_title_to_column(""B"")
    2
    >>> excel_title_to_column(""AB"")
    28
    >>> excel_title_to_column(""Z"")
    26
    """"""
    assert column_title.isupper()
    answer = 0
    index = len(column_title) - 1
    power = 0

    while index >= 0:
        value = (ord(column_title[index]) - 64) * pow(26, power)
        answer += value
        power += 1
        index -= 1

    return answer",data\repos\Python\conversions\excel_title_to_column.py,excel_title_to_column,172
533,hexadecimal_to_decimal.py::hex_to_decimal::4,"def hex_to_decimal(hex_string: str) -> int:
    """"""
    Convert a hexadecimal value to its decimal equivalent
    #https://www.programiz.com/python-programming/methods/built-in/hex

    >>> hex_to_decimal(""a"")
    10
    >>> hex_to_decimal(""12f"")
    303
    >>> hex_to_decimal(""   12f   "")
    303
    >>> hex_to_decimal(""FfFf"")
    65535
    >>> hex_to_decimal(""-Ff"")
    -255
    >>> hex_to_decimal(""F-f"")
    Traceback (most recent call last):
        ...
    ValueError: Non-hexadecimal value was passed to the function
    >>> hex_to_decimal("""")
    Traceback (most recent call last):
        ...
    ValueError: Empty string was passed to the function
    >>> hex_to_decimal(""12m"")
    Traceback (most recent call last):
        ...
    ValueError: Non-hexadecimal value was passed to the function
    """"""
    hex_string = hex_string.strip().lower()
    if not hex_string:
        raise ValueError(""Empty string was passed to the function"")
    is_negative = hex_string[0] == ""-""
    if is_negative:
        hex_string = hex_string[1:]
    if not all(char in hex_table for char in hex_string):
        raise ValueError(""Non-hexadecimal value was passed to the function"")
    decimal_number = 0
    for char in hex_string:
        decimal_number = 16 * decimal_number + hex_table[char]
    return -decimal_number if is_negative else decimal_number",data\repos\Python\conversions\hexadecimal_to_decimal.py,hex_to_decimal,332
534,hex_to_bin.py::hex_to_bin::1,"def hex_to_bin(hex_num: str) -> int:
    """"""
    Convert a hexadecimal value to its binary equivalent
    #https://stackoverflow.com/questions/1425493/convert-hex-to-binary
    Here, we have used the bitwise right shift operator: >>
    Shifts the bits of the number to the right and fills 0 on voids left as a result.
    Similar effect as of dividing the number with some power of two.
    Example:
    a = 10
    a >> 1 = 5

    >>> hex_to_bin(""AC"")
    10101100
    >>> hex_to_bin(""9A4"")
    100110100100
    >>> hex_to_bin(""   12f   "")
    100101111
    >>> hex_to_bin(""FfFf"")
    1111111111111111
    >>> hex_to_bin(""-fFfF"")
    -1111111111111111
    >>> hex_to_bin(""F-f"")
    Traceback (most recent call last):
        ...
    ValueError: Invalid value was passed to the function
    >>> hex_to_bin("""")
    Traceback (most recent call last):
        ...
    ValueError: No value was passed to the function
    """"""

    hex_num = hex_num.strip()
    if not hex_num:
        raise ValueError(""No value was passed to the function"")

    is_negative = hex_num[0] == ""-""
    if is_negative:
        hex_num = hex_num[1:]

    try:
        int_num = int(hex_num, 16)
    except ValueError:
        raise ValueError(""Invalid value was passed to the function"")

    bin_str = """"
    while int_num > 0:
        bin_str = str(int_num % 2) + bin_str
        int_num >>= 1

    return int((""-"" + bin_str) if is_negative else bin_str)",data\repos\Python\conversions\hex_to_bin.py,hex_to_bin,394
535,ipv4_conversion.py::ipv4_to_decimal::4,"def ipv4_to_decimal(ipv4_address: str) -> int:
    """"""
    Convert an IPv4 address to its decimal representation.

    Args:
        ip_address: A string representing an IPv4 address (e.g., ""192.168.0.1"").

    Returns:
        int: The decimal representation of the IP address.

    >>> ipv4_to_decimal(""192.168.0.1"")
    3232235521
    >>> ipv4_to_decimal(""10.0.0.255"")
    167772415
    >>> ipv4_to_decimal(""10.0.255"")
    Traceback (most recent call last):
        ...
    ValueError: Invalid IPv4 address format
    >>> ipv4_to_decimal(""10.0.0.256"")
    Traceback (most recent call last):
        ...
    ValueError: Invalid IPv4 octet 256
    """"""

    octets = [int(octet) for octet in ipv4_address.split(""."")]
    if len(octets) != 4:
        raise ValueError(""Invalid IPv4 address format"")

    decimal_ipv4 = 0
    for octet in octets:
        if not 0 <= octet <= 255:
            raise ValueError(f""Invalid IPv4 octet {octet}"")  # noqa: EM102
        decimal_ipv4 = (decimal_ipv4 << 8) + int(octet)

    return decimal_ipv4",data\repos\Python\conversions\ipv4_conversion.py,ipv4_to_decimal,298
536,ipv4_conversion.py::alt_ipv4_to_decimal::41,"def alt_ipv4_to_decimal(ipv4_address: str) -> int:
    """"""
    >>> alt_ipv4_to_decimal(""192.168.0.1"")
    3232235521
    >>> alt_ipv4_to_decimal(""10.0.0.255"")
    167772415
    """"""
    return int(""0x"" + """".join(f""{int(i):02x}"" for i in ipv4_address.split(""."")), 16)",data\repos\Python\conversions\ipv4_conversion.py,alt_ipv4_to_decimal,95
537,ipv4_conversion.py::decimal_to_ipv4::51,"def decimal_to_ipv4(decimal_ipv4: int) -> str:
    """"""
    Convert a decimal representation of an IP address to its IPv4 format.

    Args:
        decimal_ipv4: An integer representing the decimal IP address.

    Returns:
        The IPv4 representation of the decimal IP address.

    >>> decimal_to_ipv4(3232235521)
    '192.168.0.1'
    >>> decimal_to_ipv4(167772415)
    '10.0.0.255'
    >>> decimal_to_ipv4(-1)
    Traceback (most recent call last):
        ...
    ValueError: Invalid decimal IPv4 address
    """"""

    if not (0 <= decimal_ipv4 <= 4294967295):
        raise ValueError(""Invalid decimal IPv4 address"")

    ip_parts = []
    for _ in range(4):
        ip_parts.append(str(decimal_ipv4 & 255))
        decimal_ipv4 >>= 8

    return ""."".join(reversed(ip_parts))",data\repos\Python\conversions\ipv4_conversion.py,decimal_to_ipv4,204
538,length_conversion.py::length_conversion::58,"def length_conversion(value: float, from_type: str, to_type: str) -> float:
    """"""
    Conversion between length units.

    >>> length_conversion(4, ""METER"", ""FEET"")
    13.12336
    >>> length_conversion(4, ""M"", ""FT"")
    13.12336
    >>> length_conversion(1, ""meter"", ""kilometer"")
    0.001
    >>> length_conversion(1, ""kilometer"", ""inch"")
    39370.1
    >>> length_conversion(3, ""kilometer"", ""mile"")
    1.8641130000000001
    >>> length_conversion(2, ""feet"", ""meter"")
    0.6096
    >>> length_conversion(4, ""feet"", ""yard"")
    1.333329312
    >>> length_conversion(1, ""inch"", ""meter"")
    0.0254
    >>> length_conversion(2, ""inch"", ""mile"")
    3.15656468e-05
    >>> length_conversion(2, ""centimeter"", ""millimeter"")
    20.0
    >>> length_conversion(2, ""centimeter"", ""yard"")
    0.0218722
    >>> length_conversion(4, ""yard"", ""meter"")
    3.6576
    >>> length_conversion(4, ""yard"", ""kilometer"")
    0.0036576
    >>> length_conversion(3, ""foot"", ""meter"")
    0.9144000000000001
    >>> length_conversion(3, ""foot"", ""inch"")
    36.00001944
    >>> length_conversion(4, ""mile"", ""kilometer"")
    6.43736
    >>> length_conversion(2, ""miles"", ""InChEs"")
    126719.753468
    >>> length_conversion(3, ""millimeter"", ""centimeter"")
    0.3
    >>> length_conversion(3, ""mm"", ""in"")
    0.1181103
    >>> length_conversion(4, ""wrongUnit"", ""inch"")
    Traceback (most recent call last):
      ...
    ValueError: Invalid 'from_type' value: 'wrongUnit'.
    Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi
    """"""
    new_from = from_type.lower().rstrip(""s"")
    new_from = TYPE_CONVERSION.get(new_from, new_from)
    new_to = to_type.lower().rstrip(""s"")
    new_to = TYPE_CONVERSION.get(new_to, new_to)
    if new_from not in METRIC_CONVERSION:
        msg = (
            f""Invalid 'from_type' value: {from_type!r}.\n""
            f""Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}""
        )
        raise ValueError(msg)
    if new_to not in METRIC_CONVERSION:
        msg = (
            f""Invalid 'to_type' value: {to_type!r}.\n""
            f""Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}""
        )
        raise ValueError(msg)
    return (
        value
        * METRIC_CONVERSION[new_from].from_factor
        * METRIC_CONVERSION[new_to].to_factor
    )",data\repos\Python\conversions\length_conversion.py,length_conversion,706
539,molecular_chemistry.py::molarity_to_normality::10,"def molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:
    """"""
    Convert molarity to normality.
      Volume is taken in litres.

      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration
      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration

      >>> molarity_to_normality(2, 3.1, 0.31)
      20
      >>> molarity_to_normality(4, 11.4, 5.7)
      8
    """"""
    return round(float(moles / volume) * nfactor)",data\repos\Python\conversions\molecular_chemistry.py,molarity_to_normality,133
540,molecular_chemistry.py::moles_to_pressure::26,"def moles_to_pressure(volume: float, moles: float, temperature: float) -> float:
    """"""
    Convert moles to pressure.
      Ideal gas laws are used.
      Temperature is taken in kelvin.
      Volume is taken in litres.
      Pressure has atm as SI unit.

      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

      >>> moles_to_pressure(0.82, 3, 300)
      90
      >>> moles_to_pressure(8.2, 5, 200)
      10
    """"""
    return round(float((moles * 0.0821 * temperature) / (volume)))",data\repos\Python\conversions\molecular_chemistry.py,moles_to_pressure,165
541,molecular_chemistry.py::moles_to_volume::46,"def moles_to_volume(pressure: float, moles: float, temperature: float) -> float:
    """"""
    Convert moles to volume.
      Ideal gas laws are used.
      Temperature is taken in kelvin.
      Volume is taken in litres.
      Pressure has atm as SI unit.

      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

      >>> moles_to_volume(0.82, 3, 300)
      90
      >>> moles_to_volume(8.2, 5, 200)
      10
    """"""
    return round(float((moles * 0.0821 * temperature) / (pressure)))",data\repos\Python\conversions\molecular_chemistry.py,moles_to_volume,167
542,molecular_chemistry.py::pressure_and_volume_to_temperature::66,"def pressure_and_volume_to_temperature(
    pressure: float, moles: float, volume: float
) -> float:
    """"""
    Convert pressure and volume to temperature.
      Ideal gas laws are used.
      Temperature is taken in kelvin.
      Volume is taken in litres.
      Pressure has atm as SI unit.

      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

      >>> pressure_and_volume_to_temperature(0.82, 1, 2)
      20
      >>> pressure_and_volume_to_temperature(8.2, 5, 3)
      60
    """"""
    return round(float((pressure * volume) / (0.0821 * moles)))",data\repos\Python\conversions\molecular_chemistry.py,pressure_and_volume_to_temperature,171
543,octal_to_binary.py::octal_to_binary::11,"def octal_to_binary(octal_number: str) -> str:
    """"""
    Convert an Octal number to Binary.

    >>> octal_to_binary(""17"")
    '001111'
    >>> octal_to_binary(""7"")
    '111'
    >>> octal_to_binary(""Av"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> octal_to_binary(""@#"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> octal_to_binary("""")
    Traceback (most recent call last):
        ...
    ValueError: Empty string was passed to the function
    """"""
    if not octal_number:
        raise ValueError(""Empty string was passed to the function"")

    binary_number = """"
    octal_digits = ""01234567""
    for digit in octal_number:
        if digit not in octal_digits:
            raise ValueError(""Non-octal value was passed to the function"")

        binary_digit = """"
        value = int(digit)
        for _ in range(3):
            binary_digit = str(value % 2) + binary_digit
            value //= 2
        binary_number += binary_digit

    return binary_number",data\repos\Python\conversions\octal_to_binary.py,octal_to_binary,265
544,octal_to_decimal.py::oct_to_decimal::1,"def oct_to_decimal(oct_string: str) -> int:
    """"""
    Convert a octal value to its decimal equivalent

    >>> oct_to_decimal("""")
    Traceback (most recent call last):
        ...
    ValueError: Empty string was passed to the function
    >>> oct_to_decimal(""-"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal(""e"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal(""8"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal(""-e"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal(""-8"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal(""1"")
    1
    >>> oct_to_decimal(""-1"")
    -1
    >>> oct_to_decimal(""12"")
    10
    >>> oct_to_decimal("" 12   "")
    10
    >>> oct_to_decimal(""-45"")
    -37
    >>> oct_to_decimal(""-"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal(""0"")
    0
    >>> oct_to_decimal(""-4055"")
    -2093
    >>> oct_to_decimal(""2-0Fm"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal("""")
    Traceback (most recent call last):
        ...
    ValueError: Empty string was passed to the function
    >>> oct_to_decimal(""19"")
    Traceback (most recent call last):
        ...
    ValueError: Non-octal value was passed to the function
    """"""
    oct_string = str(oct_string).strip()
    if not oct_string:
        raise ValueError(""Empty string was passed to the function"")
    is_negative = oct_string[0] == ""-""
    if is_negative:
        oct_string = oct_string[1:]
    if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):
        raise ValueError(""Non-octal value was passed to the function"")
    decimal_number = 0
    for char in oct_string:
        decimal_number = 8 * decimal_number + int(char)
    if is_negative:
        decimal_number = -decimal_number
    return decimal_number",data\repos\Python\conversions\octal_to_decimal.py,oct_to_decimal,567
545,octal_to_hexadecimal.py::octal_to_hex::1,"def octal_to_hex(octal: str) -> str:
    """"""
    Convert an Octal number to Hexadecimal number.
    For more information: https://en.wikipedia.org/wiki/Octal

    >>> octal_to_hex(""100"")
    '0x40'
    >>> octal_to_hex(""235"")
    '0x9D'
    >>> octal_to_hex(17)
    Traceback (most recent call last):
        ...
    TypeError: Expected a string as input
    >>> octal_to_hex(""Av"")
    Traceback (most recent call last):
        ...
    ValueError: Not a Valid Octal Number
    >>> octal_to_hex("""")
    Traceback (most recent call last):
        ...
    ValueError: Empty string was passed to the function
    """"""

    if not isinstance(octal, str):
        raise TypeError(""Expected a string as input"")
    if octal.startswith(""0o""):
        octal = octal[2:]
    if octal == """":
        raise ValueError(""Empty string was passed to the function"")
    if any(char not in ""01234567"" for char in octal):
        raise ValueError(""Not a Valid Octal Number"")

    decimal = 0
    for char in octal:
        decimal <<= 3
        decimal |= int(char)

    hex_char = ""0123456789ABCDEF""

    revhex = """"
    while decimal:
        revhex += hex_char[decimal & 15]
        decimal >>= 4

    return ""0x"" + revhex[::-1]",data\repos\Python\conversions\octal_to_hexadecimal.py,octal_to_hex,320
546,prefix_conversions.py::convert_si_prefix::44,"def convert_si_prefix(
    known_amount: float,
    known_prefix: str | SIUnit,
    unknown_prefix: str | SIUnit,
) -> float:
    """"""
    Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix
    Wikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units
    >>> convert_si_prefix(1, SIUnit.giga, SIUnit.mega)
    1000
    >>> convert_si_prefix(1, SIUnit.mega, SIUnit.giga)
    0.001
    >>> convert_si_prefix(1, SIUnit.kilo, SIUnit.kilo)
    1
    >>> convert_si_prefix(1, 'giga', 'mega')
    1000
    >>> convert_si_prefix(1, 'gIGa', 'mEGa')
    1000
    """"""
    if isinstance(known_prefix, str):
        known_prefix = SIUnit[known_prefix.lower()]
    if isinstance(unknown_prefix, str):
        unknown_prefix = SIUnit[unknown_prefix.lower()]
    unknown_amount: float = known_amount * (
        10 ** (known_prefix.value - unknown_prefix.value)
    )
    return unknown_amount",data\repos\Python\conversions\prefix_conversions.py,convert_si_prefix,249
547,prefix_conversions.py::convert_binary_prefix::73,"def convert_binary_prefix(
    known_amount: float,
    known_prefix: str | BinaryUnit,
    unknown_prefix: str | BinaryUnit,
) -> float:
    """"""
    Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix
    >>> convert_binary_prefix(1, BinaryUnit.giga, BinaryUnit.mega)
    1024
    >>> convert_binary_prefix(1, BinaryUnit.mega, BinaryUnit.giga)
    0.0009765625
    >>> convert_binary_prefix(1, BinaryUnit.kilo, BinaryUnit.kilo)
    1
    >>> convert_binary_prefix(1, 'giga', 'mega')
    1024
    >>> convert_binary_prefix(1, 'gIGa', 'mEGa')
    1024
    """"""
    if isinstance(known_prefix, str):
        known_prefix = BinaryUnit[known_prefix.lower()]
    if isinstance(unknown_prefix, str):
        unknown_prefix = BinaryUnit[unknown_prefix.lower()]
    unknown_amount: float = known_amount * (
        2 ** ((known_prefix.value - unknown_prefix.value) * 10)
    )
    return unknown_amount",data\repos\Python\conversions\prefix_conversions.py,convert_binary_prefix,239
548,prefix_conversions_string.py::add_si_prefix::87,"def add_si_prefix(value: float) -> str:
    """"""
    Function that converts a number to his version with SI prefix
    @input value (an integer)
    @example:
    >>> add_si_prefix(10000)
    '10.0 kilo'
    """"""
    prefixes = SIUnit.get_positive() if value > 0 else SIUnit.get_negative()
    for name_prefix, value_prefix in prefixes.items():
        numerical_part = value / (10**value_prefix)
        if numerical_part > 1:
            return f""{numerical_part!s} {name_prefix}""
    return str(value)",data\repos\Python\conversions\prefix_conversions_string.py,add_si_prefix,126
549,prefix_conversions_string.py::add_binary_prefix::103,"def add_binary_prefix(value: float) -> str:
    """"""
    Function that converts a number to his version with Binary prefix
    @input value (an integer)
    @example:
    >>> add_binary_prefix(65536)
    '64.0 kilo'
    """"""
    for prefix in BinaryUnit:
        numerical_part = value / (2**prefix.value)
        if numerical_part > 1:
            return f""{numerical_part!s} {prefix.name}""
    return str(value)",data\repos\Python\conversions\prefix_conversions_string.py,add_binary_prefix,103
550,prefix_conversions_string.py::get_positive::56,"    def get_positive(cls) -> dict:
        """"""
        Returns a dictionary with only the elements of this enum
        that has a positive value
        >>> from itertools import islice
        >>> positive = SIUnit.get_positive()
        >>> inc = iter(positive.items())
        >>> dict(islice(inc, len(positive) // 2))
        {'yotta': 24, 'zetta': 21, 'exa': 18, 'peta': 15, 'tera': 12}
        >>> dict(inc)
        {'giga': 9, 'mega': 6, 'kilo': 3, 'hecto': 2, 'deca': 1}
        """"""
        return {unit.name: unit.value for unit in cls if unit.value > 0}",data\repos\Python\conversions\prefix_conversions_string.py,get_positive,170
551,prefix_conversions_string.py::get_negative::71,"    def get_negative(cls) -> dict:
        """"""
        Returns a dictionary with only the elements of this enum
        that has a negative value
        @example
        >>> from itertools import islice
        >>> negative = SIUnit.get_negative()
        >>> inc = iter(negative.items())
        >>> dict(islice(inc, len(negative) // 2))
        {'deci': -1, 'centi': -2, 'milli': -3, 'micro': -6, 'nano': -9}
        >>> dict(inc)
        {'pico': -12, 'femto': -15, 'atto': -18, 'zepto': -21, 'yocto': -24}
        """"""
        return {unit.name: unit.value for unit in cls if unit.value < 0}",data\repos\Python\conversions\prefix_conversions_string.py,get_negative,174
552,pressure_conversions.py::pressure_conversion::42,"def pressure_conversion(value: float, from_type: str, to_type: str) -> float:
    """"""
    Conversion between pressure units.
    >>> pressure_conversion(4, ""atm"", ""pascal"")
    405300
    >>> pressure_conversion(1, ""pascal"", ""psi"")
    0.00014401981999999998
    >>> pressure_conversion(1, ""bar"", ""atm"")
    0.986923
    >>> pressure_conversion(3, ""kilopascal"", ""bar"")
    0.029999991892499998
    >>> pressure_conversion(2, ""megapascal"", ""psi"")
    290.074434314
    >>> pressure_conversion(4, ""psi"", ""torr"")
    206.85984
    >>> pressure_conversion(1, ""inHg"", ""atm"")
    0.0334211
    >>> pressure_conversion(1, ""torr"", ""psi"")
    0.019336718261000002
    >>> pressure_conversion(4, ""wrongUnit"", ""atm"")
    Traceback (most recent call last):
        ...
    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:
    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr
    """"""
    if from_type not in PRESSURE_CONVERSION:
        raise ValueError(
            f""Invalid 'from_type' value: {from_type!r}  Supported values are:\n""
            + "", "".join(PRESSURE_CONVERSION)
        )
    if to_type not in PRESSURE_CONVERSION:
        raise ValueError(
            f""Invalid 'to_type' value: {to_type!r}.  Supported values are:\n""
            + "", "".join(PRESSURE_CONVERSION)
        )
    return (
        value
        * PRESSURE_CONVERSION[from_type].from_factor
        * PRESSURE_CONVERSION[to_type].to_factor
    )",data\repos\Python\conversions\pressure_conversions.py,pressure_conversion,420
553,rectangular_to_polar.py::rectangular_to_polar::4,"def rectangular_to_polar(real: float, img: float) -> tuple[float, float]:
    """"""
    https://en.wikipedia.org/wiki/Polar_coordinate_system

    >>> rectangular_to_polar(5,-5)
    (7.07, -45.0)
    >>> rectangular_to_polar(-1,1)
    (1.41, 135.0)
    >>> rectangular_to_polar(-1,-1)
    (1.41, -135.0)
    >>> rectangular_to_polar(1e-10,1e-10)
    (0.0, 45.0)
    >>> rectangular_to_polar(-1e-10,1e-10)
    (0.0, 135.0)
    >>> rectangular_to_polar(9.75,5.93)
    (11.41, 31.31)
    >>> rectangular_to_polar(10000,99999)
    (100497.76, 84.29)
    """"""

    mod = round(math.sqrt((real**2) + (img**2)), 2)
    ang = round(math.degrees(math.atan2(img, real)), 2)
    return (mod, ang)",data\repos\Python\conversions\rectangular_to_polar.py,rectangular_to_polar,252
554,rgb_cmyk_conversion.py::rgb_to_cmyk::1,"def rgb_to_cmyk(r_input: int, g_input: int, b_input: int) -> tuple[int, int, int, int]:
    """"""
    Simple RGB to CMYK conversion. Returns percentages of CMYK paint.
    https://www.programmingalgorithms.com/algorithm/rgb-to-cmyk/

    Note: this is a very popular algorithm that converts colors linearly and gives
    only approximate results. Actual preparation for printing requires advanced color
    conversion considering the color profiles and parameters of the target device.

    >>> rgb_to_cmyk(255, 200, ""a"")
    Traceback (most recent call last):
        ...
    ValueError: Expected int, found (<class 'int'>, <class 'int'>, <class 'str'>)

    >>> rgb_to_cmyk(255, 255, 999)
    Traceback (most recent call last):
        ...
    ValueError: Expected int of the range 0..255

    >>> rgb_to_cmyk(255, 255, 255)  # white
    (0, 0, 0, 0)

    >>> rgb_to_cmyk(128, 128, 128)  # gray
    (0, 0, 0, 50)

    >>> rgb_to_cmyk(0, 0, 0)    # black
    (0, 0, 0, 100)

    >>> rgb_to_cmyk(255, 0, 0)  # red
    (0, 100, 100, 0)

    >>> rgb_to_cmyk(0, 255, 0)  # green
    (100, 0, 100, 0)

    >>> rgb_to_cmyk(0, 0, 255)    # blue
    (100, 100, 0, 0)
    """"""

    if (
        not isinstance(r_input, int)
        or not isinstance(g_input, int)
        or not isinstance(b_input, int)
    ):
        msg = f""Expected int, found {type(r_input), type(g_input), type(b_input)}""
        raise ValueError(msg)

    if not 0 <= r_input < 256 or not 0 <= g_input < 256 or not 0 <= b_input < 256:
        raise ValueError(""Expected int of the range 0..255"")

    # changing range from 0..255 to 0..1
    r = r_input / 255
    g = g_input / 255
    b = b_input / 255

    k = 1 - max(r, g, b)

    if k == 1:  # pure black
        return 0, 0, 0, 100

    c = round(100 * (1 - r - k) / (1 - k))
    m = round(100 * (1 - g - k) / (1 - k))
    y = round(100 * (1 - b - k) / (1 - k))
    k = round(100 * k)

    return c, m, y, k",data\repos\Python\conversions\rgb_cmyk_conversion.py,rgb_to_cmyk,666
555,rgb_hsv_conversion.py::hsv_to_rgb::15,"def hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:
    """"""
    Conversion from the HSV-representation to the RGB-representation.
    Expected RGB-values taken from
    https://www.rapidtables.com/convert/color/hsv-to-rgb.html

    >>> hsv_to_rgb(0, 0, 0)
    [0, 0, 0]
    >>> hsv_to_rgb(0, 0, 1)
    [255, 255, 255]
    >>> hsv_to_rgb(0, 1, 1)
    [255, 0, 0]
    >>> hsv_to_rgb(60, 1, 1)
    [255, 255, 0]
    >>> hsv_to_rgb(120, 1, 1)
    [0, 255, 0]
    >>> hsv_to_rgb(240, 1, 1)
    [0, 0, 255]
    >>> hsv_to_rgb(300, 1, 1)
    [255, 0, 255]
    >>> hsv_to_rgb(180, 0.5, 0.5)
    [64, 128, 128]
    >>> hsv_to_rgb(234, 0.14, 0.88)
    [193, 196, 224]
    >>> hsv_to_rgb(330, 0.75, 0.5)
    [128, 32, 80]
    """"""
    if hue < 0 or hue > 360:
        raise Exception(""hue should be between 0 and 360"")

    if saturation < 0 or saturation > 1:
        raise Exception(""saturation should be between 0 and 1"")

    if value < 0 or value > 1:
        raise Exception(""value should be between 0 and 1"")

    chroma = value * saturation
    hue_section = hue / 60
    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))
    match_value = value - chroma

    if hue_section >= 0 and hue_section <= 1:
        red = round(255 * (chroma + match_value))
        green = round(255 * (second_largest_component + match_value))
        blue = round(255 * (match_value))
    elif hue_section > 1 and hue_section <= 2:
        red = round(255 * (second_largest_component + match_value))
        green = round(255 * (chroma + match_value))
        blue = round(255 * (match_value))
    elif hue_section > 2 and hue_section <= 3:
        red = round(255 * (match_value))
        green = round(255 * (chroma + match_value))
        blue = round(255 * (second_largest_component + match_value))
    elif hue_section > 3 and hue_section <= 4:
        red = round(255 * (match_value))
        green = round(255 * (second_largest_component + match_value))
        blue = round(255 * (chroma + match_value))
    elif hue_section > 4 and hue_section <= 5:
        red = round(255 * (second_largest_component + match_value))
        green = round(255 * (match_value))
        blue = round(255 * (chroma + match_value))
    else:
        red = round(255 * (chroma + match_value))
        green = round(255 * (match_value))
        blue = round(255 * (second_largest_component + match_value))

    return [red, green, blue]",data\repos\Python\conversions\rgb_hsv_conversion.py,hsv_to_rgb,771
556,rgb_hsv_conversion.py::rgb_to_hsv::84,"def rgb_to_hsv(red: int, green: int, blue: int) -> list[float]:
    """"""
    Conversion from the RGB-representation to the HSV-representation.
    The tested values are the reverse values from the hsv_to_rgb-doctests.
    Function ""approximately_equal_hsv"" is needed because of small deviations due to
    rounding for the RGB-values.

    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])
    True
    >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])
    True
    """"""
    if red < 0 or red > 255:
        raise Exception(""red should be between 0 and 255"")

    if green < 0 or green > 255:
        raise Exception(""green should be between 0 and 255"")

    if blue < 0 or blue > 255:
        raise Exception(""blue should be between 0 and 255"")

    float_red = red / 255
    float_green = green / 255
    float_blue = blue / 255
    value = max(float_red, float_green, float_blue)
    chroma = value - min(float_red, float_green, float_blue)
    saturation = 0 if value == 0 else chroma / value

    if chroma == 0:
        hue = 0.0
    elif value == float_red:
        hue = 60 * (0 + (float_green - float_blue) / chroma)
    elif value == float_green:
        hue = 60 * (2 + (float_blue - float_red) / chroma)
    else:
        hue = 60 * (4 + (float_red - float_green) / chroma)

    hue = (hue + 360) % 360

    return [hue, saturation, value]",data\repos\Python\conversions\rgb_hsv_conversion.py,rgb_to_hsv,666
557,rgb_hsv_conversion.py::approximately_equal_hsv::142,"def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:
    """"""
    Utility-function to check that two hsv-colors are approximately equal

    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])
    True
    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])
    True
    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])
    False
    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])
    False
    """"""
    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2
    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002
    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002

    return check_hue and check_saturation and check_value",data\repos\Python\conversions\rgb_hsv_conversion.py,approximately_equal_hsv,263
558,roman_numerals.py::roman_to_int::18,"def roman_to_int(roman: str) -> int:
    """"""
    LeetCode No. 13 Roman to Integer
    Given a roman numeral, convert it to an integer.
    Input is guaranteed to be within the range from 1 to 3999.
    https://en.wikipedia.org/wiki/Roman_numerals
    >>> tests = {""III"": 3, ""CLIV"": 154, ""MIX"": 1009, ""MMD"": 2500, ""MMMCMXCIX"": 3999}
    >>> all(roman_to_int(key) == value for key, value in tests.items())
    True
    """"""
    vals = {""I"": 1, ""V"": 5, ""X"": 10, ""L"": 50, ""C"": 100, ""D"": 500, ""M"": 1000}
    total = 0
    place = 0
    while place < len(roman):
        if (place + 1 < len(roman)) and (vals[roman[place]] < vals[roman[place + 1]]):
            total += vals[roman[place + 1]] - vals[roman[place]]
            place += 2
        else:
            total += vals[roman[place]]
            place += 1
    return total",data\repos\Python\conversions\roman_numerals.py,roman_to_int,276
559,roman_numerals.py::int_to_roman::41,"def int_to_roman(number: int) -> str:
    """"""
    Given a integer, convert it to an roman numeral.
    https://en.wikipedia.org/wiki/Roman_numerals
    >>> tests = {""III"": 3, ""CLIV"": 154, ""MIX"": 1009, ""MMD"": 2500, ""MMMCMXCIX"": 3999}
    >>> all(int_to_roman(value) == key for key, value in tests.items())
    True
    """"""
    result = []
    for arabic, roman in ROMAN:
        (factor, number) = divmod(number, arabic)
        result.append(roman * factor)
        if number == 0:
            break
    return """".join(result)",data\repos\Python\conversions\roman_numerals.py,int_to_roman,157
560,speed_conversions.py::convert_speed::25,"def convert_speed(speed: float, unit_from: str, unit_to: str) -> float:
    """"""
    Convert speed from one unit to another using the speed_chart above.

    ""km/h"": 1.0,
    ""m/s"": 3.6,
    ""mph"": 1.609344,
    ""knot"": 1.852,

    >>> convert_speed(100, ""km/h"", ""m/s"")
    27.778
    >>> convert_speed(100, ""km/h"", ""mph"")
    62.137
    >>> convert_speed(100, ""km/h"", ""knot"")
    53.996
    >>> convert_speed(100, ""m/s"", ""km/h"")
    360.0
    >>> convert_speed(100, ""m/s"", ""mph"")
    223.694
    >>> convert_speed(100, ""m/s"", ""knot"")
    194.384
    >>> convert_speed(100, ""mph"", ""km/h"")
    160.934
    >>> convert_speed(100, ""mph"", ""m/s"")
    44.704
    >>> convert_speed(100, ""mph"", ""knot"")
    86.898
    >>> convert_speed(100, ""knot"", ""km/h"")
    185.2
    >>> convert_speed(100, ""knot"", ""m/s"")
    51.444
    >>> convert_speed(100, ""knot"", ""mph"")
    115.078
    """"""
    if unit_to not in speed_chart or unit_from not in speed_chart_inverse:
        msg = (
            f""Incorrect 'from_type' or 'to_type' value: {unit_from!r}, {unit_to!r}\n""
            f""Valid values are: {', '.join(speed_chart_inverse)}""
        )
        raise ValueError(msg)
    return round(speed * speed_chart[unit_from] * speed_chart_inverse[unit_to], 3)",data\repos\Python\conversions\speed_conversions.py,convert_speed,416
561,temperature_conversions.py::celsius_to_fahrenheit::4,"def celsius_to_fahrenheit(celsius: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Celsius to Fahrenheit and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit

    >>> celsius_to_fahrenheit(273.354, 3)
    524.037
    >>> celsius_to_fahrenheit(273.354, 0)
    524.0
    >>> celsius_to_fahrenheit(-40.0)
    -40.0
    >>> celsius_to_fahrenheit(-20.0)
    -4.0
    >>> celsius_to_fahrenheit(0)
    32.0
    >>> celsius_to_fahrenheit(20)
    68.0
    >>> celsius_to_fahrenheit(""40"")
    104.0
    >>> celsius_to_fahrenheit(""celsius"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'celsius'
    """"""
    return round((float(celsius) * 9 / 5) + 32, ndigits)",data\repos\Python\conversions\temperature_conversions.py,celsius_to_fahrenheit,254
562,temperature_conversions.py::celsius_to_kelvin::32,"def celsius_to_kelvin(celsius: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Celsius to Kelvin and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin

    >>> celsius_to_kelvin(273.354, 3)
    546.504
    >>> celsius_to_kelvin(273.354, 0)
    547.0
    >>> celsius_to_kelvin(0)
    273.15
    >>> celsius_to_kelvin(20.0)
    293.15
    >>> celsius_to_kelvin(""40"")
    313.15
    >>> celsius_to_kelvin(""celsius"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'celsius'
    """"""
    return round(float(celsius) + 273.15, ndigits)",data\repos\Python\conversions\temperature_conversions.py,celsius_to_kelvin,215
563,temperature_conversions.py::celsius_to_rankine::56,"def celsius_to_rankine(celsius: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Celsius to Rankine and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale

    >>> celsius_to_rankine(273.354, 3)
    983.707
    >>> celsius_to_rankine(273.354, 0)
    984.0
    >>> celsius_to_rankine(0)
    491.67
    >>> celsius_to_rankine(20.0)
    527.67
    >>> celsius_to_rankine(""40"")
    563.67
    >>> celsius_to_rankine(""celsius"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'celsius'
    """"""
    return round((float(celsius) * 9 / 5) + 491.67, ndigits)",data\repos\Python\conversions\temperature_conversions.py,celsius_to_rankine,225
564,temperature_conversions.py::fahrenheit_to_celsius::80,"def fahrenheit_to_celsius(fahrenheit: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Fahrenheit to Celsius and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius

    >>> fahrenheit_to_celsius(273.354, 3)
    134.086
    >>> fahrenheit_to_celsius(273.354, 0)
    134.0
    >>> fahrenheit_to_celsius(0)
    -17.78
    >>> fahrenheit_to_celsius(20.0)
    -6.67
    >>> fahrenheit_to_celsius(40.0)
    4.44
    >>> fahrenheit_to_celsius(60)
    15.56
    >>> fahrenheit_to_celsius(80)
    26.67
    >>> fahrenheit_to_celsius(""100"")
    37.78
    >>> fahrenheit_to_celsius(""fahrenheit"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'fahrenheit'
    """"""
    return round((float(fahrenheit) - 32) * 5 / 9, ndigits)",data\repos\Python\conversions\temperature_conversions.py,fahrenheit_to_celsius,270
565,temperature_conversions.py::fahrenheit_to_kelvin::110,"def fahrenheit_to_kelvin(fahrenheit: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Fahrenheit to Kelvin and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin

    >>> fahrenheit_to_kelvin(273.354, 3)
    407.236
    >>> fahrenheit_to_kelvin(273.354, 0)
    407.0
    >>> fahrenheit_to_kelvin(0)
    255.37
    >>> fahrenheit_to_kelvin(20.0)
    266.48
    >>> fahrenheit_to_kelvin(40.0)
    277.59
    >>> fahrenheit_to_kelvin(60)
    288.71
    >>> fahrenheit_to_kelvin(80)
    299.82
    >>> fahrenheit_to_kelvin(""100"")
    310.93
    >>> fahrenheit_to_kelvin(""fahrenheit"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'fahrenheit'
    """"""
    return round(((float(fahrenheit) - 32) * 5 / 9) + 273.15, ndigits)",data\repos\Python\conversions\temperature_conversions.py,fahrenheit_to_kelvin,277
566,temperature_conversions.py::fahrenheit_to_rankine::140,"def fahrenheit_to_rankine(fahrenheit: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Fahrenheit to Rankine and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale

    >>> fahrenheit_to_rankine(273.354, 3)
    733.024
    >>> fahrenheit_to_rankine(273.354, 0)
    733.0
    >>> fahrenheit_to_rankine(0)
    459.67
    >>> fahrenheit_to_rankine(20.0)
    479.67
    >>> fahrenheit_to_rankine(40.0)
    499.67
    >>> fahrenheit_to_rankine(60)
    519.67
    >>> fahrenheit_to_rankine(80)
    539.67
    >>> fahrenheit_to_rankine(""100"")
    559.67
    >>> fahrenheit_to_rankine(""fahrenheit"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'fahrenheit'
    """"""
    return round(float(fahrenheit) + 459.67, ndigits)",data\repos\Python\conversions\temperature_conversions.py,fahrenheit_to_rankine,267
567,temperature_conversions.py::kelvin_to_celsius::170,"def kelvin_to_celsius(kelvin: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Kelvin to Celsius and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius

    >>> kelvin_to_celsius(273.354, 3)
    0.204
    >>> kelvin_to_celsius(273.354, 0)
    0.0
    >>> kelvin_to_celsius(273.15)
    0.0
    >>> kelvin_to_celsius(300)
    26.85
    >>> kelvin_to_celsius(""315.5"")
    42.35
    >>> kelvin_to_celsius(""kelvin"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'kelvin'
    """"""
    return round(float(kelvin) - 273.15, ndigits)",data\repos\Python\conversions\temperature_conversions.py,kelvin_to_celsius,219
568,temperature_conversions.py::kelvin_to_fahrenheit::194,"def kelvin_to_fahrenheit(kelvin: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Kelvin to Fahrenheit and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit

    >>> kelvin_to_fahrenheit(273.354, 3)
    32.367
    >>> kelvin_to_fahrenheit(273.354, 0)
    32.0
    >>> kelvin_to_fahrenheit(273.15)
    32.0
    >>> kelvin_to_fahrenheit(300)
    80.33
    >>> kelvin_to_fahrenheit(""315.5"")
    108.23
    >>> kelvin_to_fahrenheit(""kelvin"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'kelvin'
    """"""
    return round(((float(kelvin) - 273.15) * 9 / 5) + 32, ndigits)",data\repos\Python\conversions\temperature_conversions.py,kelvin_to_fahrenheit,231
569,temperature_conversions.py::kelvin_to_rankine::218,"def kelvin_to_rankine(kelvin: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Kelvin to Rankine and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale

    >>> kelvin_to_rankine(273.354, 3)
    492.037
    >>> kelvin_to_rankine(273.354, 0)
    492.0
    >>> kelvin_to_rankine(0)
    0.0
    >>> kelvin_to_rankine(20.0)
    36.0
    >>> kelvin_to_rankine(""40"")
    72.0
    >>> kelvin_to_rankine(""kelvin"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'kelvin'
    """"""
    return round((float(kelvin) * 9 / 5), ndigits)",data\repos\Python\conversions\temperature_conversions.py,kelvin_to_rankine,222
570,temperature_conversions.py::rankine_to_celsius::242,"def rankine_to_celsius(rankine: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Rankine to Celsius and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius

    >>> rankine_to_celsius(273.354, 3)
    -121.287
    >>> rankine_to_celsius(273.354, 0)
    -121.0
    >>> rankine_to_celsius(273.15)
    -121.4
    >>> rankine_to_celsius(300)
    -106.48
    >>> rankine_to_celsius(""315.5"")
    -97.87
    >>> rankine_to_celsius(""rankine"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'rankine'
    """"""
    return round((float(rankine) - 491.67) * 5 / 9, ndigits)",data\repos\Python\conversions\temperature_conversions.py,rankine_to_celsius,227
571,temperature_conversions.py::rankine_to_fahrenheit::266,"def rankine_to_fahrenheit(rankine: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Rankine to Fahrenheit and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit

    >>> rankine_to_fahrenheit(273.15)
    -186.52
    >>> rankine_to_fahrenheit(300)
    -159.67
    >>> rankine_to_fahrenheit(""315.5"")
    -144.17
    >>> rankine_to_fahrenheit(""rankine"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'rankine'
    """"""
    return round(float(rankine) - 459.67, ndigits)",data\repos\Python\conversions\temperature_conversions.py,rankine_to_fahrenheit,177
572,temperature_conversions.py::rankine_to_kelvin::286,"def rankine_to_kelvin(rankine: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from Rankine to Kelvin and round it to 2 decimal places.
    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin

    >>> rankine_to_kelvin(0)
    0.0
    >>> rankine_to_kelvin(20.0)
    11.11
    >>> rankine_to_kelvin(""40"")
    22.22
    >>> rankine_to_kelvin(""rankine"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'rankine'
    """"""
    return round((float(rankine) * 5 / 9), ndigits)",data\repos\Python\conversions\temperature_conversions.py,rankine_to_kelvin,178
573,temperature_conversions.py::reaumur_to_kelvin::306,"def reaumur_to_kelvin(reaumur: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from reaumur to Kelvin and round it to 2 decimal places.
    Reference:- http://www.csgnetwork.com/temp2conv.html

    >>> reaumur_to_kelvin(0)
    273.15
    >>> reaumur_to_kelvin(20.0)
    298.15
    >>> reaumur_to_kelvin(40)
    323.15
    >>> reaumur_to_kelvin(""reaumur"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'reaumur'
    """"""
    return round((float(reaumur) * 1.25 + 273.15), ndigits)",data\repos\Python\conversions\temperature_conversions.py,reaumur_to_kelvin,186
574,temperature_conversions.py::reaumur_to_fahrenheit::325,"def reaumur_to_fahrenheit(reaumur: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from reaumur to fahrenheit and round it to 2 decimal places.
    Reference:- http://www.csgnetwork.com/temp2conv.html

    >>> reaumur_to_fahrenheit(0)
    32.0
    >>> reaumur_to_fahrenheit(20.0)
    77.0
    >>> reaumur_to_fahrenheit(40)
    122.0
    >>> reaumur_to_fahrenheit(""reaumur"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'reaumur'
    """"""
    return round((float(reaumur) * 2.25 + 32), ndigits)",data\repos\Python\conversions\temperature_conversions.py,reaumur_to_fahrenheit,185
575,temperature_conversions.py::reaumur_to_celsius::344,"def reaumur_to_celsius(reaumur: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from reaumur to celsius and round it to 2 decimal places.
    Reference:- http://www.csgnetwork.com/temp2conv.html

    >>> reaumur_to_celsius(0)
    0.0
    >>> reaumur_to_celsius(20.0)
    25.0
    >>> reaumur_to_celsius(40)
    50.0
    >>> reaumur_to_celsius(""reaumur"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'reaumur'
    """"""
    return round((float(reaumur) * 1.25), ndigits)",data\repos\Python\conversions\temperature_conversions.py,reaumur_to_celsius,182
576,temperature_conversions.py::reaumur_to_rankine::363,"def reaumur_to_rankine(reaumur: float, ndigits: int = 2) -> float:
    """"""
    Convert a given value from reaumur to rankine and round it to 2 decimal places.
    Reference:- http://www.csgnetwork.com/temp2conv.html

    >>> reaumur_to_rankine(0)
    491.67
    >>> reaumur_to_rankine(20.0)
    536.67
    >>> reaumur_to_rankine(40)
    581.67
    >>> reaumur_to_rankine(""reaumur"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'reaumur'
    """"""
    return round((float(reaumur) * 2.25 + 32 + 459.67), ndigits)",data\repos\Python\conversions\temperature_conversions.py,reaumur_to_rankine,190
577,time_conversions.py::convert_time::25,"def convert_time(time_value: float, unit_from: str, unit_to: str) -> float:
    """"""
    Convert time from one unit to another using the time_chart above.

    >>> convert_time(3600, ""seconds"", ""hours"")
    1.0
    >>> convert_time(3500, ""Seconds"", ""Hours"")
    0.972
    >>> convert_time(1, ""DaYs"", ""hours"")
    24.0
    >>> convert_time(120, ""minutes"", ""SeCoNdS"")
    7200.0
    >>> convert_time(2, ""WEEKS"", ""days"")
    14.0
    >>> convert_time(0.5, ""hours"", ""MINUTES"")
    30.0
    >>> convert_time(-3600, ""seconds"", ""hours"")
    Traceback (most recent call last):
        ...
    ValueError: 'time_value' must be a non-negative number.
    >>> convert_time(""Hello"", ""hours"", ""minutes"")
    Traceback (most recent call last):
        ...
    ValueError: 'time_value' must be a non-negative number.
    >>> convert_time([0, 1, 2], ""weeks"", ""days"")
    Traceback (most recent call last):
        ...
    ValueError: 'time_value' must be a non-negative number.
    >>> convert_time(1, ""cool"", ""century"")  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValueError: Invalid unit cool is not in seconds, minutes, hours, days, weeks, ...
    >>> convert_time(1, ""seconds"", ""hot"")  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValueError: Invalid unit hot is not in seconds, minutes, hours, days, weeks, ...
    """"""
    if not isinstance(time_value, (int, float)) or time_value < 0:
        msg = ""'time_value' must be a non-negative number.""
        raise ValueError(msg)

    unit_from = unit_from.lower()
    unit_to = unit_to.lower()
    if unit_from not in time_chart or unit_to not in time_chart:
        invalid_unit = unit_from if unit_from not in time_chart else unit_to
        msg = f""Invalid unit {invalid_unit} is not in {', '.join(time_chart)}.""
        raise ValueError(msg)

    return round(
        time_value * time_chart[unit_from] * time_chart_inverse[unit_to],
        3,
    )",data\repos\Python\conversions\time_conversions.py,convert_time,536
578,volume_conversions.py::volume_conversion::40,"def volume_conversion(value: float, from_type: str, to_type: str) -> float:
    """"""
    Conversion between volume units.
    >>> volume_conversion(4, ""cubic meter"", ""litre"")
    4000
    >>> volume_conversion(1, ""litre"", ""gallon"")
    0.264172
    >>> volume_conversion(1, ""kilolitre"", ""cubic meter"")
    1
    >>> volume_conversion(3, ""gallon"", ""cubic yard"")
    0.017814279
    >>> volume_conversion(2, ""cubic yard"", ""litre"")
    1529.1
    >>> volume_conversion(4, ""cubic foot"", ""cup"")
    473.396
    >>> volume_conversion(1, ""cup"", ""kilolitre"")
    0.000236588
    >>> volume_conversion(4, ""wrongUnit"", ""litre"")
    Traceback (most recent call last):
        ...
    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:
    cubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup
    """"""
    if from_type not in METRIC_CONVERSION:
        raise ValueError(
            f""Invalid 'from_type' value: {from_type!r}  Supported values are:\n""
            + "", "".join(METRIC_CONVERSION)
        )
    if to_type not in METRIC_CONVERSION:
        raise ValueError(
            f""Invalid 'to_type' value: {to_type!r}.  Supported values are:\n""
            + "", "".join(METRIC_CONVERSION)
        )
    return (
        value
        * METRIC_CONVERSION[from_type].from_factor
        * METRIC_CONVERSION[to_type].to_factor
    )",data\repos\Python\conversions\volume_conversions.py,volume_conversion,384
579,weight_conversion.py::weight_conversion::62,"def weight_conversion(from_type: str, to_type: str, value: float) -> float:
    """"""
    Conversion of weight unit with the help of KILOGRAM_CHART

    ""kilogram"" : 1,
    ""gram"" : pow(10, 3),
    ""milligram"" : pow(10, 6),
    ""metric-ton"" : pow(10, -3),
    ""long-ton"" : 0.0009842073,
    ""short-ton"" : 0.0011023122,
    ""pound"" : 2.2046244202,
    ""stone"": 0.1574731728,
    ""ounce"" : 35.273990723,
    ""carrat"" : 5000,
    ""atomic-mass-unit"" : 6.022136652E+26

    >>> weight_conversion(""kilogram"",""kilogram"",4)
    4
    >>> weight_conversion(""kilogram"",""gram"",1)
    1000
    >>> weight_conversion(""kilogram"",""milligram"",4)
    4000000
    >>> weight_conversion(""kilogram"",""metric-ton"",4)
    0.004
    >>> weight_conversion(""kilogram"",""long-ton"",3)
    0.0029526219
    >>> weight_conversion(""kilogram"",""short-ton"",1)
    0.0011023122
    >>> weight_conversion(""kilogram"",""pound"",4)
    8.8184976808
    >>> weight_conversion(""kilogram"",""stone"",5)
    0.7873658640000001
    >>> weight_conversion(""kilogram"",""ounce"",4)
    141.095962892
    >>> weight_conversion(""kilogram"",""carrat"",3)
    15000
    >>> weight_conversion(""kilogram"",""atomic-mass-unit"",1)
    6.022136652e+26
    >>> weight_conversion(""gram"",""kilogram"",1)
    0.001
    >>> weight_conversion(""gram"",""gram"",3)
    3.0
    >>> weight_conversion(""gram"",""milligram"",2)
    2000.0
    >>> weight_conversion(""gram"",""metric-ton"",4)
    4e-06
    >>> weight_conversion(""gram"",""long-ton"",3)
    2.9526219e-06
    >>> weight_conversion(""gram"",""short-ton"",3)
    3.3069366000000003e-06
    >>> weight_conversion(""gram"",""pound"",3)
    0.0066138732606
    >>> weight_conversion(""gram"",""stone"",4)
    0.0006298926912000001
    >>> weight_conversion(""gram"",""ounce"",1)
    0.035273990723
    >>> weight_conversion(""gram"",""carrat"",2)
    10.0
    >>> weight_conversion(""gram"",""atomic-mass-unit"",1)
    6.022136652e+23
    >>> weight_conversion(""milligram"",""kilogram"",1)
    1e-06
    >>> weight_conversion(""milligram"",""gram"",2)
    0.002
    >>> weight_conversion(""milligram"",""milligram"",3)
    3.0
    >>> weight_conversion(""milligram"",""metric-ton"",3)
    3e-09
    >>> weight_conversion(""milligram"",""long-ton"",3)
    2.9526219e-09
    >>> weight_conversion(""milligram"",""short-ton"",1)
    1.1023122e-09
    >>> weight_conversion(""milligram"",""pound"",3)
    6.6138732605999995e-06
    >>> weight_conversion(""milligram"",""ounce"",2)
    7.054798144599999e-05
    >>> weight_conversion(""milligram"",""carrat"",1)
    0.005
    >>> weight_conversion(""milligram"",""atomic-mass-unit"",1)
    6.022136652e+20
    >>> weight_conversion(""metric-ton"",""kilogram"",2)
    2000
    >>> weight_conversion(""metric-ton"",""gram"",2)
    2000000
    >>> weight_conversion(""metric-ton"",""milligram"",3)
    3000000000
    >>> weight_conversion(""metric-ton"",""metric-ton"",2)
    2.0
    >>> weight_conversion(""metric-ton"",""long-ton"",3)
    2.9526219
    >>> weight_conversion(""metric-ton"",""short-ton"",2)
    2.2046244
    >>> weight_conversion(""metric-ton"",""pound"",3)
    6613.8732606
    >>> weight_conversion(""metric-ton"",""ounce"",4)
    141095.96289199998
    >>> weight_conversion(""metric-ton"",""carrat"",4)
    20000000
    >>> weight_conversion(""metric-ton"",""atomic-mass-unit"",1)
    6.022136652e+29
    >>> weight_conversion(""long-ton"",""kilogram"",4)
    4064.18432
    >>> weight_conversion(""long-ton"",""gram"",4)
    4064184.32
    >>> weight_conversion(""long-ton"",""milligram"",3)
    3048138240.0
    >>> weight_conversion(""long-ton"",""metric-ton"",4)
    4.06418432
    >>> weight_conversion(""long-ton"",""long-ton"",3)
    2.999999907217152
    >>> weight_conversion(""long-ton"",""short-ton"",1)
    1.119999989746176
    >>> weight_conversion(""long-ton"",""pound"",3)
    6720.000000049448
    >>> weight_conversion(""long-ton"",""ounce"",1)
    35840.000000060514
    >>> weight_conversion(""long-ton"",""carrat"",4)
    20320921.599999998
    >>> weight_conversion(""long-ton"",""atomic-mass-unit"",4)
    2.4475073353955697e+30
    >>> weight_conversion(""short-ton"",""kilogram"",3)
    2721.5519999999997
    >>> weight_conversion(""short-ton"",""gram"",3)
    2721552.0
    >>> weight_conversion(""short-ton"",""milligram"",1)
    907184000.0
    >>> weight_conversion(""short-ton"",""metric-ton"",4)
    3.628736
    >>> weight_conversion(""short-ton"",""long-ton"",3)
    2.6785713457296
    >>> weight_conversion(""short-ton"",""short-ton"",3)
    2.9999999725344
    >>> weight_conversion(""short-ton"",""pound"",2)
    4000.0000000294335
    >>> weight_conversion(""short-ton"",""ounce"",4)
    128000.00000021611
    >>> weight_conversion(""short-ton"",""carrat"",4)
    18143680.0
    >>> weight_conversion(""short-ton"",""atomic-mass-unit"",1)
    5.463186016507968e+29
    >>> weight_conversion(""pound"",""kilogram"",4)
    1.814368
    >>> weight_conversion(""pound"",""gram"",2)
    907.184
    >>> weight_conversion(""pound"",""milligram"",3)
    1360776.0
    >>> weight_conversion(""pound"",""metric-ton"",3)
    0.001360776
    >>> weight_conversion(""pound"",""long-ton"",2)
    0.0008928571152432
    >>> weight_conversion(""pound"",""short-ton"",1)
    0.0004999999954224
    >>> weight_conversion(""pound"",""pound"",3)
    3.0000000000220752
    >>> weight_conversion(""pound"",""ounce"",1)
    16.000000000027015
    >>> weight_conversion(""pound"",""carrat"",1)
    2267.96
    >>> weight_conversion(""pound"",""atomic-mass-unit"",4)
    1.0926372033015936e+27
    >>> weight_conversion(""stone"",""kilogram"",5)
    31.751450000000002
    >>> weight_conversion(""stone"",""gram"",2)
    12700.58
    >>> weight_conversion(""stone"",""milligram"",3)
    19050870.0
    >>> weight_conversion(""stone"",""metric-ton"",3)
    0.01905087
    >>> weight_conversion(""stone"",""long-ton"",3)
    0.018750005325351003
    >>> weight_conversion(""stone"",""short-ton"",3)
    0.021000006421614002
    >>> weight_conversion(""stone"",""pound"",2)
    28.00000881870372
    >>> weight_conversion(""stone"",""ounce"",1)
    224.00007054835967
    >>> weight_conversion(""stone"",""carrat"",2)
    63502.9
    >>> weight_conversion(""ounce"",""kilogram"",3)
    0.0850485
    >>> weight_conversion(""ounce"",""gram"",3)
    85.0485
    >>> weight_conversion(""ounce"",""milligram"",4)
    113398.0
    >>> weight_conversion(""ounce"",""metric-ton"",4)
    0.000113398
    >>> weight_conversion(""ounce"",""long-ton"",4)
    0.0001116071394054
    >>> weight_conversion(""ounce"",""short-ton"",4)
    0.0001249999988556
    >>> weight_conversion(""ounce"",""pound"",1)
    0.0625000000004599
    >>> weight_conversion(""ounce"",""ounce"",2)
    2.000000000003377
    >>> weight_conversion(""ounce"",""carrat"",1)
    141.7475
    >>> weight_conversion(""ounce"",""atomic-mass-unit"",1)
    1.70724563015874e+25
    >>> weight_conversion(""carrat"",""kilogram"",1)
    0.0002
    >>> weight_conversion(""carrat"",""gram"",4)
    0.8
    >>> weight_conversion(""carrat"",""milligram"",2)
    400.0
    >>> weight_conversion(""carrat"",""metric-ton"",2)
    4.0000000000000003e-07
    >>> weight_conversion(""carrat"",""long-ton"",3)
    5.9052438e-07
    >>> weight_conversion(""carrat"",""short-ton"",4)
    8.818497600000002e-07
    >>> weight_conversion(""carrat"",""pound"",1)
    0.00044092488404000004
    >>> weight_conversion(""carrat"",""ounce"",2)
    0.0141095962892
    >>> weight_conversion(""carrat"",""carrat"",4)
    4.0
    >>> weight_conversion(""carrat"",""atomic-mass-unit"",4)
    4.8177093216e+23
    >>> weight_conversion(""atomic-mass-unit"",""kilogram"",4)
    6.642160796e-27
    >>> weight_conversion(""atomic-mass-unit"",""gram"",2)
    3.321080398e-24
    >>> weight_conversion(""atomic-mass-unit"",""milligram"",2)
    3.3210803980000002e-21
    >>> weight_conversion(""atomic-mass-unit"",""metric-ton"",3)
    4.9816205970000004e-30
    >>> weight_conversion(""atomic-mass-unit"",""long-ton"",3)
    4.9029473573977584e-30
    >>> weight_conversion(""atomic-mass-unit"",""short-ton"",1)
    1.830433719948128e-30
    >>> weight_conversion(""atomic-mass-unit"",""pound"",3)
    1.0982602420317504e-26
    >>> weight_conversion(""atomic-mass-unit"",""ounce"",2)
    1.1714775914938915e-25
    >>> weight_conversion(""atomic-mass-unit"",""carrat"",2)
    1.660540199e-23
    >>> weight_conversion(""atomic-mass-unit"",""atomic-mass-unit"",2)
    1.999999998903455
    >>> weight_conversion(""slug"", ""kilogram"", 1)
    Traceback (most recent call last):
    ...
    ValueError: Invalid 'from_type' or 'to_type' value: 'slug', 'kilogram'
    Supported values are: kilogram, gram, milligram, metric-ton, long-ton, short-ton, \
pound, stone, ounce, carrat, atomic-mass-unit
    """"""
    if to_type not in KILOGRAM_CHART or from_type not in WEIGHT_TYPE_CHART:
        msg = (
            f""Invalid 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\n""
            f""Supported values are: {', '.join(WEIGHT_TYPE_CHART)}""
        )
        raise ValueError(msg)
    return value * KILOGRAM_CHART[to_type] * WEIGHT_TYPE_CHART[from_type]",data\repos\Python\conversions\weight_conversion.py,weight_conversion,2852
580,burrows_wheeler.py::all_rotations::24,"def all_rotations(s: str) -> list[str]:
    """"""
    :param s: The string that will be rotated len(s) times.
    :return: A list with the rotations.
    :raises TypeError: If s is not an instance of str.
    Examples:

    >>> all_rotations(""^BANANA|"") # doctest: +NORMALIZE_WHITESPACE
    ['^BANANA|', 'BANANA|^', 'ANANA|^B', 'NANA|^BA', 'ANA|^BAN', 'NA|^BANA',
    'A|^BANAN', '|^BANANA']
    >>> all_rotations(""a_asa_da_casa"") # doctest: +NORMALIZE_WHITESPACE
    ['a_asa_da_casa', '_asa_da_casaa', 'asa_da_casaa_', 'sa_da_casaa_a',
    'a_da_casaa_as', '_da_casaa_asa', 'da_casaa_asa_', 'a_casaa_asa_d',
    '_casaa_asa_da', 'casaa_asa_da_', 'asaa_asa_da_c', 'saa_asa_da_ca',
    'aa_asa_da_cas']
    >>> all_rotations(""panamabanana"") # doctest: +NORMALIZE_WHITESPACE
    ['panamabanana', 'anamabananap', 'namabananapa', 'amabananapan',
    'mabananapana', 'abananapanam', 'bananapanama', 'ananapanamab',
    'nanapanamaba', 'anapanamaban', 'napanamabana', 'apanamabanan']
    >>> all_rotations(5)
    Traceback (most recent call last):
        ...
    TypeError: The parameter s type must be str.
    """"""
    if not isinstance(s, str):
        raise TypeError(""The parameter s type must be str."")

    return [s[i:] + s[:i] for i in range(len(s))]",data\repos\Python\data_compression\burrows_wheeler.py,all_rotations,430
581,burrows_wheeler.py::bwt_transform::54,"def bwt_transform(s: str) -> BWTTransformDict:
    """"""
    :param s: The string that will be used at bwt algorithm
    :return: the string composed of the last char of each row of the ordered
    rotations and the index of the original string at ordered rotations list
    :raises TypeError: If the s parameter type is not str
    :raises ValueError: If the s parameter is empty
    Examples:

    >>> bwt_transform(""^BANANA"")
    {'bwt_string': 'BNN^AAA', 'idx_original_string': 6}
    >>> bwt_transform(""a_asa_da_casa"")
    {'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3}
    >>> bwt_transform(""panamabanana"")
    {'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11}
    >>> bwt_transform(4)
    Traceback (most recent call last):
        ...
    TypeError: The parameter s type must be str.
    >>> bwt_transform('')
    Traceback (most recent call last):
        ...
    ValueError: The parameter s must not be empty.
    """"""
    if not isinstance(s, str):
        raise TypeError(""The parameter s type must be str."")
    if not s:
        raise ValueError(""The parameter s must not be empty."")

    rotations = all_rotations(s)
    rotations.sort()  # sort the list of rotations in alphabetically order
    # make a string composed of the last char of each rotation
    response: BWTTransformDict = {
        ""bwt_string"": """".join([word[-1] for word in rotations]),
        ""idx_original_string"": rotations.index(s),
    }
    return response",data\repos\Python\data_compression\burrows_wheeler.py,bwt_transform,368
582,burrows_wheeler.py::reverse_bwt::93,"def reverse_bwt(bwt_string: str, idx_original_string: int) -> str:
    """"""
    :param bwt_string: The string returned from bwt algorithm execution
    :param idx_original_string: A 0-based index of the string that was used to
    generate bwt_string at ordered rotations list
    :return: The string used to generate bwt_string when bwt was executed
    :raises TypeError: If the bwt_string parameter type is not str
    :raises ValueError: If the bwt_string parameter is empty
    :raises TypeError: If the idx_original_string type is not int or if not
    possible to cast it to int
    :raises ValueError: If the idx_original_string value is lower than 0 or
    greater than len(bwt_string) - 1

    >>> reverse_bwt(""BNN^AAA"", 6)
    '^BANANA'
    >>> reverse_bwt(""aaaadss_c__aa"", 3)
    'a_asa_da_casa'
    >>> reverse_bwt(""mnpbnnaaaaaa"", 11)
    'panamabanana'
    >>> reverse_bwt(4, 11)
    Traceback (most recent call last):
        ...
    TypeError: The parameter bwt_string type must be str.
    >>> reverse_bwt("""", 11)
    Traceback (most recent call last):
        ...
    ValueError: The parameter bwt_string must not be empty.
    >>> reverse_bwt(""mnpbnnaaaaaa"", ""asd"") # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: The parameter idx_original_string type must be int or passive
    of cast to int.
    >>> reverse_bwt(""mnpbnnaaaaaa"", -1)
    Traceback (most recent call last):
        ...
    ValueError: The parameter idx_original_string must not be lower than 0.
    >>> reverse_bwt(""mnpbnnaaaaaa"", 12) # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: The parameter idx_original_string must be lower than
    len(bwt_string).
    >>> reverse_bwt(""mnpbnnaaaaaa"", 11.0)
    'panamabanana'
    >>> reverse_bwt(""mnpbnnaaaaaa"", 11.4)
    'panamabanana'
    """"""
    if not isinstance(bwt_string, str):
        raise TypeError(""The parameter bwt_string type must be str."")
    if not bwt_string:
        raise ValueError(""The parameter bwt_string must not be empty."")
    try:
        idx_original_string = int(idx_original_string)
    except ValueError:
        raise TypeError(
            ""The parameter idx_original_string type must be int or passive""
            "" of cast to int.""
        )
    if idx_original_string < 0:
        raise ValueError(""The parameter idx_original_string must not be lower than 0."")
    if idx_original_string >= len(bwt_string):
        raise ValueError(
            ""The parameter idx_original_string must be lower than len(bwt_string).""
        )

    ordered_rotations = [""""] * len(bwt_string)
    for _ in range(len(bwt_string)):
        for i in range(len(bwt_string)):
            ordered_rotations[i] = bwt_string[i] + ordered_rotations[i]
        ordered_rotations.sort()
    return ordered_rotations[idx_original_string]",data\repos\Python\data_compression\burrows_wheeler.py,reverse_bwt,733
583,coordinate_compression.py::compress_coordinates::60,"    def compress_coordinates(self) -> None:
        """"""
        Compress the coordinates in the input list.

        >>> arr = [100, 10, 52, 83]
        >>> cc = CoordinateCompressor(arr)
        >>> cc.coordinate_map[83]
        2
        >>> cc.coordinate_map[80]  # Value not in the original list
        Traceback (most recent call last):
            ...
        KeyError: 80
        >>> cc.reverse_map[2]
        83
        """"""
        key = 0
        for val in self.arr:
            if val not in self.coordinate_map:
                self.coordinate_map[val] = key
                self.reverse_map[key] = val
                key += 1",data\repos\Python\data_compression\coordinate_compression.py,compress_coordinates,151
584,coordinate_compression.py::compress::82,"    def compress(self, original: float | str) -> int:
        """"""
        Compress a single value.

        Args:
        original: The value to compress.

        Returns:
        The compressed integer, or -1 if not found in the original list.

        >>> arr = [100, 10, 52, 83]
        >>> cc = CoordinateCompressor(arr)
        >>> cc.compress(100)
        3
        >>> cc.compress(7)  # Value not in the original list
        -1
        """"""
        return self.coordinate_map.get(original, -1)",data\repos\Python\data_compression\coordinate_compression.py,compress,122
585,coordinate_compression.py::decompress::101,"    def decompress(self, num: int) -> int | float | str:
        """"""
        Decompress a single integer.

        Args:
        num: The compressed integer to decompress.

        Returns:
        The original value.

        >>> arr = [100, 10, 52, 83]
        >>> cc = CoordinateCompressor(arr)
        >>> cc.decompress(0)
        10
        >>> cc.decompress(5)  # Compressed coordinate out of range
        -1
        """"""
        return self.reverse_map[num] if 0 <= num < len(self.reverse_map) else -1",data\repos\Python\data_compression\coordinate_compression.py,decompress,128
586,huffman.py::parse_file::23,"def parse_file(file_path: str) -> list[Letter]:
    """"""
    Read the file and build a dict of all letters and their
    frequencies, then convert the dict into a list of Letters.
    """"""
    chars: dict[str, int] = {}
    with open(file_path) as f:
        while True:
            c = f.read(1)
            if not c:
                break
            chars[c] = chars[c] + 1 if c in chars else 1
    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)",data\repos\Python\data_compression\huffman.py,parse_file,126
587,huffman.py::build_tree::38,"def build_tree(letters: list[Letter]) -> Letter | TreeNode:
    """"""
    Run through the list of Letters and build the min heap
    for the Huffman Tree.
    """"""
    response: list[Letter | TreeNode] = list(letters)
    while len(response) > 1:
        left = response.pop(0)
        right = response.pop(0)
        total_freq = left.freq + right.freq
        node = TreeNode(total_freq, left, right)
        response.append(node)
        response.sort(key=lambda x: x.freq)
    return response[0]",data\repos\Python\data_compression\huffman.py,build_tree,119
588,huffman.py::traverse_tree::54,"def traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:
    """"""
    Recursively traverse the Huffman Tree to set each
    Letter's bitstring dictionary, and return the list of Letters
    """"""
    if isinstance(root, Letter):
        root.bitstring[root.letter] = bitstring
        return [root]
    treenode: TreeNode = root
    letters = []
    letters += traverse_tree(treenode.left, bitstring + ""0"")
    letters += traverse_tree(treenode.right, bitstring + ""1"")
    return letters",data\repos\Python\data_compression\huffman.py,traverse_tree,120
589,huffman.py::huffman::69,"def huffman(file_path: str) -> None:
    """"""
    Parse the file, build the tree, then run through the file
    again, using the letters dictionary to find and print out the
    bitstring for each letter.
    """"""
    letters_list = parse_file(file_path)
    root = build_tree(letters_list)
    letters = {
        k: v for letter in traverse_tree(root, """") for k, v in letter.bitstring.items()
    }
    print(f""Huffman Coding  of {file_path}: "")
    with open(file_path) as f:
        while True:
            c = f.read(1)
            if not c:
                break
            print(letters[c], end="" "")
    print()",data\repos\Python\data_compression\huffman.py,huffman,151
590,lempel_ziv.py::read_file_binary::11,"def read_file_binary(file_path: str) -> str:
    """"""
    Reads given file as bytes and returns them as a long string
    """"""
    result = """"
    try:
        with open(file_path, ""rb"") as binary_file:
            data = binary_file.read()
        for dat in data:
            curr_byte = f""{dat:08b}""
            result += curr_byte
        return result
    except OSError:
        print(""File not accessible"")
        sys.exit()",data\repos\Python\data_compression\lempel_ziv.py,read_file_binary,99
591,lempel_ziv.py::add_key_to_lexicon::28,"def add_key_to_lexicon(
    lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str
) -> None:
    """"""
    Adds new strings (curr_string + ""0"",  curr_string + ""1"") to the lexicon
    """"""
    lexicon.pop(curr_string)
    lexicon[curr_string + ""0""] = last_match_id

    if math.log2(index).is_integer():
        for curr_key, value in lexicon.items():
            lexicon[curr_key] = f""0{value}""

    lexicon[curr_string + ""1""] = bin(index)[2:]",data\repos\Python\data_compression\lempel_ziv.py,add_key_to_lexicon,132
592,lempel_ziv.py::compress_data::44,"def compress_data(data_bits: str) -> str:
    """"""
    Compresses given data_bits using Lempel-Ziv-Welch compression algorithm
    and returns the result as a string
    """"""
    lexicon = {""0"": ""0"", ""1"": ""1""}
    result, curr_string = """", """"
    index = len(lexicon)

    for i in range(len(data_bits)):
        curr_string += data_bits[i]
        if curr_string not in lexicon:
            continue

        last_match_id = lexicon[curr_string]
        result += last_match_id
        add_key_to_lexicon(lexicon, curr_string, index, last_match_id)
        index += 1
        curr_string = """"

    while curr_string != """" and curr_string not in lexicon:
        curr_string += ""0""

    if curr_string != """":
        last_match_id = lexicon[curr_string]
        result += last_match_id

    return result",data\repos\Python\data_compression\lempel_ziv.py,compress_data,198
593,lempel_ziv.py::add_file_length::74,"def add_file_length(source_path: str, compressed: str) -> str:
    """"""
    Adds given file's length in front (using Elias  gamma coding) of the compressed
    string
    """"""
    file_length = os.path.getsize(source_path)
    file_length_binary = bin(file_length)[2:]
    length_length = len(file_length_binary)

    return ""0"" * (length_length - 1) + file_length_binary + compressed",data\repos\Python\data_compression\lempel_ziv.py,add_file_length,92
594,lempel_ziv.py::write_file_binary::86,"def write_file_binary(file_path: str, to_write: str) -> None:
    """"""
    Writes given to_write string (should only consist of 0's and 1's) as bytes in the
    file
    """"""
    byte_length = 8
    try:
        with open(file_path, ""wb"") as opened_file:
            result_byte_array = [
                to_write[i : i + byte_length]
                for i in range(0, len(to_write), byte_length)
            ]

            if len(result_byte_array[-1]) % byte_length == 0:
                result_byte_array.append(""10000000"")
            else:
                result_byte_array[-1] += ""1"" + ""0"" * (
                    byte_length - len(result_byte_array[-1]) - 1
                )

            for elem in result_byte_array:
                opened_file.write(int(elem, 2).to_bytes(1, byteorder=""big""))
    except OSError:
        print(""File not accessible"")
        sys.exit()",data\repos\Python\data_compression\lempel_ziv.py,write_file_binary,210
595,lempel_ziv.py::compress::113,"def compress(source_path: str, destination_path: str) -> None:
    """"""
    Reads source file, compresses it and writes the compressed result in destination
    file
    """"""
    data_bits = read_file_binary(source_path)
    compressed = compress_data(data_bits)
    compressed = add_file_length(source_path, compressed)
    write_file_binary(destination_path, compressed)",data\repos\Python\data_compression\lempel_ziv.py,compress,76
596,lempel_ziv_decompress.py::read_file_binary::10,"def read_file_binary(file_path: str) -> str:
    """"""
    Reads given file as bytes and returns them as a long string
    """"""
    result = """"
    try:
        with open(file_path, ""rb"") as binary_file:
            data = binary_file.read()
        for dat in data:
            curr_byte = f""{dat:08b}""
            result += curr_byte
        return result
    except OSError:
        print(""File not accessible"")
        sys.exit()",data\repos\Python\data_compression\lempel_ziv_decompress.py,read_file_binary,99
597,lempel_ziv_decompress.py::decompress_data::27,"def decompress_data(data_bits: str) -> str:
    """"""
    Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm
    and returns the result as a string
    """"""
    lexicon = {""0"": ""0"", ""1"": ""1""}
    result, curr_string = """", """"
    index = len(lexicon)

    for i in range(len(data_bits)):
        curr_string += data_bits[i]
        if curr_string not in lexicon:
            continue

        last_match_id = lexicon[curr_string]
        result += last_match_id
        lexicon[curr_string] = last_match_id + ""0""

        if math.log2(index).is_integer():
            new_lex = {}
            for curr_key in list(lexicon):
                new_lex[""0"" + curr_key] = lexicon.pop(curr_key)
            lexicon = new_lex

        lexicon[bin(index)[2:]] = last_match_id + ""1""
        index += 1
        curr_string = """"
    return result",data\repos\Python\data_compression\lempel_ziv_decompress.py,decompress_data,217
598,lempel_ziv_decompress.py::write_file_binary::57,"def write_file_binary(file_path: str, to_write: str) -> None:
    """"""
    Writes given to_write string (should only consist of 0's and 1's) as bytes in the
    file
    """"""
    byte_length = 8
    try:
        with open(file_path, ""wb"") as opened_file:
            result_byte_array = [
                to_write[i : i + byte_length]
                for i in range(0, len(to_write), byte_length)
            ]

            if len(result_byte_array[-1]) % byte_length == 0:
                result_byte_array.append(""10000000"")
            else:
                result_byte_array[-1] += ""1"" + ""0"" * (
                    byte_length - len(result_byte_array[-1]) - 1
                )

            for elem in result_byte_array[:-1]:
                opened_file.write(int(elem, 2).to_bytes(1, byteorder=""big""))
    except OSError:
        print(""File not accessible"")
        sys.exit()",data\repos\Python\data_compression\lempel_ziv_decompress.py,write_file_binary,212
599,lempel_ziv_decompress.py::remove_prefix::84,"def remove_prefix(data_bits: str) -> str:
    """"""
    Removes size prefix, that compressed file should have
    Returns the result
    """"""
    counter = 0
    for letter in data_bits:
        if letter == ""1"":
            break
        counter += 1

    data_bits = data_bits[counter:]
    data_bits = data_bits[counter + 1 :]
    return data_bits",data\repos\Python\data_compression\lempel_ziv_decompress.py,remove_prefix,83
600,lempel_ziv_decompress.py::compress::100,"def compress(source_path: str, destination_path: str) -> None:
    """"""
    Reads source file, decompresses it and writes the result in destination file
    """"""
    data_bits = read_file_binary(source_path)
    data_bits = remove_prefix(data_bits)
    decompressed = decompress_data(data_bits)
    write_file_binary(destination_path, decompressed)",data\repos\Python\data_compression\lempel_ziv_decompress.py,compress,75
601,lz77.py::compress::69,"    def compress(self, text: str) -> list[Token]:
        """"""
        Compress the given string text using LZ77 compression algorithm.

        Args:
            text: string to be compressed

        Returns:
            output: the compressed text as a list of Tokens

        >>> lz77_compressor = LZ77Compressor()
        >>> str(lz77_compressor.compress(""ababcbababaa""))
        '[(0, 0, a), (0, 0, b), (2, 2, c), (4, 3, a), (2, 2, a)]'
        >>> str(lz77_compressor.compress(""aacaacabcabaaac""))
        '[(0, 0, a), (1, 1, c), (3, 4, b), (3, 3, a), (1, 2, c)]'
        """"""

        output = []
        search_buffer = """"

        # while there are still characters in text to compress
        while text:
            # find the next encoding phrase
            # - triplet with offset, length, indicator (the next encoding character)
            token = self._find_encoding_token(text, search_buffer)

            # update the search buffer:
            # - add new characters from text into it
            # - check if size exceed the max search buffer size, if so, drop the
            #   oldest elements
            search_buffer += text[: token.length + 1]
            if len(search_buffer) > self.search_buffer_size:
                search_buffer = search_buffer[-self.search_buffer_size :]

            # update the text
            text = text[token.length + 1 :]

            # append the token to output
            output.append(token)

        return output",data\repos\Python\data_compression\lz77.py,compress,365
602,lz77.py::decompress::111,"    def decompress(self, tokens: list[Token]) -> str:
        """"""
        Convert the list of tokens into an output string.

        Args:
            tokens: list containing triplets (offset, length, char)

        Returns:
            output: decompressed text

        Tests:
            >>> lz77_compressor = LZ77Compressor()
            >>> lz77_compressor.decompress([Token(0, 0, 'c'), Token(0, 0, 'a'),
            ... Token(0, 0, 'b'), Token(0, 0, 'r'), Token(3, 1, 'c'),
            ... Token(2, 1, 'd'), Token(7, 4, 'r'), Token(3, 5, 'd')])
            'cabracadabrarrarrad'
            >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(0, 0, 'b'),
            ... Token(2, 2, 'c'), Token(4, 3, 'a'), Token(2, 2, 'a')])
            'ababcbababaa'
            >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(1, 1, 'c'),
            ... Token(3, 4, 'b'), Token(3, 3, 'a'), Token(1, 2, 'c')])
            'aacaacabcabaaac'
        """"""

        output = """"

        for token in tokens:
            for _ in range(token.length):
                output += output[-token.offset]
            output += token.indicator

        return output",data\repos\Python\data_compression\lz77.py,decompress,352
603,peak_signal_to_noise_ratio.py::peak_signal_to_noise_ratio::17,"def peak_signal_to_noise_ratio(original: float, contrast: float) -> float:
    mse = np.mean((original - contrast) ** 2)
    if mse == 0:
        return 100

    return 20 * math.log10(PIXEL_MAX / math.sqrt(mse))",data\repos\Python\data_compression\peak_signal_to_noise_ratio.py,peak_signal_to_noise_ratio,61
604,peak_signal_to_noise_ratio.py::main::25,"def main() -> None:
    dir_path = os.path.dirname(os.path.realpath(__file__))
    # Loading images (original image and compressed image)
    original = cv2.imread(os.path.join(dir_path, ""image_data/original_image.png""))
    contrast = cv2.imread(os.path.join(dir_path, ""image_data/compressed_image.png""), 1)

    original2 = cv2.imread(os.path.join(dir_path, ""image_data/PSNR-example-base.png""))
    contrast2 = cv2.imread(
        os.path.join(dir_path, ""image_data/PSNR-example-comp-10.jpg""), 1
    )

    # Value expected: 29.73dB
    print(""-- First Test --"")
    print(f""PSNR value is {peak_signal_to_noise_ratio(original, contrast)} dB"")

    # # Value expected: 31.53dB (Wikipedia Example)
    print(""\n-- Second Test --"")
    print(f""PSNR value is {peak_signal_to_noise_ratio(original2, contrast2)} dB"")",data\repos\Python\data_compression\peak_signal_to_noise_ratio.py,main,212
605,run_length_encoding.py::run_length_encode::4,"def run_length_encode(text: str) -> list:
    """"""
    Performs Run Length Encoding
    >>> run_length_encode(""AAAABBBCCDAA"")
    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]
    >>> run_length_encode(""A"")
    [('A', 1)]
    >>> run_length_encode(""AA"")
    [('A', 2)]
    >>> run_length_encode(""AAADDDDDDFFFCCCAAVVVV"")
    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]
    """"""
    encoded = []
    count = 1

    for i in range(len(text)):
        if i + 1 < len(text) and text[i] == text[i + 1]:
            count += 1
        else:
            encoded.append((text[i], count))
            count = 1

    return encoded",data\repos\Python\data_compression\run_length_encoding.py,run_length_encode,215
606,run_length_encoding.py::run_length_decode::29,"def run_length_decode(encoded: list) -> str:
    """"""
    Performs Run Length Decoding
    >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])
    'AAAABBBCCDAA'
    >>> run_length_decode([('A', 1)])
    'A'
    >>> run_length_decode([('A', 2)])
    'AA'
    >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])
    'AAADDDDDDFFFCCCAAVVVV'
    """"""
    return """".join(char * length for char, length in encoded)",data\repos\Python\data_compression\run_length_encoding.py,run_length_decode,164
607,change_brightness.py::change_brightness::4,"def change_brightness(img: Image, level: float) -> Image:
    """"""
    Change the brightness of a PIL Image to a given level.
    """"""

    def brightness(c: int) -> float:
        """"""
        Fundamental Transformation/Operation that'll be performed on
        every bit.
        """"""
        return 128 + level + (c - 128)

    if not -255.0 <= level <= 255.0:
        raise ValueError(""level must be between -255.0 (black) and 255.0 (white)"")
    return img.point(brightness)",data\repos\Python\digital_image_processing\change_brightness.py,change_brightness,118
608,change_brightness.py::brightness::9,"    def brightness(c: int) -> float:
        """"""
        Fundamental Transformation/Operation that'll be performed on
        every bit.
        """"""
        return 128 + level + (c - 128)",data\repos\Python\digital_image_processing\change_brightness.py,brightness,42
609,change_contrast.py::change_contrast::14,"def change_contrast(img: Image, level: int) -> Image:
    """"""
    Function to change contrast
    """"""
    factor = (259 * (level + 255)) / (255 * (259 - level))

    def contrast(c: int) -> int:
        """"""
        Fundamental Transformation/Operation that'll be performed on
        every bit.
        """"""
        return int(128 + factor * (c - 128))

    return img.point(contrast)",data\repos\Python\digital_image_processing\change_contrast.py,change_contrast,96
610,change_contrast.py::contrast::20,"    def contrast(c: int) -> int:
        """"""
        Fundamental Transformation/Operation that'll be performed on
        every bit.
        """"""
        return int(128 + factor * (c - 128))",data\repos\Python\digital_image_processing\change_contrast.py,contrast,43
611,convert_to_negative.py::convert_to_negative::8,"def convert_to_negative(img):
    # getting number of pixels in the image
    pixel_h, pixel_v = img.shape[0], img.shape[1]

    # converting each pixel's color to its negative
    for i in range(pixel_h):
        for j in range(pixel_v):
            img[i][j] = [255, 255, 255] - img[i][j]

    return img",data\repos\Python\digital_image_processing\convert_to_negative.py,convert_to_negative,85
612,index_calculation.py::set_matricies::110,"    def set_matricies(self, red=None, green=None, blue=None, red_edge=None, nir=None):
        if red is not None:
            self.red = red
        if green is not None:
            self.green = green
        if blue is not None:
            self.blue = blue
        if red_edge is not None:
            self.redEdge = red_edge
        if nir is not None:
            self.nir = nir
        return True",data\repos\Python\digital_image_processing\index_calculation.py,set_matricies,96
613,index_calculation.py::calculation::123,"    def calculation(
        self, index="""", red=None, green=None, blue=None, red_edge=None, nir=None
    ):
        """"""
        performs the calculation of the index with the values instantiated in the class
        :str index: abbreviation of index name to perform
        """"""
        self.set_matricies(red=red, green=green, blue=blue, red_edge=red_edge, nir=nir)
        funcs = {
            ""ARVI2"": self.arv12,
            ""CCCI"": self.ccci,
            ""CVI"": self.cvi,
            ""GLI"": self.gli,
            ""NDVI"": self.ndvi,
            ""BNDVI"": self.bndvi,
            ""redEdgeNDVI"": self.red_edge_ndvi,
            ""GNDVI"": self.gndvi,
            ""GBNDVI"": self.gbndvi,
            ""GRNDVI"": self.grndvi,
            ""RBNDVI"": self.rbndvi,
            ""PNDVI"": self.pndvi,
            ""ATSAVI"": self.atsavi,
            ""BWDRVI"": self.bwdrvi,
            ""CIgreen"": self.ci_green,
            ""CIrededge"": self.ci_rededge,
            ""CI"": self.ci,
            ""CTVI"": self.ctvi,
            ""GDVI"": self.gdvi,
            ""EVI"": self.evi,
            ""GEMI"": self.gemi,
            ""GOSAVI"": self.gosavi,
            ""GSAVI"": self.gsavi,
            ""Hue"": self.hue,
            ""IVI"": self.ivi,
            ""IPVI"": self.ipvi,
            ""I"": self.i,
            ""RVI"": self.rvi,
            ""MRVI"": self.mrvi,
            ""MSAVI"": self.m_savi,
            ""NormG"": self.norm_g,
            ""NormNIR"": self.norm_nir,
            ""NormR"": self.norm_r,
            ""NGRDI"": self.ngrdi,
            ""RI"": self.ri,
            ""S"": self.s,
            ""IF"": self._if,
            ""DVI"": self.dvi,
            ""TVI"": self.tvi,
            ""NDRE"": self.ndre,
        }

        try:
            return funcs[index]()
        except KeyError:
            print(""Index not in the list!"")
            return False",data\repos\Python\digital_image_processing\index_calculation.py,calculation,506
614,index_calculation.py::arv12::180,"    def arv12(self):
        """"""
        Atmospherically Resistant Vegetation Index 2
        https://www.indexdatabase.de/db/i-single.php?id=396
        :return: index
            -0.18+1.17*(self.nir-self.red)/(self.nir+self.red)
        """"""
        return -0.18 + (1.17 * ((self.nir - self.red) / (self.nir + self.red)))",data\repos\Python\digital_image_processing\index_calculation.py,arv12,95
615,index_calculation.py::ccci::189,"    def ccci(self):
        """"""
        Canopy Chlorophyll Content Index
        https://www.indexdatabase.de/db/i-single.php?id=224
        :return: index
        """"""
        return ((self.nir - self.redEdge) / (self.nir + self.redEdge)) / (
            (self.nir - self.red) / (self.nir + self.red)
        )",data\repos\Python\digital_image_processing\index_calculation.py,ccci,83
616,index_calculation.py::cvi::199,"    def cvi(self):
        """"""
        Chlorophyll vegetation index
        https://www.indexdatabase.de/db/i-single.php?id=391
        :return: index
        """"""
        return self.nir * (self.red / (self.green**2))",data\repos\Python\digital_image_processing\index_calculation.py,cvi,54
617,index_calculation.py::gli::207,"    def gli(self):
        """"""
        self.green leaf index
        https://www.indexdatabase.de/db/i-single.php?id=375
        :return: index
        """"""
        return (2 * self.green - self.red - self.blue) / (
            2 * self.green + self.red + self.blue
        )",data\repos\Python\digital_image_processing\index_calculation.py,gli,67
618,index_calculation.py::ndvi::217,"    def ndvi(self):
        """"""
        Normalized Difference self.nir/self.red Normalized Difference Vegetation
        Index, Calibrated NDVI - CDVI
        https://www.indexdatabase.de/db/i-single.php?id=58
        :return: index
        """"""
        return (self.nir - self.red) / (self.nir + self.red)",data\repos\Python\digital_image_processing\index_calculation.py,ndvi,76
619,index_calculation.py::bndvi::226,"    def bndvi(self):
        """"""
            Normalized Difference self.nir/self.blue self.blue-normalized difference
        vegetation index
        https://www.indexdatabase.de/db/i-single.php?id=135
        :return: index
        """"""
        return (self.nir - self.blue) / (self.nir + self.blue)",data\repos\Python\digital_image_processing\index_calculation.py,bndvi,70
620,index_calculation.py::red_edge_ndvi::235,"    def red_edge_ndvi(self):
        """"""
        Normalized Difference self.rededge/self.red
        https://www.indexdatabase.de/db/i-single.php?id=235
        :return: index
        """"""
        return (self.redEdge - self.red) / (self.redEdge + self.red)",data\repos\Python\digital_image_processing\index_calculation.py,red_edge_ndvi,62
621,index_calculation.py::gndvi::243,"    def gndvi(self):
        """"""
        Normalized Difference self.nir/self.green self.green NDVI
        https://www.indexdatabase.de/db/i-single.php?id=401
        :return: index
        """"""
        return (self.nir - self.green) / (self.nir + self.green)",data\repos\Python\digital_image_processing\index_calculation.py,gndvi,65
622,index_calculation.py::gbndvi::251,"    def gbndvi(self):
        """"""
        self.green-self.blue NDVI
        https://www.indexdatabase.de/db/i-single.php?id=186
        :return: index
        """"""
        return (self.nir - (self.green + self.blue)) / (
            self.nir + (self.green + self.blue)
        )",data\repos\Python\digital_image_processing\index_calculation.py,gbndvi,70
623,index_calculation.py::grndvi::261,"    def grndvi(self):
        """"""
        self.green-self.red NDVI
        https://www.indexdatabase.de/db/i-single.php?id=185
        :return: index
        """"""
        return (self.nir - (self.green + self.red)) / (
            self.nir + (self.green + self.red)
        )",data\repos\Python\digital_image_processing\index_calculation.py,grndvi,70
624,index_calculation.py::rbndvi::271,"    def rbndvi(self):
        """"""
        self.red-self.blue NDVI
        https://www.indexdatabase.de/db/i-single.php?id=187
        :return: index
        """"""
        return (self.nir - (self.blue + self.red)) / (self.nir + (self.blue + self.red))",data\repos\Python\digital_image_processing\index_calculation.py,rbndvi,67
625,index_calculation.py::pndvi::279,"    def pndvi(self):
        """"""
        Pan NDVI
        https://www.indexdatabase.de/db/i-single.php?id=188
        :return: index
        """"""
        return (self.nir - (self.green + self.red + self.blue)) / (
            self.nir + (self.green + self.red + self.blue)
        )",data\repos\Python\digital_image_processing\index_calculation.py,pndvi,73
626,index_calculation.py::atsavi::289,"    def atsavi(self, x=0.08, a=1.22, b=0.03):
        """"""
        Adjusted transformed soil-adjusted VI
        https://www.indexdatabase.de/db/i-single.php?id=209
        :return: index
        """"""
        return a * (
            (self.nir - a * self.red - b)
            / (a * self.nir + self.red - a * b + x * (1 + a**2))
        )",data\repos\Python\digital_image_processing\index_calculation.py,atsavi,104
627,index_calculation.py::bwdrvi::300,"    def bwdrvi(self):
        """"""
        self.blue-wide dynamic range vegetation index
        https://www.indexdatabase.de/db/i-single.php?id=136
        :return: index
        """"""
        return (0.1 * self.nir - self.blue) / (0.1 * self.nir + self.blue)",data\repos\Python\digital_image_processing\index_calculation.py,bwdrvi,68
628,index_calculation.py::ci_green::308,"    def ci_green(self):
        """"""
        Chlorophyll Index self.green
        https://www.indexdatabase.de/db/i-single.php?id=128
        :return: index
        """"""
        return (self.nir / self.green) - 1",data\repos\Python\digital_image_processing\index_calculation.py,ci_green,52
629,index_calculation.py::ci_rededge::316,"    def ci_rededge(self):
        """"""
        Chlorophyll Index self.redEdge
        https://www.indexdatabase.de/db/i-single.php?id=131
        :return: index
        """"""
        return (self.nir / self.redEdge) - 1",data\repos\Python\digital_image_processing\index_calculation.py,ci_rededge,55
630,index_calculation.py::ci::324,"    def ci(self):
        """"""
        Coloration Index
        https://www.indexdatabase.de/db/i-single.php?id=11
        :return: index
        """"""
        return (self.red - self.blue) / self.red",data\repos\Python\digital_image_processing\index_calculation.py,ci,47
631,index_calculation.py::ctvi::332,"    def ctvi(self):
        """"""
        Corrected Transformed Vegetation Index
        https://www.indexdatabase.de/db/i-single.php?id=244
        :return: index
        """"""
        ndvi = self.ndvi()
        return ((ndvi + 0.5) / (abs(ndvi + 0.5))) * (abs(ndvi + 0.5) ** (1 / 2))",data\repos\Python\digital_image_processing\index_calculation.py,ctvi,88
632,index_calculation.py::gdvi::341,"    def gdvi(self):
        """"""
        Difference self.nir/self.green self.green Difference Vegetation Index
        https://www.indexdatabase.de/db/i-single.php?id=27
        :return: index
        """"""
        return self.nir - self.green",data\repos\Python\digital_image_processing\index_calculation.py,gdvi,53
633,index_calculation.py::evi::349,"    def evi(self):
        """"""
        Enhanced Vegetation Index
        https://www.indexdatabase.de/db/i-single.php?id=16
        :return: index
        """"""
        return 2.5 * (
            (self.nir - self.red) / (self.nir + 6 * self.red - 7.5 * self.blue + 1)
        )",data\repos\Python\digital_image_processing\index_calculation.py,evi,79
634,index_calculation.py::gemi::359,"    def gemi(self):
        """"""
        Global Environment Monitoring Index
        https://www.indexdatabase.de/db/i-single.php?id=25
        :return: index
        """"""
        n = (2 * (self.nir**2 - self.red**2) + 1.5 * self.nir + 0.5 * self.red) / (
            self.nir + self.red + 0.5
        )
        return n * (1 - 0.25 * n) - (self.red - 0.125) / (1 - self.red)",data\repos\Python\digital_image_processing\index_calculation.py,gemi,121
635,index_calculation.py::gosavi::370,"    def gosavi(self, y=0.16):
        """"""
        self.green Optimized Soil Adjusted Vegetation Index
        https://www.indexdatabase.de/db/i-single.php?id=29
        mit Y = 0,16
        :return: index
        """"""
        return (self.nir - self.green) / (self.nir + self.green + y)",data\repos\Python\digital_image_processing\index_calculation.py,gosavi,80
636,index_calculation.py::gsavi::379,"    def gsavi(self, n=0.5):
        """"""
        self.green Soil Adjusted Vegetation Index
        https://www.indexdatabase.de/db/i-single.php?id=31
        mit N = 0,5
        :return: index
        """"""
        return ((self.nir - self.green) / (self.nir + self.green + n)) * (1 + n)",data\repos\Python\digital_image_processing\index_calculation.py,gsavi,83
637,index_calculation.py::hue::388,"    def hue(self):
        """"""
        Hue
        https://www.indexdatabase.de/db/i-single.php?id=34
        :return: index
        """"""
        return np.arctan(
            ((2 * self.red - self.green - self.blue) / 30.5) * (self.green - self.blue)
        )",data\repos\Python\digital_image_processing\index_calculation.py,hue,69
638,index_calculation.py::ivi::398,"    def ivi(self, a=None, b=None):
        """"""
        Ideal vegetation index
        https://www.indexdatabase.de/db/i-single.php?id=276
        b=intercept of vegetation line
        a=soil line slope
        :return: index
        """"""
        return (self.nir - b) / (a * self.red)",data\repos\Python\digital_image_processing\index_calculation.py,ivi,75
639,index_calculation.py::ipvi::408,"    def ipvi(self):
        """"""
        Infraself.red percentage vegetation index
        https://www.indexdatabase.de/db/i-single.php?id=35
        :return: index
        """"""
        return (self.nir / ((self.nir + self.red) / 2)) * (self.ndvi() + 1)",data\repos\Python\digital_image_processing\index_calculation.py,ipvi,70
640,index_calculation.py::i::416,"    def i(self):
        """"""
        Intensity
        https://www.indexdatabase.de/db/i-single.php?id=36
        :return: index
        """"""
        return (self.red + self.green + self.blue) / 30.5",data\repos\Python\digital_image_processing\index_calculation.py,i,51
641,index_calculation.py::rvi::424,"    def rvi(self):
        """"""
        Ratio-Vegetation-Index
        http://www.seos-project.eu/modules/remotesensing/remotesensing-c03-s01-p01.html
        :return: index
        """"""
        return self.nir / self.red",data\repos\Python\digital_image_processing\index_calculation.py,rvi,56
642,index_calculation.py::mrvi::432,"    def mrvi(self):
        """"""
        Modified Normalized Difference Vegetation Index RVI
        https://www.indexdatabase.de/db/i-single.php?id=275
        :return: index
        """"""
        return (self.rvi() - 1) / (self.rvi() + 1)",data\repos\Python\digital_image_processing\index_calculation.py,mrvi,63
643,index_calculation.py::m_savi::440,"    def m_savi(self):
        """"""
        Modified Soil Adjusted Vegetation Index
        https://www.indexdatabase.de/db/i-single.php?id=44
        :return: index
        """"""
        return (
            (2 * self.nir + 1)
            - ((2 * self.nir + 1) ** 2 - 8 * (self.nir - self.red)) ** (1 / 2)
        ) / 2",data\repos\Python\digital_image_processing\index_calculation.py,m_savi,94
644,index_calculation.py::norm_g::451,"    def norm_g(self):
        """"""
        Norm G
        https://www.indexdatabase.de/db/i-single.php?id=50
        :return: index
        """"""
        return self.green / (self.nir + self.red + self.green)",data\repos\Python\digital_image_processing\index_calculation.py,norm_g,51
645,index_calculation.py::norm_nir::459,"    def norm_nir(self):
        """"""
        Norm self.nir
        https://www.indexdatabase.de/db/i-single.php?id=51
        :return: index
        """"""
        return self.nir / (self.nir + self.red + self.green)",data\repos\Python\digital_image_processing\index_calculation.py,norm_nir,55
646,index_calculation.py::norm_r::467,"    def norm_r(self):
        """"""
        Norm R
        https://www.indexdatabase.de/db/i-single.php?id=52
        :return: index
        """"""
        return self.red / (self.nir + self.red + self.green)",data\repos\Python\digital_image_processing\index_calculation.py,norm_r,51
647,index_calculation.py::ngrdi::475,"    def ngrdi(self):
        """"""
            Normalized Difference self.green/self.red Normalized self.green self.red
        difference index, Visible Atmospherically Resistant Indices self.green
        (VIself.green)
        https://www.indexdatabase.de/db/i-single.php?id=390
        :return: index
        """"""
        return (self.green - self.red) / (self.green + self.red)",data\repos\Python\digital_image_processing\index_calculation.py,ngrdi,84
648,index_calculation.py::ri::485,"    def ri(self):
        """"""
        Normalized Difference self.red/self.green self.redness Index
        https://www.indexdatabase.de/db/i-single.php?id=74
        :return: index
        """"""
        return (self.red - self.green) / (self.red + self.green)",data\repos\Python\digital_image_processing\index_calculation.py,ri,60
649,index_calculation.py::s::493,"    def s(self):
        """"""
        Saturation
        https://www.indexdatabase.de/db/i-single.php?id=77
        :return: index
        """"""
        max_value = np.max([np.max(self.red), np.max(self.green), np.max(self.blue)])
        min_value = np.min([np.min(self.red), np.min(self.green), np.min(self.blue)])
        return (max_value - min_value) / max_value",data\repos\Python\digital_image_processing\index_calculation.py,s,90
650,index_calculation.py::dvi::511,"    def dvi(self):
        """"""
        Simple Ratio self.nir/self.red Difference Vegetation Index, Vegetation Index
        Number (VIN)
        https://www.indexdatabase.de/db/i-single.php?id=12
        :return: index
        """"""
        return self.nir / self.red",data\repos\Python\digital_image_processing\index_calculation.py,dvi,61
651,index_calculation.py::tvi::520,"    def tvi(self):
        """"""
        Transformed Vegetation Index
        https://www.indexdatabase.de/db/i-single.php?id=98
        :return: index
        """"""
        return (self.ndvi() + 0.5) ** (1 / 2)",data\repos\Python\digital_image_processing\index_calculation.py,tvi,58
652,sepia.py::make_sepia::8,"def make_sepia(img, factor: int):
    """"""
    Function create sepia tone.
    Source: https://en.wikipedia.org/wiki/Sepia_(color)
    """"""
    pixel_h, pixel_v = img.shape[0], img.shape[1]

    def to_grayscale(blue, green, red):
        """"""
        Helper function to create pixel's greyscale representation
        Src: https://pl.wikipedia.org/wiki/YUV
        """"""
        return 0.2126 * red + 0.587 * green + 0.114 * blue

    def normalize(value):
        """"""Helper function to normalize R/G/B value -> return 255 if value > 255""""""
        return min(value, 255)

    for i in range(pixel_h):
        for j in range(pixel_v):
            greyscale = int(to_grayscale(*img[i][j]))
            img[i][j] = [
                normalize(greyscale),
                normalize(greyscale + factor),
                normalize(greyscale + 2 * factor),
            ]

    return img",data\repos\Python\digital_image_processing\sepia.py,make_sepia,217
653,sepia.py::to_grayscale::15,"    def to_grayscale(blue, green, red):
        """"""
        Helper function to create pixel's greyscale representation
        Src: https://pl.wikipedia.org/wiki/YUV
        """"""
        return 0.2126 * red + 0.587 * green + 0.114 * blue",data\repos\Python\digital_image_processing\sepia.py,to_grayscale,62
654,sepia.py::normalize::22,"    def normalize(value):
        """"""Helper function to normalize R/G/B value -> return 255 if value > 255""""""
        return min(value, 255)",data\repos\Python\digital_image_processing\sepia.py,normalize,33
655,test_digital_image_processing.py::test_convert_to_negative::27,"def test_convert_to_negative():
    negative_img = cn.convert_to_negative(img)
    # assert negative_img array for at least one True
    assert negative_img.any()",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_convert_to_negative,34
656,test_digital_image_processing.py::test_change_contrast::34,"def test_change_contrast():
    with Image.open(""digital_image_processing/image_data/lena_small.jpg"") as img:
        # Work around assertion for response
        assert str(cc.change_contrast(img, 110)).startswith(
            ""<PIL.Image.Image image mode=RGB size=100x100 at""
        )",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_change_contrast,65
657,test_digital_image_processing.py::test_gen_gaussian_kernel::43,"def test_gen_gaussian_kernel():
    resp = canny.gen_gaussian_kernel(9, sigma=1.4)
    # Assert ambiguous array
    assert resp.all()",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_gen_gaussian_kernel,36
658,test_digital_image_processing.py::test_canny::50,"def test_canny():
    canny_img = imread(""digital_image_processing/image_data/lena_small.jpg"", 0)
    # assert ambiguous array for all == True
    assert canny_img.all()
    canny_array = canny.canny(canny_img)
    # assert canny array for at least one True
    assert canny_array.any()",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_canny,74
659,test_digital_image_processing.py::test_convolve_filter::64,"def test_convolve_filter():
    # laplace diagonals
    laplace = array([[0.25, 0.5, 0.25], [0.5, -3, 0.5], [0.25, 0.5, 0.25]])
    res = conv.img_convolve(gray, laplace).astype(uint8)
    assert res.any()",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_convolve_filter,82
660,test_digital_image_processing.py::test_burkes::86,"def test_burkes(file_path: str = ""digital_image_processing/image_data/lena_small.jpg""):
    burkes = bs.Burkes(imread(file_path, 1), 120)
    burkes.process()
    assert burkes.output_img.any()",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_burkes,53
661,test_digital_image_processing.py::test_nearest_neighbour::92,"def test_nearest_neighbour(
    file_path: str = ""digital_image_processing/image_data/lena_small.jpg"",
):
    nn = rs.NearestNeighbour(imread(file_path, 1), 400, 200)
    nn.process()
    assert nn.output.any()",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_nearest_neighbour,58
662,test_digital_image_processing.py::test_local_binary_pattern::100,"def test_local_binary_pattern():
    # pull request 10161 before:
    # ""digital_image_processing/image_data/lena.jpg""
    # after: ""digital_image_processing/image_data/lena_small.jpg""

    from os import getenv  # Speed up our Continuous Integration tests

    file_name = ""lena_small.jpg"" if getenv(""CI"") else ""lena.jpg""
    file_path = f""digital_image_processing/image_data/{file_name}""

    # Reading the image and converting it to grayscale
    image = imread(file_path, 0)

    # Test for get_neighbors_pixel function() return not None
    x_coordinate = 0
    y_coordinate = 0
    center = image[x_coordinate][y_coordinate]

    neighbors_pixels = lbp.get_neighbors_pixel(
        image, x_coordinate, y_coordinate, center
    )

    assert neighbors_pixels is not None

    # Test for local_binary_pattern function()
    # Create a numpy array as the same height and width of read image
    lbp_image = np.zeros((image.shape[0], image.shape[1]))

    # Iterating through the image and calculating the local binary pattern value
    # for each pixel.
    for i in range(image.shape[0]):
        for j in range(image.shape[1]):
            lbp_image[i][j] = lbp.local_binary_value(image, i, j)

    assert lbp_image.any()",data\repos\Python\digital_image_processing\test_digital_image_processing.py,test_local_binary_pattern,290
663,closest_pair_of_points.py::euclidean_distance_sqr::23,"def euclidean_distance_sqr(point1, point2):
    """"""
    >>> euclidean_distance_sqr([1,2],[2,4])
    5
    """"""
    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2",data\repos\Python\divide_and_conquer\closest_pair_of_points.py,euclidean_distance_sqr,69
664,closest_pair_of_points.py::column_based_sort::31,"def column_based_sort(array, column=0):
    """"""
    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)
    [(3, 0), (5, 1), (4, 2)]
    """"""
    return sorted(array, key=lambda x: x[column])",data\repos\Python\divide_and_conquer\closest_pair_of_points.py,column_based_sort,71
665,closest_pair_of_points.py::dis_between_closest_pair::39,"def dis_between_closest_pair(points, points_counts, min_dis=float(""inf"")):
    """"""
    brute force approach to find distance between closest pair points

    Parameters :
    points, points_count, min_dis (list(tuple(int, int)), int, int)

    Returns :
    min_dis (float):  distance between closest pair of points

    >>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5)
    5

    """"""

    for i in range(points_counts - 1):
        for j in range(i + 1, points_counts):
            current_dis = euclidean_distance_sqr(points[i], points[j])
            min_dis = min(min_dis, current_dis)
    return min_dis",data\repos\Python\divide_and_conquer\closest_pair_of_points.py,dis_between_closest_pair,161
666,closest_pair_of_points.py::dis_between_closest_in_strip::61,"def dis_between_closest_in_strip(points, points_counts, min_dis=float(""inf"")):
    """"""
    closest pair of points in strip

    Parameters :
    points, points_count, min_dis (list(tuple(int, int)), int, int)

    Returns :
    min_dis (float):  distance btw closest pair of points in the strip (< min_dis)

    >>> dis_between_closest_in_strip([[1,2],[2,4],[5,7],[8,9],[11,0]],5)
    85
    """"""

    for i in range(min(6, points_counts - 1), points_counts):
        for j in range(max(0, i - 6), i):
            current_dis = euclidean_distance_sqr(points[i], points[j])
            min_dis = min(min_dis, current_dis)
    return min_dis",data\repos\Python\divide_and_conquer\closest_pair_of_points.py,dis_between_closest_in_strip,175
667,closest_pair_of_points.py::closest_pair_of_points_sqr::82,"def closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, points_counts):
    """"""divide and conquer approach

    Parameters :
    points, points_count (list(tuple(int, int)), int)

    Returns :
    (float):  distance btw closest pair of points

    >>> closest_pair_of_points_sqr([(1, 2), (3, 4)], [(5, 6), (7, 8)], 2)
    8
    """"""

    # base case
    if points_counts <= 3:
        return dis_between_closest_pair(points_sorted_on_x, points_counts)

    # recursion
    mid = points_counts // 2
    closest_in_left = closest_pair_of_points_sqr(
        points_sorted_on_x, points_sorted_on_y[:mid], mid
    )
    closest_in_right = closest_pair_of_points_sqr(
        points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid
    )
    closest_pair_dis = min(closest_in_left, closest_in_right)

    """"""
    cross_strip contains the points, whose Xcoords are at a
    distance(< closest_pair_dis) from mid's Xcoord
    """"""

    cross_strip = []
    for point in points_sorted_on_x:
        if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:
            cross_strip.append(point)

    closest_in_strip = dis_between_closest_in_strip(
        cross_strip, len(cross_strip), closest_pair_dis
    )
    return min(closest_pair_dis, closest_in_strip)",data\repos\Python\divide_and_conquer\closest_pair_of_points.py,closest_pair_of_points_sqr,327
668,closest_pair_of_points.py::closest_pair_of_points::125,"def closest_pair_of_points(points, points_counts):
    """"""
    >>> closest_pair_of_points([(2, 3), (12, 30)], len([(2, 3), (12, 30)]))
    28.792360097775937
    """"""
    points_sorted_on_x = column_based_sort(points, column=0)
    points_sorted_on_y = column_based_sort(points, column=1)
    return (
        closest_pair_of_points_sqr(
            points_sorted_on_x, points_sorted_on_y, points_counts
        )
    ) ** 0.5",data\repos\Python\divide_and_conquer\closest_pair_of_points.py,closest_pair_of_points,120
669,convex_hull.py::convex_hull_bf::223,"def convex_hull_bf(points: list[Point]) -> list[Point]:
    """"""
    Constructs the convex hull of a set of 2D points using a brute force algorithm.
    The algorithm basically considers all combinations of points (i, j) and uses the
    definition of convexity to determine whether (i, j) is part of the convex hull or
    not.  (i, j) is part of the convex hull if and only iff there are no points on both
    sides of the line segment connecting the ij, and there is no point k such that k is
    on either end of the ij.

    Runtime: O(n^3) - definitely horrible

    Parameters
    ---------
    points: array-like of object of Points, lists or tuples.
    The set of  2d points for which the convex-hull is needed

    Returns
    ------
    convex_set: list, the convex-hull of points sorted in non-decreasing order.

    See Also
    --------
    convex_hull_recursive,

     Examples
     ---------
     >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])
     [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
     >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])
     [(0.0, 0.0), (10.0, 0.0)]
     >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
     ...                 [-0.75, 1]])
     [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
     >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
     ...                 (2, -1), (2, -4), (1, -3)])
     [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]
    """"""

    points = sorted(_validate_input(points))
    n = len(points)
    convex_set = set()

    for i in range(n - 1):
        for j in range(i + 1, n):
            points_left_of_ij = points_right_of_ij = False
            ij_part_of_convex_hull = True
            for k in range(n):
                if k not in {i, j}:
                    det_k = _det(points[i], points[j], points[k])

                    if det_k > 0:
                        points_left_of_ij = True
                    elif det_k < 0:
                        points_right_of_ij = True
                    # point[i], point[j], point[k] all lie on a straight line
                    # if point[k] is to the left of point[i] or it's to the
                    # right of point[j], then point[i], point[j] cannot be
                    # part of the convex hull of A
                    elif points[k] < points[i] or points[k] > points[j]:
                        ij_part_of_convex_hull = False
                        break

                if points_left_of_ij and points_right_of_ij:
                    ij_part_of_convex_hull = False
                    break

            if ij_part_of_convex_hull:
                convex_set.update([points[i], points[j]])

    return sorted(convex_set)",data\repos\Python\divide_and_conquer\convex_hull.py,convex_hull_bf,842
670,convex_hull.py::convex_hull_recursive::295,"def convex_hull_recursive(points: list[Point]) -> list[Point]:
    """"""
    Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy
    The algorithm exploits the geometric properties of the problem by repeatedly
    partitioning the set of points into smaller hulls, and finding the convex hull of
    these smaller hulls.  The union of the convex hull from smaller hulls is the
    solution to the convex hull of the larger problem.

    Parameter
    ---------
    points: array-like of object of Points, lists or tuples.
    The set of  2d points for which the convex-hull is needed

    Runtime: O(n log n)

    Returns
    -------
    convex_set: list, the convex-hull of points sorted in non-decreasing order.

    Examples
    ---------
    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 1]])
    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 0]])
    [(0.0, 0.0), (10.0, 0.0)]
    >>> convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
    ...                        [-0.75, 1]])
    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
    >>> convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
    ...                        (2, -1), (2, -4), (1, -3)])
    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]

    """"""
    points = sorted(_validate_input(points))
    n = len(points)

    # divide all the points into an upper hull and a lower hull
    # the left most point and the right most point are definitely
    # members of the convex hull by definition.
    # use these two anchors to divide all the points into two hulls,
    # an upper hull and a lower hull.

    # all points to the left (above) the line joining the extreme points belong to the
    # upper hull
    # all points to the right (below) the line joining the extreme points below to the
    # lower hull
    # ignore all points on the line joining the extreme points since they cannot be
    # part of the convex hull

    left_most_point = points[0]
    right_most_point = points[n - 1]

    convex_set = {left_most_point, right_most_point}
    upper_hull = []
    lower_hull = []

    for i in range(1, n - 1):
        det = _det(left_most_point, right_most_point, points[i])

        if det > 0:
            upper_hull.append(points[i])
        elif det < 0:
            lower_hull.append(points[i])

    _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)
    _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)

    return sorted(convex_set)",data\repos\Python\divide_and_conquer\convex_hull.py,convex_hull_recursive,816
671,convex_hull.py::convex_hull_melkman::409,"def convex_hull_melkman(points: list[Point]) -> list[Point]:
    """"""
    Constructs the convex hull of a set of 2D points using the melkman algorithm.
    The algorithm works by iteratively inserting points of a simple polygonal chain
    (meaning that no line segments between two consecutive points cross each other).
    Sorting the points yields such a polygonal chain.

    For a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html

    Runtime: O(n log n) - O(n) if points are already sorted in the input

    Parameters
    ---------
    points: array-like of object of Points, lists or tuples.
    The set of 2d points for which the convex-hull is needed

    Returns
    ------
    convex_set: list, the convex-hull of points sorted in non-decreasing order.

    See Also
    --------

    Examples
    ---------
    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 1]])
    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 0]])
    [(0.0, 0.0), (10.0, 0.0)]
    >>> convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
    ...                 [-0.75, 1]])
    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
    >>> convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
    ...                 (2, -1), (2, -4), (1, -3)])
    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]
    """"""
    points = sorted(_validate_input(points))
    n = len(points)

    convex_hull = points[:2]
    for i in range(2, n):
        det = _det(convex_hull[1], convex_hull[0], points[i])
        if det > 0:
            convex_hull.insert(0, points[i])
            break
        elif det < 0:
            convex_hull.append(points[i])
            break
        else:
            convex_hull[1] = points[i]
    i += 1

    for j in range(i, n):
        if (
            _det(convex_hull[0], convex_hull[-1], points[j]) > 0
            and _det(convex_hull[-1], convex_hull[0], points[1]) < 0
        ):
            # The point lies within the convex hull
            continue

        convex_hull.insert(0, points[j])
        convex_hull.append(points[j])
        while _det(convex_hull[0], convex_hull[1], convex_hull[2]) >= 0:
            del convex_hull[1]
        while _det(convex_hull[-1], convex_hull[-2], convex_hull[-3]) <= 0:
            del convex_hull[-2]

    # `convex_hull` is contains the convex hull in circular order
    return sorted(convex_hull[1:] if len(convex_hull) > 3 else convex_hull)",data\repos\Python\divide_and_conquer\convex_hull.py,convex_hull_melkman,869
672,convex_hull.py::main::480,"def main():
    points = [
        (0, 3),
        (2, 2),
        (1, 1),
        (2, 1),
        (3, 0),
        (0, 0),
        (3, 3),
        (2, -1),
        (2, -4),
        (1, -3),
    ]
    # the convex set of points is
    # [(0, 0), (0, 3), (1, -3), (2, -4), (3, 0), (3, 3)]
    results_bf = convex_hull_bf(points)

    results_recursive = convex_hull_recursive(points)
    assert results_bf == results_recursive

    results_melkman = convex_hull_melkman(points)
    assert results_bf == results_melkman

    print(results_bf)",data\repos\Python\divide_and_conquer\convex_hull.py,main,191
673,heaps_algorithm.py::heaps::10,"def heaps(arr: list) -> list:
    """"""
    Pure python implementation of the Heap's algorithm (recursive version),
    returning all permutations of a list.
    >>> heaps([])
    [()]
    >>> heaps([0])
    [(0,)]
    >>> heaps([-1, 1])
    [(-1, 1), (1, -1)]
    >>> heaps([1, 2, 3])
    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
    >>> from itertools import permutations
    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
    True
    >>> all(sorted(heaps(x)) == sorted(permutations(x))
    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))
    True
    """"""

    if len(arr) <= 1:
        return [tuple(arr)]

    res = []

    def generate(k: int, arr: list):
        if k == 1:
            res.append(tuple(arr[:]))
            return

        generate(k - 1, arr)

        for i in range(k - 1):
            if k % 2 == 0:  # k is even
                arr[i], arr[k - 1] = arr[k - 1], arr[i]
            else:  # k is odd
                arr[0], arr[k - 1] = arr[k - 1], arr[0]
            generate(k - 1, arr)

    generate(len(arr), arr)
    return res",data\repos\Python\divide_and_conquer\heaps_algorithm.py,heaps,372
674,heaps_algorithm.py::generate::35,"    def generate(k: int, arr: list):
        if k == 1:
            res.append(tuple(arr[:]))
            return

        generate(k - 1, arr)

        for i in range(k - 1):
            if k % 2 == 0:  # k is even
                arr[i], arr[k - 1] = arr[k - 1], arr[i]
            else:  # k is odd
                arr[0], arr[k - 1] = arr[k - 1], arr[0]
            generate(k - 1, arr)",data\repos\Python\divide_and_conquer\heaps_algorithm.py,generate,123
675,heaps_algorithm_iterative.py::heaps::10,"def heaps(arr: list) -> list:
    """"""
    Pure python implementation of the iterative Heap's algorithm,
    returning all permutations of a list.
    >>> heaps([])
    [()]
    >>> heaps([0])
    [(0,)]
    >>> heaps([-1, 1])
    [(-1, 1), (1, -1)]
    >>> heaps([1, 2, 3])
    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
    >>> from itertools import permutations
    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
    True
    >>> all(sorted(heaps(x)) == sorted(permutations(x))
    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))
    True
    """"""

    if len(arr) <= 1:
        return [tuple(arr)]

    res = []

    def generate(n: int, arr: list):
        c = [0] * n
        res.append(tuple(arr))

        i = 0
        while i < n:
            if c[i] < i:
                if i % 2 == 0:
                    arr[0], arr[i] = arr[i], arr[0]
                else:
                    arr[c[i]], arr[i] = arr[i], arr[c[i]]
                res.append(tuple(arr))
                c[i] += 1
                i = 0
            else:
                c[i] = 0
                i += 1

    generate(len(arr), arr)
    return res",data\repos\Python\divide_and_conquer\heaps_algorithm_iterative.py,heaps,375
676,heaps_algorithm_iterative.py::generate::35,"    def generate(n: int, arr: list):
        c = [0] * n
        res.append(tuple(arr))

        i = 0
        while i < n:
            if c[i] < i:
                if i % 2 == 0:
                    arr[0], arr[i] = arr[i], arr[0]
                else:
                    arr[c[i]], arr[i] = arr[i], arr[c[i]]
                res.append(tuple(arr))
                c[i] += 1
                i = 0
            else:
                c[i] = 0
                i += 1",data\repos\Python\divide_and_conquer\heaps_algorithm_iterative.py,generate,127
677,inversions.py::count_inversions_bf::12,"def count_inversions_bf(arr):
    """"""
    Counts the number of inversions using a naive brute-force algorithm
    Parameters
    ----------
    arr: arr: array-like, the list containing the items for which the number
    of inversions is desired. The elements of `arr` must be comparable.
    Returns
    -------
    num_inversions: The total number of inversions in `arr`
    Examples
    ---------
     >>> count_inversions_bf([1, 4, 2, 4, 1])
     4
     >>> count_inversions_bf([1, 1, 2, 4, 4])
     0
     >>> count_inversions_bf([])
     0
    """"""

    num_inversions = 0
    n = len(arr)

    for i in range(n - 1):
        for j in range(i + 1, n):
            if arr[i] > arr[j]:
                num_inversions += 1

    return num_inversions",data\repos\Python\divide_and_conquer\inversions.py,count_inversions_bf,214
678,inversions.py::count_inversions_recursive::43,"def count_inversions_recursive(arr):
    """"""
    Counts the number of inversions using a divide-and-conquer algorithm
    Parameters
    -----------
    arr: array-like, the list containing the items for which the number
    of inversions is desired. The elements of `arr` must be comparable.
    Returns
    -------
    C: a sorted copy of `arr`.
    num_inversions: int, the total number of inversions in 'arr'
    Examples
    --------
    >>> count_inversions_recursive([1, 4, 2, 4, 1])
    ([1, 1, 2, 4, 4], 4)
    >>> count_inversions_recursive([1, 1, 2, 4, 4])
    ([1, 1, 2, 4, 4], 0)
    >>> count_inversions_recursive([])
    ([], 0)
    """"""
    if len(arr) <= 1:
        return arr, 0
    mid = len(arr) // 2
    p = arr[0:mid]
    q = arr[mid:]

    a, inversion_p = count_inversions_recursive(p)
    b, inversions_q = count_inversions_recursive(q)
    c, cross_inversions = _count_cross_inversions(a, b)

    num_inversions = inversion_p + inversions_q + cross_inversions
    return c, num_inversions",data\repos\Python\divide_and_conquer\inversions.py,count_inversions_recursive,300
679,inversions.py::main::121,"def main():
    arr_1 = [10, 2, 1, 5, 5, 2, 11]

    # this arr has 8 inversions:
    # (10, 2), (10, 1), (10, 5), (10, 5), (10, 2), (2, 1), (5, 2), (5, 2)

    num_inversions_bf = count_inversions_bf(arr_1)
    _, num_inversions_recursive = count_inversions_recursive(arr_1)

    assert num_inversions_bf == num_inversions_recursive == 8

    print(""number of inversions = "", num_inversions_bf)

    # testing an array with zero inversion (a sorted arr_1)

    arr_1.sort()
    num_inversions_bf = count_inversions_bf(arr_1)
    _, num_inversions_recursive = count_inversions_recursive(arr_1)

    assert num_inversions_bf == num_inversions_recursive == 0
    print(""number of inversions = "", num_inversions_bf)

    # an empty list should also have zero inversions
    arr_1 = []
    num_inversions_bf = count_inversions_bf(arr_1)
    _, num_inversions_recursive = count_inversions_recursive(arr_1)

    assert num_inversions_bf == num_inversions_recursive == 0
    print(""number of inversions = "", num_inversions_bf)",data\repos\Python\divide_and_conquer\inversions.py,main,314
680,kth_order_statistic.py::random_pivot::17,"def random_pivot(lst):
    """"""
    Choose a random pivot for the list.
    We can use a more sophisticated algorithm here, such as the median-of-medians
    algorithm.
    """"""
    return choice(lst)",data\repos\Python\divide_and_conquer\kth_order_statistic.py,random_pivot,45
681,kth_order_statistic.py::kth_number::26,"def kth_number(lst: list[int], k: int) -> int:
    """"""
    Return the kth smallest number in lst.
    >>> kth_number([2, 1, 3, 4, 5], 3)
    3
    >>> kth_number([2, 1, 3, 4, 5], 1)
    1
    >>> kth_number([2, 1, 3, 4, 5], 5)
    5
    >>> kth_number([3, 2, 5, 6, 7, 8], 2)
    3
    >>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)
    43
    """"""
    # pick a pivot and separate into list based on pivot.
    pivot = random_pivot(lst)

    # partition based on pivot
    # linear time
    small = [e for e in lst if e < pivot]
    big = [e for e in lst if e > pivot]

    # if we get lucky, pivot might be the element we want.
    # we can easily see this:
    # small (elements smaller than k)
    # + pivot (kth element)
    # + big (elements larger than k)
    if len(small) == k - 1:
        return pivot
    # pivot is in elements bigger than k
    elif len(small) < k - 1:
        return kth_number(big, k - len(small) - 1)
    # pivot is in elements smaller than k
    else:
        return kth_number(small, k)",data\repos\Python\divide_and_conquer\kth_order_statistic.py,kth_number,373
682,max_difference_pair.py::max_difference::1,"def max_difference(a: list[int]) -> tuple[int, int]:
    """"""
    We are given an array A[1..n] of integers, n >= 1. We want to
    find a pair of indices (i, j) such that
    1 <= i <= j <= n and A[j] - A[i] is as large as possible.

    Explanation:
    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/

    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])
    (1, 9)
    """"""
    # base case
    if len(a) == 1:
        return a[0], a[0]
    else:
        # split A into half.
        first = a[: len(a) // 2]
        second = a[len(a) // 2 :]

        # 2 sub problems, 1/2 of original size.
        small1, big1 = max_difference(first)
        small2, big2 = max_difference(second)

        # get min of first and max of second
        # linear time
        min_first = min(first)
        max_second = max(second)

        # 3 cases, either (small1, big1),
        # (min_first, max_second), (small2, big2)
        # constant comparisons
        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:
            return small2, big2
        elif big1 - small1 > max_second - min_first:
            return small1, big1
        else:
            return min_first, max_second",data\repos\Python\divide_and_conquer\max_difference_pair.py,max_difference,360
683,max_subarray.py::max_subarray::19,"def max_subarray(
    arr: Sequence[float], low: int, high: int
) -> tuple[int | None, int | None, float]:
    """"""
    Solves the maximum subarray problem using divide and conquer.
    :param arr:     the given array of numbers
    :param low:     the start index
    :param high:    the end index
    :return:        the start index of the maximum subarray, the end index of the
                    maximum subarray, and the maximum subarray sum

    >>> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
    >>> max_subarray(nums, 0, len(nums) - 1)
    (3, 6, 6)
    >>> nums = [2, 8, 9]
    >>> max_subarray(nums, 0, len(nums) - 1)
    (0, 2, 19)
    >>> nums = [0, 0]
    >>> max_subarray(nums, 0, len(nums) - 1)
    (0, 0, 0)
    >>> nums = [-1.0, 0.0, 1.0]
    >>> max_subarray(nums, 0, len(nums) - 1)
    (2, 2, 1.0)
    >>> nums = [-2, -3, -1, -4, -6]
    >>> max_subarray(nums, 0, len(nums) - 1)
    (2, 2, -1)
    >>> max_subarray([], 0, 0)
    (None, None, 0)
    """"""
    if not arr:
        return None, None, 0
    if low == high:
        return low, high, arr[low]

    mid = (low + high) // 2
    left_low, left_high, left_sum = max_subarray(arr, low, mid)
    right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)
    cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)
    if left_sum >= right_sum and left_sum >= cross_sum:
        return left_low, left_high, left_sum
    elif right_sum >= left_sum and right_sum >= cross_sum:
        return right_low, right_high, right_sum
    return cross_left, cross_right, cross_sum",data\repos\Python\divide_and_conquer\max_subarray.py,max_subarray,527
684,max_subarray.py::max_cross_sum::64,"def max_cross_sum(
    arr: Sequence[float], low: int, mid: int, high: int
) -> tuple[int, int, float]:
    left_sum, max_left = float(""-inf""), -1
    right_sum, max_right = float(""-inf""), -1

    summ: int | float = 0
    for i in range(mid, low - 1, -1):
        summ += arr[i]
        if summ > left_sum:
            left_sum = summ
            max_left = i

    summ = 0
    for i in range(mid + 1, high + 1):
        summ += arr[i]
        if summ > right_sum:
            right_sum = summ
            max_right = i

    return max_left, max_right, (left_sum + right_sum)",data\repos\Python\divide_and_conquer\max_subarray.py,max_cross_sum,171
685,max_subarray.py::time_max_subarray::87,"def time_max_subarray(input_size: int) -> float:
    arr = [randint(1, input_size) for _ in range(input_size)]
    start = time.time()
    max_subarray(arr, 0, input_size - 1)
    end = time.time()
    return end - start",data\repos\Python\divide_and_conquer\max_subarray.py,time_max_subarray,64
686,max_subarray.py::plot_runtimes::95,"def plot_runtimes() -> None:
    input_sizes = [10, 100, 1000, 10000, 50000, 100000, 200000, 300000, 400000, 500000]
    runtimes = [time_max_subarray(input_size) for input_size in input_sizes]
    print(""No of Inputs\t\tTime Taken"")
    for input_size, runtime in zip(input_sizes, runtimes):
        print(input_size, ""\t\t"", runtime)
    plt.plot(input_sizes, runtimes)
    plt.xlabel(""Number of Inputs"")
    plt.ylabel(""Time taken in seconds"")
    plt.show()",data\repos\Python\divide_and_conquer\max_subarray.py,plot_runtimes,136
687,mergesort.py::merge::4,"def merge(left_half: list, right_half: list) -> list:
    """"""Helper function for mergesort.

    >>> left_half = [-2]
    >>> right_half = [-1]
    >>> merge(left_half, right_half)
    [-2, -1]

    >>> left_half = [1,2,3]
    >>> right_half = [4,5,6]
    >>> merge(left_half, right_half)
    [1, 2, 3, 4, 5, 6]

    >>> left_half = [-2]
    >>> right_half = [-1]
    >>> merge(left_half, right_half)
    [-2, -1]

    >>> left_half = [12, 15]
    >>> right_half = [13, 14]
    >>> merge(left_half, right_half)
    [12, 13, 14, 15]

    >>> left_half = []
    >>> right_half = []
    >>> merge(left_half, right_half)
    []
    """"""
    sorted_array = [None] * (len(right_half) + len(left_half))

    pointer1 = 0  # pointer to current index for left Half
    pointer2 = 0  # pointer to current index for the right Half
    index = 0  # pointer to current index for the sorted array Half

    while pointer1 < len(left_half) and pointer2 < len(right_half):
        if left_half[pointer1] < right_half[pointer2]:
            sorted_array[index] = left_half[pointer1]
            pointer1 += 1
            index += 1
        else:
            sorted_array[index] = right_half[pointer2]
            pointer2 += 1
            index += 1
    while pointer1 < len(left_half):
        sorted_array[index] = left_half[pointer1]
        pointer1 += 1
        index += 1

    while pointer2 < len(right_half):
        sorted_array[index] = right_half[pointer2]
        pointer2 += 1
        index += 1

    return sorted_array",data\repos\Python\divide_and_conquer\mergesort.py,merge,433
688,mergesort.py::merge_sort::60,"def merge_sort(array: list) -> list:
    """"""Returns a list of sorted array elements using merge sort.

    >>> from random import shuffle
    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]
    >>> shuffle(array)
    >>> merge_sort(array)
    [-200, -10, -2, 3, 11, 99, 100, 100000]

    >>> shuffle(array)
    >>> merge_sort(array)
    [-200, -10, -2, 3, 11, 99, 100, 100000]

    >>> array = [-200]
    >>> merge_sort(array)
    [-200]

    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]
    >>> shuffle(array)
    >>> sorted(array) == merge_sort(array)
    True

    >>> array = [-2]
    >>> merge_sort(array)
    [-2]

    >>> array = []
    >>> merge_sort(array)
    []

    >>> array = [10000000, 1, -1111111111, 101111111112, 9000002]
    >>> sorted(array) == merge_sort(array)
    True
    """"""
    if len(array) <= 1:
        return array
    # the actual formula to calculate the middle element = left + (right - left) // 2
    # this avoids integer overflow in case of large N
    middle = 0 + (len(array) - 0) // 2

    # Split the array into halves till the array length becomes equal to One
    # merge the arrays of single length returned by mergeSort function and
    # pass them into the merge arrays function which merges the array
    left_half = array[:middle]
    right_half = array[middle:]

    return merge(merge_sort(left_half), merge_sort(right_half))",data\repos\Python\divide_and_conquer\mergesort.py,merge_sort,411
689,peak.py::peak::14,"def peak(lst: list[int]) -> int:
    """"""
    Return the peak value of `lst`.
    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])
    5
    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])
    10
    >>> peak([1, 9, 8, 7])
    9
    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])
    7
    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])
    4
    """"""
    # middle index
    m = len(lst) // 2

    # choose the middle 3 elements
    three = lst[m - 1 : m + 2]

    # if middle element is peak
    if three[1] > three[0] and three[1] > three[2]:
        return three[1]

    # if increasing, recurse on right
    elif three[0] < three[2]:
        if len(lst[:m]) == 2:
            m -= 1
        return peak(lst[m:])

    # decreasing
    else:
        if len(lst[:m]) == 2:
            m += 1
        return peak(lst[:m])",data\repos\Python\divide_and_conquer\peak.py,peak,323
690,power.py::actual_power::1,"def actual_power(a: int, b: int) -> int:
    """"""
    Function using divide and conquer to calculate a^b.
    It only works for integer a,b.

    :param a: The base of the power operation, an integer.
    :param b: The exponent of the power operation, a non-negative integer.
    :return: The result of a^b.

    Examples:
    >>> actual_power(3, 2)
    9
    >>> actual_power(5, 3)
    125
    >>> actual_power(2, 5)
    32
    >>> actual_power(7, 0)
    1
    """"""
    if b == 0:
        return 1
    half = actual_power(a, b // 2)

    if (b % 2) == 0:
        return half * half
    else:
        return a * half * half",data\repos\Python\divide_and_conquer\power.py,actual_power,193
691,power.py::power::30,"def power(a: int, b: int) -> float:
    """"""
    :param a: The base (integer).
    :param b: The exponent (integer).
    :return: The result of a^b, as a float for negative exponents.

    >>> power(4,6)
    4096
    >>> power(2,3)
    8
    >>> power(-2,3)
    -8
    >>> power(2,-3)
    0.125
    >>> power(-2,-3)
    -0.125
    """"""
    if b < 0:
        return 1 / actual_power(a, -b)
    return actual_power(a, b)",data\repos\Python\divide_and_conquer\power.py,power,148
692,strassen_matrix_multiplication.py::default_matrix_multiplication::6,"def default_matrix_multiplication(a: list, b: list) -> list:
    """"""
    Multiplication only for 2x2 matrices
    """"""
    if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:
        raise Exception(""Matrices are not 2x2"")
    new_matrix = [
        [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],
        [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],
    ]
    return new_matrix",data\repos\Python\divide_and_conquer\strassen_matrix_multiplication.py,default_matrix_multiplication,201
693,strassen_matrix_multiplication.py::matrix_addition::19,"def matrix_addition(matrix_a: list, matrix_b: list):
    return [
        [matrix_a[row][col] + matrix_b[row][col] for col in range(len(matrix_a[row]))]
        for row in range(len(matrix_a))
    ]",data\repos\Python\divide_and_conquer\strassen_matrix_multiplication.py,matrix_addition,53
694,strassen_matrix_multiplication.py::matrix_subtraction::26,"def matrix_subtraction(matrix_a: list, matrix_b: list):
    return [
        [matrix_a[row][col] - matrix_b[row][col] for col in range(len(matrix_a[row]))]
        for row in range(len(matrix_a))
    ]",data\repos\Python\divide_and_conquer\strassen_matrix_multiplication.py,matrix_subtraction,53
695,strassen_matrix_multiplication.py::split_matrix::33,"def split_matrix(a: list) -> tuple[list, list, list, list]:
    """"""
    Given an even length matrix, returns the top_left, top_right, bot_left, bot_right
    quadrant.

    >>> split_matrix([[4,3,2,4],[2,3,1,1],[6,5,4,3],[8,4,1,6]])
    ([[4, 3], [2, 3]], [[2, 4], [1, 1]], [[6, 5], [8, 4]], [[4, 3], [1, 6]])
    >>> split_matrix([
    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6],
    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6]
    ... ])  # doctest: +NORMALIZE_WHITESPACE
    ([[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4],
      [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1],
      [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3],
      [8, 4, 1, 6]])
    """"""
    if len(a) % 2 != 0 or len(a[0]) % 2 != 0:
        raise Exception(""Odd matrices are not supported!"")

    matrix_length = len(a)
    mid = matrix_length // 2

    top_right = [[a[i][j] for j in range(mid, matrix_length)] for i in range(mid)]
    bot_right = [
        [a[i][j] for j in range(mid, matrix_length)] for i in range(mid, matrix_length)
    ]

    top_left = [[a[i][j] for j in range(mid)] for i in range(mid)]
    bot_left = [[a[i][j] for j in range(mid)] for i in range(mid, matrix_length)]

    return top_left, top_right, bot_left, bot_right",data\repos\Python\divide_and_conquer\strassen_matrix_multiplication.py,split_matrix,650
696,strassen_matrix_multiplication.py::actual_strassen::74,"def actual_strassen(matrix_a: list, matrix_b: list) -> list:
    """"""
    Recursive function to calculate the product of two matrices, using the Strassen
    Algorithm. It only supports square matrices of any size that is a power of 2.
    """"""
    if matrix_dimensions(matrix_a) == (2, 2):
        return default_matrix_multiplication(matrix_a, matrix_b)

    a, b, c, d = split_matrix(matrix_a)
    e, f, g, h = split_matrix(matrix_b)

    t1 = actual_strassen(a, matrix_subtraction(f, h))
    t2 = actual_strassen(matrix_addition(a, b), h)
    t3 = actual_strassen(matrix_addition(c, d), e)
    t4 = actual_strassen(d, matrix_subtraction(g, e))
    t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))
    t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))
    t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))

    top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)
    top_right = matrix_addition(t1, t2)
    bot_left = matrix_addition(t3, t4)
    bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)

    # construct the new matrix from our 4 quadrants
    new_matrix = []
    for i in range(len(top_right)):
        new_matrix.append(top_left[i] + top_right[i])
    for i in range(len(bot_right)):
        new_matrix.append(bot_left[i] + bot_right[i])
    return new_matrix",data\repos\Python\divide_and_conquer\strassen_matrix_multiplication.py,actual_strassen,379
697,strassen_matrix_multiplication.py::strassen::107,"def strassen(matrix1: list, matrix2: list) -> list:
    """"""
    >>> strassen([[2,1,3],[3,4,6],[1,4,2],[7,6,7]], [[4,2,3,4],[2,1,1,1],[8,6,4,2]])
    [[34, 23, 19, 15], [68, 46, 37, 28], [28, 18, 15, 12], [96, 62, 55, 48]]
    >>> strassen([[3,7,5,6,9],[1,5,3,7,8],[1,4,4,5,7]], [[2,4],[5,2],[1,7],[5,5],[7,8]])
    [[139, 163], [121, 134], [100, 121]]
    """"""
    if matrix_dimensions(matrix1)[1] != matrix_dimensions(matrix2)[0]:
        msg = (
            ""Unable to multiply these matrices, please check the dimensions.\n""
            f""Matrix A: {matrix1}\n""
            f""Matrix B: {matrix2}""
        )
        raise Exception(msg)
    dimension1 = matrix_dimensions(matrix1)
    dimension2 = matrix_dimensions(matrix2)

    if dimension1[0] == dimension1[1] and dimension2[0] == dimension2[1]:
        return [matrix1, matrix2]

    maximum = max(*dimension1, *dimension2)
    maxim = int(math.pow(2, math.ceil(math.log2(maximum))))
    new_matrix1 = matrix1
    new_matrix2 = matrix2

    # Adding zeros to the matrices to convert them both into square matrices of equal
    # dimensions that are a power of 2
    for i in range(maxim):
        if i < dimension1[0]:
            for _ in range(dimension1[1], maxim):
                new_matrix1[i].append(0)
        else:
            new_matrix1.append([0] * maxim)
        if i < dimension2[0]:
            for _ in range(dimension2[1], maxim):
                new_matrix2[i].append(0)
        else:
            new_matrix2.append([0] * maxim)

    final_matrix = actual_strassen(new_matrix1, new_matrix2)

    # Removing the additional zeros
    for i in range(maxim):
        if i < dimension1[0]:
            for _ in range(dimension2[1], maxim):
                final_matrix[i].pop()
        else:
            final_matrix.pop()
    return final_matrix",data\repos\Python\divide_and_conquer\strassen_matrix_multiplication.py,strassen,559
698,abbreviation.py::abbr::15,"def abbr(a: str, b: str) -> bool:
    """"""
    >>> abbr(""daBcd"", ""ABC"")
    True
    >>> abbr(""dBcd"", ""ABC"")
    False
    """"""
    n = len(a)
    m = len(b)
    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]
    dp[0][0] = True
    for i in range(n):
        for j in range(m + 1):
            if dp[i][j]:
                if j < m and a[i].upper() == b[j]:
                    dp[i + 1][j + 1] = True
                if a[i].islower():
                    dp[i + 1][j] = True
    return dp[n][m]",data\repos\Python\dynamic_programming\abbreviation.py,abbr,173
699,all_construct.py::all_construct::9,"def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:
    """"""
    returns the list containing all the possible
    combinations a string(`target`) can be constructed from
    the given list of substrings(`word_bank`)

    >>> all_construct(""hello"", [""he"", ""l"", ""o""])
    [['he', 'l', 'l', 'o']]
    >>> all_construct(""purple"",[""purp"",""p"",""ur"",""le"",""purpl""])
    [['purp', 'le'], ['p', 'ur', 'p', 'le']]
    """"""

    word_bank = word_bank or []
    # create a table
    table_size: int = len(target) + 1

    table: list[list[list[str]]] = []
    for _ in range(table_size):
        table.append([])
    # seed value
    table[0] = [[]]  # because empty string has empty combination

    # iterate through the indices
    for i in range(table_size):
        # condition
        if table[i] != []:
            for word in word_bank:
                # slice condition
                if target[i : i + len(word)] == word:
                    new_combinations: list[list[str]] = [
                        [word, *way] for way in table[i]
                    ]
                    # adds the word to every combination the current position holds
                    # now,push that combination to the table[i+len(word)]
                    table[i + len(word)] += new_combinations

    # combinations are in reverse order so reverse for better output
    for combination in table[len(target)]:
        combination.reverse()

    return table[len(target)]",data\repos\Python\dynamic_programming\all_construct.py,all_construct,349
700,bitmask.py::count_ways_until::31,"    def count_ways_until(self, mask, task_no):
        # if mask == self.finalmask all persons are distributed tasks, return 1
        if mask == self.final_mask:
            return 1

        # if not everyone gets the task and no more tasks are available, return 0
        if task_no > self.total_tasks:
            return 0

        # if case already considered
        if self.dp[mask][task_no] != -1:
            return self.dp[mask][task_no]

        # Number of ways when we don't this task in the arrangement
        total_ways_until = self.count_ways_until(mask, task_no + 1)

        # now assign the tasks one by one to all possible persons and recursively
        # assign for the remaining tasks.
        if task_no in self.task:
            for p in self.task[task_no]:
                # if p is already given a task
                if mask & (1 << p):
                    continue

                # assign this task to p and change the mask value. And recursively
                # assign tasks with the new mask value.
                total_ways_until += self.count_ways_until(mask | (1 << p), task_no + 1)

        # save the value.
        self.dp[mask][task_no] = total_ways_until

        return self.dp[mask][task_no]",data\repos\Python\dynamic_programming\bitmask.py,count_ways_until,283
701,bitmask.py::count_no_of_ways::64,"    def count_no_of_ways(self, task_performed):
        # Store the list of persons for each task
        for i in range(len(task_performed)):
            for j in task_performed[i]:
                self.task[j].append(i)

        # call the function to fill the DP table, final answer is stored in dp[0][1]
        return self.count_ways_until(0, 1)",data\repos\Python\dynamic_programming\bitmask.py,count_no_of_ways,86
702,catalan_numbers.py::catalan_numbers::30,"def catalan_numbers(upper_limit: int) -> ""list[int]"":
    """"""
    Return a list of the Catalan number sequence from 0 through `upper_limit`.

    >>> catalan_numbers(5)
    [1, 1, 2, 5, 14, 42]
    >>> catalan_numbers(2)
    [1, 1, 2]
    >>> catalan_numbers(-1)
    Traceback (most recent call last):
    ValueError: Limit for the Catalan sequence must be  0
    """"""
    if upper_limit < 0:
        raise ValueError(""Limit for the Catalan sequence must be  0"")

    catalan_list = [0] * (upper_limit + 1)

    # Base case: C(0) = C(1) = 1
    catalan_list[0] = 1
    if upper_limit > 0:
        catalan_list[1] = 1

    # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i
    for i in range(2, upper_limit + 1):
        for j in range(i):
            catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]

    return catalan_list",data\repos\Python\dynamic_programming\catalan_numbers.py,catalan_numbers,277
703,climbing_stairs.py::climb_stairs::4,"def climb_stairs(number_of_steps: int) -> int:
    """"""
    LeetCdoe No.70: Climbing Stairs
    Distinct ways to climb a number_of_steps staircase where each time you can either
    climb 1 or 2 steps.

    Args:
        number_of_steps: number of steps on the staircase

    Returns:
        Distinct ways to climb a number_of_steps staircase

    Raises:
        AssertionError: number_of_steps not positive integer

    >>> climb_stairs(3)
    3
    >>> climb_stairs(1)
    1
    >>> climb_stairs(-7)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    AssertionError: number_of_steps needs to be positive integer, your input -7
    """"""
    assert isinstance(number_of_steps, int) and number_of_steps > 0, (
        f""number_of_steps needs to be positive integer, your input {number_of_steps}""
    )
    if number_of_steps == 1:
        return 1
    previous, current = 1, 1
    for _ in range(number_of_steps - 1):
        current, previous = current + previous, current
    return current",data\repos\Python\dynamic_programming\climbing_stairs.py,climb_stairs,262
704,combination_sum_iv.py::combination_sum_iv::26,"def combination_sum_iv(array: list[int], target: int) -> int:
    """"""
    Function checks the all possible combinations, and returns the count
    of possible combination in exponential Time Complexity.

    >>> combination_sum_iv([1,2,5], 5)
    9
    """"""

    def count_of_possible_combinations(target: int) -> int:
        if target < 0:
            return 0
        if target == 0:
            return 1
        return sum(count_of_possible_combinations(target - item) for item in array)

    return count_of_possible_combinations(target)",data\repos\Python\dynamic_programming\combination_sum_iv.py,combination_sum_iv,125
705,combination_sum_iv.py::combination_sum_iv_dp_array::45,"def combination_sum_iv_dp_array(array: list[int], target: int) -> int:
    """"""
    Function checks the all possible combinations, and returns the count
    of possible combination in O(N^2) Time Complexity as we are using Dynamic
    programming array here.

    >>> combination_sum_iv_dp_array([1,2,5], 5)
    9
    """"""

    def count_of_possible_combinations_with_dp_array(
        target: int, dp_array: list[int]
    ) -> int:
        if target < 0:
            return 0
        if target == 0:
            return 1
        if dp_array[target] != -1:
            return dp_array[target]
        answer = sum(
            count_of_possible_combinations_with_dp_array(target - item, dp_array)
            for item in array
        )
        dp_array[target] = answer
        return answer

    dp_array = [-1] * (target + 1)
    return count_of_possible_combinations_with_dp_array(target, dp_array)",data\repos\Python\dynamic_programming\combination_sum_iv.py,combination_sum_iv_dp_array,216
706,combination_sum_iv.py::combination_sum_iv_bottom_up::75,"def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:
    """"""
    Function checks the all possible combinations with using bottom up approach,
    and returns the count of possible combination in O(N^2) Time Complexity
    as we are using Dynamic programming array here.

    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)
    9
    """"""

    dp_array = [0] * (target + 1)
    dp_array[0] = 1

    for i in range(1, target + 1):
        for j in range(n):
            if i - array[j] >= 0:
                dp_array[i] += dp_array[i - array[j]]

    return dp_array[target]",data\repos\Python\dynamic_programming\combination_sum_iv.py,combination_sum_iv_bottom_up,164
707,combination_sum_iv.py::count_of_possible_combinations::35,"    def count_of_possible_combinations(target: int) -> int:
        if target < 0:
            return 0
        if target == 0:
            return 1
        return sum(count_of_possible_combinations(target - item) for item in array)",data\repos\Python\dynamic_programming\combination_sum_iv.py,count_of_possible_combinations,55
708,combination_sum_iv.py::count_of_possible_combinations_with_dp_array::55,"    def count_of_possible_combinations_with_dp_array(
        target: int, dp_array: list[int]
    ) -> int:
        if target < 0:
            return 0
        if target == 0:
            return 1
        if dp_array[target] != -1:
            return dp_array[target]
        answer = sum(
            count_of_possible_combinations_with_dp_array(target - item, dp_array)
            for item in array
        )
        dp_array[target] = answer
        return answer",data\repos\Python\dynamic_programming\combination_sum_iv.py,count_of_possible_combinations_with_dp_array,107
709,edit_distance.py::min_dist_top_down::44,"    def min_dist_top_down(self, word1: str, word2: str) -> int:
        """"""
        >>> EditDistance().min_dist_top_down(""intention"", ""execution"")
        5
        >>> EditDistance().min_dist_top_down(""intention"", """")
        9
        >>> EditDistance().min_dist_top_down("""", """")
        0
        """"""
        self.word1 = word1
        self.word2 = word2
        self.dp = [[-1 for _ in range(len(word2))] for _ in range(len(word1))]

        return self.__min_dist_top_down_dp(len(word1) - 1, len(word2) - 1)",data\repos\Python\dynamic_programming\edit_distance.py,min_dist_top_down,143
710,edit_distance.py::min_dist_bottom_up::59,"    def min_dist_bottom_up(self, word1: str, word2: str) -> int:
        """"""
        >>> EditDistance().min_dist_bottom_up(""intention"", ""execution"")
        5
        >>> EditDistance().min_dist_bottom_up(""intention"", """")
        9
        >>> EditDistance().min_dist_bottom_up("""", """")
        0
        """"""
        self.word1 = word1
        self.word2 = word2
        m = len(word1)
        n = len(word2)
        self.dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

        for i in range(m + 1):
            for j in range(n + 1):
                if i == 0:  # first string is empty
                    self.dp[i][j] = j
                elif j == 0:  # second string is empty
                    self.dp[i][j] = i
                elif word1[i - 1] == word2[j - 1]:  # last characters are equal
                    self.dp[i][j] = self.dp[i - 1][j - 1]
                else:
                    insert = self.dp[i][j - 1]
                    delete = self.dp[i - 1][j]
                    replace = self.dp[i - 1][j - 1]
                    self.dp[i][j] = 1 + min(insert, delete, replace)
        return self.dp[m][n]",data\repos\Python\dynamic_programming\edit_distance.py,min_dist_bottom_up,312
711,factorial.py::factorial::7,"def factorial(num: int) -> int:
    """"""
    >>> factorial(7)
    5040
    >>> factorial(-1)
    Traceback (most recent call last):
      ...
    ValueError: Number should not be negative.
    >>> [factorial(i) for i in range(10)]
    [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    """"""
    if num < 0:
        raise ValueError(""Number should not be negative."")

    return 1 if num in (0, 1) else num * factorial(num - 1)",data\repos\Python\dynamic_programming\factorial.py,factorial,137
712,fast_fibonacci.py::fibonacci::13,"def fibonacci(n: int) -> int:
    """"""
    return F(n)
    >>> [fibonacci(i) for i in range(13)]
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
    """"""
    if n < 0:
        raise ValueError(""Negative arguments are not supported"")
    return _fib(n)[0]",data\repos\Python\dynamic_programming\fast_fibonacci.py,fibonacci,97
713,fibonacci.py::main::27,"def main() -> None:
    print(
        ""Fibonacci Series Using Dynamic Programming\n"",
        ""Enter the index of the Fibonacci number you want to calculate "",
        ""in the prompt below. (To exit enter exit or Ctrl-C)\n"",
        sep="""",
    )
    fibonacci = Fibonacci()

    while True:
        prompt: str = input("">> "")
        if prompt in {""exit"", ""quit""}:
            break

        try:
            index: int = int(prompt)
        except ValueError:
            print(""Enter a number or 'exit'"")
            continue

        print(fibonacci.get(index))",data\repos\Python\dynamic_programming\fibonacci.py,main,126
714,fibonacci.py::get::11,"    def get(self, index: int) -> list:
        """"""
        Get the Fibonacci number of `index`. If the number does not exist,
        calculate all missing numbers leading up to the number of `index`.

        >>> Fibonacci().get(10)
        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
        >>> Fibonacci().get(5)
        [0, 1, 1, 2, 3]
        """"""
        if (difference := index - (len(self.sequence) - 2)) >= 1:
            for _ in range(difference):
                self.sequence.append(self.sequence[-1] + self.sequence[-2])
        return self.sequence[:index]",data\repos\Python\dynamic_programming\fibonacci.py,get,159
715,fizz_buzz.py::fizz_buzz::4,"def fizz_buzz(number: int, iterations: int) -> str:
    """"""
    | Plays FizzBuzz.
    | Prints Fizz if number is a multiple of ``3``.
    | Prints Buzz if its a multiple of ``5``.
    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.
    | Else Prints The Number Itself.

    >>> fizz_buzz(1,7)
    '1 2 Fizz 4 Buzz Fizz 7 '
    >>> fizz_buzz(1,0)
    Traceback (most recent call last):
      ...
    ValueError: Iterations must be done more than 0 times to play FizzBuzz
    >>> fizz_buzz(-5,5)
    Traceback (most recent call last):
        ...
    ValueError: starting number must be
                             and integer and be more than 0
    >>> fizz_buzz(10,-5)
    Traceback (most recent call last):
        ...
    ValueError: Iterations must be done more than 0 times to play FizzBuzz
    >>> fizz_buzz(1.5,5)
    Traceback (most recent call last):
        ...
    ValueError: starting number must be
                             and integer and be more than 0
    >>> fizz_buzz(1,5.5)
    Traceback (most recent call last):
        ...
    ValueError: iterations must be defined as integers
    """"""
    if not isinstance(iterations, int):
        raise ValueError(""iterations must be defined as integers"")
    if not isinstance(number, int) or not number >= 1:
        raise ValueError(
            """"""starting number must be
                         and integer and be more than 0""""""
        )
    if not iterations >= 1:
        raise ValueError(""Iterations must be done more than 0 times to play FizzBuzz"")

    out = """"
    while number <= iterations:
        if number % 3 == 0:
            out += ""Fizz""
        if number % 5 == 0:
            out += ""Buzz""
        if 0 not in (number % 3, number % 5):
            out += str(number)

        # print(out)
        number += 1
        out += "" ""
    return out",data\repos\Python\dynamic_programming\fizz_buzz.py,fizz_buzz,474
716,floyd_warshall.py::add_edge::14,"    def add_edge(self, u, v, w):
        """"""
        Adds a directed edge from node u
        to node v with weight w.

        >>> g = Graph(3)
        >>> g.add_edge(0, 1, 5)
        >>> g.dp[0][1]
        5
        """"""
        self.dp[u][v] = w",data\repos\Python\dynamic_programming\floyd_warshall.py,add_edge,77
717,floyd_warshall.py::floyd_warshall::26,"    def floyd_warshall(self):
        """"""
        Computes the shortest paths between all pairs of
        nodes using the Floyd-Warshall algorithm.

        >>> g = Graph(3)
        >>> g.add_edge(0, 1, 1)
        >>> g.add_edge(1, 2, 2)
        >>> g.floyd_warshall()
        >>> g.show_min(0, 2)
        3
        >>> g.show_min(2, 0)
        inf
        """"""
        for k in range(self.n):
            for i in range(self.n):
                for j in range(self.n):
                    self.dp[i][j] = min(self.dp[i][j], self.dp[i][k] + self.dp[k][j])",data\repos\Python\dynamic_programming\floyd_warshall.py,floyd_warshall,157
718,floyd_warshall.py::show_min::45,"    def show_min(self, u, v):
        """"""
        Returns the minimum distance from node u to node v.

        >>> g = Graph(3)
        >>> g.add_edge(0, 1, 3)
        >>> g.add_edge(1, 2, 4)
        >>> g.floyd_warshall()
        >>> g.show_min(0, 2)
        7
        >>> g.show_min(1, 0)
        inf
        """"""
        return self.dp[u][v]",data\repos\Python\dynamic_programming\floyd_warshall.py,show_min,107
719,integer_partition.py::partition::11,"def partition(m: int) -> int:
    """"""
    >>> partition(5)
    7
    >>> partition(7)
    15
    >>> partition(100)
    190569292
    >>> partition(1_000)
    24061467864032622473692149727991
    >>> partition(-7)
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    >>> partition(0)
    Traceback (most recent call last):
        ...
    IndexError: list assignment index out of range
    >>> partition(7.8)
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    """"""
    memo: list[list[int]] = [[0 for _ in range(m)] for _ in range(m + 1)]
    for i in range(m + 1):
        memo[i][0] = 1

    for n in range(m + 1):
        for k in range(1, m):
            memo[n][k] += memo[n][k - 1]
            if n - k > 0:
                memo[n][k] += memo[n - k - 1][k]

    return memo[m][m - 1]",data\repos\Python\dynamic_programming\integer_partition.py,partition,269
720,iterating_through_submasks.py::list_of_submasks::12,"def list_of_submasks(mask: int) -> list[int]:
    """"""
    Args:
        mask : number which shows mask ( always integer > 0, zero does not have any
            submasks )

    Returns:
        all_submasks : the list of submasks of mask (mask s is called submask of mask
        m if only bits that were included in original mask are set

    Raises:
        AssertionError: mask not positive integer

    >>> list_of_submasks(15)
    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    >>> list_of_submasks(13)
    [13, 12, 9, 8, 5, 4, 1]
    >>> list_of_submasks(-7)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    AssertionError: mask needs to be positive integer, your input -7
    >>> list_of_submasks(0)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    AssertionError: mask needs to be positive integer, your input 0

    """"""

    assert isinstance(mask, int) and mask > 0, (
        f""mask needs to be positive integer, your input {mask}""
    )

    """"""
    first submask iterated will be mask itself then operation will be performed
    to get other submasks till we reach empty submask that is zero ( zero is not
    included in final submasks list )
    """"""
    all_submasks = []
    submask = mask

    while submask:
        all_submasks.append(submask)
        submask = (submask - 1) & mask

    return all_submasks",data\repos\Python\dynamic_programming\iterating_through_submasks.py,list_of_submasks,406
721,knapsack.py::mf_knapsack::10,"def mf_knapsack(i, wt, val, j):
    """"""
    This code involves the concept of memory functions. Here we solve the subproblems
    which are needed unlike the below example
    F is a 2D array with ``-1`` s filled up
    """"""
    global f  # a global dp table for knapsack
    if f[i][j] < 0:
        if j < wt[i - 1]:
            val = mf_knapsack(i - 1, wt, val, j)
        else:
            val = max(
                mf_knapsack(i - 1, wt, val, j),
                mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],
            )
        f[i][j] = val
    return f[i][j]",data\repos\Python\dynamic_programming\knapsack.py,mf_knapsack,188
722,knapsack.py::knapsack::29,"def knapsack(w, wt, val, n):
    dp = [[0] * (w + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w_ in range(1, w + 1):
            if wt[i - 1] <= w_:
                dp[i][w_] = max(val[i - 1] + dp[i - 1][w_ - wt[i - 1]], dp[i - 1][w_])
            else:
                dp[i][w_] = dp[i - 1][w_]

    return dp[n][w_], dp",data\repos\Python\dynamic_programming\knapsack.py,knapsack,140
723,knapsack.py::knapsack_with_example_solution::42,"def knapsack_with_example_solution(w: int, wt: list, val: list):
    """"""
    Solves the integer weights knapsack problem returns one of
    the several possible optimal subsets.

    Parameters
    ----------

    * `w`: int, the total maximum weight for the given knapsack problem.
    * `wt`: list, the vector of weights for all items where ``wt[i]`` is the weight
       of the ``i``-th item.
    * `val`: list, the vector of values for all items where ``val[i]`` is the value
      of the ``i``-th item

    Returns
    -------

    * `optimal_val`: float, the optimal value for the given knapsack problem
    * `example_optional_set`: set, the indices of one of the optimal subsets
      which gave rise to the optimal value.

    Examples
    --------

    >>> knapsack_with_example_solution(10, [1, 3, 5, 2], [10, 20, 100, 22])
    (142, {2, 3, 4})
    >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4, 4])
    (8, {3, 4})
    >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4])
    Traceback (most recent call last):
        ...
    ValueError: The number of weights must be the same as the number of values.
    But got 4 weights and 3 values
    """"""
    if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):
        raise ValueError(
            ""Both the weights and values vectors must be either lists or tuples""
        )

    num_items = len(wt)
    if num_items != len(val):
        msg = (
            ""The number of weights must be the same as the number of values.\n""
            f""But got {num_items} weights and {len(val)} values""
        )
        raise ValueError(msg)
    for i in range(num_items):
        if not isinstance(wt[i], int):
            msg = (
                ""All weights must be integers but got weight of ""
                f""type {type(wt[i])} at index {i}""
            )
            raise TypeError(msg)

    optimal_val, dp_table = knapsack(w, wt, val, num_items)
    example_optional_set: set = set()
    _construct_solution(dp_table, wt, num_items, w, example_optional_set)

    return optimal_val, example_optional_set",data\repos\Python\dynamic_programming\knapsack.py,knapsack_with_example_solution,575
724,k_means_clustering_tensorflow.py::tf_k_means_cluster::7,"def tf_k_means_cluster(vectors, noofclusters):
    """"""
    K-Means Clustering using TensorFlow.
    'vectors' should be a n*k 2-D NumPy array, where n is the number
    of vectors of dimensionality k.
    'noofclusters' should be an integer.
    """"""

    noofclusters = int(noofclusters)
    assert noofclusters < len(vectors)

    # Find out the dimensionality
    dim = len(vectors[0])

    # Will help select random centroids from among the available vectors
    vector_indices = list(range(len(vectors)))
    shuffle(vector_indices)

    # GRAPH OF COMPUTATION
    # We initialize a new graph and set it as the default during each run
    # of this algorithm. This ensures that as this function is called
    # multiple times, the default graph doesn't keep getting crowded with
    # unused ops and Variables from previous function calls.

    graph = tf.Graph()

    with graph.as_default():
        # SESSION OF COMPUTATION

        sess = tf.Session()

        ##CONSTRUCTING THE ELEMENTS OF COMPUTATION

        ##First lets ensure we have a Variable vector for each centroid,
        ##initialized to one of the vectors from the available data points
        centroids = [
            tf.Variable(vectors[vector_indices[i]]) for i in range(noofclusters)
        ]
        ##These nodes will assign the centroid Variables the appropriate
        ##values
        centroid_value = tf.placeholder(""float64"", [dim])
        cent_assigns = []
        for centroid in centroids:
            cent_assigns.append(tf.assign(centroid, centroid_value))

        ##Variables for cluster assignments of individual vectors(initialized
        ##to 0 at first)
        assignments = [tf.Variable(0) for i in range(len(vectors))]
        ##These nodes will assign an assignment Variable the appropriate
        ##value
        assignment_value = tf.placeholder(""int32"")
        cluster_assigns = []
        for assignment in assignments:
            cluster_assigns.append(tf.assign(assignment, assignment_value))

        ##Now lets construct the node that will compute the mean
        # The placeholder for the input
        mean_input = tf.placeholder(""float"", [None, dim])
        # The Node/op takes the input and computes a mean along the 0th
        # dimension, i.e. the list of input vectors
        mean_op = tf.reduce_mean(mean_input, 0)

        ##Node for computing Euclidean distances
        # Placeholders for input
        v1 = tf.placeholder(""float"", [dim])
        v2 = tf.placeholder(""float"", [dim])
        euclid_dist = tf.sqrt(tf.reduce_sum(tf.pow(tf.sub(v1, v2), 2)))

        ##This node will figure out which cluster to assign a vector to,
        ##based on Euclidean distances of the vector from the centroids.
        # Placeholder for input
        centroid_distances = tf.placeholder(""float"", [noofclusters])
        cluster_assignment = tf.argmin(centroid_distances, 0)

        ##INITIALIZING STATE VARIABLES

        ##This will help initialization of all Variables defined with respect
        ##to the graph. The Variable-initializer should be defined after
        ##all the Variables have been constructed, so that each of them
        ##will be included in the initialization.
        init_op = tf.initialize_all_variables()

        # Initialize all variables
        sess.run(init_op)

        ##CLUSTERING ITERATIONS

        # Now perform the Expectation-Maximization steps of K-Means clustering
        # iterations. To keep things simple, we will only do a set number of
        # iterations, instead of using a Stopping Criterion.
        noofiterations = 100
        for _ in range(noofiterations):
            ##EXPECTATION STEP
            ##Based on the centroid locations till last iteration, compute
            ##the _expected_ centroid assignments.
            # Iterate over each vector
            for vector_n in range(len(vectors)):
                vect = vectors[vector_n]
                # Compute Euclidean distance between this vector and each
                # centroid. Remember that this list cannot be named
                #'centroid_distances', since that is the input to the
                # cluster assignment node.
                distances = [
                    sess.run(euclid_dist, feed_dict={v1: vect, v2: sess.run(centroid)})
                    for centroid in centroids
                ]
                # Now use the cluster assignment node, with the distances
                # as the input
                assignment = sess.run(
                    cluster_assignment, feed_dict={centroid_distances: distances}
                )
                # Now assign the value to the appropriate state variable
                sess.run(
                    cluster_assigns[vector_n], feed_dict={assignment_value: assignment}
                )

            ##MAXIMIZATION STEP
            # Based on the expected state computed from the Expectation Step,
            # compute the locations of the centroids so as to maximize the
            # overall objective of minimizing within-cluster Sum-of-Squares
            for cluster_n in range(noofclusters):
                # Collect all the vectors assigned to this cluster
                assigned_vects = [
                    vectors[i]
                    for i in range(len(vectors))
                    if sess.run(assignments[i]) == cluster_n
                ]
                # Compute new centroid location
                new_location = sess.run(
                    mean_op, feed_dict={mean_input: array(assigned_vects)}
                )
                # Assign value to appropriate variable
                sess.run(
                    cent_assigns[cluster_n], feed_dict={centroid_value: new_location}
                )

        # Return centroids and assignments
        centroids = sess.run(centroids)
        assignments = sess.run(assignments)
        return centroids, assignments",data\repos\Python\dynamic_programming\k_means_clustering_tensorflow.py,tf_k_means_cluster,1187
725,largest_divisible_subset.py::largest_divisible_subset::4,"def largest_divisible_subset(items: list[int]) -> list[int]:
    """"""
    Algorithm to find the biggest subset in the given array such that for any 2 elements
    x and y in the subset, either x divides y or y divides x.
    >>> largest_divisible_subset([1, 16, 7, 8, 4])
    [16, 8, 4, 1]
    >>> largest_divisible_subset([1, 2, 3])
    [2, 1]
    >>> largest_divisible_subset([-1, -2, -3])
    [-3]
    >>> largest_divisible_subset([1, 2, 4, 8])
    [8, 4, 2, 1]
    >>> largest_divisible_subset((1, 2, 4, 8))
    [8, 4, 2, 1]
    >>> largest_divisible_subset([1, 1, 1])
    [1, 1, 1]
    >>> largest_divisible_subset([0, 0, 0])
    [0, 0, 0]
    >>> largest_divisible_subset([-1, -1, -1])
    [-1, -1, -1]
    >>> largest_divisible_subset([])
    []
    """"""
    # Sort the array in ascending order as the sequence does not matter we only have to
    # pick up a subset.
    items = sorted(items)

    number_of_items = len(items)

    # Initialize memo with 1s and hash with increasing numbers
    memo = [1] * number_of_items
    hash_array = list(range(number_of_items))

    # Iterate through the array
    for i, item in enumerate(items):
        for prev_index in range(i):
            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (
                (1 + memo[prev_index]) > memo[i]
            ):
                memo[i] = 1 + memo[prev_index]
                hash_array[i] = prev_index

    ans = -1
    last_index = -1

    # Find the maximum length and its corresponding index
    for i, memo_item in enumerate(memo):
        if memo_item > ans:
            ans = memo_item
            last_index = i

    # Reconstruct the divisible subset
    if last_index == -1:
        return []
    result = [items[last_index]]
    while hash_array[last_index] != last_index:
        last_index = hash_array[last_index]
        result.append(items[last_index])

    return result",data\repos\Python\dynamic_programming\largest_divisible_subset.py,largest_divisible_subset,547
726,longest_common_subsequence.py::longest_common_subsequence::9,"def longest_common_subsequence(x: str, y: str):
    """"""
    Finds the longest common subsequence between two strings. Also returns the
    The subsequence found

    Parameters
    ----------

    x: str, one of the strings
    y: str, the other string

    Returns
    -------
    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)
    Seq: str, the subsequence found

    >>> longest_common_subsequence(""programming"", ""gaming"")
    (6, 'gaming')
    >>> longest_common_subsequence(""physics"", ""smartphone"")
    (2, 'ph')
    >>> longest_common_subsequence(""computer"", ""food"")
    (1, 'o')
    >>> longest_common_subsequence("""", ""abc"")  # One string is empty
    (0, '')
    >>> longest_common_subsequence(""abc"", """")  # Other string is empty
    (0, '')
    >>> longest_common_subsequence("""", """")  # Both strings are empty
    (0, '')
    >>> longest_common_subsequence(""abc"", ""def"")  # No common subsequence
    (0, '')
    >>> longest_common_subsequence(""abc"", ""abc"")  # Identical strings
    (3, 'abc')
    >>> longest_common_subsequence(""a"", ""a"")  # Single character match
    (1, 'a')
    >>> longest_common_subsequence(""a"", ""b"")  # Single character no match
    (0, '')
    >>> longest_common_subsequence(""abcdef"", ""ace"")  # Interleaved subsequence
    (3, 'ace')
    >>> longest_common_subsequence(""ABCD"", ""ACBD"")  # No repeated characters
    (3, 'ABD')
    """"""
    # find the length of strings

    assert x is not None
    assert y is not None

    m = len(x)
    n = len(y)

    # declaring the array for storing the dp values
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            match = 1 if x[i - 1] == y[j - 1] else 0

            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)

    seq = """"
    i, j = m, n
    while i > 0 and j > 0:
        match = 1 if x[i - 1] == y[j - 1] else 0

        if dp[i][j] == dp[i - 1][j - 1] + match:
            if match == 1:
                seq = x[i - 1] + seq
            i -= 1
            j -= 1
        elif dp[i][j] == dp[i - 1][j]:
            i -= 1
        else:
            j -= 1

    return dp[m][n], seq",data\repos\Python\dynamic_programming\longest_common_subsequence.py,longest_common_subsequence,671
727,longest_common_substring.py::longest_common_substring::13,"def longest_common_substring(text1: str, text2: str) -> str:
    """"""
    Finds the longest common substring between two strings.

    >>> longest_common_substring("""", """")
    ''
    >>> longest_common_substring(""a"","""")
    ''
    >>> longest_common_substring("""", ""a"")
    ''
    >>> longest_common_substring(""a"", ""a"")
    'a'
    >>> longest_common_substring(""abcdef"", ""bcd"")
    'bcd'
    >>> longest_common_substring(""abcdef"", ""xabded"")
    'ab'
    >>> longest_common_substring(""GeeksforGeeks"", ""GeeksQuiz"")
    'Geeks'
    >>> longest_common_substring(""abcdxyz"", ""xyzabcd"")
    'abcd'
    >>> longest_common_substring(""zxabcdezy"", ""yzabcdezx"")
    'abcdez'
    >>> longest_common_substring(""OldSite:GeeksforGeeks.org"", ""NewSite:GeeksQuiz.com"")
    'Site:Geeks'
    >>> longest_common_substring(1, 1)
    Traceback (most recent call last):
        ...
    ValueError: longest_common_substring() takes two strings for inputs
    """"""

    if not (isinstance(text1, str) and isinstance(text2, str)):
        raise ValueError(""longest_common_substring() takes two strings for inputs"")

    if not text1 or not text2:
        return """"

    text1_length = len(text1)
    text2_length = len(text2)

    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]
    end_pos = 0
    max_length = 0

    for i in range(1, text1_length + 1):
        for j in range(1, text2_length + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = 1 + dp[i - 1][j - 1]
                if dp[i][j] > max_length:
                    end_pos = i
                    max_length = dp[i][j]

    return text1[end_pos - max_length : end_pos]",data\repos\Python\dynamic_programming\longest_common_substring.py,longest_common_substring,461
728,longest_increasing_subsequence.py::longest_subsequence::19,"def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive
    """"""
    Some examples

    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])
    [10, 22, 33, 41, 60, 80]
    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])
    [1, 2, 3, 9]
    >>> longest_subsequence([28, 26, 12, 23, 35, 39])
    [12, 23, 35, 39]
    >>> longest_subsequence([9, 8, 7, 6, 5, 7])
    [5, 7]
    >>> longest_subsequence([1, 1, 1])
    [1, 1, 1]
    >>> longest_subsequence([])
    []
    """"""
    array_length = len(array)
    # If the array contains only one element, we return it (it's the stop condition of
    # recursion)
    if array_length <= 1:
        return array
        # Else
    pivot = array[0]
    is_found = False
    i = 1
    longest_subseq: list[int] = []
    while not is_found and i < array_length:
        if array[i] < pivot:
            is_found = True
            temp_array = array[i:]
            temp_array = longest_subsequence(temp_array)
            if len(temp_array) > len(longest_subseq):
                longest_subseq = temp_array
        else:
            i += 1

    temp_array = [element for element in array[1:] if element >= pivot]
    temp_array = [pivot, *longest_subsequence(temp_array)]
    if len(temp_array) > len(longest_subseq):
        return temp_array
    else:
        return longest_subseq",data\repos\Python\dynamic_programming\longest_increasing_subsequence.py,longest_subsequence,430
729,longest_increasing_subsequence_iterative.py::longest_subsequence::21,"def longest_subsequence(array: list[int]) -> list[int]:
    """"""
    Some examples

    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])
    [10, 22, 33, 50, 60, 80]
    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])
    [1, 2, 3, 9]
    >>> longest_subsequence([9, 8, 7, 6, 5, 7])
    [7, 7]
    >>> longest_subsequence([28, 26, 12, 23, 35, 39])
    [12, 23, 35, 39]
    >>> longest_subsequence([1, 1, 1])
    [1, 1, 1]
    >>> longest_subsequence([])
    []
    """"""
    n = len(array)
    # The longest increasing subsequence ending at array[i]
    longest_increasing_subsequence = []
    for i in range(n):
        longest_increasing_subsequence.append([array[i]])

    for i in range(1, n):
        for prev in range(i):
            # If array[prev] is less than or equal to array[i], then
            # longest_increasing_subsequence[prev] + array[i]
            # is a valid increasing subsequence

            # longest_increasing_subsequence[i] is only set to
            # longest_increasing_subsequence[prev] + array[i] if the length is longer.

            if array[prev] <= array[i] and len(
                longest_increasing_subsequence[prev]
            ) + 1 > len(longest_increasing_subsequence[i]):
                longest_increasing_subsequence[i] = copy.copy(
                    longest_increasing_subsequence[prev]
                )
                longest_increasing_subsequence[i].append(array[i])

    result: list[int] = []
    for i in range(n):
        if len(longest_increasing_subsequence[i]) > len(result):
            result = longest_increasing_subsequence[i]

    return result",data\repos\Python\dynamic_programming\longest_increasing_subsequence_iterative.py,longest_subsequence,466
730,longest_increasing_subsequence_o_nlogn.py::ceil_index::10,"def ceil_index(v, left, right, key):
    while right - left > 1:
        middle = (left + right) // 2
        if v[middle] >= key:
            right = middle
        else:
            left = middle
    return right",data\repos\Python\dynamic_programming\longest_increasing_subsequence_o_nlogn.py,ceil_index,57
731,longest_increasing_subsequence_o_nlogn.py::longest_increasing_subsequence_length::20,"def longest_increasing_subsequence_length(v: list[int]) -> int:
    """"""
    >>> longest_increasing_subsequence_length([2, 5, 3, 7, 11, 8, 10, 13, 6])
    6
    >>> longest_increasing_subsequence_length([])
    0
    >>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13,
    ...                                     3, 11, 7, 15])
    6
    >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1])
    1
    """"""
    if len(v) == 0:
        return 0

    tail = [0] * len(v)
    length = 1

    tail[0] = v[0]

    for i in range(1, len(v)):
        if v[i] < tail[0]:
            tail[0] = v[i]
        elif v[i] > tail[length - 1]:
            tail[length] = v[i]
            length += 1
        else:
            tail[ceil_index(tail, -1, length - 1, v[i])] = v[i]

    return length",data\repos\Python\dynamic_programming\longest_increasing_subsequence_o_nlogn.py,longest_increasing_subsequence_length,286
732,longest_palindromic_subsequence.py::longest_palindromic_subsequence::11,"def longest_palindromic_subsequence(input_string: str) -> int:
    """"""
    This function returns the longest palindromic subsequence in a string
    >>> longest_palindromic_subsequence(""bbbab"")
    4
    >>> longest_palindromic_subsequence(""bbabcbcab"")
    7
    """"""
    n = len(input_string)
    rev = input_string[::-1]
    m = len(rev)
    dp = [[-1] * (m + 1) for i in range(n + 1)]
    for i in range(n + 1):
        dp[i][0] = 0
    for i in range(m + 1):
        dp[0][i] = 0

    # create and initialise dp array
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            # If characters at i and j are the same
            # include them in the palindromic subsequence
            if input_string[i - 1] == rev[j - 1]:
                dp[i][j] = 1 + dp[i - 1][j - 1]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[n][m]",data\repos\Python\dynamic_programming\longest_palindromic_subsequence.py,longest_palindromic_subsequence,288
733,matrix_chain_multiplication.py::matrix_chain_multiply::54,"def matrix_chain_multiply(arr: list[int]) -> int:
    """"""
    Find the minimum number of multiplcations required to multiply the chain of matrices

    Args:
        `arr`: The input array of integers.

    Returns:
        Minimum number of multiplications needed to multiply the chain

    Examples:

    >>> matrix_chain_multiply([1, 2, 3, 4, 3])
    30
    >>> matrix_chain_multiply([10])
    0
    >>> matrix_chain_multiply([10, 20])
    0
    >>> matrix_chain_multiply([19, 2, 19])
    722
    >>> matrix_chain_multiply(list(range(1, 100)))
    323398
    >>> # matrix_chain_multiply(list(range(1, 251)))
    # 2626798
    """"""
    if len(arr) < 2:
        return 0
    # initialising 2D dp matrix
    n = len(arr)
    dp = [[maxsize for j in range(n)] for i in range(n)]
    # we want minimum cost of multiplication of matrices
    # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].
    for i in range(n - 1, 0, -1):
        for j in range(i, n):
            if i == j:
                dp[i][j] = 0
                continue
            for k in range(i, j):
                dp[i][j] = min(
                    dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]
                )

    return dp[1][n - 1]",data\repos\Python\dynamic_programming\matrix_chain_multiplication.py,matrix_chain_multiply,369
734,matrix_chain_multiplication.py::matrix_chain_order::99,"def matrix_chain_order(dims: list[int]) -> int:
    """"""
    Source: https://en.wikipedia.org/wiki/Matrix_chain_multiplication

    The dynamic programming solution is faster than cached the recursive solution and
    can handle larger inputs.

    >>> matrix_chain_order([1, 2, 3, 4, 3])
    30
    >>> matrix_chain_order([10])
    0
    >>> matrix_chain_order([10, 20])
    0
    >>> matrix_chain_order([19, 2, 19])
    722
    >>> matrix_chain_order(list(range(1, 100)))
    323398
    >>> # matrix_chain_order(list(range(1, 251)))  # Max before RecursionError is raised
    # 2626798
    """"""

    @cache
    def a(i: int, j: int) -> int:
        return min(
            (a(i, k) + dims[i] * dims[k] * dims[j] + a(k, j) for k in range(i + 1, j)),
            default=0,
        )

    return a(0, len(dims) - 1)",data\repos\Python\dynamic_programming\matrix_chain_multiplication.py,matrix_chain_order,249
735,matrix_chain_multiplication.py::elapsed_time::131,"def elapsed_time(msg: str) -> Iterator:
    # print(f""Starting: {msg}"")
    from time import perf_counter_ns

    start = perf_counter_ns()
    yield
    print(f""Finished: {msg} in {(perf_counter_ns() - start) / 10**9} seconds."")",data\repos\Python\dynamic_programming\matrix_chain_multiplication.py,elapsed_time,64
736,matrix_chain_multiplication.py::a::121,"    def a(i: int, j: int) -> int:
        return min(
            (a(i, k) + dims[i] * dims[k] * dims[j] + a(k, j) for k in range(i + 1, j)),
            default=0,
        )",data\repos\Python\dynamic_programming\matrix_chain_multiplication.py,a,61
737,matrix_chain_order.py::matrix_chain_order::13,"def matrix_chain_order(array: list[int]) -> tuple[list[list[int]], list[list[int]]]:
    """"""
    >>> matrix_chain_order([10, 30, 5])
    ([[0, 0, 0], [0, 0, 1500], [0, 0, 0]], [[0, 0, 0], [0, 0, 1], [0, 0, 0]])
    """"""
    n = len(array)
    matrix = [[0 for _ in range(n)] for _ in range(n)]
    sol = [[0 for _ in range(n)] for _ in range(n)]

    for chain_length in range(2, n):
        for a in range(1, n - chain_length + 1):
            b = a + chain_length - 1

            matrix[a][b] = sys.maxsize
            for c in range(a, b):
                cost = (
                    matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]
                )
                if cost < matrix[a][b]:
                    matrix[a][b] = cost
                    sol[a][b] = c
    return matrix, sol",data\repos\Python\dynamic_programming\matrix_chain_order.py,matrix_chain_order,260
738,matrix_chain_order.py::print_optimal_solution::37,"def print_optimal_solution(optimal_solution: list[list[int]], i: int, j: int):
    """"""
    Print order of matrix with Ai as Matrix.
    """"""

    if i == j:
        print(""A"" + str(i), end="" "")
    else:
        print(""("", end="" "")
        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])
        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)
        print("")"", end="" "")",data\repos\Python\dynamic_programming\matrix_chain_order.py,print_optimal_solution,108
739,matrix_chain_order.py::main::51,"def main():
    """"""
    Size of matrix created from array [30, 35, 15, 5, 10, 20, 25] will be:
    30*35 35*15 15*5 5*10 10*20 20*25
    """"""

    array = [30, 35, 15, 5, 10, 20, 25]
    n = len(array)

    matrix, optimal_solution = matrix_chain_order(array)

    print(""No. of Operation required: "" + str(matrix[1][n - 1]))
    print_optimal_solution(optimal_solution, 1, n - 1)",data\repos\Python\dynamic_programming\matrix_chain_order.py,main,143
740,max_non_adjacent_sum.py::maximum_non_adjacent_sum::6,"def maximum_non_adjacent_sum(nums: list[int]) -> int:
    """"""
    Find the maximum non-adjacent sum of the integers in the nums input list

    >>> maximum_non_adjacent_sum([1, 2, 3])
    4
    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])
    18
    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])
    0
    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])
    500
    """"""
    if not nums:
        return 0
    max_including = nums[0]
    max_excluding = 0
    for num in nums[1:]:
        max_including, max_excluding = (
            max_excluding + num,
            max(max_including, max_excluding),
        )
    return max(max_excluding, max_including)",data\repos\Python\dynamic_programming\max_non_adjacent_sum.py,maximum_non_adjacent_sum,227
741,max_product_subarray.py::max_product_subarray::1,"def max_product_subarray(numbers: list[int]) -> int:
    """"""
    Returns the maximum product that can be obtained by multiplying a
    contiguous subarray of the given integer list `numbers`.

    Example:

    >>> max_product_subarray([2, 3, -2, 4])
    6
    >>> max_product_subarray((-2, 0, -1))
    0
    >>> max_product_subarray([2, 3, -2, 4, -1])
    48
    >>> max_product_subarray([-1])
    -1
    >>> max_product_subarray([0])
    0
    >>> max_product_subarray([])
    0
    >>> max_product_subarray("""")
    0
    >>> max_product_subarray(None)
    0
    >>> max_product_subarray([2, 3, -2, 4.5, -1])
    Traceback (most recent call last):
        ...
    ValueError: numbers must be an iterable of integers
    >>> max_product_subarray(""ABC"")
    Traceback (most recent call last):
        ...
    ValueError: numbers must be an iterable of integers
    """"""
    if not numbers:
        return 0

    if not isinstance(numbers, (list, tuple)) or not all(
        isinstance(number, int) for number in numbers
    ):
        raise ValueError(""numbers must be an iterable of integers"")

    max_till_now = min_till_now = max_prod = numbers[0]

    for i in range(1, len(numbers)):
        # update the maximum and minimum subarray products
        number = numbers[i]
        if number < 0:
            max_till_now, min_till_now = min_till_now, max_till_now
        max_till_now = max(number, max_till_now * number)
        min_till_now = min(number, min_till_now * number)

        # update the maximum product found till now
        max_prod = max(max_prod, max_till_now)

    return max_prod",data\repos\Python\dynamic_programming\max_product_subarray.py,max_product_subarray,430
742,max_subarray_sum.py::max_subarray_sum::16,"def max_subarray_sum(
    arr: Sequence[float], allow_empty_subarrays: bool = False
) -> float:
    """"""
    Solves the maximum subarray sum problem using Kadane's algorithm.
    :param arr: the given array of numbers
    :param allow_empty_subarrays: if True, then the algorithm considers empty subarrays

    >>> max_subarray_sum([2, 8, 9])
    19
    >>> max_subarray_sum([0, 0])
    0
    >>> max_subarray_sum([-1.0, 0.0, 1.0])
    1.0
    >>> max_subarray_sum([1, 2, 3, 4, -2])
    10
    >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])
    6
    >>> max_subarray_sum([2, 3, -9, 8, -2])
    8
    >>> max_subarray_sum([-2, -3, -1, -4, -6])
    -1
    >>> max_subarray_sum([-2, -3, -1, -4, -6], allow_empty_subarrays=True)
    0
    >>> max_subarray_sum([])
    0
    """"""
    if not arr:
        return 0

    max_sum = 0 if allow_empty_subarrays else float(""-inf"")
    curr_sum = 0.0
    for num in arr:
        curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)
        max_sum = max(max_sum, curr_sum)

    return max_sum",data\repos\Python\dynamic_programming\max_subarray_sum.py,max_subarray_sum,366
743,minimum_coin_change.py::dp_count::10,"def dp_count(s, n):
    """"""
    >>> dp_count([1, 2, 3], 4)
    4
    >>> dp_count([1, 2, 3], 7)
    8
    >>> dp_count([2, 5, 3, 6], 10)
    5
    >>> dp_count([10], 99)
    0
    >>> dp_count([4, 5, 6], 0)
    1
    >>> dp_count([1, 2, 3], -5)
    0
    """"""
    if n < 0:
        return 0
    # table[i] represents the number of ways to get to amount i
    table = [0] * (n + 1)

    # There is exactly 1 way to get to zero(You pick no coins).
    table[0] = 1

    # Pick all coins one by one and update table[] values
    # after the index greater than or equal to the value of the
    # picked coin
    for coin_val in s:
        for j in range(coin_val, n + 1):
            table[j] += table[j - coin_val]

    return table[n]",data\repos\Python\dynamic_programming\minimum_coin_change.py,dp_count,267
744,minimum_cost_path.py::minimum_cost_path::6,"def minimum_cost_path(matrix: list[list[int]]) -> int:
    """"""
    Find the minimum cost traced by all possible paths from top left to bottom right in
    a given matrix

    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])
    6

    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])
    7
    """"""

    # preprocessing the first row
    for i in range(1, len(matrix[0])):
        matrix[0][i] += matrix[0][i - 1]

    # preprocessing the first column
    for i in range(1, len(matrix)):
        matrix[i][0] += matrix[i - 1][0]

    # updating the path cost for current position
    for i in range(1, len(matrix)):
        for j in range(1, len(matrix[0])):
            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])

    return matrix[-1][-1]",data\repos\Python\dynamic_programming\minimum_cost_path.py,minimum_cost_path,239
745,minimum_partition.py::find_min::6,"def find_min(numbers: list[int]) -> int:
    """"""
    >>> find_min([1, 2, 3, 4, 5])
    1
    >>> find_min([5, 5, 5, 5, 5])
    5
    >>> find_min([5, 5, 5, 5])
    0
    >>> find_min([3])
    3
    >>> find_min([])
    0
    >>> find_min([1, 2, 3, 4])
    0
    >>> find_min([0, 0, 0, 0])
    0
    >>> find_min([-1, -5, 5, 1])
    0
    >>> find_min([-1, -5, 5, 1])
    0
    >>> find_min([9, 9, 9, 9, 9])
    9
    >>> find_min([1, 5, 10, 3])
    1
    >>> find_min([-1, 0, 1])
    0
    >>> find_min(range(10, 0, -1))
    1
    >>> find_min([-1])
    Traceback (most recent call last):
        --
    IndexError: list assignment index out of range
    >>> find_min([0, 0, 0, 1, 2, -4])
    Traceback (most recent call last):
        ...
    IndexError: list assignment index out of range
    >>> find_min([-1, -5, -10, -3])
    Traceback (most recent call last):
        ...
    IndexError: list assignment index out of range
    """"""
    n = len(numbers)
    s = sum(numbers)

    dp = [[False for x in range(s + 1)] for y in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = True

    for i in range(1, s + 1):
        dp[0][i] = False

    for i in range(1, n + 1):
        for j in range(1, s + 1):
            dp[i][j] = dp[i - 1][j]

            if numbers[i - 1] <= j:
                dp[i][j] = dp[i][j] or dp[i - 1][j - numbers[i - 1]]

    for j in range(int(s / 2), -1, -1):
        if dp[n][j] is True:
            diff = s - 2 * j
            break

    return diff",data\repos\Python\dynamic_programming\minimum_partition.py,find_min,566
746,minimum_size_subarray_sum.py::minimum_subarray_sum::4,"def minimum_subarray_sum(target: int, numbers: list[int]) -> int:
    """"""
    Return the length of the shortest contiguous subarray in a list of numbers whose sum
    is at least target.  Reference: https://stackoverflow.com/questions/8269916

    >>> minimum_subarray_sum(7, [2, 3, 1, 2, 4, 3])
    2
    >>> minimum_subarray_sum(7, [2, 3, -1, 2, 4, -3])
    4
    >>> minimum_subarray_sum(11, [1, 1, 1, 1, 1, 1, 1, 1])
    0
    >>> minimum_subarray_sum(10, [1, 2, 3, 4, 5, 6, 7])
    2
    >>> minimum_subarray_sum(5, [1, 1, 1, 1, 1, 5])
    1
    >>> minimum_subarray_sum(0, [])
    0
    >>> minimum_subarray_sum(0, [1, 2, 3])
    1
    >>> minimum_subarray_sum(10, [10, 20, 30])
    1
    >>> minimum_subarray_sum(7, [1, 1, 1, 1, 1, 1, 10])
    1
    >>> minimum_subarray_sum(6, [])
    0
    >>> minimum_subarray_sum(2, [1, 2, 3])
    1
    >>> minimum_subarray_sum(-6, [])
    0
    >>> minimum_subarray_sum(-6, [3, 4, 5])
    1
    >>> minimum_subarray_sum(8, None)
    0
    >>> minimum_subarray_sum(2, ""ABC"")
    Traceback (most recent call last):
        ...
    ValueError: numbers must be an iterable of integers
    """"""
    if not numbers:
        return 0
    if target == 0 and target in numbers:
        return 0
    if not isinstance(numbers, (list, tuple)) or not all(
        isinstance(number, int) for number in numbers
    ):
        raise ValueError(""numbers must be an iterable of integers"")

    left = right = curr_sum = 0
    min_len = sys.maxsize

    while right < len(numbers):
        curr_sum += numbers[right]
        while curr_sum >= target and left <= right:
            min_len = min(min_len, right - left + 1)
            curr_sum -= numbers[left]
            left += 1
        right += 1

    return 0 if min_len == sys.maxsize else min_len",data\repos\Python\dynamic_programming\minimum_size_subarray_sum.py,minimum_subarray_sum,593
747,minimum_squares_to_represent_a_number.py::minimum_squares_to_represent_a_number::5,"def minimum_squares_to_represent_a_number(number: int) -> int:
    """"""
    Count the number of minimum squares to represent a number

    >>> minimum_squares_to_represent_a_number(25)
    1
    >>> minimum_squares_to_represent_a_number(37)
    2
    >>> minimum_squares_to_represent_a_number(21)
    3
    >>> minimum_squares_to_represent_a_number(58)
    2
    >>> minimum_squares_to_represent_a_number(-1)
    Traceback (most recent call last):
        ...
    ValueError: the value of input must not be a negative number
    >>> minimum_squares_to_represent_a_number(0)
    1
    >>> minimum_squares_to_represent_a_number(12.34)
    Traceback (most recent call last):
        ...
    ValueError: the value of input must be a natural number
    """"""
    if number != int(number):
        raise ValueError(""the value of input must be a natural number"")
    if number < 0:
        raise ValueError(""the value of input must not be a negative number"")
    if number == 0:
        return 1
    answers = [-1] * (number + 1)
    answers[0] = 0
    for i in range(1, number + 1):
        answer = sys.maxsize
        root = int(math.sqrt(i))
        for j in range(1, root + 1):
            current_answer = 1 + answers[i - (j**2)]
            answer = min(answer, current_answer)
        answers[i] = answer
    return answers[number]",data\repos\Python\dynamic_programming\minimum_squares_to_represent_a_number.py,minimum_squares_to_represent_a_number,348
748,minimum_steps_to_one.py::min_steps_to_one::30,"def min_steps_to_one(number: int) -> int:
    """"""
    Minimum steps to 1 implemented using tabulation.
    >>> min_steps_to_one(10)
    3
    >>> min_steps_to_one(15)
    4
    >>> min_steps_to_one(6)
    2

    :param number:
    :return int:
    """"""

    if number <= 0:
        msg = f""n must be greater than 0. Got n = {number}""
        raise ValueError(msg)

    table = [number + 1] * (number + 1)

    # starting position
    table[1] = 0
    for i in range(1, number):
        table[i + 1] = min(table[i + 1], table[i] + 1)
        # check if out of bounds
        if i * 2 <= number:
            table[i * 2] = min(table[i * 2], table[i] + 1)
        # check if out of bounds
        if i * 3 <= number:
            table[i * 3] = min(table[i * 3], table[i] + 1)
    return table[number]",data\repos\Python\dynamic_programming\minimum_steps_to_one.py,min_steps_to_one,252
749,minimum_tickets_cost.py::mincost_tickets::28,"def mincost_tickets(days: list[int], costs: list[int]) -> int:
    """"""
    >>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])
    11

    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])
    17

    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])
    24

    >>> mincost_tickets([2], [2, 90, 150])
    2

    >>> mincost_tickets([], [2, 90, 150])
    0

    >>> mincost_tickets('hello', [2, 90, 150])
    Traceback (most recent call last):
     ...
    ValueError: The parameter days should be a list of integers

    >>> mincost_tickets([], 'world')
    Traceback (most recent call last):
     ...
    ValueError: The parameter costs should be a list of three integers

    >>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])
    Traceback (most recent call last):
     ...
    ValueError: The parameter days should be a list of integers

    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])
    Traceback (most recent call last):
     ...
    ValueError: The parameter costs should be a list of three integers

    >>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])
    Traceback (most recent call last):
     ...
    ValueError: All days elements should be greater than 0

    >>> mincost_tickets([2, 367], [2, 90, 150])
    Traceback (most recent call last):
     ...
    ValueError: All days elements should be less than 366

    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])
    Traceback (most recent call last):
     ...
    ValueError: The parameter costs should be a list of three integers

    >>> mincost_tickets([], [])
    Traceback (most recent call last):
     ...
    ValueError: The parameter costs should be a list of three integers

    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])
    Traceback (most recent call last):
     ...
    ValueError: The parameter costs should be a list of three integers
    """"""

    # Validation
    if not isinstance(days, list) or not all(isinstance(day, int) for day in days):
        raise ValueError(""The parameter days should be a list of integers"")

    if len(costs) != 3 or not all(isinstance(cost, int) for cost in costs):
        raise ValueError(""The parameter costs should be a list of three integers"")

    if len(days) == 0:
        return 0

    if min(days) <= 0:
        raise ValueError(""All days elements should be greater than 0"")

    if max(days) >= 366:
        raise ValueError(""All days elements should be less than 366"")

    days_set = set(days)

    @functools.cache
    def dynamic_programming(index: int) -> int:
        if index > 365:
            return 0

        if index not in days_set:
            return dynamic_programming(index + 1)

        return min(
            costs[0] + dynamic_programming(index + 1),
            costs[1] + dynamic_programming(index + 7),
            costs[2] + dynamic_programming(index + 30),
        )

    return dynamic_programming(1)",data\repos\Python\dynamic_programming\minimum_tickets_cost.py,mincost_tickets,971
750,minimum_tickets_cost.py::dynamic_programming::110,"    def dynamic_programming(index: int) -> int:
        if index > 365:
            return 0

        if index not in days_set:
            return dynamic_programming(index + 1)

        return min(
            costs[0] + dynamic_programming(index + 1),
            costs[1] + dynamic_programming(index + 7),
            costs[2] + dynamic_programming(index + 30),
        )",data\repos\Python\dynamic_programming\minimum_tickets_cost.py,dynamic_programming,90
751,min_distance_up_bottom.py::min_distance_up_bottom::14,"def min_distance_up_bottom(word1: str, word2: str) -> int:
    """"""
    >>> min_distance_up_bottom(""intention"", ""execution"")
    5
    >>> min_distance_up_bottom(""intention"", """")
    9
    >>> min_distance_up_bottom("""", """")
    0
    >>> min_distance_up_bottom(""zooicoarchaeologist"", ""zoologist"")
    10
    """"""
    len_word1 = len(word1)
    len_word2 = len(word2)

    @functools.cache
    def min_distance(index1: int, index2: int) -> int:
        # if first word index overflows - delete all from the second word
        if index1 >= len_word1:
            return len_word2 - index2
        # if second word index overflows - delete all from the first word
        if index2 >= len_word2:
            return len_word1 - index1
        diff = int(word1[index1] != word2[index2])  # current letters not identical
        return min(
            1 + min_distance(index1 + 1, index2),
            1 + min_distance(index1, index2 + 1),
            diff + min_distance(index1 + 1, index2 + 1),
        )

    return min_distance(0, 0)",data\repos\Python\dynamic_programming\min_distance_up_bottom.py,min_distance_up_bottom,283
752,min_distance_up_bottom.py::min_distance::29,"    def min_distance(index1: int, index2: int) -> int:
        # if first word index overflows - delete all from the second word
        if index1 >= len_word1:
            return len_word2 - index2
        # if second word index overflows - delete all from the first word
        if index2 >= len_word2:
            return len_word1 - index1
        diff = int(word1[index1] != word2[index2])  # current letters not identical
        return min(
            1 + min_distance(index1 + 1, index2),
            1 + min_distance(index1, index2 + 1),
            diff + min_distance(index1 + 1, index2 + 1),
        )",data\repos\Python\dynamic_programming\min_distance_up_bottom.py,min_distance,160
753,optimal_binary_search_tree.py::print_binary_search_tree::38,"def print_binary_search_tree(root, key, i, j, parent, is_left):
    """"""
    Recursive function to print a BST from a root table.

    >>> key = [3, 8, 9, 10, 17, 21]
    >>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3], \
                [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]
    >>> print_binary_search_tree(root, key, 0, 5, -1, False)
    8 is the root of the binary search tree.
    3 is the left child of key 8.
    10 is the right child of key 8.
    9 is the left child of key 10.
    21 is the right child of key 10.
    17 is the left child of key 21.
    """"""
    if i > j or i < 0 or j > len(root) - 1:
        return

    node = root[i][j]
    if parent == -1:  # root does not have a parent
        print(f""{key[node]} is the root of the binary search tree."")
    elif is_left:
        print(f""{key[node]} is the left child of key {parent}."")
    else:
        print(f""{key[node]} is the right child of key {parent}."")

    print_binary_search_tree(root, key, i, node - 1, key[node], True)
    print_binary_search_tree(root, key, node + 1, j, key[node], False)",data\repos\Python\dynamic_programming\optimal_binary_search_tree.py,print_binary_search_tree,410
754,optimal_binary_search_tree.py::find_optimal_binary_search_tree::68,"def find_optimal_binary_search_tree(nodes):
    """"""
    This function calculates and prints the optimal binary search tree.
    The dynamic programming algorithm below runs in O(n^2) time.
    Implemented from CLRS (Introduction to Algorithms) book.
    https://en.wikipedia.org/wiki/Introduction_to_Algorithms

    >>> find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50), \
                                         Node(42, 3), Node(25, 40), Node(37, 30)])
    Binary search tree nodes:
    Node(key=10, freq=34)
    Node(key=12, freq=8)
    Node(key=20, freq=50)
    Node(key=25, freq=40)
    Node(key=37, freq=30)
    Node(key=42, freq=3)
    <BLANKLINE>
    The cost of optimal BST for given tree nodes is 324.
    20 is the root of the binary search tree.
    10 is the left child of key 20.
    12 is the right child of key 10.
    25 is the right child of key 20.
    37 is the right child of key 25.
    42 is the right child of key 37.
    """"""
    # Tree nodes must be sorted first, the code below sorts the keys in
    # increasing order and rearrange its frequencies accordingly.
    nodes.sort(key=lambda node: node.key)

    n = len(nodes)

    keys = [nodes[i].key for i in range(n)]
    freqs = [nodes[i].freq for i in range(n)]

    # This 2D array stores the overall tree cost (which's as minimized as possible);
    # for a single key, cost is equal to frequency of the key.
    dp = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]
    # sum[i][j] stores the sum of key frequencies between i and j inclusive in nodes
    # array
    total = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]
    # stores tree roots that will be used later for constructing binary search tree
    root = [[i if i == j else 0 for j in range(n)] for i in range(n)]

    for interval_length in range(2, n + 1):
        for i in range(n - interval_length + 1):
            j = i + interval_length - 1

            dp[i][j] = sys.maxsize  # set the value to ""infinity""
            total[i][j] = total[i][j - 1] + freqs[j]

            # Apply Knuth's optimization
            # Loop without optimization: for r in range(i, j + 1):
            for r in range(root[i][j - 1], root[i + 1][j] + 1):  # r is a temporal root
                left = dp[i][r - 1] if r != i else 0  # optimal cost for left subtree
                right = dp[r + 1][j] if r != j else 0  # optimal cost for right subtree
                cost = left + total[i][j] + right

                if dp[i][j] > cost:
                    dp[i][j] = cost
                    root[i][j] = r

    print(""Binary search tree nodes:"")
    for node in nodes:
        print(node)

    print(f""\nThe cost of optimal BST for given tree nodes is {dp[0][n - 1]}."")
    print_binary_search_tree(root, keys, 0, n - 1, -1, False)",data\repos\Python\dynamic_programming\optimal_binary_search_tree.py,find_optimal_binary_search_tree,798
755,optimal_binary_search_tree.py::main::137,"def main():
    # A sample binary search tree
    nodes = [Node(i, randint(1, 50)) for i in range(10, 0, -1)]
    find_optimal_binary_search_tree(nodes)",data\repos\Python\dynamic_programming\optimal_binary_search_tree.py,main,47
756,palindrome_partitioning.py::find_minimum_partitions::12,"def find_minimum_partitions(string: str) -> int:
    """"""
    Returns the minimum cuts needed for a palindrome partitioning of string

    >>> find_minimum_partitions(""aab"")
    1
    >>> find_minimum_partitions(""aaa"")
    0
    >>> find_minimum_partitions(""ababbbabbababa"")
    3
    """"""
    length = len(string)
    cut = [0] * length
    is_palindromic = [[False for i in range(length)] for j in range(length)]
    for i, c in enumerate(string):
        mincut = i
        for j in range(i + 1):
            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):
                is_palindromic[j][i] = True
                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))
        cut[i] = mincut
    return cut[length - 1]",data\repos\Python\dynamic_programming\palindrome_partitioning.py,find_minimum_partitions,218
757,range_sum_query.py::prefix_sum::64,"def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:
    """"""
    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])
    [81, 85, 63]
    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])
    [9, 9, 7]
    """"""
    # The prefix sum array
    dp = [0] * len(array)
    dp[0] = array[0]
    for i in range(1, len(array)):
        dp[i] = dp[i - 1] + array[i]

    # See Algorithm section (Line 44)
    result = []
    for query in queries:
        left, right = query
        res = dp[right]
        if left > 0:
            res -= dp[left - 1]
        result.append(res)

    return result",data\repos\Python\dynamic_programming\range_sum_query.py,prefix_sum,232
758,regex_match.py::recursive_match::13,"def recursive_match(text: str, pattern: str) -> bool:
    r""""""
    Recursive matching algorithm.

    | Time complexity: O(2^(\|text\| + \|pattern\|))
    | Space complexity: Recursion depth is O(\|text\| + \|pattern\|).

    :param text: Text to match.
    :param pattern: Pattern to match.
    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.

    >>> recursive_match('abc', 'a.c')
    True
    >>> recursive_match('abc', 'af*.c')
    True
    >>> recursive_match('abc', 'a.c*')
    True
    >>> recursive_match('abc', 'a.c*d')
    False
    >>> recursive_match('aa', '.*')
    True
    """"""
    if not pattern:
        return not text

    if not text:
        return pattern[-1] == ""*"" and recursive_match(text, pattern[:-2])

    if text[-1] == pattern[-1] or pattern[-1] == ""."":
        return recursive_match(text[:-1], pattern[:-1])

    if pattern[-1] == ""*"":
        return recursive_match(text[:-1], pattern) or recursive_match(
            text, pattern[:-2]
        )

    return False",data\repos\Python\dynamic_programming\regex_match.py,recursive_match,273
759,regex_match.py::dp_match::52,"def dp_match(text: str, pattern: str) -> bool:
    r""""""
    Dynamic programming matching algorithm.

    | Time complexity: O(\|text\| * \|pattern\|)
    | Space complexity: O(\|text\| * \|pattern\|)

    :param text: Text to match.
    :param pattern: Pattern to match.
    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.

    >>> dp_match('abc', 'a.c')
    True
    >>> dp_match('abc', 'af*.c')
    True
    >>> dp_match('abc', 'a.c*')
    True
    >>> dp_match('abc', 'a.c*d')
    False
    >>> dp_match('aa', '.*')
    True
    """"""
    m = len(text)
    n = len(pattern)
    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]
    dp[0][0] = True

    for j in range(1, n + 1):
        dp[0][j] = pattern[j - 1] == ""*"" and dp[0][j - 2]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if pattern[j - 1] in {""."", text[i - 1]}:
                dp[i][j] = dp[i - 1][j - 1]
            elif pattern[j - 1] == ""*"":
                dp[i][j] = dp[i][j - 2]
                if pattern[j - 2] in {""."", text[i - 1]}:
                    dp[i][j] |= dp[i - 1][j]
            else:
                dp[i][j] = False

    return dp[m][n]",data\repos\Python\dynamic_programming\regex_match.py,dp_match,394
760,rod_cutting.py::naive_cut_rod_recursive::14,"def naive_cut_rod_recursive(n: int, prices: list):
    """"""
    Solves the rod-cutting problem via naively without using the benefit of dynamic
    programming. The results is the same sub-problems are solved several times
    leading to an exponential runtime

    Runtime: O(2^n)

    Arguments
    ---------

    * `n`: int, the length of the rod
    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the
      price for a rod of length ``i``

    Returns
    -------

    The maximum revenue obtainable for a rod of length `n` given the list of prices
    for each piece.

    Examples
    --------

    >>> naive_cut_rod_recursive(4, [1, 5, 8, 9])
    10
    >>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
    30
    """"""

    _enforce_args(n, prices)
    if n == 0:
        return 0
    max_revue = float(""-inf"")
    for i in range(1, n + 1):
        max_revue = max(
            max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)
        )

    return max_revue",data\repos\Python\dynamic_programming\rod_cutting.py,naive_cut_rod_recursive,308
761,rod_cutting.py::top_down_cut_rod::56,"def top_down_cut_rod(n: int, prices: list):
    """"""
    Constructs a top-down dynamic programming solution for the rod-cutting
    problem via memoization. This function serves as a wrapper for
    ``_top_down_cut_rod_recursive``

    Runtime: O(n^2)

    Arguments
    ---------

    * `n`: int, the length of the rod
    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the
      price for a rod of length ``i``

    .. note::
      For convenience and because Python's lists using ``0``-indexing, ``length(max_rev)
      = n + 1``, to accommodate for the revenue obtainable from a rod of length ``0``.

    Returns
    -------

    The maximum revenue obtainable for a rod of length `n` given the list of prices
    for each piece.

    Examples
    --------

    >>> top_down_cut_rod(4, [1, 5, 8, 9])
    10
    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
    30
    """"""
    _enforce_args(n, prices)
    max_rev = [float(""-inf"") for _ in range(n + 1)]
    return _top_down_cut_rod_recursive(n, prices, max_rev)",data\repos\Python\dynamic_programming\rod_cutting.py,top_down_cut_rod,317
762,rod_cutting.py::bottom_up_cut_rod::133,"def bottom_up_cut_rod(n: int, prices: list):
    """"""
    Constructs a bottom-up dynamic programming solution for the rod-cutting problem

    Runtime: O(n^2)

    Arguments
    ---------

    * `n`: int, the maximum length of the rod.
    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the
      price for a rod of length ``i``

    Returns
    -------

    The maximum revenue obtainable from cutting a rod of length `n` given
    the prices for each piece of rod p.

    Examples
    --------

    >>> bottom_up_cut_rod(4, [1, 5, 8, 9])
    10
    >>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
    30
    """"""
    _enforce_args(n, prices)

    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of
    # length 0.
    max_rev = [float(""-inf"") for _ in range(n + 1)]
    max_rev[0] = 0

    for i in range(1, n + 1):
        max_revenue_i = max_rev[i]
        for j in range(1, i + 1):
            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])

        max_rev[i] = max_revenue_i

    return max_rev[n]",data\repos\Python\dynamic_programming\rod_cutting.py,bottom_up_cut_rod,350
763,rod_cutting.py::main::200,"def main():
    prices = [6, 10, 12, 15, 20, 23]
    n = len(prices)

    # the best revenue comes from cutting the rod into 6 pieces, each
    # of length 1 resulting in a revenue of 6 * 6 = 36.
    expected_max_revenue = 36

    max_rev_top_down = top_down_cut_rod(n, prices)
    max_rev_bottom_up = bottom_up_cut_rod(n, prices)
    max_rev_naive = naive_cut_rod_recursive(n, prices)

    assert expected_max_revenue == max_rev_top_down
    assert max_rev_top_down == max_rev_bottom_up
    assert max_rev_bottom_up == max_rev_naive",data\repos\Python\dynamic_programming\rod_cutting.py,main,157
764,smith_waterman.py::score_function::12,"def score_function(
    source_char: str,
    target_char: str,
    match: int = 1,
    mismatch: int = -1,
    gap: int = -2,
) -> int:
    """"""
    Calculate the score for a character pair based on whether they match or mismatch.
    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the
    characters is a gap.
    >>> score_function('A', 'A')
    1
    >>> score_function('A', 'C')
    -1
    >>> score_function('-', 'A')
    -2
    >>> score_function('A', '-')
    -2
    >>> score_function('-', '-')
    -2
    """"""
    if ""-"" in (source_char, target_char):
        return gap
    return match if source_char == target_char else mismatch",data\repos\Python\dynamic_programming\smith_waterman.py,score_function,181
765,smith_waterman.py::smith_waterman::39,"def smith_waterman(
    query: str,
    subject: str,
    match: int = 1,
    mismatch: int = -1,
    gap: int = -2,
) -> list[list[int]]:
    """"""
    Perform the Smith-Waterman local sequence alignment algorithm.
    Returns a 2D list representing the score matrix. Each value in the matrix
    corresponds to the score of the best local alignment ending at that point.
    >>> smith_waterman('ACAC', 'CA')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
    >>> smith_waterman('acac', 'ca')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
    >>> smith_waterman('ACAC', 'ca')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
    >>> smith_waterman('acac', 'CA')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
    >>> smith_waterman('ACAC', '')
    [[0], [0], [0], [0], [0]]
    >>> smith_waterman('', 'CA')
    [[0, 0, 0]]
    >>> smith_waterman('ACAC', 'CA')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

    >>> smith_waterman('acac', 'ca')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

    >>> smith_waterman('ACAC', 'ca')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

    >>> smith_waterman('acac', 'CA')
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

    >>> smith_waterman('ACAC', '')
    [[0], [0], [0], [0], [0]]

    >>> smith_waterman('', 'CA')
    [[0, 0, 0]]

    >>> smith_waterman('AGT', 'AGT')
    [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]

    >>> smith_waterman('AGT', 'GTA')
    [[0, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 2, 0]]

    >>> smith_waterman('AGT', 'GTC')
    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0]]

    >>> smith_waterman('AGT', 'G')
    [[0, 0], [0, 0], [0, 1], [0, 0]]

    >>> smith_waterman('G', 'AGT')
    [[0, 0, 0, 0], [0, 0, 1, 0]]

    >>> smith_waterman('AGT', 'AGTCT')
    [[0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0], [0, 0, 0, 3, 1, 1]]

    >>> smith_waterman('AGTCT', 'AGT')
    [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 1]]

    >>> smith_waterman('AGTCT', 'GTC')
    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 1, 1]]
    """"""
    # make both query and subject uppercase
    query = query.upper()
    subject = subject.upper()

    # Initialize score matrix
    m = len(query)
    n = len(subject)
    score = [[0] * (n + 1) for _ in range(m + 1)]
    kwargs = {""match"": match, ""mismatch"": mismatch, ""gap"": gap}

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # Calculate scores for each cell
            match = score[i - 1][j - 1] + score_function(
                query[i - 1], subject[j - 1], **kwargs
            )
            delete = score[i - 1][j] + gap
            insert = score[i][j - 1] + gap

            # Take maximum score
            score[i][j] = max(0, match, delete, insert)

    return score",data\repos\Python\dynamic_programming\smith_waterman.py,smith_waterman,1373
766,smith_waterman.py::traceback::129,"def traceback(score: list[list[int]], query: str, subject: str) -> str:
    r""""""
    Perform traceback to find the optimal local alignment.
    Starts from the highest scoring cell in the matrix and traces back recursively
    until a 0 score is found. Returns the alignment strings.
    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'CA')
    'CA\nCA'
    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'ca')
    'CA\nCA'
    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'ca')
    'CA\nCA'
    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'CA')
    'CA\nCA'
    >>> traceback([[0, 0, 0]], 'ACAC', '')
    ''
    """"""
    # make both query and subject uppercase
    query = query.upper()
    subject = subject.upper()
    # find the indices of the maximum value in the score matrix
    max_value = float(""-inf"")
    i_max = j_max = 0
    for i, row in enumerate(score):
        for j, value in enumerate(row):
            if value > max_value:
                max_value = value
                i_max, j_max = i, j
    # Traceback logic to find optimal alignment
    i = i_max
    j = j_max
    align1 = """"
    align2 = """"
    gap = score_function(""-"", ""-"")
    # guard against empty query or subject
    if i == 0 or j == 0:
        return """"
    while i > 0 and j > 0:
        if score[i][j] == score[i - 1][j - 1] + score_function(
            query[i - 1], subject[j - 1]
        ):
            # optimal path is a diagonal take both letters
            align1 = query[i - 1] + align1
            align2 = subject[j - 1] + align2
            i -= 1
            j -= 1
        elif score[i][j] == score[i - 1][j] + gap:
            # optimal path is a vertical
            align1 = query[i - 1] + align1
            align2 = f""-{align2}""
            i -= 1
        else:
            # optimal path is a horizontal
            align1 = f""-{align1}""
            align2 = subject[j - 1] + align2
            j -= 1

    return f""{align1}\n{align2}""",data\repos\Python\dynamic_programming\smith_waterman.py,traceback,696
767,subset_generation.py::subset_combinations::1,"def subset_combinations(elements: list[int], n: int) -> list:
    """"""
    Compute n-element combinations from a given list using dynamic programming.

    Args:
        * `elements`: The list of elements from which combinations will be generated.
        * `n`: The number of elements in each combination.

    Returns:
        A list of tuples, each representing a combination of `n` elements.

    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)
    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]
    >>> subset_combinations(elements=[1, 2, 3], n=1)
    [(1,), (2,), (3,)]
    >>> subset_combinations(elements=[1, 2, 3], n=3)
    [(1, 2, 3)]
    >>> subset_combinations(elements=[42], n=1)
    [(42,)]
    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)
    [(6, 7, 8, 9)]
    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)
    [()]
    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)
    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]
    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)
    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]
    >>> subset_combinations(elements=['single'], n=0)
    [()]
    >>> subset_combinations(elements=[], n=9)
    []
    >>> from itertools import combinations
    >>> all(subset_combinations(items, n) == list(combinations(items, n))
    ...     for items, n in (
    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),
    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),
    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))
    True
    """"""
    r = len(elements)
    if n > r:
        return []

    dp: list[list[tuple]] = [[] for _ in range(r + 1)]

    dp[0].append(())

    for i in range(1, r + 1):
        for j in range(i, 0, -1):
            for prev_combination in dp[j - 1]:
                dp[j].append((*prev_combination, elements[i - 1]))

    try:
        return sorted(dp[n])
    except TypeError:
        return dp[n]",data\repos\Python\dynamic_programming\subset_generation.py,subset_combinations,695
768,sum_of_subset.py::is_sum_subset::1,"def is_sum_subset(arr: list[int], required_sum: int) -> bool:
    """"""
    >>> is_sum_subset([2, 4, 6, 8], 5)
    False
    >>> is_sum_subset([2, 4, 6, 8], 14)
    True
    """"""
    # a subset value says 1 if that subset sum can be formed else 0
    # initially no subsets can be formed hence False/0
    arr_len = len(arr)
    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]

    # for each arr value, a sum of zero(0) can be formed by not taking any element
    # hence True/1
    for i in range(arr_len + 1):
        subset[i][0] = True

    # sum is not zero and set is empty then false
    for i in range(1, required_sum + 1):
        subset[0][i] = False

    for i in range(1, arr_len + 1):
        for j in range(1, required_sum + 1):
            if arr[i - 1] > j:
                subset[i][j] = subset[i - 1][j]
            if arr[i - 1] <= j:
                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]

    return subset[arr_len][required_sum]",data\repos\Python\dynamic_programming\sum_of_subset.py,is_sum_subset,321
769,trapped_water.py::trapped_rainwater::16,"def trapped_rainwater(heights: tuple[int, ...]) -> int:
    """"""
    The trapped_rainwater function calculates the total amount of rainwater that can be
    trapped given an array of bar heights.
    It uses a dynamic programming approach, determining the maximum height of bars on
    both sides for each bar, and then computing the trapped water above each bar.
    The function returns the total trapped water.

    >>> trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1))
    6
    >>> trapped_rainwater((7, 1, 5, 3, 6, 4))
    9
    >>> trapped_rainwater((7, 1, 5, 3, 6, -1))
    Traceback (most recent call last):
        ...
    ValueError: No height can be negative
    """"""
    if not heights:
        return 0
    if any(h < 0 for h in heights):
        raise ValueError(""No height can be negative"")
    length = len(heights)

    left_max = [0] * length
    left_max[0] = heights[0]
    for i, height in enumerate(heights[1:], start=1):
        left_max[i] = max(height, left_max[i - 1])

    right_max = [0] * length
    right_max[-1] = heights[-1]
    for i in range(length - 2, -1, -1):
        right_max[i] = max(heights[i], right_max[i + 1])

    return sum(
        min(left, right) - height
        for left, right, height in zip(left_max, right_max, heights)
    )",data\repos\Python\dynamic_programming\trapped_water.py,trapped_rainwater,386
770,tribonacci.py::tribonacci::4,"def tribonacci(num: int) -> list[int]:
    """"""
    Given a number, return first n Tribonacci Numbers.
    >>> tribonacci(5)
    [0, 0, 1, 1, 2]
    >>> tribonacci(8)
    [0, 0, 1, 1, 2, 4, 7, 13]
    """"""
    dp = [0] * num
    dp[2] = 1

    for i in range(3, num):
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]

    return dp",data\repos\Python\dynamic_programming\tribonacci.py,tribonacci,138
771,viterbi.py::viterbi::4,"def viterbi(
    observations_space: list,
    states_space: list,
    initial_probabilities: dict,
    transition_probabilities: dict,
    emission_probabilities: dict,
) -> list:
    """"""
    Viterbi Algorithm, to find the most likely path of
    states from the start and the expected output.

    https://en.wikipedia.org/wiki/Viterbi_algorithm

    Wikipedia example

    >>> observations = [""normal"", ""cold"", ""dizzy""]
    >>> states = [""Healthy"", ""Fever""]
    >>> start_p = {""Healthy"": 0.6, ""Fever"": 0.4}
    >>> trans_p = {
    ...     ""Healthy"": {""Healthy"": 0.7, ""Fever"": 0.3},
    ...     ""Fever"": {""Healthy"": 0.4, ""Fever"": 0.6},
    ... }
    >>> emit_p = {
    ...     ""Healthy"": {""normal"": 0.5, ""cold"": 0.4, ""dizzy"": 0.1},
    ...     ""Fever"": {""normal"": 0.1, ""cold"": 0.3, ""dizzy"": 0.6},
    ... }
    >>> viterbi(observations, states, start_p, trans_p, emit_p)
    ['Healthy', 'Healthy', 'Fever']
    >>> viterbi((), states, start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter
    >>> viterbi(observations, (), start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter
    >>> viterbi(observations, states, {}, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter
    >>> viterbi(observations, states, start_p, {}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter
    >>> viterbi(observations, states, start_p, trans_p, {})
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter
    >>> viterbi(""invalid"", states, start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: observations_space must be a list
    >>> viterbi([""valid"", 123], states, start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: observations_space must be a list of strings
    >>> viterbi(observations, ""invalid"", start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: states_space must be a list
    >>> viterbi(observations, [""valid"", 123], start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: states_space must be a list of strings
    >>> viterbi(observations, states, ""invalid"", trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: initial_probabilities must be a dict
    >>> viterbi(observations, states, {2:2}, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: initial_probabilities all keys must be strings
    >>> viterbi(observations, states, {""a"":2}, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: initial_probabilities all values must be float
    >>> viterbi(observations, states, start_p, ""invalid"", emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities must be a dict
    >>> viterbi(observations, states, start_p, {""a"":2}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities all values must be dict
    >>> viterbi(observations, states, start_p, {2:{2:2}}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities all keys must be strings
    >>> viterbi(observations, states, start_p, {""a"":{2:2}}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities all keys must be strings
    >>> viterbi(observations, states, start_p, {""a"":{""b"":2}}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities nested dictionary all values must be float
    >>> viterbi(observations, states, start_p, trans_p, ""invalid"")
    Traceback (most recent call last):
        ...
    ValueError: emission_probabilities must be a dict
    >>> viterbi(observations, states, start_p, trans_p, None)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter

    """"""
    _validation(
        observations_space,
        states_space,
        initial_probabilities,
        transition_probabilities,
        emission_probabilities,
    )
    # Creates data structures and fill initial step
    probabilities: dict = {}
    pointers: dict = {}
    for state in states_space:
        observation = observations_space[0]
        probabilities[(state, observation)] = (
            initial_probabilities[state] * emission_probabilities[state][observation]
        )
        pointers[(state, observation)] = None

    # Fills the data structure with the probabilities of
    # different transitions and pointers to previous states
    for o in range(1, len(observations_space)):
        observation = observations_space[o]
        prior_observation = observations_space[o - 1]
        for state in states_space:
            # Calculates the argmax for probability function
            arg_max = """"
            max_probability = -1
            for k_state in states_space:
                probability = (
                    probabilities[(k_state, prior_observation)]
                    * transition_probabilities[k_state][state]
                    * emission_probabilities[state][observation]
                )
                if probability > max_probability:
                    max_probability = probability
                    arg_max = k_state

            # Update probabilities and pointers dicts
            probabilities[(state, observation)] = (
                probabilities[(arg_max, prior_observation)]
                * transition_probabilities[arg_max][state]
                * emission_probabilities[state][observation]
            )

            pointers[(state, observation)] = arg_max

    # The final observation
    final_observation = observations_space[len(observations_space) - 1]

    # argmax for given final observation
    arg_max = """"
    max_probability = -1
    for k_state in states_space:
        probability = probabilities[(k_state, final_observation)]
        if probability > max_probability:
            max_probability = probability
            arg_max = k_state
    last_state = arg_max

    # Process pointers backwards
    previous = last_state
    result = []
    for o in range(len(observations_space) - 1, -1, -1):
        result.append(previous)
        previous = pointers[previous, observations_space[o]]
    result.reverse()

    return result",data\repos\Python\dynamic_programming\viterbi.py,viterbi,1539
772,wildcard_matching.py::is_match::19,"def is_match(string: str, pattern: str) -> bool:
    """"""
    >>> is_match("""", """")
    True
    >>> is_match(""aa"", ""a"")
    False
    >>> is_match(""abc"", ""abc"")
    True
    >>> is_match(""abc"", ""*c"")
    True
    >>> is_match(""abc"", ""a*"")
    True
    >>> is_match(""abc"", ""*a*"")
    True
    >>> is_match(""abc"", ""?b?"")
    True
    >>> is_match(""abc"", ""*?"")
    True
    >>> is_match(""abc"", ""a*d"")
    False
    >>> is_match(""abc"", ""a*c?"")
    False
    >>> is_match('baaabab','*****ba*****ba')
    False
    >>> is_match('baaabab','*****ba*****ab')
    True
    >>> is_match('aa','*')
    True
    """"""
    dp = [[False] * (len(pattern) + 1) for _ in string + ""1""]
    dp[0][0] = True
    # Fill in the first row
    for j, char in enumerate(pattern, 1):
        if char == ""*"":
            dp[0][j] = dp[0][j - 1]
    # Fill in the rest of the DP table
    for i, s_char in enumerate(string, 1):
        for j, p_char in enumerate(pattern, 1):
            if p_char in (s_char, ""?""):
                dp[i][j] = dp[i - 1][j - 1]
            elif pattern[j - 1] == ""*"":
                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
    return dp[len(string)][len(pattern)]",data\repos\Python\dynamic_programming\wildcard_matching.py,is_match,379
773,word_break.py::word_break::27,"def word_break(string: str, words: list[str]) -> bool:
    """"""
    Return True if numbers have opposite signs False otherwise.

    >>> word_break(""applepenapple"", [""apple"",""pen""])
    True
    >>> word_break(""catsandog"", [""cats"",""dog"",""sand"",""and"",""cat""])
    False
    >>> word_break(""cars"", [""car"",""ca"",""rs""])
    True
    >>> word_break('abc', [])
    False
    >>> word_break(123, ['a'])
    Traceback (most recent call last):
        ...
    ValueError: the string should be not empty string
    >>> word_break('', ['a'])
    Traceback (most recent call last):
        ...
    ValueError: the string should be not empty string
    >>> word_break('abc', [123])
    Traceback (most recent call last):
        ...
    ValueError: the words should be a list of non-empty strings
    >>> word_break('abc', [''])
    Traceback (most recent call last):
        ...
    ValueError: the words should be a list of non-empty strings
    """"""

    # Validation
    if not isinstance(string, str) or len(string) == 0:
        raise ValueError(""the string should be not empty string"")

    if not isinstance(words, list) or not all(
        isinstance(item, str) and len(item) > 0 for item in words
    ):
        raise ValueError(""the words should be a list of non-empty strings"")

    # Build trie
    trie: dict[str, Any] = {}
    word_keeper_key = ""WORD_KEEPER""

    for word in words:
        trie_node = trie
        for c in word:
            if c not in trie_node:
                trie_node[c] = {}

            trie_node = trie_node[c]

        trie_node[word_keeper_key] = True

    len_string = len(string)

    # Dynamic programming method
    @functools.cache
    def is_breakable(index: int) -> bool:
        """"""
        >>> string = 'a'
        >>> is_breakable(1)
        True
        """"""
        if index == len_string:
            return True

        trie_node: Any = trie
        for i in range(index, len_string):
            trie_node = trie_node.get(string[i], None)

            if trie_node is None:
                return False

            if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):
                return True

        return False

    return is_breakable(0)",data\repos\Python\dynamic_programming\word_break.py,word_break,526
774,word_break.py::is_breakable::84,"    def is_breakable(index: int) -> bool:
        """"""
        >>> string = 'a'
        >>> is_breakable(1)
        True
        """"""
        if index == len_string:
            return True

        trie_node: Any = trie
        for i in range(index, len_string):
            trie_node = trie_node.get(string[i], None)

            if trie_node is None:
                return False

            if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):
                return True

        return False",data\repos\Python\dynamic_programming\word_break.py,is_breakable,113
775,apparent_power.py::apparent_power::5,"def apparent_power(
    voltage: float, current: float, voltage_angle: float, current_angle: float
) -> complex:
    """"""
    Calculate the apparent power in a single-phase AC circuit.

    Reference: https://en.wikipedia.org/wiki/AC_power#Apparent_power

    >>> apparent_power(100, 5, 0, 0)
    (500+0j)
    >>> apparent_power(100, 5, 90, 0)
    (3.061616997868383e-14+500j)
    >>> apparent_power(100, 5, -45, -60)
    (-129.40952255126027-482.9629131445341j)
    >>> apparent_power(200, 10, -30, -90)
    (-999.9999999999998-1732.0508075688776j)
    """"""
    # Convert angles from degrees to radians
    voltage_angle_rad = math.radians(voltage_angle)
    current_angle_rad = math.radians(current_angle)

    # Convert voltage and current to rectangular form
    voltage_rect = cmath.rect(voltage, voltage_angle_rad)
    current_rect = cmath.rect(current, current_angle_rad)

    # Calculate apparent power
    return voltage_rect * current_rect",data\repos\Python\electronics\apparent_power.py,apparent_power,266
776,builtin_voltage.py::builtin_voltage::8,"def builtin_voltage(
    donor_conc: float,  # donor concentration
    acceptor_conc: float,  # acceptor concentration
    intrinsic_conc: float,  # intrinsic concentration
) -> float:
    """"""
    This function can calculate the Builtin Voltage of a pn junction diode.
    This is calculated from the given three values.
    Examples -
    >>> builtin_voltage(donor_conc=1e17, acceptor_conc=1e17, intrinsic_conc=1e10)
    0.833370010652644
    >>> builtin_voltage(donor_conc=0, acceptor_conc=1600, intrinsic_conc=200)
    Traceback (most recent call last):
      ...
    ValueError: Donor concentration should be positive
    >>> builtin_voltage(donor_conc=1000, acceptor_conc=0, intrinsic_conc=1200)
    Traceback (most recent call last):
      ...
    ValueError: Acceptor concentration should be positive
    >>> builtin_voltage(donor_conc=1000, acceptor_conc=1000, intrinsic_conc=0)
    Traceback (most recent call last):
      ...
    ValueError: Intrinsic concentration should be positive
    >>> builtin_voltage(donor_conc=1000, acceptor_conc=3000, intrinsic_conc=2000)
    Traceback (most recent call last):
      ...
    ValueError: Donor concentration should be greater than intrinsic concentration
    >>> builtin_voltage(donor_conc=3000, acceptor_conc=1000, intrinsic_conc=2000)
    Traceback (most recent call last):
      ...
    ValueError: Acceptor concentration should be greater than intrinsic concentration
    """"""

    if donor_conc <= 0:
        raise ValueError(""Donor concentration should be positive"")
    elif acceptor_conc <= 0:
        raise ValueError(""Acceptor concentration should be positive"")
    elif intrinsic_conc <= 0:
        raise ValueError(""Intrinsic concentration should be positive"")
    elif donor_conc <= intrinsic_conc:
        raise ValueError(
            ""Donor concentration should be greater than intrinsic concentration""
        )
    elif acceptor_conc <= intrinsic_conc:
        raise ValueError(
            ""Acceptor concentration should be greater than intrinsic concentration""
        )
    else:
        return (
            Boltzmann
            * T
            * log((donor_conc * acceptor_conc) / intrinsic_conc**2)
            / physical_constants[""electron volt""][0]
        )",data\repos\Python\electronics\builtin_voltage.py,builtin_voltage,527
777,capacitor_equivalence.py::capacitor_parallel::6,"def capacitor_parallel(capacitors: list[float]) -> float:
    """"""
    Ceq = C1 + C2 + ... + Cn
    Calculate the equivalent resistance for any number of capacitors in parallel.
    >>> capacitor_parallel([5.71389, 12, 3])
    20.71389
    >>> capacitor_parallel([5.71389, 12, -3])
    Traceback (most recent call last):
        ...
    ValueError: Capacitor at index 2 has a negative value!
    """"""
    sum_c = 0.0
    for index, capacitor in enumerate(capacitors):
        if capacitor < 0:
            msg = f""Capacitor at index {index} has a negative value!""
            raise ValueError(msg)
        sum_c += capacitor
    return sum_c",data\repos\Python\electronics\capacitor_equivalence.py,capacitor_parallel,170
778,capacitor_equivalence.py::capacitor_series::26,"def capacitor_series(capacitors: list[float]) -> float:
    """"""
    Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)
    >>> capacitor_series([5.71389, 12, 3])
    1.6901062252507735
    >>> capacitor_series([5.71389, 12, -3])
    Traceback (most recent call last):
        ...
    ValueError: Capacitor at index 2 has a negative or zero value!
    >>> capacitor_series([5.71389, 12, 0.000])
    Traceback (most recent call last):
        ...
    ValueError: Capacitor at index 2 has a negative or zero value!
    """"""

    first_sum = 0.0
    for index, capacitor in enumerate(capacitors):
        if capacitor <= 0:
            msg = f""Capacitor at index {index} has a negative or zero value!""
            raise ValueError(msg)
        first_sum += 1 / capacitor
    return 1 / first_sum",data\repos\Python\electronics\capacitor_equivalence.py,capacitor_series,224
779,carrier_concentration.py::carrier_concentration::8,"def carrier_concentration(
    electron_conc: float,
    hole_conc: float,
    intrinsic_conc: float,
) -> tuple:
    """"""
    This function can calculate any one of the three -
    1. Electron Concentration
    2, Hole Concentration
    3. Intrinsic Concentration
    given the other two.
    Examples -
    >>> carrier_concentration(electron_conc=25, hole_conc=100, intrinsic_conc=0)
    ('intrinsic_conc', 50.0)
    >>> carrier_concentration(electron_conc=0, hole_conc=1600, intrinsic_conc=200)
    ('electron_conc', 25.0)
    >>> carrier_concentration(electron_conc=1000, hole_conc=0, intrinsic_conc=1200)
    ('hole_conc', 1440.0)
    >>> carrier_concentration(electron_conc=1000, hole_conc=400, intrinsic_conc=1200)
    Traceback (most recent call last):
        ...
    ValueError: You cannot supply more or less than 2 values
    >>> carrier_concentration(electron_conc=-1000, hole_conc=0, intrinsic_conc=1200)
    Traceback (most recent call last):
        ...
    ValueError: Electron concentration cannot be negative in a semiconductor
    >>> carrier_concentration(electron_conc=0, hole_conc=-400, intrinsic_conc=1200)
    Traceback (most recent call last):
        ...
    ValueError: Hole concentration cannot be negative in a semiconductor
    >>> carrier_concentration(electron_conc=0, hole_conc=400, intrinsic_conc=-1200)
    Traceback (most recent call last):
        ...
    ValueError: Intrinsic concentration cannot be negative in a semiconductor
    """"""
    if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:
        raise ValueError(""You cannot supply more or less than 2 values"")
    elif electron_conc < 0:
        raise ValueError(""Electron concentration cannot be negative in a semiconductor"")
    elif hole_conc < 0:
        raise ValueError(""Hole concentration cannot be negative in a semiconductor"")
    elif intrinsic_conc < 0:
        raise ValueError(
            ""Intrinsic concentration cannot be negative in a semiconductor""
        )
    elif electron_conc == 0:
        return (
            ""electron_conc"",
            intrinsic_conc**2 / hole_conc,
        )
    elif hole_conc == 0:
        return (
            ""hole_conc"",
            intrinsic_conc**2 / electron_conc,
        )
    elif intrinsic_conc == 0:
        return (
            ""intrinsic_conc"",
            (electron_conc * hole_conc) ** 0.5,
        )
    else:
        return (-1, -1)",data\repos\Python\electronics\carrier_concentration.py,carrier_concentration,607
780,charging_capacitor.py::charging_capacitor::21,"def charging_capacitor(
    source_voltage: float,  # voltage in volts.
    resistance: float,  # resistance in ohms.
    capacitance: float,  # capacitance in farads.
    time_sec: float,  # time in seconds after charging initiation of capacitor.
) -> float:
    """"""
    Find capacitor voltage at any nth second after initiating its charging.

    Examples
    --------
    >>> charging_capacitor(source_voltage=.2,resistance=.9,capacitance=8.4,time_sec=.5)
    0.013

    >>> charging_capacitor(source_voltage=2.2,resistance=3.5,capacitance=2.4,time_sec=9)
    1.446

    >>> charging_capacitor(source_voltage=15,resistance=200,capacitance=20,time_sec=2)
    0.007

    >>> charging_capacitor(20, 2000, 30*pow(10,-5), 4)
    19.975

    >>> charging_capacitor(source_voltage=0,resistance=10.0,capacitance=.30,time_sec=3)
    Traceback (most recent call last):
        ...
    ValueError: Source voltage must be positive.

    >>> charging_capacitor(source_voltage=20,resistance=-2000,capacitance=30,time_sec=4)
    Traceback (most recent call last):
        ...
    ValueError: Resistance must be positive.

    >>> charging_capacitor(source_voltage=30,resistance=1500,capacitance=0,time_sec=4)
    Traceback (most recent call last):
        ...
    ValueError: Capacitance must be positive.
    """"""

    if source_voltage <= 0:
        raise ValueError(""Source voltage must be positive."")
    if resistance <= 0:
        raise ValueError(""Resistance must be positive."")
    if capacitance <= 0:
        raise ValueError(""Capacitance must be positive."")
    return round(source_voltage * (1 - exp(-time_sec / (resistance * capacitance))), 3)",data\repos\Python\electronics\charging_capacitor.py,charging_capacitor,441
781,charging_inductor.py::charging_inductor::32,"def charging_inductor(
    source_voltage: float,  # source_voltage should be in volts.
    resistance: float,  # resistance should be in ohms.
    inductance: float,  # inductance should be in henrys.
    time: float,  # time should in seconds.
) -> float:
    """"""
    Find inductor current at any nth second after initiating its charging.

    Examples
    --------
    >>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2)
    2.817

    >>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2)
    1.543

    >>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2)
    0.016

    >>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12)
    Traceback (most recent call last):
        ...
    ValueError: Source voltage must be positive.

    >>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5)
    Traceback (most recent call last):
        ...
    ValueError: Resistance must be positive.

    >>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5)
    Traceback (most recent call last):
        ...
    ValueError: Inductance must be positive.

    >>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5)
    Traceback (most recent call last):
        ...
    ValueError: Source voltage must be positive.

    >>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5)
    Traceback (most recent call last):
        ...
    ValueError: Resistance must be positive.

    >>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5)
    Traceback (most recent call last):
        ...
    ValueError: Inductance must be positive.
    """"""

    if source_voltage <= 0:
        raise ValueError(""Source voltage must be positive."")
    if resistance <= 0:
        raise ValueError(""Resistance must be positive."")
    if inductance <= 0:
        raise ValueError(""Inductance must be positive."")
    return round(
        source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3
    )",data\repos\Python\electronics\charging_inductor.py,charging_inductor,531
782,circular_convolution.py::circular_convolution::34,"    def circular_convolution(self) -> list[float]:
        """"""
        This function performs the circular convolution of the first and second signal
        using matrix method

        Usage:
        >>> convolution = CircularConvolution()
        >>> convolution.circular_convolution()
        [10.0, 10.0, 6.0, 14.0]

        >>> convolution.first_signal = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]
        >>> convolution.second_signal = [0.1, 0.3, 0.5, 0.7, 0.9, 1.1, 1.3, 1.5]
        >>> convolution.circular_convolution()
        [5.2, 6.0, 6.48, 6.64, 6.48, 6.0, 5.2, 4.08]

        >>> convolution.first_signal = [-1, 1, 2, -2]
        >>> convolution.second_signal = [0.5, 1, -1, 2, 0.75]
        >>> convolution.circular_convolution()
        [6.25, -3.0, 1.5, -2.0, -2.75]

        >>> convolution.first_signal = [1, -1, 2, 3, -1]
        >>> convolution.second_signal = [1, 2, 3]
        >>> convolution.circular_convolution()
        [8.0, -2.0, 3.0, 4.0, 11.0]

        """"""

        length_first_signal = len(self.first_signal)
        length_second_signal = len(self.second_signal)

        max_length = max(length_first_signal, length_second_signal)

        # create a zero matrix of max_length x max_length
        matrix = [[0] * max_length for i in range(max_length)]

        # fills the smaller signal with zeros to make both signals of same length
        if length_first_signal < length_second_signal:
            self.first_signal += [0] * (max_length - length_first_signal)
        elif length_first_signal > length_second_signal:
            self.second_signal += [0] * (max_length - length_second_signal)

        """"""
        Fills the matrix in the following way assuming 'x' is the signal of length 4
        [
            [x[0], x[3], x[2], x[1]],
            [x[1], x[0], x[3], x[2]],
            [x[2], x[1], x[0], x[3]],
            [x[3], x[2], x[1], x[0]]
        ]
        """"""
        for i in range(max_length):
            rotated_signal = deque(self.second_signal)
            rotated_signal.rotate(i)
            for j, item in enumerate(rotated_signal):
                matrix[i][j] += item

        # multiply the matrix with the first signal
        final_signal = np.matmul(np.transpose(matrix), np.transpose(self.first_signal))

        # rounding-off to two decimal places
        return [float(round(i, 2)) for i in final_signal]",data\repos\Python\electronics\circular_convolution.py,circular_convolution,685
783,coulombs_law.py::couloumbs_law::8,"def couloumbs_law(
    force: float, charge1: float, charge2: float, distance: float
) -> dict[str, float]:
    """"""
    Apply Coulomb's Law on any three given values. These can be force, charge1,
    charge2, or distance, and then in a Python dict return name/value pair of
    the zero value.

    Coulomb's Law states that the magnitude of the electrostatic force of
    attraction or repulsion between two point charges is directly proportional
    to the product of the magnitudes of charges and inversely proportional to
    the square of the distance between them.

    Reference
    ----------
    Coulomb (1785) ""Premier mmoire sur l'lectricit et le magntisme,""
    Histoire de l'Acadmie Royale des Sciences, pp. 569-577.

    Parameters
    ----------
    force : float with units in Newtons

    charge1 : float with units in Coulombs

    charge2 : float with units in Coulombs

    distance : float with units in meters

    Returns
    -------
    result : dict name/value pair of the zero value

    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=2000)
    {'force': 33705.0}

    >>> couloumbs_law(force=10, charge1=3, charge2=5, distance=0)
    {'distance': 116112.01488218177}

    >>> couloumbs_law(force=10, charge1=0, charge2=5, distance=2000)
    {'charge1': 0.0008900756564307966}

    >>> couloumbs_law(force=0, charge1=0, charge2=5, distance=2000)
    Traceback (most recent call last):
      ...
    ValueError: One and only one argument must be 0

    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=-2000)
    Traceback (most recent call last):
      ...
    ValueError: Distance cannot be negative

    """"""

    charge_product = abs(charge1 * charge2)

    if (force, charge1, charge2, distance).count(0) != 1:
        raise ValueError(""One and only one argument must be 0"")
    if distance < 0:
        raise ValueError(""Distance cannot be negative"")
    if force == 0:
        force = COULOMBS_CONSTANT * charge_product / (distance**2)
        return {""force"": force}
    elif charge1 == 0:
        charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)
        return {""charge1"": charge1}
    elif charge2 == 0:
        charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)
        return {""charge2"": charge2}
    elif distance == 0:
        distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5
        return {""distance"": distance}
    raise ValueError(""Exactly one argument must be 0"")",data\repos\Python\electronics\coulombs_law.py,couloumbs_law,695
784,electrical_impedance.py::electrical_impedance::12,"def electrical_impedance(
    resistance: float, reactance: float, impedance: float
) -> dict[str, float]:
    """"""
    Apply Electrical Impedance formula, on any two given electrical values,
    which can be resistance, reactance, and impedance, and then in a Python dict
    return name/value pair of the zero value.

    >>> electrical_impedance(3,4,0)
    {'impedance': 5.0}
    >>> electrical_impedance(0,4,5)
    {'resistance': 3.0}
    >>> electrical_impedance(3,0,5)
    {'reactance': 4.0}
    >>> electrical_impedance(3,4,5)
    Traceback (most recent call last):
      ...
    ValueError: One and only one argument must be 0
    """"""
    if (resistance, reactance, impedance).count(0) != 1:
        raise ValueError(""One and only one argument must be 0"")
    if resistance == 0:
        return {""resistance"": sqrt(pow(impedance, 2) - pow(reactance, 2))}
    elif reactance == 0:
        return {""reactance"": sqrt(pow(impedance, 2) - pow(resistance, 2))}
    elif impedance == 0:
        return {""impedance"": sqrt(pow(resistance, 2) + pow(reactance, 2))}
    else:
        raise ValueError(""Exactly one argument must be 0"")",data\repos\Python\electronics\electrical_impedance.py,electrical_impedance,325
785,electric_conductivity.py::electric_conductivity::6,"def electric_conductivity(
    conductivity: float,
    electron_conc: float,
    mobility: float,
) -> tuple[str, float]:
    """"""
    This function can calculate any one of the three -
    1. Conductivity
    2. Electron Concentration
    3. Electron Mobility
    This is calculated from the other two provided values
    Examples -
    >>> electric_conductivity(conductivity=25, electron_conc=100, mobility=0)
    ('mobility', 1.5604519068722301e+18)
    >>> electric_conductivity(conductivity=0, electron_conc=1600, mobility=200)
    ('conductivity', 5.12672e-14)
    >>> electric_conductivity(conductivity=1000, electron_conc=0, mobility=1200)
    ('electron_conc', 5.201506356240767e+18)
    >>> electric_conductivity(conductivity=-10, electron_conc=100, mobility=0)
    Traceback (most recent call last):
        ...
    ValueError: Conductivity cannot be negative
    >>> electric_conductivity(conductivity=50, electron_conc=-10, mobility=0)
    Traceback (most recent call last):
        ...
    ValueError: Electron concentration cannot be negative
    >>> electric_conductivity(conductivity=50, electron_conc=0, mobility=-10)
    Traceback (most recent call last):
        ...
    ValueError: mobility cannot be negative
    >>> electric_conductivity(conductivity=50, electron_conc=0, mobility=0)
    Traceback (most recent call last):
        ...
    ValueError: You cannot supply more or less than 2 values
    >>> electric_conductivity(conductivity=50, electron_conc=200, mobility=300)
    Traceback (most recent call last):
        ...
    ValueError: You cannot supply more or less than 2 values
    """"""
    if (conductivity, electron_conc, mobility).count(0) != 1:
        raise ValueError(""You cannot supply more or less than 2 values"")
    elif conductivity < 0:
        raise ValueError(""Conductivity cannot be negative"")
    elif electron_conc < 0:
        raise ValueError(""Electron concentration cannot be negative"")
    elif mobility < 0:
        raise ValueError(""mobility cannot be negative"")
    elif conductivity == 0:
        return (
            ""conductivity"",
            mobility * electron_conc * ELECTRON_CHARGE,
        )
    elif electron_conc == 0:
        return (
            ""electron_conc"",
            conductivity / (mobility * ELECTRON_CHARGE),
        )
    else:
        return (
            ""mobility"",
            conductivity / (electron_conc * ELECTRON_CHARGE),
        )",data\repos\Python\electronics\electric_conductivity.py,electric_conductivity,596
786,electric_power.py::electric_power::12,"def electric_power(voltage: float, current: float, power: float) -> tuple:
    """"""
    This function can calculate any one of the three (voltage, current, power),
    fundamental value of electrical system.
    examples are below:
    >>> electric_power(voltage=0, current=2, power=5)
    Result(name='voltage', value=2.5)
    >>> electric_power(voltage=2, current=2, power=0)
    Result(name='power', value=4.0)
    >>> electric_power(voltage=-2, current=3, power=0)
    Result(name='power', value=6.0)
    >>> electric_power(voltage=2, current=4, power=2)
    Traceback (most recent call last):
        ...
    ValueError: Exactly one argument must be 0
    >>> electric_power(voltage=0, current=0, power=2)
    Traceback (most recent call last):
        ...
    ValueError: Exactly one argument must be 0
    >>> electric_power(voltage=0, current=2, power=-4)
    Traceback (most recent call last):
        ...
    ValueError: Power cannot be negative in any electrical/electronics system
    >>> electric_power(voltage=2.2, current=2.2, power=0)
    Result(name='power', value=4.84)
    >>> electric_power(current=0, power=6, voltage=2)
    Result(name='current', value=3.0)
    """"""
    if (voltage, current, power).count(0) != 1:
        raise ValueError(""Exactly one argument must be 0"")
    elif power < 0:
        raise ValueError(
            ""Power cannot be negative in any electrical/electronics system""
        )
    elif voltage == 0:
        return Result(""voltage"", power / current)
    elif current == 0:
        return Result(""current"", power / voltage)
    elif power == 0:
        return Result(""power"", float(round(abs(voltage * current), 2)))
    else:
        raise AssertionError",data\repos\Python\electronics\electric_power.py,electric_power,445
787,ic_555_timer.py::astable_frequency::26,"def astable_frequency(
    resistance_1: float, resistance_2: float, capacitance: float
) -> float:
    """"""
    Usage examples:
    >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=7)
    1523.8095238095239
    >>> astable_frequency(resistance_1=356, resistance_2=234, capacitance=976)
    1.7905459175553078
    >>> astable_frequency(resistance_1=2, resistance_2=-1, capacitance=2)
    Traceback (most recent call last):
        ...
    ValueError: All values must be positive
    >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=0)
    Traceback (most recent call last):
        ...
    ValueError: All values must be positive
    """"""

    if resistance_1 <= 0 or resistance_2 <= 0 or capacitance <= 0:
        raise ValueError(""All values must be positive"")
    return (1.44 / ((resistance_1 + 2 * resistance_2) * capacitance)) * 10**6",data\repos\Python\electronics\ic_555_timer.py,astable_frequency,250
788,ic_555_timer.py::astable_duty_cycle::50,"def astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:
    """"""
    Usage examples:
    >>> astable_duty_cycle(resistance_1=45, resistance_2=45)
    66.66666666666666
    >>> astable_duty_cycle(resistance_1=356, resistance_2=234)
    71.60194174757282
    >>> astable_duty_cycle(resistance_1=2, resistance_2=-1)
    Traceback (most recent call last):
        ...
    ValueError: All values must be positive
    >>> astable_duty_cycle(resistance_1=0, resistance_2=0)
    Traceback (most recent call last):
        ...
    ValueError: All values must be positive
    """"""

    if resistance_1 <= 0 or resistance_2 <= 0:
        raise ValueError(""All values must be positive"")
    return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100",data\repos\Python\electronics\ic_555_timer.py,astable_duty_cycle,225
789,ind_reactance.py::ind_reactance::7,"def ind_reactance(
    inductance: float, frequency: float, reactance: float
) -> dict[str, float]:
    """"""
    Calculate inductive reactance, frequency or inductance from two given electrical
    properties then return name/value pair of the zero value in a Python dict.

    Parameters
    ----------
    inductance : float with units in Henries

    frequency : float with units in Hertz

    reactance : float with units in Ohms

    >>> ind_reactance(-35e-6, 1e3, 0)
    Traceback (most recent call last):
        ...
    ValueError: Inductance cannot be negative

    >>> ind_reactance(35e-6, -1e3, 0)
    Traceback (most recent call last):
        ...
    ValueError: Frequency cannot be negative

    >>> ind_reactance(35e-6, 0, -1)
    Traceback (most recent call last):
        ...
    ValueError: Inductive reactance cannot be negative

    >>> ind_reactance(0, 10e3, 50)
    {'inductance': 0.0007957747154594767}

    >>> ind_reactance(35e-3, 0, 50)
    {'frequency': 227.36420441699332}

    >>> ind_reactance(35e-6, 1e3, 0)
    {'reactance': 0.2199114857512855}

    """"""

    if (inductance, frequency, reactance).count(0) != 1:
        raise ValueError(""One and only one argument must be 0"")
    if inductance < 0:
        raise ValueError(""Inductance cannot be negative"")
    if frequency < 0:
        raise ValueError(""Frequency cannot be negative"")
    if reactance < 0:
        raise ValueError(""Inductive reactance cannot be negative"")
    if inductance == 0:
        return {""inductance"": reactance / (2 * pi * frequency)}
    elif frequency == 0:
        return {""frequency"": reactance / (2 * pi * inductance)}
    elif reactance == 0:
        return {""reactance"": 2 * pi * frequency * inductance}
    else:
        raise ValueError(""Exactly one argument must be 0"")",data\repos\Python\electronics\ind_reactance.py,ind_reactance,504
790,ohms_law.py::ohms_law::5,"def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:
    """"""
    Apply Ohm's Law, on any two given electrical values, which can be voltage, current,
    and resistance, and then in a Python dict return name/value pair of the zero value.

    >>> ohms_law(voltage=10, resistance=5, current=0)
    {'current': 2.0}
    >>> ohms_law(voltage=0, current=0, resistance=10)
    Traceback (most recent call last):
      ...
    ValueError: One and only one argument must be 0
    >>> ohms_law(voltage=0, current=1, resistance=-2)
    Traceback (most recent call last):
      ...
    ValueError: Resistance cannot be negative
    >>> ohms_law(resistance=0, voltage=-10, current=1)
    {'resistance': -10.0}
    >>> ohms_law(voltage=0, current=-1.5, resistance=2)
    {'voltage': -3.0}
    """"""
    if (voltage, current, resistance).count(0) != 1:
        raise ValueError(""One and only one argument must be 0"")
    if resistance < 0:
        raise ValueError(""Resistance cannot be negative"")
    if voltage == 0:
        return {""voltage"": float(current * resistance)}
    elif current == 0:
        return {""current"": voltage / resistance}
    elif resistance == 0:
        return {""resistance"": voltage / current}
    else:
        raise ValueError(""Exactly one argument must be 0"")",data\repos\Python\electronics\ohms_law.py,ohms_law,351
791,real_and_reactive_power.py::real_power::4,"def real_power(apparent_power: float, power_factor: float) -> float:
    """"""
    Calculate real power from apparent power and power factor.

    Examples:
    >>> real_power(100, 0.9)
    90.0
    >>> real_power(0, 0.8)
    0.0
    >>> real_power(100, -0.9)
    -90.0
    """"""
    if (
        not isinstance(power_factor, (int, float))
        or power_factor < -1
        or power_factor > 1
    ):
        raise ValueError(""power_factor must be a valid float value between -1 and 1."")
    return apparent_power * power_factor",data\repos\Python\electronics\real_and_reactive_power.py,real_power,147
792,real_and_reactive_power.py::reactive_power::25,"def reactive_power(apparent_power: float, power_factor: float) -> float:
    """"""
    Calculate reactive power from apparent power and power factor.

    Examples:
    >>> reactive_power(100, 0.9)
    43.58898943540673
    >>> reactive_power(0, 0.8)
    0.0
    >>> reactive_power(100, -0.9)
    43.58898943540673
    """"""
    if (
        not isinstance(power_factor, (int, float))
        or power_factor < -1
        or power_factor > 1
    ):
        raise ValueError(""power_factor must be a valid float value between -1 and 1."")
    return apparent_power * math.sqrt(1 - power_factor**2)",data\repos\Python\electronics\real_and_reactive_power.py,reactive_power,163
793,resistor_color_code.py::get_significant_digits::138,"def get_significant_digits(colors: list) -> str:
    """"""
    Function returns the digit associated with the color. Function takes a
    list containing colors as input and returns digits as string

    >>> get_significant_digits(['Black','Blue'])
    '06'

    >>> get_significant_digits(['Aqua','Blue'])
    Traceback (most recent call last):
      ...
    ValueError: Aqua is not a valid color for significant figure bands

    """"""
    digit = """"
    for color in colors:
        if color not in significant_figures_color_values:
            msg = f""{color} is not a valid color for significant figure bands""
            raise ValueError(msg)
        digit = digit + str(significant_figures_color_values[color])
    return str(digit)",data\repos\Python\electronics\resistor_color_code.py,get_significant_digits,157
794,resistor_color_code.py::get_multiplier::161,"def get_multiplier(color: str) -> float:
    """"""
    Function returns the multiplier value associated with the color.
    Function takes color as input and returns multiplier value

    >>> get_multiplier('Gold')
    0.1

    >>> get_multiplier('Ivory')
    Traceback (most recent call last):
      ...
    ValueError: Ivory is not a valid color for multiplier band

    """"""
    if color not in multiplier_color_values:
        msg = f""{color} is not a valid color for multiplier band""
        raise ValueError(msg)
    return multiplier_color_values[color]",data\repos\Python\electronics\resistor_color_code.py,get_multiplier,119
795,resistor_color_code.py::get_tolerance::181,"def get_tolerance(color: str) -> float:
    """"""
    Function returns the tolerance value associated with the color.
    Function takes color as input and returns tolerance value.

    >>> get_tolerance('Green')
    0.5

    >>> get_tolerance('Indigo')
    Traceback (most recent call last):
      ...
    ValueError: Indigo is not a valid color for tolerance band

    """"""
    if color not in tolerance_color_values:
        msg = f""{color} is not a valid color for tolerance band""
        raise ValueError(msg)
    return tolerance_color_values[color]",data\repos\Python\electronics\resistor_color_code.py,get_tolerance,119
796,resistor_color_code.py::get_temperature_coeffecient::201,"def get_temperature_coeffecient(color: str) -> int:
    """"""
    Function returns the temperature coeffecient value associated with the color.
    Function takes color as input and returns temperature coeffecient value.

    >>> get_temperature_coeffecient('Yellow')
    25

    >>> get_temperature_coeffecient('Cyan')
    Traceback (most recent call last):
      ...
    ValueError: Cyan is not a valid color for temperature coeffecient band

    """"""
    if color not in temperature_coeffecient_color_values:
        msg = f""{color} is not a valid color for temperature coeffecient band""
        raise ValueError(msg)
    return temperature_coeffecient_color_values[color]",data\repos\Python\electronics\resistor_color_code.py,get_temperature_coeffecient,143
797,resistor_color_code.py::get_band_type_count::221,"def get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:
    """"""
    Function returns the number of bands of a given type in a resistor with n bands
    Function takes total_number_of_bands and type_of_band as input and returns
    number of bands belonging to that type in the given resistor

    >>> get_band_type_count(3,'significant')
    2

    >>> get_band_type_count(2,'significant')
    Traceback (most recent call last):
      ...
    ValueError: 2 is not a valid number of bands

    >>> get_band_type_count(3,'sign')
    Traceback (most recent call last):
      ...
    ValueError: sign is not valid for a 3 band resistor

    >>> get_band_type_count(3,'tolerance')
    Traceback (most recent call last):
      ...
    ValueError: tolerance is not valid for a 3 band resistor

    >>> get_band_type_count(5,'temp_coeffecient')
    Traceback (most recent call last):
      ...
    ValueError: temp_coeffecient is not valid for a 5 band resistor

    """"""
    if total_number_of_bands not in band_types:
        msg = f""{total_number_of_bands} is not a valid number of bands""
        raise ValueError(msg)
    if type_of_band not in band_types[total_number_of_bands]:
        msg = f""{type_of_band} is not valid for a {total_number_of_bands} band resistor""
        raise ValueError(msg)
    return band_types[total_number_of_bands][type_of_band]",data\repos\Python\electronics\resistor_color_code.py,get_band_type_count,336
798,resistor_color_code.py::check_validity::260,"def check_validity(number_of_bands: int, colors: list) -> bool:
    """"""
    Function checks if the input provided is valid or not.
    Function takes number_of_bands and colors as input and returns
    True if it is valid

    >>> check_validity(3, [""Black"",""Blue"",""Orange""])
    True

    >>> check_validity(4, [""Black"",""Blue"",""Orange""])
    Traceback (most recent call last):
      ...
    ValueError: Expecting 4 colors, provided 3 colors

    >>> check_validity(3, [""Cyan"",""Red"",""Yellow""])
    Traceback (most recent call last):
      ...
    ValueError: Cyan is not a valid color

    """"""
    if number_of_bands >= 3 and number_of_bands <= 6:
        if number_of_bands == len(colors):
            for color in colors:
                if color not in valid_colors:
                    msg = f""{color} is not a valid color""
                    raise ValueError(msg)
            return True
        else:
            msg = f""Expecting {number_of_bands} colors, provided {len(colors)} colors""
            raise ValueError(msg)
    else:
        msg = ""Invalid number of bands. Resistor bands must be 3 to 6""
        raise ValueError(msg)",data\repos\Python\electronics\resistor_color_code.py,check_validity,272
799,resistor_color_code.py::calculate_resistance::295,"def calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:
    """"""
    Function calculates the total resistance of the resistor using the color codes.
    Function takes number_of_bands, color_code_list as input and returns
    resistance

    >>> calculate_resistance(3, [""Black"",""Blue"",""Orange""])
    {'resistance': '6000 20% '}

    >>> calculate_resistance(4, [""Orange"",""Green"",""Blue"",""Gold""])
    {'resistance': '35000000 5% '}

    >>> calculate_resistance(5, [""Violet"",""Brown"",""Grey"",""Silver"",""Green""])
    {'resistance': '7.18 0.5% '}

    >>> calculate_resistance(6, [""Red"",""Green"",""Blue"",""Yellow"",""Orange"",""Grey""])
    {'resistance': '2560000 0.05% 1 ppm/K'}

    >>> calculate_resistance(0, [""Violet"",""Brown"",""Grey"",""Silver"",""Green""])
    Traceback (most recent call last):
      ...
    ValueError: Invalid number of bands. Resistor bands must be 3 to 6

    >>> calculate_resistance(4, [""Violet"",""Brown"",""Grey"",""Silver"",""Green""])
    Traceback (most recent call last):
      ...
    ValueError: Expecting 4 colors, provided 5 colors

    >>> calculate_resistance(4, [""Violet"",""Silver"",""Brown"",""Grey""])
    Traceback (most recent call last):
      ...
    ValueError: Silver is not a valid color for significant figure bands

    >>> calculate_resistance(4, [""Violet"",""Blue"",""Lime"",""Grey""])
    Traceback (most recent call last):
      ...
    ValueError: Lime is not a valid color

    """"""
    is_valid = check_validity(number_of_bands, color_code_list)
    if is_valid:
        number_of_significant_bands = get_band_type_count(
            number_of_bands, ""significant""
        )
        significant_colors = color_code_list[:number_of_significant_bands]
        significant_digits = int(get_significant_digits(significant_colors))
        multiplier_color = color_code_list[number_of_significant_bands]
        multiplier = get_multiplier(multiplier_color)
        if number_of_bands == 3:
            tolerance_color = None
        else:
            tolerance_color = color_code_list[number_of_significant_bands + 1]
        tolerance = (
            20 if tolerance_color is None else get_tolerance(str(tolerance_color))
        )
        if number_of_bands != 6:
            temperature_coeffecient_color = None
        else:
            temperature_coeffecient_color = color_code_list[
                number_of_significant_bands + 2
            ]
        temperature_coeffecient = (
            0
            if temperature_coeffecient_color is None
            else get_temperature_coeffecient(str(temperature_coeffecient_color))
        )
        resisitance = significant_digits * multiplier
        if temperature_coeffecient == 0:
            answer = f""{resisitance} {tolerance}% ""
        else:
            answer = f""{resisitance} {tolerance}% {temperature_coeffecient} ppm/K""
        return {""resistance"": answer}
    else:
        raise ValueError(""Input is invalid"")",data\repos\Python\electronics\resistor_color_code.py,calculate_resistance,706
800,resistor_equivalence.py::resistor_parallel::6,"def resistor_parallel(resistors: list[float]) -> float:
    """"""
    Req = 1/ (1/R1 + 1/R2 + ... + 1/Rn)

    >>> resistor_parallel([3.21389, 2, 3])
    0.8737571620498019
    >>> resistor_parallel([3.21389, 2, -3])
    Traceback (most recent call last):
        ...
    ValueError: Resistor at index 2 has a negative or zero value!
    >>> resistor_parallel([3.21389, 2, 0.000])
    Traceback (most recent call last):
        ...
    ValueError: Resistor at index 2 has a negative or zero value!
    """"""

    first_sum = 0.00
    for index, resistor in enumerate(resistors):
        if resistor <= 0:
            msg = f""Resistor at index {index} has a negative or zero value!""
            raise ValueError(msg)
        first_sum += 1 / float(resistor)
    return 1 / first_sum",data\repos\Python\electronics\resistor_equivalence.py,resistor_parallel,224
801,resistor_equivalence.py::resistor_series::31,"def resistor_series(resistors: list[float]) -> float:
    """"""
    Req = R1 + R2 + ... + Rn

    Calculate the equivalent resistance for any number of resistors in parallel.

    >>> resistor_series([3.21389, 2, 3])
    8.21389
    >>> resistor_series([3.21389, 2, -3])
    Traceback (most recent call last):
        ...
    ValueError: Resistor at index 2 has a negative value!
    """"""
    sum_r = 0.00
    for index, resistor in enumerate(resistors):
        sum_r += resistor
        if resistor < 0:
            msg = f""Resistor at index {index} has a negative value!""
            raise ValueError(msg)
    return sum_r",data\repos\Python\electronics\resistor_equivalence.py,resistor_series,168
802,resonant_frequency.py::resonant_frequency::16,"def resonant_frequency(inductance: float, capacitance: float) -> tuple:
    """"""
    This function can calculate the resonant frequency of LC circuit,
    for the given value of inductance and capacitnace.

    Examples are given below:
    >>> resonant_frequency(inductance=10, capacitance=5)
    ('Resonant frequency', 0.022507907903927652)
    >>> resonant_frequency(inductance=0, capacitance=5)
    Traceback (most recent call last):
      ...
    ValueError: Inductance cannot be 0 or negative
    >>> resonant_frequency(inductance=10, capacitance=0)
    Traceback (most recent call last):
      ...
    ValueError: Capacitance cannot be 0 or negative
    """"""

    if inductance <= 0:
        raise ValueError(""Inductance cannot be 0 or negative"")

    elif capacitance <= 0:
        raise ValueError(""Capacitance cannot be 0 or negative"")

    else:
        return (
            ""Resonant frequency"",
            float(1 / (2 * pi * (sqrt(inductance * capacitance)))),
        )",data\repos\Python\electronics\resonant_frequency.py,resonant_frequency,249
803,wheatstone_bridge.py::wheatstone_solver::5,"def wheatstone_solver(
    resistance_1: float, resistance_2: float, resistance_3: float
) -> float:
    """"""
    This function can calculate the unknown resistance in an wheatstone network,
    given that the three other resistances in the network are known.
    The formula to calculate the same is:

    ---------------
    |Rx=(R2/R1)*R3|
    ---------------

    Usage examples:
    >>> wheatstone_solver(resistance_1=2, resistance_2=4, resistance_3=5)
    10.0
    >>> wheatstone_solver(resistance_1=356, resistance_2=234, resistance_3=976)
    641.5280898876405
    >>> wheatstone_solver(resistance_1=2, resistance_2=-1, resistance_3=2)
    Traceback (most recent call last):
        ...
    ValueError: All resistance values must be positive
    >>> wheatstone_solver(resistance_1=0, resistance_2=0, resistance_3=2)
    Traceback (most recent call last):
        ...
    ValueError: All resistance values must be positive
    """"""

    if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:
        raise ValueError(""All resistance values must be positive"")
    else:
        return float((resistance_2 / resistance_1) * resistance_3)",data\repos\Python\electronics\wheatstone_bridge.py,wheatstone_solver,300
804,receive_file.py::main::4,"def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    host = socket.gethostname()
    port = 12312

    sock.connect((host, port))
    sock.send(b""Hello server!"")

    with open(""Received_file"", ""wb"") as out_file:
        print(""File opened"")
        print(""Receiving data..."")
        while True:
            data = sock.recv(1024)
            if not data:
                break
            out_file.write(data)

    print(""Successfully received the file"")
    sock.close()
    print(""Connection closed"")",data\repos\Python\file_transfer\receive_file.py,main,118
805,send_file.py::send_file::1,"def send_file(filename: str = ""mytext.txt"", testing: bool = False) -> None:
    import socket

    port = 12312  # Reserve a port for your service.
    sock = socket.socket()  # Create a socket object
    host = socket.gethostname()  # Get local machine name
    sock.bind((host, port))  # Bind to the port
    sock.listen(5)  # Now wait for client connection.

    print(""Server listening...."")

    while True:
        conn, addr = sock.accept()  # Establish connection with client.
        print(f""Got connection from {addr}"")
        data = conn.recv(1024)
        print(f""Server received: {data = }"")

        with open(filename, ""rb"") as in_file:
            data = in_file.read(1024)
            while data:
                conn.send(data)
                print(f""Sent {data!r}"")
                data = in_file.read(1024)

        print(""Done sending"")
        conn.close()
        if testing:  # Allow the test to complete
            break

    sock.shutdown(1)
    sock.close()",data\repos\Python\file_transfer\send_file.py,send_file,239
806,equated_monthly_installments.py::equated_monthly_installments::11,"def equated_monthly_installments(
    principal: float, rate_per_annum: float, years_to_repay: int
) -> float:
    """"""
    Formula for amortization amount per month:
    A = p * r * (1 + r)^n / ((1 + r)^n - 1)
    where p is the principal, r is the rate of interest per month
    and n is the number of payments

    >>> equated_monthly_installments(25000, 0.12, 3)
    830.3577453212793
    >>> equated_monthly_installments(25000, 0.12, 10)
    358.67737100646826
    >>> equated_monthly_installments(0, 0.12, 3)
    Traceback (most recent call last):
        ...
    Exception: Principal borrowed must be > 0
    >>> equated_monthly_installments(25000, -1, 3)
    Traceback (most recent call last):
        ...
    Exception: Rate of interest must be >= 0
    >>> equated_monthly_installments(25000, 0.12, 0)
    Traceback (most recent call last):
        ...
    Exception: Years to repay must be an integer > 0
    """"""
    if principal <= 0:
        raise Exception(""Principal borrowed must be > 0"")
    if rate_per_annum < 0:
        raise Exception(""Rate of interest must be >= 0"")
    if years_to_repay <= 0 or not isinstance(years_to_repay, int):
        raise Exception(""Years to repay must be an integer > 0"")

    # Yearly rate is divided by 12 to get monthly rate
    rate_per_month = rate_per_annum / 12

    # Years to repay is multiplied by 12 to get number of payments as payment is monthly
    number_of_payments = years_to_repay * 12

    return (
        principal
        * rate_per_month
        * (1 + rate_per_month) ** number_of_payments
        / ((1 + rate_per_month) ** number_of_payments - 1)
    )",data\repos\Python\financial\equated_monthly_installments.py,equated_monthly_installments,463
807,exponential_moving_average.py::exponential_moving_average::15,"def exponential_moving_average(
    stock_prices: Iterator[float], window_size: int
) -> Iterator[float]:
    """"""
    Yields exponential moving averages of the given stock prices.
    >>> tuple(exponential_moving_average(iter([2, 5, 3, 8.2, 6, 9, 10]), 3))
    (2, 3.5, 3.25, 5.725, 5.8625, 7.43125, 8.715625)

    :param stock_prices: A stream of stock prices
    :param window_size: The number of stock prices that will trigger a new calculation
                        of the exponential average (window_size > 0)
    :return: Yields a sequence of exponential moving averages

    Formula:

    st = alpha * xt + (1 - alpha) * st_prev

    Where,
    st : Exponential moving average at timestamp t
    xt : stock price in from the stock prices at timestamp t
    st_prev : Exponential moving average at timestamp t-1
    alpha : 2/(1 + window_size) - smoothing factor

    Exponential moving average (EMA) is a rule of thumb technique for
    smoothing time series data using an exponential window function.
    """"""

    if window_size <= 0:
        raise ValueError(""window_size must be > 0"")

    # Calculating smoothing factor
    alpha = 2 / (1 + window_size)

    # Exponential average at timestamp t
    moving_average = 0.0

    for i, stock_price in enumerate(stock_prices):
        if i <= window_size:
            # Assigning simple moving average till the window_size for the first time
            # is reached
            moving_average = (moving_average + stock_price) * 0.5 if i else stock_price
        else:
            # Calculating exponential moving average based on current timestamp data
            # point and previous exponential average value
            moving_average = (alpha * stock_price) + ((1 - alpha) * moving_average)
        yield moving_average",data\repos\Python\financial\exponential_moving_average.py,exponential_moving_average,436
808,interest.py::simple_interest::6,"def simple_interest(
    principal: float, daily_interest_rate: float, days_between_payments: float
) -> float:
    """"""
    >>> simple_interest(18000.0, 0.06, 3)
    3240.0
    >>> simple_interest(0.5, 0.06, 3)
    0.09
    >>> simple_interest(18000.0, 0.01, 10)
    1800.0
    >>> simple_interest(18000.0, 0.0, 3)
    0.0
    >>> simple_interest(5500.0, 0.01, 100)
    5500.0
    >>> simple_interest(10000.0, -0.06, 3)
    Traceback (most recent call last):
        ...
    ValueError: daily_interest_rate must be >= 0
    >>> simple_interest(-10000.0, 0.06, 3)
    Traceback (most recent call last):
        ...
    ValueError: principal must be > 0
    >>> simple_interest(5500.0, 0.01, -5)
    Traceback (most recent call last):
        ...
    ValueError: days_between_payments must be > 0
    """"""
    if days_between_payments <= 0:
        raise ValueError(""days_between_payments must be > 0"")
    if daily_interest_rate < 0:
        raise ValueError(""daily_interest_rate must be >= 0"")
    if principal <= 0:
        raise ValueError(""principal must be > 0"")
    return principal * daily_interest_rate * days_between_payments",data\repos\Python\financial\interest.py,simple_interest,345
809,interest.py::compound_interest::42,"def compound_interest(
    principal: float,
    nominal_annual_interest_rate_percentage: float,
    number_of_compounding_periods: float,
) -> float:
    """"""
    >>> compound_interest(10000.0, 0.05, 3)
    1576.2500000000014
    >>> compound_interest(10000.0, 0.05, 1)
    500.00000000000045
    >>> compound_interest(0.5, 0.05, 3)
    0.07881250000000006
    >>> compound_interest(10000.0, 0.06, -4)
    Traceback (most recent call last):
        ...
    ValueError: number_of_compounding_periods must be > 0
    >>> compound_interest(10000.0, -3.5, 3.0)
    Traceback (most recent call last):
        ...
    ValueError: nominal_annual_interest_rate_percentage must be >= 0
    >>> compound_interest(-5500.0, 0.01, 5)
    Traceback (most recent call last):
        ...
    ValueError: principal must be > 0
    """"""
    if number_of_compounding_periods <= 0:
        raise ValueError(""number_of_compounding_periods must be > 0"")
    if nominal_annual_interest_rate_percentage < 0:
        raise ValueError(""nominal_annual_interest_rate_percentage must be >= 0"")
    if principal <= 0:
        raise ValueError(""principal must be > 0"")

    return principal * (
        (1 + nominal_annual_interest_rate_percentage) ** number_of_compounding_periods
        - 1
    )",data\repos\Python\financial\interest.py,compound_interest,352
810,interest.py::apr_interest::80,"def apr_interest(
    principal: float,
    nominal_annual_percentage_rate: float,
    number_of_years: float,
) -> float:
    """"""
    >>> apr_interest(10000.0, 0.05, 3)
    1618.223072263547
    >>> apr_interest(10000.0, 0.05, 1)
    512.6749646744732
    >>> apr_interest(0.5, 0.05, 3)
    0.08091115361317736
    >>> apr_interest(10000.0, 0.06, -4)
    Traceback (most recent call last):
        ...
    ValueError: number_of_years must be > 0
    >>> apr_interest(10000.0, -3.5, 3.0)
    Traceback (most recent call last):
        ...
    ValueError: nominal_annual_percentage_rate must be >= 0
    >>> apr_interest(-5500.0, 0.01, 5)
    Traceback (most recent call last):
        ...
    ValueError: principal must be > 0
    """"""
    if number_of_years <= 0:
        raise ValueError(""number_of_years must be > 0"")
    if nominal_annual_percentage_rate < 0:
        raise ValueError(""nominal_annual_percentage_rate must be >= 0"")
    if principal <= 0:
        raise ValueError(""principal must be > 0"")

    return compound_interest(
        principal, nominal_annual_percentage_rate / 365, number_of_years * 365
    )",data\repos\Python\financial\interest.py,apr_interest,335
811,present_value.py::present_value::12,"def present_value(discount_rate: float, cash_flows: list[float]) -> float:
    """"""
    >>> present_value(0.13, [10, 20.70, -293, 297])
    4.69
    >>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])
    -42739.63
    >>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])
    175519.15
    >>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])
    Traceback (most recent call last):
        ...
    ValueError: Discount rate cannot be negative
    >>> present_value(0.03, [])
    Traceback (most recent call last):
        ...
    ValueError: Cash flows list cannot be empty
    """"""
    if discount_rate < 0:
        raise ValueError(""Discount rate cannot be negative"")
    if not cash_flows:
        raise ValueError(""Cash flows list cannot be empty"")
    present_value = sum(
        cash_flow / ((1 + discount_rate) ** i) for i, cash_flow in enumerate(cash_flows)
    )
    return round(present_value, ndigits=2)",data\repos\Python\financial\present_value.py,present_value,295
812,price_plus_tax.py::price_plus_tax::6,"def price_plus_tax(price: float, tax_rate: float) -> float:
    """"""
    >>> price_plus_tax(100, 0.25)
    125.0
    >>> price_plus_tax(125.50, 0.05)
    131.775
    """"""
    return price * (1 + tax_rate)",data\repos\Python\financial\price_plus_tax.py,price_plus_tax,70
813,simple_moving_average.py::simple_moving_average::13,"def simple_moving_average(
    data: Sequence[float], window_size: int
) -> list[float | None]:
    """"""
    Calculate the simple moving average (SMA) for some given time series data.

    :param data: A list of numerical data points.
    :param window_size: An integer representing the size of the SMA window.
    :return: A list of SMA values with the same length as the input data.

    Examples:
    >>> sma = simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 3)
    >>> [round(value, 2) if value is not None else None for value in sma]
    [None, None, 12.33, 13.33, 14.0, 14.33, 16.0, 17.0, 18.0, 19.0]
    >>> simple_moving_average([10, 12, 15], 5)
    [None, None, None]
    >>> simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 0)
    Traceback (most recent call last):
    ...
    ValueError: Window size must be a positive integer
    """"""
    if window_size < 1:
        raise ValueError(""Window size must be a positive integer"")

    sma: list[float | None] = []

    for i in range(len(data)):
        if i < window_size - 1:
            sma.append(None)  # SMA not available for early data points
        else:
            window = data[i - window_size + 1 : i + 1]
            sma_value = sum(window) / window_size
            sma.append(sma_value)
    return sma",data\repos\Python\financial\simple_moving_average.py,simple_moving_average,400
814,straight_line_depreciation.py::straight_line_depreciation::32,"def straight_line_depreciation(
    useful_years: int,
    purchase_value: float,
    residual_value: float = 0.0,
) -> list[float]:
    """"""
    Calculate the depreciation expenses over the given period
    :param useful_years: Number of years the asset will be used
    :param purchase_value: Purchase expenditure for the asset
    :param residual_value: Residual value of the asset at the end of its useful life
    :return: A list of annual depreciation expenses over the asset's useful life
    >>> straight_line_depreciation(10, 1100.0, 100.0)
    [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]
    >>> straight_line_depreciation(6, 1250.0, 50.0)
    [200.0, 200.0, 200.0, 200.0, 200.0, 200.0]
    >>> straight_line_depreciation(4, 1001.0)
    [250.25, 250.25, 250.25, 250.25]
    >>> straight_line_depreciation(11, 380.0, 50.0)
    [30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0]
    >>> straight_line_depreciation(1, 4985, 100)
    [4885.0]
    """"""

    if not isinstance(useful_years, int):
        raise TypeError(""Useful years must be an integer"")

    if useful_years < 1:
        raise ValueError(""Useful years cannot be less than 1"")

    if not isinstance(purchase_value, (float, int)):
        raise TypeError(""Purchase value must be numeric"")

    if not isinstance(residual_value, (float, int)):
        raise TypeError(""Residual value must be numeric"")

    if purchase_value < 0.0:
        raise ValueError(""Purchase value cannot be less than zero"")

    if purchase_value < residual_value:
        raise ValueError(""Purchase value cannot be less than residual value"")

    # Calculate annual depreciation expense
    depreciable_cost = purchase_value - residual_value
    annual_depreciation_expense = depreciable_cost / useful_years

    # List of annual depreciation expenses
    list_of_depreciation_expenses = []
    accumulated_depreciation_expense = 0.0
    for period in range(useful_years):
        if period != useful_years - 1:
            accumulated_depreciation_expense += annual_depreciation_expense
            list_of_depreciation_expenses.append(annual_depreciation_expense)
        else:
            depreciation_expense_in_end_year = (
                depreciable_cost - accumulated_depreciation_expense
            )
            list_of_depreciation_expenses.append(depreciation_expense_in_end_year)

    return list_of_depreciation_expenses",data\repos\Python\financial\straight_line_depreciation.py,straight_line_depreciation,679
815,time_and_half_pay.py::pay::6,"def pay(hours_worked: float, pay_rate: float, hours: float = 40) -> float:
    """"""
    hours_worked = The total hours worked
    pay_rate = Amount of money per hour
    hours = Number of hours that must be worked before you receive time and a half

    >>> pay(41, 1)
    41.5
    >>> pay(65, 19)
    1472.5
    >>> pay(10, 1)
    10.0
    """"""
    # Check that all input parameters are float or integer
    assert isinstance(hours_worked, (float, int)), (
        ""Parameter 'hours_worked' must be of type 'int' or 'float'""
    )
    assert isinstance(pay_rate, (float, int)), (
        ""Parameter 'pay_rate' must be of type 'int' or 'float'""
    )
    assert isinstance(hours, (float, int)), (
        ""Parameter 'hours' must be of type 'int' or 'float'""
    )

    normal_pay = hours_worked * pay_rate
    over_time = max(0, hours_worked - hours)
    over_time_pay = over_time * pay_rate / 2
    return normal_pay + over_time_pay",data\repos\Python\financial\time_and_half_pay.py,pay,267
816,julia_sets.py::eval_exponential::40,"def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:
    """"""
    Evaluate $e^z + c$.
    >>> float(eval_exponential(0, 0))
    1.0
    >>> bool(abs(eval_exponential(1, np.pi*1.j)) < 1e-15)
    True
    >>> bool(abs(eval_exponential(1.j, 0)-1-1.j) < 1e-15)
    True
    """"""
    return np.exp(z_values) + c_parameter",data\repos\Python\fractals\julia_sets.py,eval_exponential,116
817,julia_sets.py::eval_quadratic_polynomial::53,"def eval_quadratic_polynomial(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:
    """"""
    >>> eval_quadratic_polynomial(0, 2)
    4
    >>> eval_quadratic_polynomial(-1, 1)
    0
    >>> round(eval_quadratic_polynomial(1.j, 0).imag)
    1
    >>> round(eval_quadratic_polynomial(1.j, 0).real)
    0
    """"""
    return z_values * z_values + c_parameter",data\repos\Python\fractals\julia_sets.py,eval_quadratic_polynomial,111
818,julia_sets.py::prepare_grid::67,"def prepare_grid(window_size: float, nb_pixels: int) -> np.ndarray:
    """"""
    Create a grid of complex values of size nb_pixels*nb_pixels with real and
     imaginary parts ranging from -window_size to window_size (inclusive).
    Returns a numpy array.

    >>> prepare_grid(1,3)
    array([[-1.-1.j, -1.+0.j, -1.+1.j],
           [ 0.-1.j,  0.+0.j,  0.+1.j],
           [ 1.-1.j,  1.+0.j,  1.+1.j]])
    """"""
    x = np.linspace(-window_size, window_size, nb_pixels)
    x = x.reshape((nb_pixels, 1))
    y = np.linspace(-window_size, window_size, nb_pixels)
    y = y.reshape((1, nb_pixels))
    return x + 1.0j * y",data\repos\Python\fractals\julia_sets.py,prepare_grid,197
819,julia_sets.py::iterate_function::85,"def iterate_function(
    eval_function: Callable[[Any, np.ndarray], np.ndarray],
    function_params: Any,
    nb_iterations: int,
    z_0: np.ndarray,
    infinity: float | None = None,
) -> np.ndarray:
    """"""
    Iterate the function ""eval_function"" exactly nb_iterations times.
    The first argument of the function is a parameter which is contained in
    function_params. The variable z_0 is an array that contains the initial
    values to iterate from.
    This function returns the final iterates.

    >>> iterate_function(eval_quadratic_polynomial, 0, 3, np.array([0,1,2])).shape
    (3,)
    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,
    ... 0,
    ... 3,
    ... np.array([0,1,2]))[0]))
    0j
    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,
    ... 0,
    ... 3,
    ... np.array([0,1,2]))[1]))
    (1+0j)
    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,
    ... 0,
    ... 3,
    ... np.array([0,1,2]))[2]))
    (256+0j)
    """"""

    z_n = z_0.astype(""complex64"")
    for _ in range(nb_iterations):
        z_n = eval_function(function_params, z_n)
        if infinity is not None:
            np.nan_to_num(z_n, copy=False, nan=infinity)
            z_n[abs(z_n) == np.inf] = infinity
    return z_n",data\repos\Python\fractals\julia_sets.py,iterate_function,353
820,julia_sets.py::show_results::127,"def show_results(
    function_label: str,
    function_params: Any,
    escape_radius: float,
    z_final: np.ndarray,
) -> None:
    """"""
    Plots of whether the absolute value of z_final is greater than
    the value of escape_radius. Adds the function_label and function_params to
    the title.

    >>> show_results('80', 0, 1, np.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))
    """"""

    abs_z_final = (abs(z_final)).transpose()
    abs_z_final[:, :] = abs_z_final[::-1, :]
    plt.matshow(abs_z_final < escape_radius)
    plt.title(f""Julia set of ${function_label}$, $c={function_params}$"")
    plt.show()",data\repos\Python\fractals\julia_sets.py,show_results,175
821,julia_sets.py::ignore_overflow_warnings::148,"def ignore_overflow_warnings() -> None:
    """"""
    Ignore some overflow and invalid value warnings.

    >>> ignore_overflow_warnings()
    """"""
    warnings.filterwarnings(
        ""ignore"", category=RuntimeWarning, message=""overflow encountered in multiply""
    )
    warnings.filterwarnings(
        ""ignore"",
        category=RuntimeWarning,
        message=""invalid value encountered in multiply"",
    )
    warnings.filterwarnings(
        ""ignore"", category=RuntimeWarning, message=""overflow encountered in absolute""
    )
    warnings.filterwarnings(
        ""ignore"", category=RuntimeWarning, message=""overflow encountered in exp""
    )",data\repos\Python\fractals\julia_sets.py,ignore_overflow_warnings,122
822,koch_snowflake.py::iterate::38,"def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:
    """"""
    Go through the number of iterations determined by the argument ""steps"".
    Be careful with high values (above 5) since the time to calculate increases
    exponentially.
    >>> iterate([np.array([0, 0]), np.array([1, 0])], 1)
    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \
0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]
    """"""
    vectors = initial_vectors
    for _ in range(steps):
        vectors = iteration_step(vectors)
    return vectors",data\repos\Python\fractals\koch_snowflake.py,iterate,163
823,koch_snowflake.py::iteration_step::53,"def iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:
    """"""
    Loops through each pair of adjacent vectors. Each line between two adjacent
    vectors is divided into 4 segments by adding 3 additional vectors in-between
    the original two vectors. The vector in the middle is constructed through a
    60 degree rotation so it is bent outwards.
    >>> iteration_step([np.array([0, 0]), np.array([1, 0])])
    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \
0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]
    """"""
    new_vectors = []
    for i, start_vector in enumerate(vectors[:-1]):
        end_vector = vectors[i + 1]
        new_vectors.append(start_vector)
        difference_vector = end_vector - start_vector
        new_vectors.append(start_vector + difference_vector / 3)
        new_vectors.append(
            start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)
        )
        new_vectors.append(start_vector + difference_vector * 2 / 3)
    new_vectors.append(vectors[-1])
    return new_vectors",data\repos\Python\fractals\koch_snowflake.py,iteration_step,275
824,koch_snowflake.py::rotate::77,"def rotate(vector: np.ndarray, angle_in_degrees: float) -> np.ndarray:
    """"""
    Standard rotation of a 2D vector with a rotation matrix
    (see https://en.wikipedia.org/wiki/Rotation_matrix )
    >>> rotate(np.array([1, 0]), 60)
    array([0.5      , 0.8660254])
    >>> rotate(np.array([1, 0]), 90)
    array([6.123234e-17, 1.000000e+00])
    """"""
    theta = np.radians(angle_in_degrees)
    c, s = np.cos(theta), np.sin(theta)
    rotation_matrix = np.array(((c, -s), (s, c)))
    return np.dot(rotation_matrix, vector)",data\repos\Python\fractals\koch_snowflake.py,rotate,161
825,koch_snowflake.py::plot::92,"def plot(vectors: list[np.ndarray]) -> None:
    """"""
    Utility function to plot the vectors using matplotlib.pyplot
    No doctest was implemented since this function does not have a return value
    """"""
    # avoid stretched display of graph
    axes = plt.gca()
    axes.set_aspect(""equal"")

    # matplotlib.pyplot.plot takes a list of all x-coordinates and a list of all
    # y-coordinates as inputs, which are constructed from the vector-list using
    # zip()
    x_coordinates, y_coordinates = zip(*vectors)
    plt.plot(x_coordinates, y_coordinates)
    plt.show()",data\repos\Python\fractals\koch_snowflake.py,plot,129
826,mandelbrot.py::get_distance::23,"def get_distance(x: float, y: float, max_step: int) -> float:
    """"""
    Return the relative distance (= step/max_step) after which the complex number
    constituted by this x-y-pair diverges. Members of the Mandelbrot set do not
    diverge so their distance is 1.

    >>> get_distance(0, 0, 50)
    1.0
    >>> get_distance(0.5, 0.5, 50)
    0.061224489795918366
    >>> get_distance(2, 0, 50)
    0.0
    """"""
    a = x
    b = y
    for step in range(max_step):  # noqa: B007
        a_new = a * a - b * b + x
        b = 2 * a * b + y
        a = a_new

        # divergence happens for all complex number with an absolute value
        # greater than 4
        if a * a + b * b > 4:
            break
    return step / (max_step - 1)",data\repos\Python\fractals\mandelbrot.py,get_distance,241
827,mandelbrot.py::get_black_and_white_rgb::50,"def get_black_and_white_rgb(distance: float) -> tuple:
    """"""
    Black&white color-coding that ignores the relative distance. The Mandelbrot
    set is black, everything else is white.

    >>> get_black_and_white_rgb(0)
    (255, 255, 255)
    >>> get_black_and_white_rgb(0.5)
    (255, 255, 255)
    >>> get_black_and_white_rgb(1)
    (0, 0, 0)
    """"""
    if distance == 1:
        return (0, 0, 0)
    else:
        return (255, 255, 255)",data\repos\Python\fractals\mandelbrot.py,get_black_and_white_rgb,140
828,mandelbrot.py::get_color_coded_rgb::68,"def get_color_coded_rgb(distance: float) -> tuple:
    """"""
    Color-coding taking the relative distance into account. The Mandelbrot set
    is black.

    >>> get_color_coded_rgb(0)
    (255, 0, 0)
    >>> get_color_coded_rgb(0.5)
    (0, 255, 255)
    >>> get_color_coded_rgb(1)
    (0, 0, 0)
    """"""
    if distance == 1:
        return (0, 0, 0)
    else:
        return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))",data\repos\Python\fractals\mandelbrot.py,get_color_coded_rgb,148
829,mandelbrot.py::get_image::86,"def get_image(
    image_width: int = 800,
    image_height: int = 600,
    figure_center_x: float = -0.6,
    figure_center_y: float = 0,
    figure_width: float = 3.2,
    max_step: int = 50,
    use_distance_color_coding: bool = True,
) -> Image.Image:
    """"""
    Function to generate the image of the Mandelbrot set. Two types of coordinates
    are used: image-coordinates that refer to the pixels and figure-coordinates
    that refer to the complex numbers inside and outside the Mandelbrot set. The
    figure-coordinates in the arguments of this function determine which section
    of the Mandelbrot set is viewed. The main area of the Mandelbrot set is
    roughly between ""-1.5 < x < 0.5"" and ""-1 < y < 1"" in the figure-coordinates.

    Commenting out tests that slow down pytest...
    # 13.35s call     fractals/mandelbrot.py::mandelbrot.get_image
    # >>> get_image().load()[0,0]
    (255, 0, 0)
    # >>> get_image(use_distance_color_coding = False).load()[0,0]
    (255, 255, 255)
    """"""
    img = Image.new(""RGB"", (image_width, image_height))
    pixels = img.load()

    # loop through the image-coordinates
    for image_x in range(image_width):
        for image_y in range(image_height):
            # determine the figure-coordinates based on the image-coordinates
            figure_height = figure_width / image_width * image_height
            figure_x = figure_center_x + (image_x / image_width - 0.5) * figure_width
            figure_y = figure_center_y + (image_y / image_height - 0.5) * figure_height

            distance = get_distance(figure_x, figure_y, max_step)

            # color the corresponding pixel based on the selected coloring-function
            if use_distance_color_coding:
                pixels[image_x, image_y] = get_color_coded_rgb(distance)
            else:
                pixels[image_x, image_y] = get_black_and_white_rgb(distance)

    return img",data\repos\Python\fractals\mandelbrot.py,get_image,489
830,sierpinski_triangle.py::get_mid::30,"def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:
    """"""
    Find the midpoint of two points

    >>> get_mid((0, 0), (2, 2))
    (1.0, 1.0)
    >>> get_mid((-3, -3), (3, 3))
    (0.0, 0.0)
    >>> get_mid((1, 0), (3, 2))
    (2.0, 1.0)
    >>> get_mid((0, 0), (1, 1))
    (0.5, 0.5)
    >>> get_mid((0, 0), (0, 0))
    (0.0, 0.0)
    """"""
    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2",data\repos\Python\fractals\sierpinski_triangle.py,get_mid,205
831,sierpinski_triangle.py::triangle::48,"def triangle(
    vertex1: tuple[float, float],
    vertex2: tuple[float, float],
    vertex3: tuple[float, float],
    depth: int,
) -> None:
    """"""
    Recursively draw the Sierpinski triangle given the vertices of the triangle
    and the recursion depth
    """"""
    my_pen.up()
    my_pen.goto(vertex1[0], vertex1[1])
    my_pen.down()
    my_pen.goto(vertex2[0], vertex2[1])
    my_pen.goto(vertex3[0], vertex3[1])
    my_pen.goto(vertex1[0], vertex1[1])

    if depth == 0:
        return

    triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)
    triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)
    triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)",data\repos\Python\fractals\sierpinski_triangle.py,triangle,220
832,vicsek.py::draw_cross::18,"def draw_cross(x: float, y: float, length: float):
    """"""
    Draw a cross at the specified position and with the specified length.
    """"""
    turtle.up()
    turtle.goto(x - length / 2, y - length / 6)
    turtle.down()
    turtle.seth(0)
    turtle.begin_fill()
    for _ in range(4):
        turtle.fd(length / 3)
        turtle.right(90)
        turtle.fd(length / 3)
        turtle.left(90)
        turtle.fd(length / 3)
        turtle.left(90)
    turtle.end_fill()",data\repos\Python\fractals\vicsek.py,draw_cross,125
833,vicsek.py::draw_fractal_recursive::37,"def draw_fractal_recursive(x: float, y: float, length: float, depth: float):
    """"""
    Recursively draw the Vicsek fractal at the specified position, with the
    specified length and depth.
    """"""
    if depth == 0:
        draw_cross(x, y, length)
        return

    draw_fractal_recursive(x, y, length / 3, depth - 1)
    draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)
    draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)
    draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)
    draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)",data\repos\Python\fractals\vicsek.py,draw_fractal_recursive,182
834,vicsek.py::draw_vicsek_fractal::57,"def draw_vicsek_fractal(x: float, y: float, length: float, depth: float, color=""blue""):
    """"""
    Draw the Vicsek fractal at the specified position, with the specified
    length and depth.
    """"""
    turtle.speed(0)
    turtle.hideturtle()
    set_color(color)
    draw_fractal_recursive(x, y, length, depth)
    turtle.Screen().update()",data\repos\Python\fractals\vicsek.py,draw_vicsek_fractal,89
835,fuzzy_operations.py::complement::77,"    def complement(self) -> FuzzySet:
        """"""
        Calculate the complement (negation) of this fuzzy set.
        Returns:
            FuzzySet: A new fuzzy set representing the complement.

        >>> FuzzySet(""fuzzy_set"", 0.1, 0.2, 0.3).complement()
        FuzzySet(name='fuzzy_set', left_boundary=0.7, peak=0.9, right_boundary=0.8)
        """"""
        return FuzzySet(
            f""{self.name}"",
            1 - self.right_boundary,
            1 - self.left_boundary,
            1 - self.peak,
        )",data\repos\Python\fuzzy_logic\fuzzy_operations.py,complement,142
836,fuzzy_operations.py::intersection::93,"    def intersection(self, other) -> FuzzySet:
        """"""
        Calculate the intersection of this fuzzy set
        with another fuzzy set.
        Args:
            other: Another fuzzy set to intersect with.
        Returns:
            A new fuzzy set representing the intersection.

        >>> FuzzySet(""a"", 0.1, 0.2, 0.3).intersection(FuzzySet(""b"", 0.4, 0.5, 0.6))
        FuzzySet(name='a  b', left_boundary=0.4, peak=0.3, right_boundary=0.35)
        """"""
        return FuzzySet(
            f""{self.name}  {other.name}"",
            max(self.left_boundary, other.left_boundary),
            min(self.right_boundary, other.right_boundary),
            (self.peak + other.peak) / 2,
        )",data\repos\Python\fuzzy_logic\fuzzy_operations.py,intersection,186
837,fuzzy_operations.py::membership::112,"    def membership(self, x: float) -> float:
        """"""
        Calculate the membership value of an input 'x' in the fuzzy set.
        Returns:
            The membership value of 'x' in the fuzzy set.

        >>> a = FuzzySet(""a"", 0.1, 0.2, 0.3)
        >>> a.membership(0.09)
        0.0
        >>> a.membership(0.1)
        0.0
        >>> a.membership(0.11)
        0.09999999999999995
        >>> a.membership(0.4)
        0.0
        >>> FuzzySet(""A"", 0, 0.5, 1).membership(0.1)
        0.2
        >>> FuzzySet(""B"", 0.2, 0.7, 1).membership(0.6)
        0.8
        """"""
        if x <= self.left_boundary or x >= self.right_boundary:
            return 0.0
        elif self.left_boundary < x <= self.peak:
            return (x - self.left_boundary) / (self.peak - self.left_boundary)
        elif self.peak < x < self.right_boundary:
            return (self.right_boundary - x) / (self.right_boundary - self.peak)
        msg = f""Invalid value {x} for fuzzy set {self}""
        raise ValueError(msg)",data\repos\Python\fuzzy_logic\fuzzy_operations.py,membership,310
838,fuzzy_operations.py::union::141,"    def union(self, other) -> FuzzySet:
        """"""
        Calculate the union of this fuzzy set with another fuzzy set.
        Args:
            other (FuzzySet): Another fuzzy set to union with.
        Returns:
            FuzzySet: A new fuzzy set representing the union.

        >>> FuzzySet(""a"", 0.1, 0.2, 0.3).union(FuzzySet(""b"", 0.4, 0.5, 0.6))
        FuzzySet(name='a U b', left_boundary=0.1, peak=0.6, right_boundary=0.35)
        """"""
        return FuzzySet(
            f""{self.name} U {other.name}"",
            min(self.left_boundary, other.left_boundary),
            max(self.right_boundary, other.right_boundary),
            (self.peak + other.peak) / 2,
        )",data\repos\Python\fuzzy_logic\fuzzy_operations.py,union,190
839,fuzzy_operations.py::plot::159,"    def plot(self):
        """"""
        Plot the membership function of the fuzzy set.
        """"""
        x = np.linspace(0, 1, 1000)
        y = [self.membership(xi) for xi in x]

        plt.plot(x, y, label=self.name)",data\repos\Python\fuzzy_logic\fuzzy_operations.py,plot,59
840,basic_string.py::evaluate::24,"def evaluate(item: str, main_target: str) -> tuple[str, float]:
    """"""
    Evaluate how similar the item is with the target by just
    counting each char in the right position
    >>> evaluate(""Helxo Worlx"", ""Hello World"")
    ('Helxo Worlx', 9.0)
    """"""
    score = len([g for position, g in enumerate(item) if g == main_target[position]])
    return (item, float(score))",data\repos\Python\genetic_algorithm\basic_string.py,evaluate,97
841,basic_string.py::crossover::35,"def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:
    """"""
    Slice and combine two strings at a random point.
    >>> random.seed(42)
    >>> crossover(""123456"", ""abcdef"")
    ('12345f', 'abcde6')
    """"""
    random_slice = random.randint(0, len(parent_1) - 1)
    child_1 = parent_1[:random_slice] + parent_2[random_slice:]
    child_2 = parent_2[:random_slice] + parent_1[random_slice:]
    return (child_1, child_2)",data\repos\Python\genetic_algorithm\basic_string.py,crossover,130
842,basic_string.py::mutate::48,"def mutate(child: str, genes: list[str]) -> str:
    """"""
    Mutate a random gene of a child with another one from the list.
    >>> random.seed(123)
    >>> mutate(""123456"", list(""ABCDEF""))
    '12345A'
    """"""
    child_list = list(child)
    if random.uniform(0, 1) < MUTATION_PROBABILITY:
        child_list[random.randint(0, len(child)) - 1] = random.choice(genes)
    return """".join(child_list)",data\repos\Python\genetic_algorithm\basic_string.py,mutate,111
843,basic_string.py::select::62,"def select(
    parent_1: tuple[str, float],
    population_score: list[tuple[str, float]],
    genes: list[str],
) -> list[str]:
    """"""
    Select the second parent and generate new population

    >>> random.seed(42)
    >>> parent_1 = (""123456"", 8.0)
    >>> population_score = [(""abcdef"", 4.0), (""ghijkl"", 5.0), (""mnopqr"", 7.0)]
    >>> genes = list(""ABCDEF"")
    >>> child_n = int(min(parent_1[1] + 1, 10))
    >>> population = []
    >>> for _ in range(child_n):
    ...     parent_2 = population_score[random.randrange(len(population_score))][0]
    ...     child_1, child_2 = crossover(parent_1[0], parent_2)
    ...     population.extend((mutate(child_1, genes), mutate(child_2, genes)))
    >>> len(population) == (int(parent_1[1]) + 1) * 2
    True
    """"""
    pop = []
    # Generate more children proportionally to the fitness score.
    child_n = int(parent_1[1] * 100) + 1
    child_n = 10 if child_n >= 10 else child_n
    for _ in range(child_n):
        parent_2 = population_score[random.randint(0, N_SELECTED)][0]

        child_1, child_2 = crossover(parent_1[0], parent_2)
        # Append new string to the population list.
        pop.append(mutate(child_1, genes))
        pop.append(mutate(child_2, genes))
    return pop",data\repos\Python\genetic_algorithm\basic_string.py,select,364
844,basic_string.py::basic::97,"def basic(target: str, genes: list[str], debug: bool = True) -> tuple[int, int, str]:
    """"""
    Verify that the target contains no genes besides the ones inside genes variable.

    >>> from string import ascii_lowercase
    >>> basic(""doctest"", ascii_lowercase, debug=False)[2]
    'doctest'
    >>> genes = list(ascii_lowercase)
    >>> genes.remove(""e"")
    >>> basic(""test"", genes)
    Traceback (most recent call last):
        ...
    ValueError: ['e'] is not in genes list, evolution cannot converge
    >>> genes.remove(""s"")
    >>> basic(""test"", genes)
    Traceback (most recent call last):
        ...
    ValueError: ['e', 's'] is not in genes list, evolution cannot converge
    >>> genes.remove(""t"")
    >>> basic(""test"", genes)
    Traceback (most recent call last):
        ...
    ValueError: ['e', 's', 't'] is not in genes list, evolution cannot converge
    """"""

    # Verify if N_POPULATION is bigger than N_SELECTED
    if N_POPULATION < N_SELECTED:
        msg = f""{N_POPULATION} must be bigger than {N_SELECTED}""
        raise ValueError(msg)
    # Verify that the target contains no genes besides the ones inside genes variable.
    not_in_genes_list = sorted({c for c in target if c not in genes})
    if not_in_genes_list:
        msg = f""{not_in_genes_list} is not in genes list, evolution cannot converge""
        raise ValueError(msg)

    # Generate random starting population.
    population = []
    for _ in range(N_POPULATION):
        population.append("""".join([random.choice(genes) for i in range(len(target))]))

    # Just some logs to know what the algorithms is doing.
    generation, total_population = 0, 0

    # This loop will end when we find a perfect match for our target.
    while True:
        generation += 1
        total_population += len(population)

        # Random population created. Now it's time to evaluate.

        # (Option 1) Adding a bit of concurrency can make everything faster,
        #
        # import concurrent.futures
        # population_score: list[tuple[str, float]] = []
        # with concurrent.futures.ThreadPoolExecutor(
        #                                   max_workers=NUM_WORKERS) as executor:
        #     futures = {executor.submit(evaluate, item, target) for item in population}
        #     concurrent.futures.wait(futures)
        #     population_score = [item.result() for item in futures]
        #
        # but with a simple algorithm like this, it will probably be slower.
        # (Option 2) We just need to call evaluate for every item inside the population.
        population_score = [evaluate(item, target) for item in population]

        # Check if there is a matching evolution.
        population_score = sorted(population_score, key=lambda x: x[1], reverse=True)
        if population_score[0][0] == target:
            return (generation, total_population, population_score[0][0])

        # Print the best result every 10 generation.
        # Just to know that the algorithm is working.
        if debug and generation % 10 == 0:
            print(
                f""\nGeneration: {generation}""
                f""\nTotal Population:{total_population}""
                f""\nBest score: {population_score[0][1]}""
                f""\nBest string: {population_score[0][0]}""
            )

        # Flush the old population, keeping some of the best evolutions.
        # Keeping this avoid regression of evolution.
        population_best = population[: int(N_POPULATION / 3)]
        population.clear()
        population.extend(population_best)
        # Normalize population score to be between 0 and 1.
        population_score = [
            (item, score / len(target)) for item, score in population_score
        ]

        # This is selection
        for i in range(N_SELECTED):
            population.extend(select(population_score[int(i)], population_score, genes))
            # Check if the population has already reached the maximum value and if so,
            # break the cycle.  If this check is disabled, the algorithm will take
            # forever to compute large strings, but will also calculate small strings in
            # a far fewer generations.
            if len(population) > N_POPULATION:
                break",data\repos\Python\genetic_algorithm\basic_string.py,basic,931
845,haversine_distance.py::haversine_distance::8,"def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """"""
    Calculate great circle distance between two points in a sphere,
    given longitudes and latitudes https://en.wikipedia.org/wiki/Haversine_formula

    We know that the globe is ""sort of"" spherical, so a path between two points
    isn't exactly a straight line. We need to account for the Earth's curvature
    when calculating distance from point A to B. This effect is negligible for
    small distances but adds up as distance increases. The Haversine method treats
    the earth as a sphere which allows us to ""project"" the two points A and B
    onto the surface of that sphere and approximate the spherical distance between
    them. Since the Earth is not a perfect sphere, other methods which model the
    Earth's ellipsoidal nature are more accurate but a quick and modifiable
    computation like Haversine can be handy for shorter range distances.

    Args:
        * `lat1`, `lon1`: latitude and longitude of coordinate 1
        * `lat2`, `lon2`: latitude and longitude of coordinate 2
    Returns:
        geographical distance between two points in metres

    >>> from collections import namedtuple
    >>> point_2d = namedtuple(""point_2d"", ""lat lon"")
    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)
    >>> YOSEMITE = point_2d(37.864742, -119.537521)
    >>> f""{haversine_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters""
    '254,352 meters'
    """"""
    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System
    # Distance in metres(m)
    # Equation parameters
    # Equation https://en.wikipedia.org/wiki/Haversine_formula#Formulation
    flattening = (AXIS_A - AXIS_B) / AXIS_A
    phi_1 = atan((1 - flattening) * tan(radians(lat1)))
    phi_2 = atan((1 - flattening) * tan(radians(lat2)))
    lambda_1 = radians(lon1)
    lambda_2 = radians(lon2)
    # Equation
    sin_sq_phi = sin((phi_2 - phi_1) / 2)
    sin_sq_lambda = sin((lambda_2 - lambda_1) / 2)
    # Square both values
    sin_sq_phi *= sin_sq_phi
    sin_sq_lambda *= sin_sq_lambda
    h_value = sqrt(sin_sq_phi + (cos(phi_1) * cos(phi_2) * sin_sq_lambda))
    return 2 * RADIUS * asin(h_value)",data\repos\Python\geodesy\haversine_distance.py,haversine_distance,598
846,lamberts_ellipsoidal_distance.py::lamberts_ellipsoidal_distance::10,"def lamberts_ellipsoidal_distance(
    lat1: float, lon1: float, lat2: float, lon2: float
) -> float:
    """"""
    Calculate the shortest distance along the surface of an ellipsoid between
    two points on the surface of earth given longitudes and latitudes
    https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines

    NOTE: This algorithm uses geodesy/haversine_distance.py to compute central angle,
        sigma

    Representing the earth as an ellipsoid allows us to approximate distances between
    points on the surface much better than a sphere. Ellipsoidal formulas treat the
    Earth as an oblate ellipsoid which means accounting for the flattening that happens
    at the North and South poles. Lambert's formulae provide accuracy on the order of
    10 meteres over thousands of kilometeres. Other methods can provide
    millimeter-level accuracy but this is a simpler method to calculate long range
    distances without increasing computational intensity.

    Args:
        lat1, lon1: latitude and longitude of coordinate 1
        lat2, lon2: latitude and longitude of coordinate 2
    Returns:
        geographical distance between two points in metres

    >>> from collections import namedtuple
    >>> point_2d = namedtuple(""point_2d"", ""lat lon"")
    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)
    >>> YOSEMITE = point_2d(37.864742, -119.537521)
    >>> NEW_YORK = point_2d(40.713019, -74.012647)
    >>> VENICE = point_2d(45.443012, 12.313071)
    >>> f""{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters""
    '254,351 meters'
    >>> f""{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *NEW_YORK):0,.0f} meters""
    '4,138,992 meters'
    >>> f""{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *VENICE):0,.0f} meters""
    '9,737,326 meters'
    """"""

    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System
    # Distance in metres(m)
    # Equation Parameters
    # https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines
    flattening = (AXIS_A - AXIS_B) / AXIS_A
    # Parametric latitudes
    # https://en.wikipedia.org/wiki/Latitude#Parametric_(or_reduced)_latitude
    b_lat1 = atan((1 - flattening) * tan(radians(lat1)))
    b_lat2 = atan((1 - flattening) * tan(radians(lat2)))

    # Compute central angle between two points
    # using haversine theta. sigma =  haversine_distance / equatorial radius
    sigma = haversine_distance(lat1, lon1, lat2, lon2) / EQUATORIAL_RADIUS

    # Intermediate P and Q values
    p_value = (b_lat1 + b_lat2) / 2
    q_value = (b_lat2 - b_lat1) / 2

    # Intermediate X value
    # X = (sigma - sin(sigma)) * sin^2Pcos^2Q / cos^2(sigma/2)
    x_numerator = (sin(p_value) ** 2) * (cos(q_value) ** 2)
    x_demonimator = cos(sigma / 2) ** 2
    x_value = (sigma - sin(sigma)) * (x_numerator / x_demonimator)

    # Intermediate Y value
    # Y = (sigma + sin(sigma)) * cos^2Psin^2Q / sin^2(sigma/2)
    y_numerator = (cos(p_value) ** 2) * (sin(q_value) ** 2)
    y_denominator = sin(sigma / 2) ** 2
    y_value = (sigma + sin(sigma)) * (y_numerator / y_denominator)

    return EQUATORIAL_RADIUS * (sigma - ((flattening / 2) * (x_value + y_value)))",data\repos\Python\geodesy\lamberts_ellipsoidal_distance.py,lamberts_ellipsoidal_distance,941
847,geometry.py::area::95,"    def area(self) -> float:
        """"""
        >>> Ellipse(5, 10).area
        157.07963267948966
        """"""
        return math.pi * self.major_radius * self.minor_radius",data\repos\Python\geometry\geometry.py,area,47
848,geometry.py::perimeter::103,"    def perimeter(self) -> float:
        """"""
        >>> Ellipse(5, 10).perimeter
        47.12388980384689
        """"""
        return math.pi * (self.major_radius + self.minor_radius)",data\repos\Python\geometry\geometry.py,perimeter,50
849,geometry.py::diameter::135,"    def diameter(self) -> float:
        """"""
        >>> Circle(5).diameter
        10
        """"""
        return self.radius * 2",data\repos\Python\geometry\geometry.py,diameter,32
850,geometry.py::max_parts::142,"    def max_parts(self, num_cuts: float) -> float:
        """"""
        Return the maximum number of parts that circle can be divided into if cut
        'num_cuts' times.

        >>> circle = Circle(5)
        >>> circle.max_parts(0)
        1.0
        >>> circle.max_parts(7)
        29.0
        >>> circle.max_parts(54)
        1486.0
        >>> circle.max_parts(22.5)
        265.375
        >>> circle.max_parts(-222)
        Traceback (most recent call last):
            ...
        TypeError: num_cuts must be a positive numeric value.
        >>> circle.max_parts(""-222"")
        Traceback (most recent call last):
            ...
        TypeError: num_cuts must be a positive numeric value.
        """"""
        if not isinstance(num_cuts, (int, float)) or num_cuts < 0:
            raise TypeError(""num_cuts must be a positive numeric value."")
        return (num_cuts + 2 + num_cuts**2) * 0.5",data\repos\Python\geometry\geometry.py,max_parts,230
851,geometry.py::add_side::194,"    def add_side(self, side: Side) -> Self:
        """"""
        >>> Polygon().add_side(Side(5))
        Polygon(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None)])
        """"""
        self.sides.append(side)
        return self",data\repos\Python\geometry\geometry.py,add_side,60
852,geometry.py::get_side::202,"    def get_side(self, index: int) -> Side:
        """"""
        >>> Polygon().get_side(0)
        Traceback (most recent call last):
            ...
        IndexError: list index out of range
        >>> Polygon().add_side(Side(5)).get_side(-1)
        Side(length=5, angle=Angle(degrees=90), next_side=None)
        """"""
        return self.sides[index]",data\repos\Python\geometry\geometry.py,get_side,87
853,geometry.py::set_side::213,"    def set_side(self, index: int, side: Side) -> Self:
        """"""
        >>> Polygon().set_side(0, Side(5))
        Traceback (most recent call last):
            ...
        IndexError: list assignment index out of range
        >>> Polygon().add_side(Side(5)).set_side(0, Side(10))
        Polygon(sides=[Side(length=10, angle=Angle(degrees=90), next_side=None)])
        """"""
        self.sides[index] = side
        return self",data\repos\Python\geometry\geometry.py,set_side,109
854,geometry.py::post_init::247,"    def post_init(self) -> None:
        """"""
        >>> Rectangle(5, 10)  # doctest: +NORMALIZE_WHITESPACE
        Rectangle(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None),
        Side(length=10, angle=Angle(degrees=90), next_side=None)])
        """"""
        self.short_side = Side(self.short_side_length)
        self.long_side = Side(self.long_side_length)
        super().add_side(self.short_side)
        super().add_side(self.long_side)",data\repos\Python\geometry\geometry.py,post_init,114
855,bezier_curve.py::basis_function::25,"    def basis_function(self, t: float) -> list[float]:
        """"""
        The basis function determines the weight of each control point at time t.
            t: time value between 0 and 1 inclusive at which to evaluate the basis of
               the curve.
        returns the x, y values of basis function at time t

        >>> curve = BezierCurve([(1,1), (1,2)])
        >>> [float(x) for x in curve.basis_function(0)]
        [1.0, 0.0]
        >>> [float(x) for x in curve.basis_function(1)]
        [0.0, 1.0]
        """"""
        assert 0 <= t <= 1, ""Time t must be between 0 and 1.""
        output_values: list[float] = []
        for i in range(len(self.list_of_points)):
            # basis function for each i
            output_values.append(
                comb(self.degree, i) * ((1 - t) ** (self.degree - i)) * (t**i)
            )
        # the basis must sum up to 1 for it to produce a valid Bezier curve.
        assert round(sum(output_values), 5) == 1
        return output_values",data\repos\Python\graphics\bezier_curve.py,basis_function,263
856,bezier_curve.py::bezier_curve_function::49,"    def bezier_curve_function(self, t: float) -> tuple[float, float]:
        """"""
        The function to produce the values of the Bezier curve at time t.
            t: the value of time t at which to evaluate the Bezier function
        Returns the x, y coordinates of the Bezier curve at time t.
            The first point in the curve is when t = 0.
            The last point in the curve is when t = 1.

        >>> curve = BezierCurve([(1,1), (1,2)])
        >>> tuple(float(x) for x in curve.bezier_curve_function(0))
        (1.0, 1.0)
        >>> tuple(float(x) for x in curve.bezier_curve_function(1))
        (1.0, 2.0)
        """"""

        assert 0 <= t <= 1, ""Time t must be between 0 and 1.""

        basis_function = self.basis_function(t)
        x = 0.0
        y = 0.0
        for i in range(len(self.list_of_points)):
            # For all points, sum up the product of i-th basis function and i-th point.
            x += basis_function[i] * self.list_of_points[i][0]
            y += basis_function[i] * self.list_of_points[i][1]
        return (x, y)",data\repos\Python\graphics\bezier_curve.py,bezier_curve_function,289
857,bezier_curve.py::plot_curve::75,"    def plot_curve(self, step_size: float = 0.01):
        """"""
        Plots the Bezier curve using matplotlib plotting capabilities.
            step_size: defines the step(s) at which to evaluate the Bezier curve.
            The smaller the step size, the finer the curve produced.
        """"""
        from matplotlib import pyplot as plt

        to_plot_x: list[float] = []  # x coordinates of points to plot
        to_plot_y: list[float] = []  # y coordinates of points to plot

        t = 0.0
        while t <= 1:
            value = self.bezier_curve_function(t)
            to_plot_x.append(value[0])
            to_plot_y.append(value[1])
            t += step_size

        x = [i[0] for i in self.list_of_points]
        y = [i[1] for i in self.list_of_points]

        plt.plot(
            to_plot_x,
            to_plot_y,
            color=""blue"",
            label=""Curve of Degree "" + str(self.degree),
        )
        plt.scatter(x, y, color=""red"", label=""Control Points"")
        plt.legend()
        plt.show()",data\repos\Python\graphics\bezier_curve.py,plot_curve,247
858,butterfly_pattern.py::butterfly_pattern::1,"def butterfly_pattern(n: int) -> str:
    """"""
    Creates a butterfly pattern of size n and returns it as a string.

    >>> print(butterfly_pattern(3))
    *   *
    ** **
    *****
    ** **
    *   *
    >>> print(butterfly_pattern(5))
    *       *
    **     **
    ***   ***
    **** ****
    *********
    **** ****
    ***   ***
    **     **
    *       *
    """"""
    result = []

    # Upper part
    for i in range(1, n):
        left_stars = ""*"" * i
        spaces = "" "" * (2 * (n - i) - 1)
        right_stars = ""*"" * i
        result.append(left_stars + spaces + right_stars)

    # Middle part
    result.append(""*"" * (2 * n - 1))

    # Lower part
    for i in range(n - 1, 0, -1):
        left_stars = ""*"" * i
        spaces = "" "" * (2 * (n - i) - 1)
        right_stars = ""*"" * i
        result.append(left_stars + spaces + right_stars)

    return ""\n"".join(result)",data\repos\Python\graphics\butterfly_pattern.py,butterfly_pattern,266
859,digital_differential_analyzer_line.py::digital_differential_analyzer_line::4,"def digital_differential_analyzer_line(
    p1: tuple[int, int], p2: tuple[int, int]
) -> list[tuple[int, int]]:
    """"""
    Draws a line between two points using the DDA algorithm.

    Args:
    - p1: Coordinates of the starting point.
    - p2: Coordinates of the ending point.
    Returns:
    - List of coordinate points that form the line.

    >>> digital_differential_analyzer_line((1, 1), (4, 4))
    [(2, 2), (3, 3), (4, 4)]
    """"""
    x1, y1 = p1
    x2, y2 = p2
    dx = x2 - x1
    dy = y2 - y1
    steps = max(abs(dx), abs(dy))
    x_increment = dx / float(steps)
    y_increment = dy / float(steps)
    coordinates = []
    x: float = x1
    y: float = y1
    for _ in range(steps):
        x += x_increment
        y += y_increment
        coordinates.append((round(x), round(y)))
    return coordinates",data\repos\Python\graphics\digital_differential_analyzer_line.py,digital_differential_analyzer_line,247
860,vector3_for_2d_rendering.py::convert_to_2d::13,"def convert_to_2d(
    x: float, y: float, z: float, scale: float, distance: float
) -> tuple[float, float]:
    """"""
    Converts 3d point to a 2d drawable point

    >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)
    (7.6923076923076925, 15.384615384615385)

    >>> convert_to_2d(1, 2, 3, 10, 10)
    (7.6923076923076925, 15.384615384615385)

    >>> convert_to_2d(""1"", 2, 3, 10, 10)  # '1' is str
    Traceback (most recent call last):
        ...
    TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]
    """"""
    if not all(isinstance(val, (float, int)) for val in locals().values()):
        msg = f""Input values must either be float or int: {list(locals().values())}""
        raise TypeError(msg)
    projected_x = ((x * distance) / (z + distance)) * scale
    projected_y = ((y * distance) / (z + distance)) * scale
    return projected_x, projected_y",data\repos\Python\graphics\vector3_for_2d_rendering.py,convert_to_2d,304
861,vector3_for_2d_rendering.py::rotate::38,"def rotate(
    x: float, y: float, z: float, axis: str, angle: float
) -> tuple[float, float, float]:
    """"""
    rotate a point around a certain axis with a certain angle
    angle can be any integer between 1, 360 and axis can be any one of
    'x', 'y', 'z'

    >>> rotate(1.0, 2.0, 3.0, 'y', 90.0)
    (3.130524675073759, 2.0, 0.4470070007889556)

    >>> rotate(1, 2, 3, ""z"", 180)
    (0.999736015495891, -2.0001319704760485, 3)

    >>> rotate('1', 2, 3, ""z"", 90.0)  # '1' is str
    Traceback (most recent call last):
        ...
    TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]

    >>> rotate(1, 2, 3, ""n"", 90)  # 'n' is not a valid axis
    Traceback (most recent call last):
        ...
    ValueError: not a valid axis, choose one of 'x', 'y', 'z'

    >>> rotate(1, 2, 3, ""x"", -90)
    (1, -2.5049096187183877, -2.5933429780983657)

    >>> rotate(1, 2, 3, ""x"", 450)  # 450 wrap around to 90
    (1, 3.5776792428178217, -0.44744970165427644)
    """"""
    if not isinstance(axis, str):
        raise TypeError(""Axis must be a str"")
    input_variables = locals()
    del input_variables[""axis""]
    if not all(isinstance(val, (float, int)) for val in input_variables.values()):
        msg = (
            ""Input values except axis must either be float or int: ""
            f""{list(input_variables.values())}""
        )
        raise TypeError(msg)
    angle = (angle % 360) / 450 * 180 / math.pi
    if axis == ""z"":
        new_x = x * math.cos(angle) - y * math.sin(angle)
        new_y = y * math.cos(angle) + x * math.sin(angle)
        new_z = z
    elif axis == ""x"":
        new_y = y * math.cos(angle) - z * math.sin(angle)
        new_z = z * math.cos(angle) + y * math.sin(angle)
        new_x = x
    elif axis == ""y"":
        new_x = x * math.cos(angle) - z * math.sin(angle)
        new_z = z * math.cos(angle) + x * math.sin(angle)
        new_y = y
    else:
        raise ValueError(""not a valid axis, choose one of 'x', 'y', 'z'"")

    return new_x, new_y, new_z",data\repos\Python\graphics\vector3_for_2d_rendering.py,rotate,672
862,ant_colony_optimization_algorithms.py::main::29,"def main(
    cities: dict[int, list[int]],
    ants_num: int,
    iterations_num: int,
    pheromone_evaporation: float,
    alpha: float,
    beta: float,
    q: float,  # Pheromone system parameters Q, which is a constant
) -> tuple[list[int], float]:
    """"""
    Ant colony algorithm main function
    >>> main(cities=cities, ants_num=10, iterations_num=20,
    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
    ([0, 1, 2, 3, 4, 5, 6, 7, 0], 37.909778143828696)
    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,
    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
    ([0, 1, 0], 5.656854249492381)
    >>> main(cities={0: [0, 0], 1: [2, 2], 4: [4, 4]}, ants_num=5, iterations_num=5,
    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
    Traceback (most recent call last):
      ...
    IndexError: list index out of range
    >>> main(cities={}, ants_num=5, iterations_num=5,
    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
    Traceback (most recent call last):
      ...
    StopIteration
    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=0, iterations_num=5,
    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
    ([], inf)
    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=0,
    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
    ([], inf)
    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,
    ...      pheromone_evaporation=1, alpha=1.0, beta=5.0, q=10)
    ([0, 1, 0], 5.656854249492381)
    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,
    ...      pheromone_evaporation=0, alpha=1.0, beta=5.0, q=10)
    ([0, 1, 0], 5.656854249492381)
    """"""
    # Initialize the pheromone matrix
    cities_num = len(cities)
    pheromone = [[1.0] * cities_num] * cities_num

    best_path: list[int] = []
    best_distance = float(""inf"")
    for _ in range(iterations_num):
        ants_route = []
        for _ in range(ants_num):
            unvisited_cities = copy.deepcopy(cities)
            current_city = {next(iter(cities.keys())): next(iter(cities.values()))}
            del unvisited_cities[next(iter(current_city.keys()))]
            ant_route = [next(iter(current_city.keys()))]
            while unvisited_cities:
                current_city, unvisited_cities = city_select(
                    pheromone, current_city, unvisited_cities, alpha, beta
                )
                ant_route.append(next(iter(current_city.keys())))
            ant_route.append(0)
            ants_route.append(ant_route)

        pheromone, best_path, best_distance = pheromone_update(
            pheromone,
            cities,
            pheromone_evaporation,
            ants_route,
            q,
            best_path,
            best_distance,
        )
    return best_path, best_distance",data\repos\Python\graphs\ant_colony_optimization_algorithms.py,main,954
863,ant_colony_optimization_algorithms.py::distance::102,"def distance(city1: list[int], city2: list[int]) -> float:
    """"""
    Calculate the distance between two coordinate points
    >>> distance([0, 0], [3, 4] )
    5.0
    >>> distance([0, 0], [-3, 4] )
    5.0
    >>> distance([0, 0], [-3, -4] )
    5.0
    """"""
    return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5",data\repos\Python\graphs\ant_colony_optimization_algorithms.py,distance,136
864,ant_colony_optimization_algorithms.py::pheromone_update::115,"def pheromone_update(
    pheromone: list[list[float]],
    cities: dict[int, list[int]],
    pheromone_evaporation: float,
    ants_route: list[list[int]],
    q: float,  # Pheromone system parameters Q, which is a constant
    best_path: list[int],
    best_distance: float,
) -> tuple[list[list[float]], list[int], float]:
    """"""
    Update pheromones on the route and update the best route
    >>>
    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],
    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,
    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],
    ...                  best_distance=float(""inf""))
    ([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381)
    >>> pheromone_update(pheromone=[],
    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,
    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],
    ...                  best_distance=float(""inf""))
    Traceback (most recent call last):
      ...
    IndexError: list index out of range
    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],
    ...                  cities={}, pheromone_evaporation=0.7,
    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],
    ...                  best_distance=float(""inf""))
    Traceback (most recent call last):
      ...
    KeyError: 0
    """"""
    for a in range(len(cities)):  # Update the volatilization of pheromone on all routes
        for b in range(len(cities)):
            pheromone[a][b] *= pheromone_evaporation
    for ant_route in ants_route:
        total_distance = 0.0
        for i in range(len(ant_route) - 1):  # Calculate total distance
            total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])
        delta_pheromone = q / total_distance
        for i in range(len(ant_route) - 1):  # Update pheromones
            pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone
            pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][
                ant_route[i + 1]
            ]

        if total_distance < best_distance:
            best_path = ant_route
            best_distance = total_distance

    return pheromone, best_path, best_distance",data\repos\Python\graphs\ant_colony_optimization_algorithms.py,pheromone_update,681
865,ant_colony_optimization_algorithms.py::city_select::168,"def city_select(
    pheromone: list[list[float]],
    current_city: dict[int, list[int]],
    unvisited_cities: dict[int, list[int]],
    alpha: float,
    beta: float,
) -> tuple[dict[int, list[int]], dict[int, list[int]]]:
    """"""
    Choose the next city for ants
    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},
    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)
    ({1: [2, 2]}, {})
    >>> city_select(pheromone=[], current_city={0: [0,0]},
    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)
    Traceback (most recent call last):
      ...
    IndexError: list index out of range
    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={},
    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)
    Traceback (most recent call last):
      ...
    StopIteration
    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},
    ...             unvisited_cities={}, alpha=1.0, beta=5.0)
    Traceback (most recent call last):
      ...
    IndexError: list index out of range
    """"""
    probabilities = []
    for city, value in unvisited_cities.items():
        city_distance = distance(value, next(iter(current_city.values())))
        probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (
            (1 / city_distance) ** beta
        )
        probabilities.append(probability)

    chosen_city_i = random.choices(
        list(unvisited_cities.keys()), weights=probabilities
    )[0]
    chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}
    del unvisited_cities[next(iter(chosen_city.keys()))]
    return chosen_city, unvisited_cities",data\repos\Python\graphs\ant_colony_optimization_algorithms.py,city_select,509
866,articulation_points.py::compute_ap::2,"def compute_ap(graph):
    n = len(graph)
    out_edge_count = 0
    low = [0] * n
    visited = [False] * n
    is_art = [False] * n

    def dfs(root, at, parent, out_edge_count):
        if parent == root:
            out_edge_count += 1
        visited[at] = True
        low[at] = at

        for to in graph[at]:
            if to == parent:
                pass
            elif not visited[to]:
                out_edge_count = dfs(root, to, at, out_edge_count)
                low[at] = min(low[at], low[to])

                # AP found via bridge
                if at < low[to]:
                    is_art[at] = True
                # AP found via cycle
                if at == low[to]:
                    is_art[at] = True
            else:
                low[at] = min(low[at], to)
        return out_edge_count

    for i in range(n):
        if not visited[i]:
            out_edge_count = 0
            out_edge_count = dfs(i, i, -1, out_edge_count)
            is_art[i] = out_edge_count > 1

    for x in range(len(is_art)):
        if is_art[x] is True:
            print(x)",data\repos\Python\graphs\articulation_points.py,compute_ap,275
867,articulation_points.py::dfs::9,"    def dfs(root, at, parent, out_edge_count):
        if parent == root:
            out_edge_count += 1
        visited[at] = True
        low[at] = at

        for to in graph[at]:
            if to == parent:
                pass
            elif not visited[to]:
                out_edge_count = dfs(root, to, at, out_edge_count)
                low[at] = min(low[at], low[to])

                # AP found via bridge
                if at < low[to]:
                    is_art[at] = True
                # AP found via cycle
                if at == low[to]:
                    is_art[at] = True
            else:
                low[at] = min(low[at], to)
        return out_edge_count",data\repos\Python\graphs\articulation_points.py,dfs,154
868,a_star.py::search::12,"def search(
    grid: list[list[int]],
    init: list[int],
    goal: list[int],
    cost: int,
    heuristic: list[list[int]],
) -> tuple[list[list[int]], list[list[int]]]:
    """"""
    Search for a path on a grid avoiding obstacles.
    >>> grid = [[0, 1, 0, 0, 0, 0],
    ...         [0, 1, 0, 0, 0, 0],
    ...         [0, 1, 0, 0, 0, 0],
    ...         [0, 1, 0, 0, 1, 0],
    ...         [0, 0, 0, 0, 1, 0]]
    >>> init = [0, 0]
    >>> goal = [len(grid) - 1, len(grid[0]) - 1]
    >>> cost = 1
    >>> heuristic = [[0] * len(grid[0]) for _ in range(len(grid))]
    >>> heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]
    >>> for i in range(len(grid)):
    ...     for j in range(len(grid[0])):
    ...         heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])
    ...         if grid[i][j] == 1:
    ...             heuristic[i][j] = 99
    >>> path, action = search(grid, init, goal, cost, heuristic)
    >>> path  # doctest: +NORMALIZE_WHITESPACE
    [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [3, 3],
    [2, 3], [2, 4], [2, 5], [3, 5], [4, 5]]
    >>> action  # doctest: +NORMALIZE_WHITESPACE
    [[0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0], [2, 0, 0, 0, 3, 3],
    [2, 0, 0, 0, 0, 2], [2, 3, 3, 3, 0, 2]]
    """"""
    closed = [
        [0 for col in range(len(grid[0]))] for row in range(len(grid))
    ]  # the reference grid
    closed[init[0]][init[1]] = 1
    action = [
        [0 for col in range(len(grid[0]))] for row in range(len(grid))
    ]  # the action grid

    x = init[0]
    y = init[1]
    g = 0
    f = g + heuristic[x][y]  # cost from starting cell to destination cell
    cell = [[f, g, x, y]]

    found = False  # flag that is set when search is complete
    resign = False  # flag set if we can't find expand

    while not found and not resign:
        if len(cell) == 0:
            raise ValueError(""Algorithm is unable to find solution"")
        else:  # to choose the least costliest action so as to move closer to the goal
            cell.sort()
            cell.reverse()
            next_cell = cell.pop()
            x = next_cell[2]
            y = next_cell[3]
            g = next_cell[1]

            if x == goal[0] and y == goal[1]:
                found = True
            else:
                for i in range(len(DIRECTIONS)):  # to try out different valid actions
                    x2 = x + DIRECTIONS[i][0]
                    y2 = y + DIRECTIONS[i][1]
                    if (
                        x2 >= 0
                        and x2 < len(grid)
                        and y2 >= 0
                        and y2 < len(grid[0])
                        and closed[x2][y2] == 0
                        and grid[x2][y2] == 0
                    ):
                        g2 = g + cost
                        f2 = g2 + heuristic[x2][y2]
                        cell.append([f2, g2, x2, y2])
                        closed[x2][y2] = 1
                        action[x2][y2] = i
    invpath = []
    x = goal[0]
    y = goal[1]
    invpath.append([x, y])  # we get the reverse path from here
    while x != init[0] or y != init[1]:
        x2 = x - DIRECTIONS[action[x][y]][0]
        y2 = y - DIRECTIONS[action[x][y]][1]
        x = x2
        y = y2
        invpath.append([x, y])

    path = []
    for i in range(len(invpath)):
        path.append(invpath[len(invpath) - 1 - i])
    return path, action",data\repos\Python\graphs\a_star.py,search,1124
869,basic_graphs.py::initialize_unweighted_directed_graph::8,"def initialize_unweighted_directed_graph(
    node_count: int, edge_count: int
) -> dict[int, list[int]]:
    graph: dict[int, list[int]] = {}
    for i in range(node_count):
        graph[i + 1] = []

    for e in range(edge_count):
        x, y = (int(i) for i in _input(f""Edge {e + 1}: <node1> <node2> ""))
        graph[x].append(y)
    return graph",data\repos\Python\graphs\basic_graphs.py,initialize_unweighted_directed_graph,105
870,basic_graphs.py::initialize_unweighted_undirected_graph::21,"def initialize_unweighted_undirected_graph(
    node_count: int, edge_count: int
) -> dict[int, list[int]]:
    graph: dict[int, list[int]] = {}
    for i in range(node_count):
        graph[i + 1] = []

    for e in range(edge_count):
        x, y = (int(i) for i in _input(f""Edge {e + 1}: <node1> <node2> ""))
        graph[x].append(y)
        graph[y].append(x)
    return graph",data\repos\Python\graphs\basic_graphs.py,initialize_unweighted_undirected_graph,113
871,basic_graphs.py::initialize_weighted_undirected_graph::35,"def initialize_weighted_undirected_graph(
    node_count: int, edge_count: int
) -> dict[int, list[tuple[int, int]]]:
    graph: dict[int, list[tuple[int, int]]] = {}
    for i in range(node_count):
        graph[i + 1] = []

    for e in range(edge_count):
        x, y, w = (int(i) for i in _input(f""Edge {e + 1}: <node1> <node2> <weight> ""))
        graph[x].append((y, w))
        graph[y].append((x, w))
    return graph",data\repos\Python\graphs\basic_graphs.py,initialize_weighted_undirected_graph,134
872,basic_graphs.py::dfs::79,"def dfs(g, s):
    """"""
    >>> dfs({1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: []}, 1)
    1
    2
    4
    5
    3
    """"""
    vis, _s = {s}, [s]
    print(s)
    while _s:
        flag = 0
        for i in g[_s[-1]]:
            if i not in vis:
                _s.append(i)
                vis.add(i)
                flag = 1
                print(i)
                break
        if not flag:
            _s.pop()",data\repos\Python\graphs\basic_graphs.py,dfs,145
873,basic_graphs.py::bfs::114,"def bfs(g, s):
    """"""
    >>> bfs({1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [8], 6: [], 7: [], 8: []}, 1)
    1
    2
    3
    4
    5
    6
    7
    8
    """"""
    vis, q = {s}, deque([s])
    print(s)
    while q:
        u = q.popleft()
        for v in g[u]:
            if v not in vis:
                vis.add(v)
                q.append(v)
                print(v)",data\repos\Python\graphs\basic_graphs.py,bfs,153
874,basic_graphs.py::dijk::149,"def dijk(g, s):
    """"""
    dijk({1: [(2, 7), (3, 9), (6, 14)],
        2: [(1, 7), (3, 10), (4, 15)],
        3: [(1, 9), (2, 10), (4, 11), (6, 2)],
        4: [(2, 15), (3, 11), (5, 6)],
        5: [(4, 6), (6, 9)],
        6: [(1, 14), (3, 2), (5, 9)]}, 1)
    7
    9
    11
    20
    20
    """"""
    dist, known, path = {s: 0}, set(), {s: 0}
    while True:
        if len(known) == len(g) - 1:
            break
        mini = 100000
        for key, value in dist:
            if key not in known and value < mini:
                mini = value
                u = key
        known.add(u)
        for v in g[u]:
            if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):
                dist[v[0]] = dist[u] + v[1]
                path[v[0]] = u
    for key, value in dist.items():
        if key != s:
            print(value)",data\repos\Python\graphs\basic_graphs.py,dijk,331
875,basic_graphs.py::topo::189,"def topo(g, ind=None, q=None):
    if q is None:
        q = [1]
    if ind is None:
        ind = [0] * (len(g) + 1)  # SInce oth Index is ignored
        for u in g:
            for v in g[u]:
                ind[v] += 1
        q = deque()
        for i in g:
            if ind[i] == 0:
                q.append(i)
    if len(q) == 0:
        return
    v = q.popleft()
    print(v)
    for w in g[v]:
        ind[w] -= 1
        if ind[w] == 0:
            q.append(w)
    topo(g, ind, q)",data\repos\Python\graphs\basic_graphs.py,topo,160
876,basic_graphs.py::adjm::219,"def adjm():
    r""""""
    Reading an Adjacency matrix

    Parameters:
        None

    Returns:
        tuple: A tuple containing a list of edges and number of edges

    Example:
    >>> # Simulate user input for 3 nodes
    >>> input_data = ""4\n0 1 0 1\n1 0 1 0\n0 1 0 1\n1 0 1 0\n""
    >>> import sys,io
    >>> original_input = sys.stdin
    >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing
    >>> adjm()
    ([(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)], 4)
    >>> sys.stdin = original_input  # Restore original stdin
    """"""
    n = int(input().strip())
    a = []
    for _ in range(n):
        a.append(tuple(map(int, input().strip().split())))
    return a, n",data\repos\Python\graphs\basic_graphs.py,adjm,237
877,basic_graphs.py::floy::259,"def floy(a_and_n):
    (a, n) = a_and_n
    dist = list(a)
    path = [[0] * n for i in range(n)]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    path[i][k] = k
    print(dist)",data\repos\Python\graphs\basic_graphs.py,floy,109
878,basic_graphs.py::prim::284,"def prim(g, s):
    dist, known, path = {s: 0}, set(), {s: 0}
    while True:
        if len(known) == len(g) - 1:
            break
        mini = 100000
        for key, value in dist.items():
            if key not in known and value < mini:
                mini = value
                u = key
        known.add(u)
        for v in g[u]:
            if v[0] not in known and v[1] < dist.get(v[0], 100000):
                dist[v[0]] = v[1]
                path[v[0]] = u
    return dist",data\repos\Python\graphs\basic_graphs.py,prim,145
879,basic_graphs.py::edglist::313,"def edglist():
    r""""""
    Get the edges and number of edges from the user

    Parameters:
        None

    Returns:
        tuple: A tuple containing a list of edges and number of edges

    Example:
    >>> # Simulate user input for 3 edges and 4 vertices: (1, 2), (2, 3), (3, 4)
    >>> input_data = ""4 3\n1 2\n2 3\n3 4\n""
    >>> import sys,io
    >>> original_input = sys.stdin
    >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing
    >>> edglist()
    ([(1, 2), (2, 3), (3, 4)], 4)
    >>> sys.stdin = original_input  # Restore original stdin
    """"""
    n, m = tuple(map(int, input().split("" "")))
    edges = []
    for _ in range(m):
        edges.append(tuple(map(int, input().split("" ""))))
    return edges, n",data\repos\Python\graphs\basic_graphs.py,edglist,225
880,basic_graphs.py::krusk::350,"def krusk(e_and_n):
    """"""
    Sort edges on the basis of distance
    """"""
    (e, n) = e_and_n
    e.sort(reverse=True, key=lambda x: x[2])
    s = [{i} for i in range(1, n + 1)]
    while True:
        if len(s) == 1:
            break
        print(s)
        x = e.pop()
        for i in range(len(s)):
            if x[0] in s[i]:
                break
        for j in range(len(s)):
            if x[1] in s[j]:
                if i == j:
                    break
                s[j].update(s[i])
                s.pop(i)
                break",data\repos\Python\graphs\basic_graphs.py,krusk,153
881,basic_graphs.py::find_isolated_nodes::374,"def find_isolated_nodes(graph):
    """"""
    Find the isolated node in the graph

    Parameters:
    graph (dict): A dictionary representing a graph.

    Returns:
    list: A list of isolated nodes.

    Examples:
    >>> graph1 = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []}
    >>> find_isolated_nodes(graph1)
    [4]

    >>> graph2 = {'A': ['B', 'C'], 'B': ['A'], 'C': ['A'], 'D': []}
    >>> find_isolated_nodes(graph2)
    ['D']

    >>> graph3 = {'X': [], 'Y': [], 'Z': []}
    >>> find_isolated_nodes(graph3)
    ['X', 'Y', 'Z']

    >>> graph4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}
    >>> find_isolated_nodes(graph4)
    []

    >>> graph5 = {}
    >>> find_isolated_nodes(graph5)
    []
    """"""
    isolated = []
    for node in graph:
        if not graph[node]:
            isolated.append(node)
    return isolated",data\repos\Python\graphs\basic_graphs.py,find_isolated_nodes,264
882,bellman_ford.py::print_distance::4,"def print_distance(distance: list[float], src):
    print(f""Vertex\tShortest Distance from vertex {src}"")
    for i, d in enumerate(distance):
        print(f""{i}\t\t{d}"")",data\repos\Python\graphs\bellman_ford.py,print_distance,44
883,bellman_ford.py::check_negative_cycle::10,"def check_negative_cycle(
    graph: list[dict[str, int]], distance: list[float], edge_count: int
):
    for j in range(edge_count):
        u, v, w = (graph[j][k] for k in [""src"", ""dst"", ""weight""])
        if distance[u] != float(""inf"") and distance[u] + w < distance[v]:
            return True
    return False",data\repos\Python\graphs\bellman_ford.py,check_negative_cycle,86
884,bellman_ford.py::bellman_ford::20,"def bellman_ford(
    graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int
) -> list[float]:
    """"""
    Returns shortest paths from a vertex src to all
    other vertices.
    >>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]
    >>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges]
    >>> bellman_ford(g, 4, 4, 0)
    [0.0, -2.0, 8.0, 5.0]
    >>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges + [(1, 3, 5)]]
    >>> bellman_ford(g, 4, 5, 0)
    Traceback (most recent call last):
     ...
    Exception: Negative cycle found
    """"""
    distance = [float(""inf"")] * vertex_count
    distance[src] = 0.0

    for _ in range(vertex_count - 1):
        for j in range(edge_count):
            u, v, w = (graph[j][k] for k in [""src"", ""dst"", ""weight""])

            if distance[u] != float(""inf"") and distance[u] + w < distance[v]:
                distance[v] = distance[u] + w

    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)
    if negative_cycle_exists:
        raise Exception(""Negative cycle found"")

    return distance",data\repos\Python\graphs\bellman_ford.py,bellman_ford,362
885,bidirectional_a_star.py::calculate_heuristic::63,"    def calculate_heuristic(self) -> float:
        """"""
        Heuristic for the A*
        """"""
        dy = self.pos_x - self.goal_x
        dx = self.pos_y - self.goal_y
        if HEURISTIC == 1:
            return abs(dx) + abs(dy)
        else:
            return sqrt(dy**2 + dx**2)",data\repos\Python\graphs\bidirectional_a_star.py,calculate_heuristic,75
886,bidirectional_a_star.py::search::103,"    def search(self) -> list[TPosition]:
        while self.open_nodes:
            # Open Nodes are sorted using __lt__
            self.open_nodes.sort()
            current_node = self.open_nodes.pop(0)

            if current_node.pos == self.target.pos:
                return self.retrace_path(current_node)

            self.closed_nodes.append(current_node)
            successors = self.get_successors(current_node)

            for child_node in successors:
                if child_node in self.closed_nodes:
                    continue

                if child_node not in self.open_nodes:
                    self.open_nodes.append(child_node)
                else:
                    # retrieve the best current path
                    better_node = self.open_nodes.pop(self.open_nodes.index(child_node))

                    if child_node.g_cost < better_node.g_cost:
                        self.open_nodes.append(child_node)
                    else:
                        self.open_nodes.append(better_node)

        return [self.start.pos]",data\repos\Python\graphs\bidirectional_a_star.py,search,182
887,bidirectional_a_star.py::get_successors::132,"    def get_successors(self, parent: Node) -> list[Node]:
        """"""
        Returns a list of successors (both in the grid and free spaces)
        """"""
        successors = []
        for action in delta:
            pos_x = parent.pos_x + action[1]
            pos_y = parent.pos_y + action[0]
            if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):
                continue

            if grid[pos_y][pos_x] != 0:
                continue

            successors.append(
                Node(
                    pos_x,
                    pos_y,
                    self.target.pos_y,
                    self.target.pos_x,
                    parent.g_cost + 1,
                    parent,
                )
            )
        return successors",data\repos\Python\graphs\bidirectional_a_star.py,get_successors,164
888,bidirectional_a_star.py::retrace_path::158,"    def retrace_path(self, node: Node | None) -> list[TPosition]:
        """"""
        Retrace the path from parents to parents until start node
        """"""
        current_node = node
        path = []
        while current_node is not None:
            path.append((current_node.pos_y, current_node.pos_x))
            current_node = current_node.parent
        path.reverse()
        return path",data\repos\Python\graphs\bidirectional_a_star.py,retrace_path,82
889,bidirectional_a_star.py::search::189,"    def search(self) -> list[TPosition]:
        while self.fwd_astar.open_nodes or self.bwd_astar.open_nodes:
            self.fwd_astar.open_nodes.sort()
            self.bwd_astar.open_nodes.sort()
            current_fwd_node = self.fwd_astar.open_nodes.pop(0)
            current_bwd_node = self.bwd_astar.open_nodes.pop(0)

            if current_bwd_node.pos == current_fwd_node.pos:
                return self.retrace_bidirectional_path(
                    current_fwd_node, current_bwd_node
                )

            self.fwd_astar.closed_nodes.append(current_fwd_node)
            self.bwd_astar.closed_nodes.append(current_bwd_node)

            self.fwd_astar.target = current_bwd_node
            self.bwd_astar.target = current_fwd_node

            successors = {
                self.fwd_astar: self.fwd_astar.get_successors(current_fwd_node),
                self.bwd_astar: self.bwd_astar.get_successors(current_bwd_node),
            }

            for astar in [self.fwd_astar, self.bwd_astar]:
                for child_node in successors[astar]:
                    if child_node in astar.closed_nodes:
                        continue

                    if child_node not in astar.open_nodes:
                        astar.open_nodes.append(child_node)
                    else:
                        # retrieve the best current path
                        better_node = astar.open_nodes.pop(
                            astar.open_nodes.index(child_node)
                        )

                        if child_node.g_cost < better_node.g_cost:
                            astar.open_nodes.append(child_node)
                        else:
                            astar.open_nodes.append(better_node)

        return [self.fwd_astar.start.pos]",data\repos\Python\graphs\bidirectional_a_star.py,search,350
890,bidirectional_a_star.py::retrace_bidirectional_path::232,"    def retrace_bidirectional_path(
        self, fwd_node: Node, bwd_node: Node
    ) -> list[TPosition]:
        fwd_path = self.fwd_astar.retrace_path(fwd_node)
        bwd_path = self.bwd_astar.retrace_path(bwd_node)
        bwd_path.pop()
        bwd_path.reverse()
        path = fwd_path + bwd_path
        return path",data\repos\Python\graphs\bidirectional_a_star.py,retrace_bidirectional_path,87
891,bidirectional_breadth_first_search.py::search::62,"    def search(self) -> Path | None:
        while self.node_queue:
            current_node = self.node_queue.pop(0)

            if current_node.pos == self.target.pos:
                self.reached = True
                return self.retrace_path(current_node)

            successors = self.get_successors(current_node)

            for node in successors:
                self.node_queue.append(node)

        if not self.reached:
            return [self.start.pos]
        return None",data\repos\Python\graphs\bidirectional_breadth_first_search.py,search,93
892,bidirectional_breadth_first_search.py::get_successors::79,"    def get_successors(self, parent: Node) -> list[Node]:
        """"""
        Returns a list of successors (both in the grid and free spaces)
        """"""
        successors = []
        for action in delta:
            pos_x = parent.pos_x + action[1]
            pos_y = parent.pos_y + action[0]
            if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):
                continue

            if grid[pos_y][pos_x] != 0:
                continue

            successors.append(
                Node(pos_x, pos_y, self.target.pos_y, self.target.pos_x, parent)
            )
        return successors",data\repos\Python\graphs\bidirectional_breadth_first_search.py,get_successors,148
893,bidirectional_breadth_first_search.py::retrace_path::98,"    def retrace_path(self, node: Node | None) -> Path:
        """"""
        Retrace the path from parents to parents until start node
        """"""
        current_node = node
        path = []
        while current_node is not None:
            path.append((current_node.pos_y, current_node.pos_x))
            current_node = current_node.parent
        path.reverse()
        return path",data\repos\Python\graphs\bidirectional_breadth_first_search.py,retrace_path,80
894,bidirectional_breadth_first_search.py::search::130,"    def search(self) -> Path | None:
        while self.fwd_bfs.node_queue or self.bwd_bfs.node_queue:
            current_fwd_node = self.fwd_bfs.node_queue.pop(0)
            current_bwd_node = self.bwd_bfs.node_queue.pop(0)

            if current_bwd_node.pos == current_fwd_node.pos:
                self.reached = True
                return self.retrace_bidirectional_path(
                    current_fwd_node, current_bwd_node
                )

            self.fwd_bfs.target = current_bwd_node
            self.bwd_bfs.target = current_fwd_node

            successors = {
                self.fwd_bfs: self.fwd_bfs.get_successors(current_fwd_node),
                self.bwd_bfs: self.bwd_bfs.get_successors(current_bwd_node),
            }

            for bfs in [self.fwd_bfs, self.bwd_bfs]:
                for node in successors[bfs]:
                    bfs.node_queue.append(node)

        if not self.reached:
            return [self.fwd_bfs.start.pos]
        return None",data\repos\Python\graphs\bidirectional_breadth_first_search.py,search,225
895,bidirectional_breadth_first_search.py::retrace_bidirectional_path::157,"    def retrace_bidirectional_path(self, fwd_node: Node, bwd_node: Node) -> Path:
        fwd_path = self.fwd_bfs.retrace_path(fwd_node)
        bwd_path = self.bwd_bfs.retrace_path(bwd_node)
        bwd_path.pop()
        bwd_path.reverse()
        path = fwd_path + bwd_path
        return path",data\repos\Python\graphs\bidirectional_breadth_first_search.py,retrace_bidirectional_path,81
896,bidirectional_search.py::expand_search::17,"def expand_search(
    graph: dict[int, list[int]],
    queue: deque[int],
    parents: dict[int, int | None],
    opposite_direction_parents: dict[int, int | None],
) -> int | None:
    if not queue:
        return None

    current = queue.popleft()
    for neighbor in graph[current]:
        if neighbor in parents:
            continue

        parents[neighbor] = current
        queue.append(neighbor)

        # Check if this creates an intersection
        if neighbor in opposite_direction_parents:
            return neighbor

    return None",data\repos\Python\graphs\bidirectional_search.py,expand_search,117
897,bidirectional_search.py::construct_path::41,"def construct_path(current: int | None, parents: dict[int, int | None]) -> list[int]:
    path: list[int] = []
    while current is not None:
        path.append(current)
        current = parents[current]
    return path",data\repos\Python\graphs\bidirectional_search.py,construct_path,51
898,bidirectional_search.py::bidirectional_search::49,"def bidirectional_search(
    graph: dict[int, list[int]], start: int, goal: int
) -> list[int] | None:
    """"""
    Perform bidirectional search on a graph to find the shortest path.

    Args:
        graph: A dictionary where keys are nodes and values are lists of adjacent nodes
        start: The starting node
        goal: The target node

    Returns:
        A list representing the path from start to goal, or None if no path exists

    Examples:
        >>> graph = {
        ...     0: [1, 2],
        ...     1: [0, 3, 4],
        ...     2: [0, 5, 6],
        ...     3: [1, 7],
        ...     4: [1, 8],
        ...     5: [2, 9],
        ...     6: [2, 10],
        ...     7: [3, 11],
        ...     8: [4, 11],
        ...     9: [5, 11],
        ...     10: [6, 11],
        ...     11: [7, 8, 9, 10],
        ... }
        >>> bidirectional_search(graph=graph, start=0, goal=11)
        [0, 1, 3, 7, 11]
        >>> bidirectional_search(graph=graph, start=5, goal=5)
        [5]
        >>> disconnected_graph = {
        ...     0: [1, 2],
        ...     1: [0],
        ...     2: [0],
        ...     3: [4],
        ...     4: [3],
        ... }
        >>> bidirectional_search(graph=disconnected_graph, start=0, goal=3) is None
        True
    """"""
    if start == goal:
        return [start]

    # Check if start and goal are in the graph
    if start not in graph or goal not in graph:
        return None

    # Initialize forward and backward search dictionaries
    # Each maps a node to its parent in the search
    forward_parents: dict[int, int | None] = {start: None}
    backward_parents: dict[int, int | None] = {goal: None}

    # Initialize forward and backward search queues
    forward_queue = deque([start])
    backward_queue = deque([goal])

    # Intersection node (where the two searches meet)
    intersection = None

    # Continue until both queues are empty or an intersection is found
    while forward_queue and backward_queue and intersection is None:
        # Expand forward search
        intersection = expand_search(
            graph=graph,
            queue=forward_queue,
            parents=forward_parents,
            opposite_direction_parents=backward_parents,
        )

        # If no intersection found, expand backward search
        if intersection is not None:
            break

        intersection = expand_search(
            graph=graph,
            queue=backward_queue,
            parents=backward_parents,
            opposite_direction_parents=forward_parents,
        )

    # If no intersection found, there's no path
    if intersection is None:
        return None

    # Construct path from start to intersection
    forward_path: list[int] = construct_path(
        current=intersection, parents=forward_parents
    )
    forward_path.reverse()

    # Construct path from intersection to goal
    backward_path: list[int] = construct_path(
        current=backward_parents[intersection], parents=backward_parents
    )

    # Return the complete path
    return forward_path + backward_path",data\repos\Python\graphs\bidirectional_search.py,bidirectional_search,769
899,bidirectional_search.py::main::151,"def main() -> None:
    """"""
    Run example of bidirectional search algorithm.

    Examples:
        >>> main()  # doctest: +NORMALIZE_WHITESPACE
        Path from 0 to 11: [0, 1, 3, 7, 11]
        Path from 5 to 5: [5]
        Path from 0 to 3: None
    """"""
    # Example graph represented as an adjacency list
    example_graph = {
        0: [1, 2],
        1: [0, 3, 4],
        2: [0, 5, 6],
        3: [1, 7],
        4: [1, 8],
        5: [2, 9],
        6: [2, 10],
        7: [3, 11],
        8: [4, 11],
        9: [5, 11],
        10: [6, 11],
        11: [7, 8, 9, 10],
    }

    # Test case 1: Path exists
    start, goal = 0, 11
    path = bidirectional_search(graph=example_graph, start=start, goal=goal)
    print(f""Path from {start} to {goal}: {path}"")

    # Test case 2: Start and goal are the same
    start, goal = 5, 5
    path = bidirectional_search(graph=example_graph, start=start, goal=goal)
    print(f""Path from {start} to {goal}: {path}"")

    # Test case 3: No path exists (disconnected graph)
    disconnected_graph = {
        0: [1, 2],
        1: [0],
        2: [0],
        3: [4],
        4: [3],
    }
    start, goal = 0, 3
    path = bidirectional_search(graph=disconnected_graph, start=start, goal=goal)
    print(f""Path from {start} to {goal}: {path}"")",data\repos\Python\graphs\bidirectional_search.py,main,454
900,bi_directional_dijkstra.py::pass_and_relaxation::19,"def pass_and_relaxation(
    graph: dict,
    v: str,
    visited_forward: set,
    visited_backward: set,
    cst_fwd: dict,
    cst_bwd: dict,
    queue: PriorityQueue,
    parent: dict,
    shortest_distance: float,
) -> float:
    for nxt, d in graph[v]:
        if nxt in visited_forward:
            continue
        old_cost_f = cst_fwd.get(nxt, np.inf)
        new_cost_f = cst_fwd[v] + d
        if new_cost_f < old_cost_f:
            queue.put((new_cost_f, nxt))
            cst_fwd[nxt] = new_cost_f
            parent[nxt] = v
        if (
            nxt in visited_backward
            and cst_fwd[v] + d + cst_bwd[nxt] < shortest_distance
        ):
            shortest_distance = cst_fwd[v] + d + cst_bwd[nxt]
    return shortest_distance",data\repos\Python\graphs\bi_directional_dijkstra.py,pass_and_relaxation,197
901,bi_directional_dijkstra.py::bidirectional_dij::47,"def bidirectional_dij(
    source: str, destination: str, graph_forward: dict, graph_backward: dict
) -> int:
    """"""
    Bi-directional Dijkstra's algorithm.

    Returns:
        shortest_path_distance (int): length of the shortest path.

    Warnings:
        If the destination is not reachable, function returns -1

    >>> bidirectional_dij(""E"", ""F"", graph_fwd, graph_bwd)
    3
    """"""
    shortest_path_distance = -1

    visited_forward = set()
    visited_backward = set()
    cst_fwd = {source: 0}
    cst_bwd = {destination: 0}
    parent_forward = {source: None}
    parent_backward = {destination: None}
    queue_forward: PriorityQueue[Any] = PriorityQueue()
    queue_backward: PriorityQueue[Any] = PriorityQueue()

    shortest_distance = np.inf

    queue_forward.put((0, source))
    queue_backward.put((0, destination))

    if source == destination:
        return 0

    while not queue_forward.empty() and not queue_backward.empty():
        _, v_fwd = queue_forward.get()
        visited_forward.add(v_fwd)

        _, v_bwd = queue_backward.get()
        visited_backward.add(v_bwd)

        shortest_distance = pass_and_relaxation(
            graph_forward,
            v_fwd,
            visited_forward,
            visited_backward,
            cst_fwd,
            cst_bwd,
            queue_forward,
            parent_forward,
            shortest_distance,
        )

        shortest_distance = pass_and_relaxation(
            graph_backward,
            v_bwd,
            visited_backward,
            visited_forward,
            cst_bwd,
            cst_fwd,
            queue_backward,
            parent_backward,
            shortest_distance,
        )

        if cst_fwd[v_fwd] + cst_bwd[v_bwd] >= shortest_distance:
            break

    if shortest_distance != np.inf:
        shortest_path_distance = shortest_distance
    return shortest_path_distance",data\repos\Python\graphs\bi_directional_dijkstra.py,bidirectional_dij,402
902,boruvka.py::test_vector::141,"def test_vector() -> None:
    """"""
    >>> g = Graph(8)
    >>> for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4),
    ...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)):
    ...        g.add_edge(*u_v_w)
    >>> g.boruvka()
    Added edge [0 - 3]
    Added weight: 5
    <BLANKLINE>
    Added edge [0 - 1]
    Added weight: 10
    <BLANKLINE>
    Added edge [2 - 3]
    Added weight: 4
    <BLANKLINE>
    Added edge [4 - 7]
    Added weight: 5
    <BLANKLINE>
    Added edge [4 - 5]
    Added weight: 10
    <BLANKLINE>
    Added edge [6 - 7]
    Added weight: 4
    <BLANKLINE>
    Added edge [3 - 4]
    Added weight: 8
    <BLANKLINE>
    The total weight of the minimal spanning tree is: 46
    """"""",data\repos\Python\graphs\boruvka.py,test_vector,315
903,boruvka.py::add_edge::49,"    def add_edge(self, u_node: int, v_node: int, weight: int) -> None:
        """"""Adds an edge in the format [first, second, edge weight] to graph.""""""

        self.m_edges.append([u_node, v_node, weight])",data\repos\Python\graphs\boruvka.py,add_edge,56
904,boruvka.py::find_component::54,"    def find_component(self, u_node: int) -> int:
        """"""Propagates a new component throughout a given component.""""""

        if self.m_component[u_node] == u_node:
            return u_node
        return self.find_component(self.m_component[u_node])",data\repos\Python\graphs\boruvka.py,find_component,55
905,boruvka.py::set_component::61,"    def set_component(self, u_node: int) -> None:
        """"""Finds the component index of a given node""""""

        if self.m_component[u_node] != u_node:
            for k in self.m_component:
                self.m_component[k] = self.find_component(k)",data\repos\Python\graphs\boruvka.py,set_component,58
906,boruvka.py::union::68,"    def union(self, component_size: list[int], u_node: int, v_node: int) -> None:
        """"""Union finds the roots of components for two nodes, compares the components
        in terms of size, and attaches the smaller one to the larger one to form
        single component""""""

        if component_size[u_node] <= component_size[v_node]:
            self.m_component[u_node] = v_node
            component_size[v_node] += component_size[u_node]
            self.set_component(u_node)

        elif component_size[u_node] >= component_size[v_node]:
            self.m_component[v_node] = self.find_component(u_node)
            component_size[u_node] += component_size[v_node]
            self.set_component(v_node)",data\repos\Python\graphs\boruvka.py,union,151
907,boruvka.py::boruvka::83,"    def boruvka(self) -> None:
        """"""Performs Borvka's algorithm to find MST.""""""

        # Initialize additional lists required to algorithm.
        component_size = []
        mst_weight = 0

        minimum_weight_edge: list[Any] = [-1] * self.m_num_of_nodes

        # A list of components (initialized to all of the nodes)
        for node in range(self.m_num_of_nodes):
            self.m_component.update({node: node})
            component_size.append(1)

        num_of_components = self.m_num_of_nodes

        while num_of_components > 1:
            for edge in self.m_edges:
                u, v, w = edge

                u_component = self.m_component[u]
                v_component = self.m_component[v]

                if u_component != v_component:
                    """"""If the current minimum weight edge of component u doesn't
                    exist (is -1), or if it's greater than the edge we're
                    observing right now, we will assign the value of the edge
                    we're observing to it.

                    If the current minimum weight edge of component v doesn't
                    exist (is -1), or if it's greater than the edge we're
                    observing right now, we will assign the value of the edge
                    we're observing to it""""""

                    for component in (u_component, v_component):
                        if (
                            minimum_weight_edge[component] == -1
                            or minimum_weight_edge[component][2] > w
                        ):
                            minimum_weight_edge[component] = [u, v, w]

            for edge in minimum_weight_edge:
                if isinstance(edge, list):
                    u, v, w = edge

                    u_component = self.m_component[u]
                    v_component = self.m_component[v]

                    if u_component != v_component:
                        mst_weight += w
                        self.union(component_size, u_component, v_component)
                        print(f""Added edge [{u} - {v}]\nAdded weight: {w}\n"")
                        num_of_components -= 1

            minimum_weight_edge = [-1] * self.m_num_of_nodes
        print(f""The total weight of the minimal spanning tree is: {mst_weight}"")",data\repos\Python\graphs\boruvka.py,boruvka,463
908,breadth_first_search.py::print_graph::14,"    def print_graph(self) -> None:
        """"""
        prints adjacency list representation of graaph
        >>> g = Graph()
        >>> g.print_graph()
        >>> g.add_edge(0, 1)
        >>> g.print_graph()
        0  :  1
        """"""
        for i in self.vertices:
            print(i, "" : "", "" -> "".join([str(j) for j in self.vertices[i]]))",data\repos\Python\graphs\breadth_first_search.py,print_graph,90
909,breadth_first_search.py::add_edge::26,"    def add_edge(self, from_vertex: int, to_vertex: int) -> None:
        """"""
        adding the edge between two vertices
        >>> g = Graph()
        >>> g.print_graph()
        >>> g.add_edge(0, 1)
        >>> g.print_graph()
        0  :  1
        """"""
        if from_vertex in self.vertices:
            self.vertices[from_vertex].append(to_vertex)
        else:
            self.vertices[from_vertex] = [to_vertex]",data\repos\Python\graphs\breadth_first_search.py,add_edge,101
910,breadth_first_search.py::bfs::40,"    def bfs(self, start_vertex: int) -> set[int]:
        """"""
        >>> g = Graph()
        >>> g.add_edge(0, 1)
        >>> g.add_edge(0, 1)
        >>> g.add_edge(0, 2)
        >>> g.add_edge(1, 2)
        >>> g.add_edge(2, 0)
        >>> g.add_edge(2, 3)
        >>> g.add_edge(3, 3)
        >>> sorted(g.bfs(2))
        [0, 1, 2, 3]
        """"""
        # initialize set for storing already visited vertices
        visited = set()

        # create a first in first out queue to store all the vertices for BFS
        queue: Queue = Queue()

        # mark the source node as visited and enqueue it
        visited.add(start_vertex)
        queue.put(start_vertex)

        while not queue.empty():
            vertex = queue.get()

            # loop through all adjacent vertex and enqueue it if not yet visited
            for adjacent_vertex in self.vertices[vertex]:
                if adjacent_vertex not in visited:
                    queue.put(adjacent_vertex)
                    visited.add(adjacent_vertex)
        return visited",data\repos\Python\graphs\breadth_first_search.py,bfs,247
911,breadth_first_search_2.py::breadth_first_search::32,"def breadth_first_search(graph: dict, start: str) -> list[str]:
    """"""
    Implementation of breadth first search using queue.Queue.

    >>> ''.join(breadth_first_search(G, 'A'))
    'ABCDEF'
    """"""
    explored = {start}
    result = [start]
    queue: Queue = Queue()
    queue.put(start)
    while not queue.empty():
        v = queue.get()
        for w in graph[v]:
            if w not in explored:
                explored.add(w)
                result.append(w)
                queue.put(w)
    return result",data\repos\Python\graphs\breadth_first_search_2.py,breadth_first_search,117
912,breadth_first_search_2.py::breadth_first_search_with_deque::53,"def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:
    """"""
    Implementation of breadth first search using collection.queue.

    >>> ''.join(breadth_first_search_with_deque(G, 'A'))
    'ABCDEF'
    """"""
    visited = {start}
    result = [start]
    queue = deque([start])
    while queue:
        v = queue.popleft()
        for child in graph[v]:
            if child not in visited:
                visited.add(child)
                result.append(child)
                queue.append(child)
    return result",data\repos\Python\graphs\breadth_first_search_2.py,breadth_first_search_with_deque,117
913,breadth_first_search_2.py::benchmark_function::73,"def benchmark_function(name: str) -> None:
    setup = f""from __main__ import G, {name}""
    number = 10000
    res = timeit(f""{name}(G, 'A')"", setup=setup, number=number)
    print(f""{name:<35} finished {number} runs in {res:.5f} seconds"")",data\repos\Python\graphs\breadth_first_search_2.py,benchmark_function,77
914,breadth_first_search_shortest_path.py::breath_first_search::29,"    def breath_first_search(self) -> None:
        """"""
        This function is a helper for running breath first search on this graph.
        >>> g = Graph(graph, ""G"")
        >>> g.breath_first_search()
        >>> g.parent
        {'G': None, 'C': 'G', 'A': 'C', 'F': 'C', 'B': 'A', 'E': 'A', 'D': 'B'}
        """"""
        visited = {self.source_vertex}
        self.parent[self.source_vertex] = None
        queue = [self.source_vertex]  # first in first out queue

        while queue:
            vertex = queue.pop(0)
            for adjacent_vertex in self.graph[vertex]:
                if adjacent_vertex not in visited:
                    visited.add(adjacent_vertex)
                    self.parent[adjacent_vertex] = vertex
                    queue.append(adjacent_vertex)",data\repos\Python\graphs\breadth_first_search_shortest_path.py,breath_first_search,183
915,breadth_first_search_shortest_path.py::shortest_path::49,"    def shortest_path(self, target_vertex: str) -> str:
        """"""
        This shortest path function returns a string, describing the result:
        1.) No path is found. The string is a human readable message to indicate this.
        2.) The shortest path is found. The string is in the form
            `v1(->v2->v3->...->vn)`, where v1 is the source vertex and vn is the target
            vertex, if it exists separately.

        >>> g = Graph(graph, ""G"")
        >>> g.breath_first_search()

        Case 1 - No path is found.
        >>> g.shortest_path(""Foo"")
        Traceback (most recent call last):
            ...
        ValueError: No path from vertex: G to vertex: Foo

        Case 2 - The path is found.
        >>> g.shortest_path(""D"")
        'G->C->A->B->D'
        >>> g.shortest_path(""G"")
        'G'
        """"""
        if target_vertex == self.source_vertex:
            return self.source_vertex

        target_vertex_parent = self.parent.get(target_vertex)
        if target_vertex_parent is None:
            msg = (
                f""No path from vertex: {self.source_vertex} to vertex: {target_vertex}""
            )
            raise ValueError(msg)

        return self.shortest_path(target_vertex_parent) + f""->{target_vertex}""",data\repos\Python\graphs\breadth_first_search_shortest_path.py,shortest_path,294
916,breadth_first_search_shortest_path_2.py::bfs_shortest_path::21,"def bfs_shortest_path(graph: dict, start, goal) -> list[str]:
    """"""Find the shortest path between `start` and `goal` nodes.
    Args:
        graph (dict): node/list of neighboring nodes key/value pairs.
        start: start node.
        goal: target node.
    Returns:
        Shortest path between `start` and `goal` nodes as a string of nodes.
        'Not found' string if no path found.
    Example:
        >>> bfs_shortest_path(demo_graph, ""G"", ""D"")
        ['G', 'C', 'A', 'B', 'D']
        >>> bfs_shortest_path(demo_graph, ""G"", ""G"")
        ['G']
        >>> bfs_shortest_path(demo_graph, ""G"", ""Unknown"")
        []
    """"""
    # keep track of explored nodes
    explored = set()
    # keep track of all the paths to be checked
    queue = deque([[start]])

    # return path if start is goal
    if start == goal:
        return [start]

    # keeps looping until all possible paths have been checked
    while queue:
        # pop the first path from the queue
        path = queue.popleft()
        # get the last node from the path
        node = path[-1]
        if node not in explored:
            neighbours = graph[node]
            # go through all neighbour nodes, construct a new path and
            # push it into the queue
            for neighbour in neighbours:
                new_path = list(path)
                new_path.append(neighbour)
                queue.append(new_path)
                # return path if neighbour is goal
                if neighbour == goal:
                    return new_path

            # mark node as explored
            explored.add(node)

    # in case there's no path between the 2 nodes
    return []",data\repos\Python\graphs\breadth_first_search_shortest_path_2.py,bfs_shortest_path,382
917,breadth_first_search_shortest_path_2.py::bfs_shortest_path_distance::72,"def bfs_shortest_path_distance(graph: dict, start, target) -> int:
    """"""Find the shortest path distance between `start` and `target` nodes.
    Args:
        graph: node/list of neighboring nodes key/value pairs.
        start: node to start search from.
        target: node to search for.
    Returns:
        Number of edges in the shortest path between `start` and `target` nodes.
        -1 if no path exists.
    Example:
        >>> bfs_shortest_path_distance(demo_graph, ""G"", ""D"")
        4
        >>> bfs_shortest_path_distance(demo_graph, ""A"", ""A"")
        0
        >>> bfs_shortest_path_distance(demo_graph, ""A"", ""Unknown"")
        -1
    """"""
    if not graph or start not in graph or target not in graph:
        return -1
    if start == target:
        return 0
    queue = deque([start])
    visited = set(start)
    # Keep tab on distances from `start` node.
    dist = {start: 0, target: -1}
    while queue:
        node = queue.popleft()
        if node == target:
            dist[target] = (
                dist[node] if dist[target] == -1 else min(dist[target], dist[node])
            )
        for adjacent in graph[node]:
            if adjacent not in visited:
                visited.add(adjacent)
                queue.append(adjacent)
                dist[adjacent] = dist[node] + 1
    return dist[target]",data\repos\Python\graphs\breadth_first_search_shortest_path_2.py,bfs_shortest_path_distance,322
918,breadth_first_search_zero_one_shortest_path.py::add_edge::37,"    def add_edge(self, from_vertex: int, to_vertex: int, weight: int):
        """"""
        >>> g = AdjacencyList(2)
        >>> g.add_edge(0, 1, 0)
        >>> g.add_edge(1, 0, 1)
        >>> list(g[0])
        [Edge(destination_vertex=1, weight=0)]
        >>> list(g[1])
        [Edge(destination_vertex=0, weight=1)]
        >>> g.add_edge(0, 1, 2)
        Traceback (most recent call last):
            ...
        ValueError: Edge weight must be either 0 or 1.
        >>> g.add_edge(0, 2, 1)
        Traceback (most recent call last):
            ...
        ValueError: Vertex indexes must be in [0; size).
        """"""
        if weight not in (0, 1):
            raise ValueError(""Edge weight must be either 0 or 1."")

        if to_vertex < 0 or to_vertex >= self.size:
            raise ValueError(""Vertex indexes must be in [0; size)."")

        self._graph[from_vertex].append(Edge(to_vertex, weight))",data\repos\Python\graphs\breadth_first_search_zero_one_shortest_path.py,add_edge,247
919,breadth_first_search_zero_one_shortest_path.py::get_shortest_path::63,"    def get_shortest_path(self, start_vertex: int, finish_vertex: int) -> int | None:
        """"""
        Return the shortest distance from start_vertex to finish_vertex in 0-1-graph.
              1                  1         1
         0--------->3        6--------7>------->8
         |          ^        ^        ^         |1
         |          |        |        |0        v
        0|          |0      1|        9-------->10
         |          |        |        ^    1
         v          |        |        |0
         1--------->2<-------4------->5
              0         1        1
        >>> g = AdjacencyList(11)
        >>> g.add_edge(0, 1, 0)
        >>> g.add_edge(0, 3, 1)
        >>> g.add_edge(1, 2, 0)
        >>> g.add_edge(2, 3, 0)
        >>> g.add_edge(4, 2, 1)
        >>> g.add_edge(4, 5, 1)
        >>> g.add_edge(4, 6, 1)
        >>> g.add_edge(5, 9, 0)
        >>> g.add_edge(6, 7, 1)
        >>> g.add_edge(7, 8, 1)
        >>> g.add_edge(8, 10, 1)
        >>> g.add_edge(9, 7, 0)
        >>> g.add_edge(9, 10, 1)
        >>> g.add_edge(1, 2, 2)
        Traceback (most recent call last):
            ...
        ValueError: Edge weight must be either 0 or 1.
        >>> g.get_shortest_path(0, 3)
        0
        >>> g.get_shortest_path(0, 4)
        Traceback (most recent call last):
            ...
        ValueError: No path from start_vertex to finish_vertex.
        >>> g.get_shortest_path(4, 10)
        2
        >>> g.get_shortest_path(4, 8)
        2
        >>> g.get_shortest_path(0, 1)
        0
        >>> g.get_shortest_path(1, 0)
        Traceback (most recent call last):
            ...
        ValueError: No path from start_vertex to finish_vertex.
        """"""
        queue = deque([start_vertex])
        distances: list[int | None] = [None] * self.size
        distances[start_vertex] = 0

        while queue:
            current_vertex = queue.popleft()
            current_distance = distances[current_vertex]
            if current_distance is None:
                continue

            for edge in self[current_vertex]:
                new_distance = current_distance + edge.weight
                dest_vertex_distance = distances[edge.destination_vertex]
                if (
                    isinstance(dest_vertex_distance, int)
                    and new_distance >= dest_vertex_distance
                ):
                    continue
                distances[edge.destination_vertex] = new_distance
                if edge.weight == 0:
                    queue.appendleft(edge.destination_vertex)
                else:
                    queue.append(edge.destination_vertex)

        if distances[finish_vertex] is None:
            raise ValueError(""No path from start_vertex to finish_vertex."")

        return distances[finish_vertex]",data\repos\Python\graphs\breadth_first_search_zero_one_shortest_path.py,get_shortest_path,711
920,check_bipatrite.py::is_bipartite_dfs::4,"def is_bipartite_dfs(graph: dict[int, list[int]]) -> bool:
    """"""
    Check if a graph is bipartite using depth-first search (DFS).

    Args:
        `graph`: Adjacency list representing the graph.

    Returns:
        ``True`` if bipartite, ``False`` otherwise.

    Checks if the graph can be divided into two sets of vertices, such that no two
    vertices within the same set are connected by an edge.

    Examples:

    >>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 4]})
    True
    >>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 1]})
    False
    >>> is_bipartite_dfs({})
    True
    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
    True
    >>> is_bipartite_dfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})
    False
    >>> is_bipartite_dfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})
    True
    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
    False
    >>> is_bipartite_dfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
    False

    >>> # FIXME: This test should fails with KeyError: 4.
    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})
    False
    >>> is_bipartite_dfs({0: [-1, 3], 1: [0, -2]})
    False
    >>> is_bipartite_dfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})
    True
    >>> is_bipartite_dfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
    True

    >>> # FIXME: This test should fails with
    >>> # TypeError: list indices must be integers or...
    >>> is_bipartite_dfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})
    True
    >>> is_bipartite_dfs({""a"": [1, 3], ""b"": [0, 2], ""c"": [1, 3], ""d"": [0, 2]})
    True
    >>> is_bipartite_dfs({0: [""b"", ""d""], 1: [""a"", ""c""], 2: [""b"", ""d""], 3: [""a"", ""c""]})
    True
    """"""

    def depth_first_search(node: int, color: int) -> bool:
        """"""
        Perform Depth-First Search (DFS) on the graph starting from a node.

        Args:
            node: The current node being visited.
            color: The color assigned to the current node.

        Returns:
            True if the graph is bipartite starting from the current node,
            False otherwise.
        """"""
        if visited[node] == -1:
            visited[node] = color
            if node not in graph:
                return True
            for neighbor in graph[node]:
                if not depth_first_search(neighbor, 1 - color):
                    return False
        return visited[node] == color

    visited: defaultdict[int, int] = defaultdict(lambda: -1)
    for node in graph:
        if visited[node] == -1 and not depth_first_search(node, 0):
            return False
    return True",data\repos\Python\graphs\check_bipatrite.py,is_bipartite_dfs,1023
921,check_bipatrite.py::is_bipartite_bfs::84,"def is_bipartite_bfs(graph: dict[int, list[int]]) -> bool:
    """"""
    Check if a graph is bipartite using a breadth-first search (BFS).

    Args:
        `graph`: Adjacency list representing the graph.

    Returns:
        ``True`` if bipartite, ``False`` otherwise.

    Check if the graph can be divided into two sets of vertices, such that no two
    vertices within the same set are connected by an edge.

    Examples:

    >>> is_bipartite_bfs({0: [1, 2], 1: [0, 3], 2: [0, 4]})
    True
    >>> is_bipartite_bfs({0: [1, 2], 1: [0, 2], 2: [0, 1]})
    False
    >>> is_bipartite_bfs({})
    True
    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
    True
    >>> is_bipartite_bfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})
    False
    >>> is_bipartite_bfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})
    True
    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
    False
    >>> is_bipartite_bfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
    False

    >>> # FIXME: This test should fails with KeyError: 4.
    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})
    False
    >>> is_bipartite_bfs({0: [-1, 3], 1: [0, -2]})
    False
    >>> is_bipartite_bfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})
    True
    >>> is_bipartite_bfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
    True

    >>> # FIXME: This test should fails with
    >>> # TypeError: list indices must be integers or...
    >>> is_bipartite_bfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})
    True
    >>> is_bipartite_bfs({""a"": [1, 3], ""b"": [0, 2], ""c"": [1, 3], ""d"": [0, 2]})
    True
    >>> is_bipartite_bfs({0: [""b"", ""d""], 1: [""a"", ""c""], 2: [""b"", ""d""], 3: [""a"", ""c""]})
    True
    """"""
    visited: defaultdict[int, int] = defaultdict(lambda: -1)
    for node in graph:
        if visited[node] == -1:
            queue: deque[int] = deque()
            queue.append(node)
            visited[node] = 0
            while queue:
                curr_node = queue.popleft()
                if curr_node not in graph:
                    continue
                for neighbor in graph[curr_node]:
                    if visited[neighbor] == -1:
                        visited[neighbor] = 1 - visited[curr_node]
                        queue.append(neighbor)
                    elif visited[neighbor] == visited[curr_node]:
                        return False
    return True",data\repos\Python\graphs\check_bipatrite.py,is_bipartite_bfs,967
922,check_bipatrite.py::depth_first_search::56,"    def depth_first_search(node: int, color: int) -> bool:
        """"""
        Perform Depth-First Search (DFS) on the graph starting from a node.

        Args:
            node: The current node being visited.
            color: The color assigned to the current node.

        Returns:
            True if the graph is bipartite starting from the current node,
            False otherwise.
        """"""
        if visited[node] == -1:
            visited[node] = color
            if node not in graph:
                return True
            for neighbor in graph[node]:
                if not depth_first_search(neighbor, 1 - color):
                    return False
        return visited[node] == color",data\repos\Python\graphs\check_bipatrite.py,depth_first_search,141
923,check_cycle.py::check_cycle::6,"def check_cycle(graph: dict) -> bool:
    """"""
    Returns True if graph is cyclic else False
    >>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]})
    False
    >>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]})
    True
    """"""
    # Keep track of visited nodes
    visited: set[int] = set()
    # To detect a back edge, keep track of vertices currently in the recursion stack
    rec_stk: set[int] = set()
    return any(
        node not in visited and depth_first_search(graph, node, visited, rec_stk)
        for node in graph
    )",data\repos\Python\graphs\check_cycle.py,check_cycle,178
924,check_cycle.py::depth_first_search::24,"def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:
    """"""
    Recur for all neighbours.
    If any neighbour is visited and in rec_stk then graph is cyclic.
    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}
    >>> vertex, visited, rec_stk = 0, set(), set()
    >>> depth_first_search(graph, vertex, visited, rec_stk)
    False
    """"""
    # Mark current node as visited and add to recursion stack
    visited.add(vertex)
    rec_stk.add(vertex)

    for node in graph[vertex]:
        if node not in visited:
            if depth_first_search(graph, node, visited, rec_stk):
                return True
        elif node in rec_stk:
            return True

    # The node needs to be removed from recursion stack before function ends
    rec_stk.remove(vertex)
    return False",data\repos\Python\graphs\check_cycle.py,depth_first_search,221
925,connected_components.py::dfs::13,"def dfs(graph: dict, vert: int, visited: list) -> list:
    """"""
    Use depth first search to find all vertices
    being in the same component as initial vertex
    >>> dfs(test_graph_1, 0, 5 * [False])
    [0, 1, 3, 2]
    >>> dfs(test_graph_2, 0, 6 * [False])
    [0, 1, 3, 2]
    """"""

    visited[vert] = True
    connected_verts = []

    for neighbour in graph[vert]:
        if not visited[neighbour]:
            connected_verts += dfs(graph, neighbour, visited)

    return [vert, *connected_verts]",data\repos\Python\graphs\connected_components.py,dfs,150
926,connected_components.py::connected_components::33,"def connected_components(graph: dict) -> list:
    """"""
    This function takes graph as a parameter
    and then returns the list of connected components
    >>> connected_components(test_graph_1)
    [[0, 1, 3, 2], [4, 5, 6]]
    >>> connected_components(test_graph_2)
    [[0, 1, 3, 2], [4], [5]]
    """"""

    graph_size = len(graph)
    visited = graph_size * [False]
    components_list = []

    for i in range(graph_size):
        if not visited[i]:
            i_connected = dfs(graph, i, visited)
            components_list.append(i_connected)

    return components_list",data\repos\Python\graphs\connected_components.py,connected_components,149
927,deep_clone_graph.py::clone_graph::36,"def clone_graph(node: Node | None) -> Node | None:
    """"""
    This function returns a clone of a connected undirected graph.
    >>> clone_graph(Node(1))
    Node(value=1, neighbors=[])
    >>> clone_graph(Node(1, [Node(2)]))
    Node(value=1, neighbors=[Node(value=2, neighbors=[])])
    >>> clone_graph(None) is None
    True
    """"""
    if not node:
        return None

    originals_to_clones = {}  # map nodes to clones

    stack = [node]

    while stack:
        original = stack.pop()

        if original in originals_to_clones:
            continue

        originals_to_clones[original] = Node(original.value)

        stack.extend(original.neighbors or [])

    for original, clone in originals_to_clones.items():
        for neighbor in original.neighbors or []:
            cloned_neighbor = originals_to_clones[neighbor]

            if not clone.neighbors:
                clone.neighbors = []

            clone.neighbors.append(cloned_neighbor)

    return originals_to_clones[node]",data\repos\Python\graphs\deep_clone_graph.py,clone_graph,220
928,depth_first_search.py::depth_first_search::6,"def depth_first_search(graph: dict, start: str) -> set[str]:
    """"""Depth First Search on Graph
    :param graph: directed graph in dictionary format
    :param start: starting vertex as a string
    :returns: the trace of the search
    >>> input_G = { ""A"": [""B"", ""C"", ""D""], ""B"": [""A"", ""D"", ""E""],
    ... ""C"": [""A"", ""F""], ""D"": [""B"", ""D""], ""E"": [""B"", ""F""],
    ... ""F"": [""C"", ""E"", ""G""], ""G"": [""F""] }
    >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'})
    >>> all(x in output_G for x in list(depth_first_search(input_G, ""A"")))
    True
    >>> all(x in output_G for x in list(depth_first_search(input_G, ""G"")))
    True
    """"""
    explored, stack = set(start), [start]

    while stack:
        v = stack.pop()
        explored.add(v)
        # Differences from BFS:
        # 1) pop last element instead of first one
        # 2) add adjacent elements to stack without exploring them
        for adj in reversed(graph[v]):
            if adj not in explored:
                stack.append(adj)
    return explored",data\repos\Python\graphs\depth_first_search.py,depth_first_search,293
929,depth_first_search_2.py::print_graph::11,"    def print_graph(self) -> None:
        """"""
        Print the graph vertices.

        Example:
        >>> g = Graph()
        >>> g.add_edge(0, 1)
        >>> g.add_edge(0, 2)
        >>> g.add_edge(1, 2)
        >>> g.add_edge(2, 0)
        >>> g.add_edge(2, 3)
        >>> g.add_edge(3, 3)
        >>> g.print_graph()
        {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}
        0  ->  1 -> 2
        1  ->  2
        2  ->  0 -> 3
        3  ->  3
        """"""
        print(self.vertex)
        for i in self.vertex:
            print(i, "" -> "", "" -> "".join([str(j) for j in self.vertex[i]]))",data\repos\Python\graphs\depth_first_search_2.py,print_graph,208
930,depth_first_search_2.py::add_edge::35,"    def add_edge(self, from_vertex: int, to_vertex: int) -> None:
        """"""
        Add an edge between two vertices.

        :param from_vertex: The source vertex.
        :param to_vertex: The destination vertex.

        Example:
        >>> g = Graph()
        >>> g.add_edge(0, 1)
        >>> g.add_edge(0, 2)
        >>> g.print_graph()
        {0: [1, 2]}
        0  ->  1 -> 2
        """"""
        # check if vertex is already present,
        if from_vertex in self.vertex:
            self.vertex[from_vertex].append(to_vertex)
        else:
            # else make a new vertex
            self.vertex[from_vertex] = [to_vertex]",data\repos\Python\graphs\depth_first_search_2.py,add_edge,159
931,depth_first_search_2.py::dfs::57,"    def dfs(self) -> None:
        """"""
        Perform depth-first search (DFS) traversal on the graph
        and print the visited vertices.

        Example:
        >>> g = Graph()
        >>> g.add_edge(0, 1)
        >>> g.add_edge(0, 2)
        >>> g.add_edge(1, 2)
        >>> g.add_edge(2, 0)
        >>> g.add_edge(2, 3)
        >>> g.add_edge(3, 3)
        >>> g.dfs()
        0 1 2 3
        """"""
        # visited array for storing already visited nodes
        visited = [False] * len(self.vertex)

        # call the recursive helper function
        for i in range(len(self.vertex)):
            if not visited[i]:
                self.dfs_recursive(i, visited)",data\repos\Python\graphs\depth_first_search_2.py,dfs,176
932,depth_first_search_2.py::dfs_recursive::81,"    def dfs_recursive(self, start_vertex: int, visited: list) -> None:
        """"""
        Perform a recursive depth-first search (DFS) traversal on the graph.

        :param start_vertex: The starting vertex for the traversal.
        :param visited: A list to track visited vertices.

        Example:
        >>> g = Graph()
        >>> g.add_edge(0, 1)
        >>> g.add_edge(0, 2)
        >>> g.add_edge(1, 2)
        >>> g.add_edge(2, 0)
        >>> g.add_edge(2, 3)
        >>> g.add_edge(3, 3)
        >>> visited = [False] * len(g.vertex)
        >>> g.dfs_recursive(0, visited)
        0 1 2 3
        """"""
        # mark start vertex as visited
        visited[start_vertex] = True

        print(start_vertex, end="""")

        # Recur for all the vertices that are adjacent to this node
        for i in self.vertex:
            if not visited[i]:
                print("" "", end="""")
                self.dfs_recursive(i, visited)",data\repos\Python\graphs\depth_first_search_2.py,dfs_recursive,237
933,dijkstra.py::dijkstra::37,"def dijkstra(graph, start, end):
    """"""Return the cost of the shortest path between vertices start and end.

    >>> dijkstra(G, ""E"", ""C"")
    6
    >>> dijkstra(G2, ""E"", ""F"")
    3
    >>> dijkstra(G3, ""E"", ""F"")
    3
    """"""

    heap = [(0, start)]  # cost from start node,end node
    visited = set()
    while heap:
        (cost, u) = heapq.heappop(heap)
        if u in visited:
            continue
        visited.add(u)
        if u == end:
            return cost
        for v, c in graph[u]:
            if v in visited:
                continue
            next_item = cost + c
            heapq.heappush(heap, (next_item, v))
    return -1",data\repos\Python\graphs\dijkstra.py,dijkstra,186
934,dijkstra_2.py::print_dist::1,"def print_dist(dist, v):
    print(""\nVertex Distance"")
    for i in range(v):
        if dist[i] != float(""inf""):
            print(i, ""\t"", int(dist[i]), end=""\t"")
        else:
            print(i, ""\t"", ""INF"", end=""\t"")
        print()",data\repos\Python\graphs\dijkstra_2.py,print_dist,66
935,dijkstra_2.py::min_dist::11,"def min_dist(mdist, vset, v):
    min_val = float(""inf"")
    min_ind = -1
    for i in range(v):
        if (not vset[i]) and mdist[i] < min_val:
            min_ind = i
            min_val = mdist[i]
    return min_ind",data\repos\Python\graphs\dijkstra_2.py,min_dist,68
936,dijkstra_2.py::dijkstra::21,"def dijkstra(graph, v, src):
    mdist = [float(""inf"") for _ in range(v)]
    vset = [False for _ in range(v)]
    mdist[src] = 0.0

    for _ in range(v - 1):
        u = min_dist(mdist, vset, v)
        vset[u] = True

        for i in range(v):
            if (
                (not vset[i])
                and graph[u][i] != float(""inf"")
                and mdist[u] + graph[u][i] < mdist[i]
            ):
                mdist[i] = mdist[u] + graph[u][i]

    print_dist(mdist, i)",data\repos\Python\graphs\dijkstra_2.py,dijkstra,151
937,dijkstra_algorithm.py::is_empty::30,"    def is_empty(self):
        """"""
        Conditional boolean method to determine if the priority queue is empty or not.

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.is_empty()
        True
        >>> priority_queue_test.insert((2, 'A'))
        >>> priority_queue_test.is_empty()
        False
        """"""
        return self.cur_size == 0",data\repos\Python\graphs\dijkstra_algorithm.py,is_empty,78
938,dijkstra_algorithm.py::min_heapify::44,"    def min_heapify(self, idx):
        """"""
        Sorts the queue array so that the minimum element is root.

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.cur_size = 3
        >>> priority_queue_test.pos = {'A': 0, 'B': 1, 'C': 2}

        >>> priority_queue_test.array = [(5, 'A'), (10, 'B'), (15, 'C')]
        >>> priority_queue_test.min_heapify(0)
        >>> priority_queue_test.array
        [(5, 'A'), (10, 'B'), (15, 'C')]

        >>> priority_queue_test.array = [(10, 'A'), (5, 'B'), (15, 'C')]
        >>> priority_queue_test.min_heapify(0)
        >>> priority_queue_test.array
        [(5, 'B'), (10, 'A'), (15, 'C')]

        >>> priority_queue_test.array = [(10, 'A'), (15, 'B'), (5, 'C')]
        >>> priority_queue_test.min_heapify(0)
        >>> priority_queue_test.array
        [(5, 'C'), (15, 'B'), (10, 'A')]

        >>> priority_queue_test.array = [(10, 'A'), (5, 'B')]
        >>> priority_queue_test.cur_size = len(priority_queue_test.array)
        >>> priority_queue_test.pos = {'A': 0, 'B': 1}
        >>> priority_queue_test.min_heapify(0)
        >>> priority_queue_test.array
        [(5, 'B'), (10, 'A')]
        """"""
        lc = self.left(idx)
        rc = self.right(idx)
        if lc < self.cur_size and self.array[lc][0] < self.array[idx][0]:
            smallest = lc
        else:
            smallest = idx
        if rc < self.cur_size and self.array[rc][0] < self.array[smallest][0]:
            smallest = rc
        if smallest != idx:
            self.swap(idx, smallest)
            self.min_heapify(smallest)",data\repos\Python\graphs\dijkstra_algorithm.py,min_heapify,445
939,dijkstra_algorithm.py::insert::87,"    def insert(self, tup):
        """"""
        Inserts a node into the Priority Queue.

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.insert((10, 'A'))
        >>> priority_queue_test.array
        [(10, 'A')]
        >>> priority_queue_test.insert((15, 'B'))
        >>> priority_queue_test.array
        [(10, 'A'), (15, 'B')]
        >>> priority_queue_test.insert((5, 'C'))
        >>> priority_queue_test.array
        [(5, 'C'), (10, 'A'), (15, 'B')]
        """"""
        self.pos[tup[1]] = self.cur_size
        self.cur_size += 1
        self.array.append((sys.maxsize, tup[1]))
        self.decrease_key((sys.maxsize, tup[1]), tup[0])",data\repos\Python\graphs\dijkstra_algorithm.py,insert,179
940,dijkstra_algorithm.py::extract_min::108,"    def extract_min(self):
        """"""
        Removes and returns the min element at top of priority queue.

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.array = [(10, 'A'), (15, 'B')]
        >>> priority_queue_test.cur_size = len(priority_queue_test.array)
        >>> priority_queue_test.pos = {'A': 0, 'B': 1}
        >>> priority_queue_test.insert((5, 'C'))
        >>> priority_queue_test.extract_min()
        'C'
        >>> priority_queue_test.array[0]
        (10, 'A')
        """"""
        min_node = self.array[0][1]
        self.array[0] = self.array[self.cur_size - 1]
        self.cur_size -= 1
        self.min_heapify(0)
        del self.pos[min_node]
        return min_node",data\repos\Python\graphs\dijkstra_algorithm.py,extract_min,180
941,dijkstra_algorithm.py::left::130,"    def left(self, i):
        """"""
        Returns the index of left child

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.left(0)
        1
        >>> priority_queue_test.left(1)
        3
        """"""
        return 2 * i + 1",data\repos\Python\graphs\dijkstra_algorithm.py,left,65
942,dijkstra_algorithm.py::right::143,"    def right(self, i):
        """"""
        Returns the index of right child

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.right(0)
        2
        >>> priority_queue_test.right(1)
        4
        """"""
        return 2 * i + 2",data\repos\Python\graphs\dijkstra_algorithm.py,right,65
943,dijkstra_algorithm.py::par::156,"    def par(self, i):
        """"""
        Returns the index of parent

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.par(1)
        0
        >>> priority_queue_test.par(2)
        1
        >>> priority_queue_test.par(4)
        2
        """"""
        return math.floor(i / 2)",data\repos\Python\graphs\dijkstra_algorithm.py,par,77
944,dijkstra_algorithm.py::swap::171,"    def swap(self, i, j):
        """"""
        Swaps array elements at indices i and j, update the pos{}

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.array = [(10, 'A'), (15, 'B')]
        >>> priority_queue_test.cur_size = len(priority_queue_test.array)
        >>> priority_queue_test.pos = {'A': 0, 'B': 1}
        >>> priority_queue_test.swap(0, 1)
        >>> priority_queue_test.array
        [(15, 'B'), (10, 'A')]
        >>> priority_queue_test.pos
        {'A': 1, 'B': 0}
        """"""
        self.pos[self.array[i][1]] = j
        self.pos[self.array[j][1]] = i
        temp = self.array[i]
        self.array[i] = self.array[j]
        self.array[j] = temp",data\repos\Python\graphs\dijkstra_algorithm.py,swap,191
945,dijkstra_algorithm.py::decrease_key::192,"    def decrease_key(self, tup, new_d):
        """"""
        Decrease the key value for a given tuple, assuming the new_d is at most old_d.

        Examples:
        >>> priority_queue_test = PriorityQueue()
        >>> priority_queue_test.array = [(10, 'A'), (15, 'B')]
        >>> priority_queue_test.cur_size = len(priority_queue_test.array)
        >>> priority_queue_test.pos = {'A': 0, 'B': 1}
        >>> priority_queue_test.decrease_key((10, 'A'), 5)
        >>> priority_queue_test.array
        [(5, 'A'), (15, 'B')]
        """"""
        idx = self.pos[tup[1]]
        # assuming the new_d is at most old_d
        self.array[idx] = (new_d, tup[1])
        while idx > 0 and self.array[self.par(idx)][0] > self.array[idx][0]:
            self.swap(idx, self.par(idx))
            idx = self.par(idx)",data\repos\Python\graphs\dijkstra_algorithm.py,decrease_key,210
946,dijkstra_algorithm.py::add_edge::235,"    def add_edge(self, u, v, w):
        """"""
        Add edge going from node u to v and v to u with weight w: u (w)-> v, v (w) -> u

        Examples:
        >>> graph_test = Graph(1)
        >>> graph_test.add_edge(1, 2, 1)
        >>> graph_test.add_edge(2, 3, 2)
        >>> graph_test.adjList
        {1: [(2, 1)], 2: [(1, 1), (3, 2)], 3: [(2, 2)]}
        """"""
        # Check if u already in graph
        if u in self.adjList:
            self.adjList[u].append((v, w))
        else:
            self.adjList[u] = [(v, w)]

        # Assuming undirected graph
        if v in self.adjList:
            self.adjList[v].append((u, w))
        else:
            self.adjList[v] = [(u, w)]",data\repos\Python\graphs\dijkstra_algorithm.py,add_edge,216
947,dijkstra_algorithm.py::show_graph::258,"    def show_graph(self):
        """"""
        Show the graph: u -> v(w)

        Examples:
        >>> graph_test = Graph(1)
        >>> graph_test.add_edge(1, 2, 1)
        >>> graph_test.show_graph()
        1 -> 2(1)
        2 -> 1(1)
        >>> graph_test.add_edge(2, 3, 2)
        >>> graph_test.show_graph()
        1 -> 2(1)
        2 -> 1(1) -> 3(2)
        3 -> 2(2)
        """"""
        for u in self.adjList:
            print(u, ""->"", "" -> "".join(str(f""{v}({w})"") for v, w in self.adjList[u]))",data\repos\Python\graphs\dijkstra_algorithm.py,show_graph,164
948,dijkstra_algorithm.py::dijkstra::277,"    def dijkstra(self, src):
        """"""
        Dijkstra algorithm

        Examples:
        >>> graph_test = Graph(3)
        >>> graph_test.add_edge(0, 1, 2)
        >>> graph_test.add_edge(1, 2, 2)
        >>> graph_test.dijkstra(0)
        Distance from node: 0
        Node 0 has distance: 0
        Node 1 has distance: 2
        Node 2 has distance: 4
        >>> graph_test.dist
        [0, 2, 4]

        >>> graph_test = Graph(2)
        >>> graph_test.add_edge(0, 1, 2)
        >>> graph_test.dijkstra(0)
        Distance from node: 0
        Node 0 has distance: 0
        Node 1 has distance: 2
        >>> graph_test.dist
        [0, 2]

        >>> graph_test = Graph(3)
        >>> graph_test.add_edge(0, 1, 2)
        >>> graph_test.dijkstra(0)
        Distance from node: 0
        Node 0 has distance: 0
        Node 1 has distance: 2
        Node 2 has distance: 0
        >>> graph_test.dist
        [0, 2, 0]

        >>> graph_test = Graph(3)
        >>> graph_test.add_edge(0, 1, 2)
        >>> graph_test.add_edge(1, 2, 2)
        >>> graph_test.add_edge(0, 2, 1)
        >>> graph_test.dijkstra(0)
        Distance from node: 0
        Node 0 has distance: 0
        Node 1 has distance: 2
        Node 2 has distance: 1
        >>> graph_test.dist
        [0, 2, 1]

        >>> graph_test = Graph(4)
        >>> graph_test.add_edge(0, 1, 4)
        >>> graph_test.add_edge(1, 2, 2)
        >>> graph_test.add_edge(2, 3, 1)
        >>> graph_test.add_edge(0, 2, 3)
        >>> graph_test.dijkstra(0)
        Distance from node: 0
        Node 0 has distance: 0
        Node 1 has distance: 4
        Node 2 has distance: 3
        Node 3 has distance: 4
        >>> graph_test.dist
        [0, 4, 3, 4]

        >>> graph_test = Graph(4)
        >>> graph_test.add_edge(0, 1, 4)
        >>> graph_test.add_edge(1, 2, 2)
        >>> graph_test.add_edge(2, 3, 1)
        >>> graph_test.add_edge(0, 2, 7)
        >>> graph_test.dijkstra(0)
        Distance from node: 0
        Node 0 has distance: 0
        Node 1 has distance: 4
        Node 2 has distance: 6
        Node 3 has distance: 7
        >>> graph_test.dist
        [0, 4, 6, 7]
        """"""
        # Flush old junk values in par[]
        self.par = [-1] * self.num_nodes
        # src is the source node
        self.dist[src] = 0
        q = PriorityQueue()
        q.insert((0, src))  # (dist from src, node)
        for u in self.adjList:
            if u != src:
                self.dist[u] = sys.maxsize  # Infinity
                self.par[u] = -1

        while not q.is_empty():
            u = q.extract_min()  # Returns node with the min dist from source
            # Update the distance of all the neighbours of u and
            # if their prev dist was INFINITY then push them in Q
            for v, w in self.adjList[u]:
                new_dist = self.dist[u] + w
                if self.dist[v] > new_dist:
                    if self.dist[v] == sys.maxsize:
                        q.insert((new_dist, v))
                    else:
                        q.decrease_key((self.dist[v], v), new_dist)
                    self.dist[v] = new_dist
                    self.par[v] = u

        # Show the shortest distances from src
        self.show_distances(src)",data\repos\Python\graphs\dijkstra_algorithm.py,dijkstra,942
949,dijkstra_algorithm.py::show_distances::380,"    def show_distances(self, src):
        """"""
        Show the distances from src to all other nodes in a graph

        Examples:
        >>> graph_test = Graph(1)
        >>> graph_test.show_distances(0)
        Distance from node: 0
        Node 0 has distance: 0
        """"""
        print(f""Distance from node: {src}"")
        for u in range(self.num_nodes):
            print(f""Node {u} has distance: {self.dist[u]}"")",data\repos\Python\graphs\dijkstra_algorithm.py,show_distances,102
950,dijkstra_algorithm.py::show_path::394,"    def show_path(self, src, dest):
        """"""
        Shows the shortest path from src to dest.
        WARNING: Use it *after* calling dijkstra.

        Examples:
        >>> graph_test = Graph(4)
        >>> graph_test.add_edge(0, 1, 1)
        >>> graph_test.add_edge(1, 2, 2)
        >>> graph_test.add_edge(2, 3, 3)
        >>> graph_test.dijkstra(0)
        Distance from node: 0
        Node 0 has distance: 0
        Node 1 has distance: 1
        Node 2 has distance: 3
        Node 3 has distance: 6
        >>> graph_test.show_path(0, 3)  # doctest: +NORMALIZE_WHITESPACE
        ----Path to reach 3 from 0----
        0 -> 1 -> 2 -> 3
        Total cost of path:  6
        """"""
        path = []
        cost = 0
        temp = dest
        # Backtracking from dest to src
        while self.par[temp] != -1:
            path.append(temp)
            if temp != src:
                for v, w in self.adjList[temp]:
                    if v == self.par[temp]:
                        cost += w
                        break
            temp = self.par[temp]
        path.append(src)
        path.reverse()

        print(f""----Path to reach {dest} from {src}----"")
        for u in path:
            print(f""{u}"", end="" "")
            if u != dest:
                print(""-> "", end="""")

        print(""\nTotal cost of path: "", cost)",data\repos\Python\graphs\dijkstra_algorithm.py,show_path,355
951,dijkstra_alternate.py::print_solution::18,"    def print_solution(self, distances_from_source: list[int]) -> None:
        """"""
        >>> Graph(0).print_solution([])  # doctest: +NORMALIZE_WHITESPACE
        Vertex 	 Distance from Source
        """"""
        print(""Vertex \t Distance from Source"")
        for vertex in range(self.vertices):
            print(vertex, ""\t\t"", distances_from_source[vertex])",data\repos\Python\graphs\dijkstra_alternate.py,print_solution,80
952,dijkstra_alternate.py::minimum_distance::27,"    def minimum_distance(
        self, distances_from_source: list[int], visited: list[bool]
    ) -> int:
        """"""
        A utility function to find the vertex with minimum distance value, from the set
        of vertices not yet included in shortest path tree.

        >>> Graph(3).minimum_distance([1, 2, 3], [False, False, True])
        0
        """"""

        # Initialize minimum distance for next node
        minimum = 1e7
        min_index = 0

        # Search not nearest vertex not in the shortest path tree
        for vertex in range(self.vertices):
            if distances_from_source[vertex] < minimum and visited[vertex] is False:
                minimum = distances_from_source[vertex]
                min_index = vertex
        return min_index",data\repos\Python\graphs\dijkstra_alternate.py,minimum_distance,165
953,dijkstra_alternate.py::dijkstra::49,"    def dijkstra(self, source: int) -> None:
        """"""
        Function that implements Dijkstra's single source shortest path algorithm for a
        graph represented using adjacency matrix representation.

        >>> Graph(4).dijkstra(1)  # doctest: +NORMALIZE_WHITESPACE
        Vertex  Distance from Source
        0 		 10000000
        1 		 0
        2 		 10000000
        3 		 10000000
        """"""

        distances = [int(1e7)] * self.vertices  # distances from the source
        distances[source] = 0
        visited = [False] * self.vertices

        for _ in range(self.vertices):
            u = self.minimum_distance(distances, visited)
            visited[u] = True

            # Update dist value of the adjacent vertices
            # of the picked vertex only if the current
            # distance is greater than new distance and
            # the vertex in not in the shortest path tree
            for v in range(self.vertices):
                if (
                    self.graph[u][v] > 0
                    and visited[v] is False
                    and distances[v] > distances[u] + self.graph[u][v]
                ):
                    distances[v] = distances[u] + self.graph[u][v]

        self.print_solution(distances)",data\repos\Python\graphs\dijkstra_alternate.py,dijkstra,282
954,dijkstra_binary_grid.py::dijkstra::14,"def dijkstra(
    grid: np.ndarray,
    source: tuple[int, int],
    destination: tuple[int, int],
    allow_diagonal: bool,
) -> tuple[float | int, list[tuple[int, int]]]:
    """"""
    Implements Dijkstra's algorithm on a binary grid.

    Args:
        grid (np.ndarray): A 2D numpy array representing the grid.
        1 represents a walkable node and 0 represents an obstacle.
        source (Tuple[int, int]): A tuple representing the start node.
        destination (Tuple[int, int]): A tuple representing the
        destination node.
        allow_diagonal (bool): A boolean determining whether
        diagonal movements are allowed.

    Returns:
        Tuple[Union[float, int], List[Tuple[int, int]]]:
        The shortest distance from the start node to the destination node
        and the shortest path as a list of nodes.

    >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), False)
    (4.0, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])

    >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), True)
    (2.0, [(0, 0), (1, 1), (2, 2)])

    >>> dijkstra(np.array([[1, 1, 1], [0, 0, 1], [0, 1, 1]]), (0, 0), (2, 2), False)
    (4.0, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)])
    """"""
    rows, cols = grid.shape
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    if allow_diagonal:
        dx += [-1, -1, 1, 1]
        dy += [-1, 1, -1, 1]

    queue, visited = [(0, source)], set()
    matrix = np.full((rows, cols), np.inf)
    matrix[source] = 0
    predecessors = np.empty((rows, cols), dtype=object)
    predecessors[source] = None

    while queue:
        (dist, (x, y)) = heappop(queue)
        if (x, y) in visited:
            continue
        visited.add((x, y))

        if (x, y) == destination:
            path = []
            while (x, y) != source:
                path.append((x, y))
                x, y = predecessors[x, y]
            path.append(source)  # add the source manually
            path.reverse()
            return float(matrix[destination]), path

        for i in range(len(dx)):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < rows and 0 <= ny < cols:
                next_node = grid[nx][ny]
                if next_node == 1 and matrix[nx, ny] > dist + 1:
                    heappush(queue, (dist + 1, (nx, ny)))
                    matrix[nx, ny] = dist + 1
                    predecessors[nx, ny] = (x, y)

    return np.inf, []",data\repos\Python\graphs\dijkstra_binary_grid.py,dijkstra,787
955,dinic.py::add_edge::17,"    def add_edge(self, a, b, c, rcap=0):
        self.adj[a].append([b, len(self.adj[b]), c, 0])
        self.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])",data\repos\Python\graphs\dinic.py,add_edge,60
956,dinic.py::depth_first_search::22,"    def depth_first_search(self, vertex, sink, flow):
        if vertex == sink or not flow:
            return flow

        for i in range(self.ptr[vertex], len(self.adj[vertex])):
            e = self.adj[vertex][i]
            if self.lvl[e[0]] == self.lvl[vertex] + 1:
                p = self.depth_first_search(e[0], sink, min(flow, e[2] - e[3]))
                if p:
                    self.adj[vertex][i][3] += p
                    self.adj[e[0]][e[1]][3] -= p
                    return p
            self.ptr[vertex] = self.ptr[vertex] + 1
        return 0",data\repos\Python\graphs\dinic.py,depth_first_search,147
957,dinic.py::max_flow::38,"    def max_flow(self, source, sink):
        flow, self.q[0] = 0, source
        for l in range(31):  # l = 30 maybe faster for random data  # noqa: E741
            while True:
                self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)
                qi, qe, self.lvl[source] = 0, 1, 1
                while qi < qe and not self.lvl[sink]:
                    v = self.q[qi]
                    qi += 1
                    for e in self.adj[v]:
                        if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):
                            self.q[qe] = e[0]
                            qe += 1
                            self.lvl[e[0]] = self.lvl[v] + 1

                p = self.depth_first_search(source, sink, INF)
                while p:
                    flow += p
                    p = self.depth_first_search(source, sink, INF)

                if not self.lvl[sink]:
                    break

        return flow",data\repos\Python\graphs\dinic.py,max_flow,248
958,directed_and_undirected_weighted_graph.py::add_pair::16,"    def add_pair(self, u, v, w=1):
        if self.graph.get(u):
            if self.graph[u].count([w, v]) == 0:
                self.graph[u].append([w, v])
        else:
            self.graph[u] = [[w, v]]
        if not self.graph.get(v):
            self.graph[v] = []",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,add_pair,77
959,directed_and_undirected_weighted_graph.py::remove_pair::29,"    def remove_pair(self, u, v):
        if self.graph.get(u):
            for _ in self.graph[u]:
                if _[1] == v:
                    self.graph[u].remove(_)",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,remove_pair,41
960,directed_and_undirected_weighted_graph.py::dfs::36,"    def dfs(self, s=-2, d=-1):
        if s == d:
            return []
        stack = []
        visited = []
        if s == -2:
            s = next(iter(self.graph))
        stack.append(s)
        visited.append(s)
        ss = s

        while True:
            # check if there is any non isolated nodes
            if len(self.graph[s]) != 0:
                ss = s
                for node in self.graph[s]:
                    if visited.count(node[1]) < 1:
                        if node[1] == d:
                            visited.append(d)
                            return visited
                        else:
                            stack.append(node[1])
                            visited.append(node[1])
                            ss = node[1]
                            break

            # check if all the children are visited
            if s == ss:
                stack.pop()
                if len(stack) != 0:
                    s = stack[len(stack) - 1]
            else:
                s = ss

            # check if se have reached the starting point
            if len(stack) == 0:
                return visited",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,dfs,227
961,directed_and_undirected_weighted_graph.py::fill_graph_randomly::76,"    def fill_graph_randomly(self, c=-1):
        if c == -1:
            c = floor(random() * 10000) + 10
        for i in range(c):
            # every vertex has max 100 edges
            for _ in range(floor(random() * 102) + 1):
                n = floor(random() * c) + 1
                if n != i:
                    self.add_pair(i, n, 1)",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,fill_graph_randomly,97
962,directed_and_undirected_weighted_graph.py::bfs::86,"    def bfs(self, s=-2):
        d = deque()
        visited = []
        if s == -2:
            s = next(iter(self.graph))
        d.append(s)
        visited.append(s)
        while d:
            s = d.popleft()
            if len(self.graph[s]) != 0:
                for node in self.graph[s]:
                    if visited.count(node[1]) < 1:
                        d.append(node[1])
                        visited.append(node[1])
        return visited",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,bfs,102
963,directed_and_undirected_weighted_graph.py::in_degree::102,"    def in_degree(self, u):
        count = 0
        for x in self.graph:
            for y in self.graph[x]:
                if y[1] == u:
                    count += 1
        return count",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,in_degree,47
964,directed_and_undirected_weighted_graph.py::topological_sort::113,"    def topological_sort(self, s=-2):
        stack = []
        visited = []
        if s == -2:
            s = next(iter(self.graph))
        stack.append(s)
        visited.append(s)
        ss = s
        sorted_nodes = []

        while True:
            # check if there is any non isolated nodes
            if len(self.graph[s]) != 0:
                ss = s
                for node in self.graph[s]:
                    if visited.count(node[1]) < 1:
                        stack.append(node[1])
                        visited.append(node[1])
                        ss = node[1]
                        break

            # check if all the children are visited
            if s == ss:
                sorted_nodes.append(stack.pop())
                if len(stack) != 0:
                    s = stack[len(stack) - 1]
            else:
                s = ss

            # check if se have reached the starting point
            if len(stack) == 0:
                return sorted_nodes",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,topological_sort,204
965,directed_and_undirected_weighted_graph.py::cycle_nodes::146,"    def cycle_nodes(self):
        stack = []
        visited = []
        s = next(iter(self.graph))
        stack.append(s)
        visited.append(s)
        parent = -2
        indirect_parents = []
        ss = s
        on_the_way_back = False
        anticipating_nodes = set()

        while True:
            # check if there is any non isolated nodes
            if len(self.graph[s]) != 0:
                ss = s
                for node in self.graph[s]:
                    if (
                        visited.count(node[1]) > 0
                        and node[1] != parent
                        and indirect_parents.count(node[1]) > 0
                        and not on_the_way_back
                    ):
                        len_stack = len(stack) - 1
                        while len_stack >= 0:
                            if stack[len_stack] == node[1]:
                                anticipating_nodes.add(node[1])
                                break
                            else:
                                anticipating_nodes.add(stack[len_stack])
                                len_stack -= 1
                    if visited.count(node[1]) < 1:
                        stack.append(node[1])
                        visited.append(node[1])
                        ss = node[1]
                        break

            # check if all the children are visited
            if s == ss:
                stack.pop()
                on_the_way_back = True
                if len(stack) != 0:
                    s = stack[len(stack) - 1]
            else:
                on_the_way_back = False
                indirect_parents.append(parent)
                parent = s
                s = ss

            # check if se have reached the starting point
            if len(stack) == 0:
                return list(anticipating_nodes)",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,cycle_nodes,346
966,directed_and_undirected_weighted_graph.py::has_cycle::199,"    def has_cycle(self):
        stack = []
        visited = []
        s = next(iter(self.graph))
        stack.append(s)
        visited.append(s)
        parent = -2
        indirect_parents = []
        ss = s
        on_the_way_back = False
        anticipating_nodes = set()

        while True:
            # check if there is any non isolated nodes
            if len(self.graph[s]) != 0:
                ss = s
                for node in self.graph[s]:
                    if (
                        visited.count(node[1]) > 0
                        and node[1] != parent
                        and indirect_parents.count(node[1]) > 0
                        and not on_the_way_back
                    ):
                        len_stack_minus_one = len(stack) - 1
                        while len_stack_minus_one >= 0:
                            if stack[len_stack_minus_one] == node[1]:
                                anticipating_nodes.add(node[1])
                                break
                            else:
                                return True
                    if visited.count(node[1]) < 1:
                        stack.append(node[1])
                        visited.append(node[1])
                        ss = node[1]
                        break

            # check if all the children are visited
            if s == ss:
                stack.pop()
                on_the_way_back = True
                if len(stack) != 0:
                    s = stack[len(stack) - 1]
            else:
                on_the_way_back = False
                indirect_parents.append(parent)
                parent = s
                s = ss

            # check if se have reached the starting point
            if len(stack) == 0:
                return False",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,has_cycle,335
967,directed_and_undirected_weighted_graph.py::dfs_time::251,"    def dfs_time(self, s=-2, e=-1):
        begin = time()
        self.dfs(s, e)
        end = time()
        return end - begin",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,dfs_time,37
968,directed_and_undirected_weighted_graph.py::bfs_time::257,"    def bfs_time(self, s=-2):
        begin = time()
        self.bfs(s)
        end = time()
        return end - begin",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,bfs_time,31
969,directed_and_undirected_weighted_graph.py::add_pair::271,"    def add_pair(self, u, v, w=1):
        # check if the u exists
        if self.graph.get(u):
            # if there already is a edge
            if self.graph[u].count([w, v]) == 0:
                self.graph[u].append([w, v])
        else:
            # if u does not exist
            self.graph[u] = [[w, v]]
        # add the other way
        if self.graph.get(v):
            # if there already is a edge
            if self.graph[v].count([w, u]) == 0:
                self.graph[v].append([w, u])
        else:
            # if u does not exist
            self.graph[v] = [[w, u]]",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,add_pair,159
970,directed_and_undirected_weighted_graph.py::remove_pair::290,"    def remove_pair(self, u, v):
        if self.graph.get(u):
            for _ in self.graph[u]:
                if _[1] == v:
                    self.graph[u].remove(_)
        # the other way round
        if self.graph.get(v):
            for _ in self.graph[v]:
                if _[1] == u:
                    self.graph[v].remove(_)",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,remove_pair,80
971,directed_and_undirected_weighted_graph.py::dfs::302,"    def dfs(self, s=-2, d=-1):
        if s == d:
            return []
        stack = []
        visited = []
        if s == -2:
            s = next(iter(self.graph))
        stack.append(s)
        visited.append(s)
        ss = s

        while True:
            # check if there is any non isolated nodes
            if len(self.graph[s]) != 0:
                ss = s
                for node in self.graph[s]:
                    if visited.count(node[1]) < 1:
                        if node[1] == d:
                            visited.append(d)
                            return visited
                        else:
                            stack.append(node[1])
                            visited.append(node[1])
                            ss = node[1]
                            break

            # check if all the children are visited
            if s == ss:
                stack.pop()
                if len(stack) != 0:
                    s = stack[len(stack) - 1]
            else:
                s = ss

            # check if se have reached the starting point
            if len(stack) == 0:
                return visited",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,dfs,227
972,directed_and_undirected_weighted_graph.py::fill_graph_randomly::342,"    def fill_graph_randomly(self, c=-1):
        if c == -1:
            c = floor(random() * 10000) + 10
        for i in range(c):
            # every vertex has max 100 edges
            for _ in range(floor(random() * 102) + 1):
                n = floor(random() * c) + 1
                if n != i:
                    self.add_pair(i, n, 1)",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,fill_graph_randomly,97
973,directed_and_undirected_weighted_graph.py::bfs::352,"    def bfs(self, s=-2):
        d = deque()
        visited = []
        if s == -2:
            s = next(iter(self.graph))
        d.append(s)
        visited.append(s)
        while d:
            s = d.popleft()
            if len(self.graph[s]) != 0:
                for node in self.graph[s]:
                    if visited.count(node[1]) < 1:
                        d.append(node[1])
                        visited.append(node[1])
        return visited",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,bfs,102
974,directed_and_undirected_weighted_graph.py::cycle_nodes::371,"    def cycle_nodes(self):
        stack = []
        visited = []
        s = next(iter(self.graph))
        stack.append(s)
        visited.append(s)
        parent = -2
        indirect_parents = []
        ss = s
        on_the_way_back = False
        anticipating_nodes = set()

        while True:
            # check if there is any non isolated nodes
            if len(self.graph[s]) != 0:
                ss = s
                for node in self.graph[s]:
                    if (
                        visited.count(node[1]) > 0
                        and node[1] != parent
                        and indirect_parents.count(node[1]) > 0
                        and not on_the_way_back
                    ):
                        len_stack = len(stack) - 1
                        while len_stack >= 0:
                            if stack[len_stack] == node[1]:
                                anticipating_nodes.add(node[1])
                                break
                            else:
                                anticipating_nodes.add(stack[len_stack])
                                len_stack -= 1
                    if visited.count(node[1]) < 1:
                        stack.append(node[1])
                        visited.append(node[1])
                        ss = node[1]
                        break

            # check if all the children are visited
            if s == ss:
                stack.pop()
                on_the_way_back = True
                if len(stack) != 0:
                    s = stack[len(stack) - 1]
            else:
                on_the_way_back = False
                indirect_parents.append(parent)
                parent = s
                s = ss

            # check if se have reached the starting point
            if len(stack) == 0:
                return list(anticipating_nodes)",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,cycle_nodes,346
975,directed_and_undirected_weighted_graph.py::has_cycle::424,"    def has_cycle(self):
        stack = []
        visited = []
        s = next(iter(self.graph))
        stack.append(s)
        visited.append(s)
        parent = -2
        indirect_parents = []
        ss = s
        on_the_way_back = False
        anticipating_nodes = set()

        while True:
            # check if there is any non isolated nodes
            if len(self.graph[s]) != 0:
                ss = s
                for node in self.graph[s]:
                    if (
                        visited.count(node[1]) > 0
                        and node[1] != parent
                        and indirect_parents.count(node[1]) > 0
                        and not on_the_way_back
                    ):
                        len_stack_minus_one = len(stack) - 1
                        while len_stack_minus_one >= 0:
                            if stack[len_stack_minus_one] == node[1]:
                                anticipating_nodes.add(node[1])
                                break
                            else:
                                return True
                    if visited.count(node[1]) < 1:
                        stack.append(node[1])
                        visited.append(node[1])
                        ss = node[1]
                        break

            # check if all the children are visited
            if s == ss:
                stack.pop()
                on_the_way_back = True
                if len(stack) != 0:
                    s = stack[len(stack) - 1]
            else:
                on_the_way_back = False
                indirect_parents.append(parent)
                parent = s
                s = ss

            # check if se have reached the starting point
            if len(stack) == 0:
                return False",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,has_cycle,335
976,directed_and_undirected_weighted_graph.py::dfs_time::479,"    def dfs_time(self, s=-2, e=-1):
        begin = time()
        self.dfs(s, e)
        end = time()
        return end - begin",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,dfs_time,37
977,directed_and_undirected_weighted_graph.py::bfs_time::485,"    def bfs_time(self, s=-2):
        begin = time()
        self.bfs(s)
        end = time()
        return end - begin",data\repos\Python\graphs\directed_and_undirected_weighted_graph.py,bfs_time,31
978,edmonds_karp_multiple_source_and_sink.py::find_maximum_flow::47,"    def find_maximum_flow(self):
        if self.maximum_flow_algorithm is None:
            raise Exception(""You need to set maximum flow algorithm before."")
        if self.source_index is None or self.sink_index is None:
            return 0

        self.maximum_flow_algorithm.execute()
        return self.maximum_flow_algorithm.getMaximumFlow()",data\repos\Python\graphs\edmonds_karp_multiple_source_and_sink.py,find_maximum_flow,66
979,edmonds_karp_multiple_source_and_sink.py::get_maximum_flow::87,"    def get_maximum_flow(self):
        if not self.executed:
            raise Exception(""You should execute algorithm before using its result!"")

        return self.maximum_flow",data\repos\Python\graphs\edmonds_karp_multiple_source_and_sink.py,get_maximum_flow,32
980,edmonds_karp_multiple_source_and_sink.py::process_vertex::135,"    def process_vertex(self, vertex_index):
        while self.excesses[vertex_index] > 0:
            for neighbour_index in range(self.verticies_count):
                # if it's neighbour and current vertex is higher
                if (
                    self.graph[vertex_index][neighbour_index]
                    - self.preflow[vertex_index][neighbour_index]
                    > 0
                    and self.heights[vertex_index] > self.heights[neighbour_index]
                ):
                    self.push(vertex_index, neighbour_index)

            self.relabel(vertex_index)",data\repos\Python\graphs\edmonds_karp_multiple_source_and_sink.py,process_vertex,110
981,edmonds_karp_multiple_source_and_sink.py::push::149,"    def push(self, from_index, to_index):
        preflow_delta = min(
            self.excesses[from_index],
            self.graph[from_index][to_index] - self.preflow[from_index][to_index],
        )
        self.preflow[from_index][to_index] += preflow_delta
        self.preflow[to_index][from_index] -= preflow_delta
        self.excesses[from_index] -= preflow_delta
        self.excesses[to_index] += preflow_delta",data\repos\Python\graphs\edmonds_karp_multiple_source_and_sink.py,push,102
982,edmonds_karp_multiple_source_and_sink.py::relabel::159,"    def relabel(self, vertex_index):
        min_height = None
        for to_index in range(self.verticies_count):
            if (
                self.graph[vertex_index][to_index]
                - self.preflow[vertex_index][to_index]
                > 0
            ) and (min_height is None or self.heights[to_index] < min_height):
                min_height = self.heights[to_index]

        if min_height is not None:
            self.heights[vertex_index] = min_height + 1",data\repos\Python\graphs\edmonds_karp_multiple_source_and_sink.py,relabel,104
983,eulerian_path_and_circuit_for_undirected_graph.py::dfs::9,"def dfs(u, graph, visited_edge, path=None):
    path = (path or []) + [u]
    for v in graph[u]:
        if visited_edge[u][v] is False:
            visited_edge[u][v], visited_edge[v][u] = True, True
            path = dfs(v, graph, visited_edge, path)
    return path",data\repos\Python\graphs\eulerian_path_and_circuit_for_undirected_graph.py,dfs,75
984,eulerian_path_and_circuit_for_undirected_graph.py::check_circuit_or_path::19,"def check_circuit_or_path(graph, max_node):
    odd_degree_nodes = 0
    odd_node = -1
    for i in range(max_node):
        if i not in graph:
            continue
        if len(graph[i]) % 2 == 1:
            odd_degree_nodes += 1
            odd_node = i
    if odd_degree_nodes == 0:
        return 1, odd_node
    if odd_degree_nodes == 2:
        return 2, odd_node
    return 3, odd_node",data\repos\Python\graphs\eulerian_path_and_circuit_for_undirected_graph.py,check_circuit_or_path,112
985,eulerian_path_and_circuit_for_undirected_graph.py::check_euler::35,"def check_euler(graph, max_node):
    visited_edge = [[False for _ in range(max_node + 1)] for _ in range(max_node + 1)]
    check, odd_node = check_circuit_or_path(graph, max_node)
    if check == 3:
        print(""graph is not Eulerian"")
        print(""no path"")
        return
    start_node = 1
    if check == 2:
        start_node = odd_node
        print(""graph has a Euler path"")
    if check == 1:
        print(""graph has a Euler cycle"")
    path = dfs(start_node, graph, visited_edge)
    print(path)",data\repos\Python\graphs\eulerian_path_and_circuit_for_undirected_graph.py,check_euler,138
986,eulerian_path_and_circuit_for_undirected_graph.py::main::52,"def main():
    g1 = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}
    g2 = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}
    g3 = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}
    g4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}
    g5 = {
        1: [],
        2: [],
        # all degree is zero
    }
    max_node = 10
    check_euler(g1, max_node)
    check_euler(g2, max_node)
    check_euler(g3, max_node)
    check_euler(g4, max_node)
    check_euler(g5, max_node)",data\repos\Python\graphs\eulerian_path_and_circuit_for_undirected_graph.py,main,274
987,even_tree.py::dfs::20,"def dfs(start: int) -> int:
    """"""DFS traversal""""""
    # pylint: disable=redefined-outer-name
    ret = 1
    visited[start] = True
    for v in tree[start]:
        if v not in visited:
            ret += dfs(v)
    if ret % 2 == 0:
        cuts.append(start)
    return ret",data\repos\Python\graphs\even_tree.py,dfs,76
988,even_tree.py::even_tree::33,"def even_tree():
    """"""
    2 1
    3 1
    4 3
    5 2
    6 1
    7 2
    8 6
    9 8
    10 8
    On removing edges (1,3) and (1,6), we can get the desired result 2.
    """"""
    dfs(1)",data\repos\Python\graphs\even_tree.py,even_tree,91
989,finding_bridges.py::compute_bridges::60,"def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:
    """"""
    Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi
    >>> compute_bridges(__get_demo_graph(0))
    [(3, 4), (2, 3), (2, 5)]
    >>> compute_bridges(__get_demo_graph(1))
    [(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]
    >>> compute_bridges(__get_demo_graph(2))
    [(1, 6), (4, 6), (0, 4)]
    >>> compute_bridges(__get_demo_graph(3))
    []
    >>> compute_bridges({})
    []
    """"""

    id_ = 0
    n = len(graph)  # No of vertices in graph
    low = [0] * n
    visited = [False] * n

    def dfs(at, parent, bridges, id_):
        visited[at] = True
        low[at] = id_
        id_ += 1
        for to in graph[at]:
            if to == parent:
                pass
            elif not visited[to]:
                dfs(to, at, bridges, id_)
                low[at] = min(low[at], low[to])
                if id_ <= low[to]:
                    bridges.append((at, to) if at < to else (to, at))
            else:
                # This edge is a back edge and cannot be a bridge
                low[at] = min(low[at], low[to])

    bridges: list[tuple[int, int]] = []
    for i in range(n):
        if not visited[i]:
            dfs(i, -1, bridges, id_)
    return bridges",data\repos\Python\graphs\finding_bridges.py,compute_bridges,399
990,finding_bridges.py::dfs::80,"    def dfs(at, parent, bridges, id_):
        visited[at] = True
        low[at] = id_
        id_ += 1
        for to in graph[at]:
            if to == parent:
                pass
            elif not visited[to]:
                dfs(to, at, bridges, id_)
                low[at] = min(low[at], low[to])
                if id_ <= low[to]:
                    bridges.append((at, to) if at < to else (to, at))
            else:
                # This edge is a back edge and cannot be a bridge
                low[at] = min(low[at], low[to])",data\repos\Python\graphs\finding_bridges.py,dfs,132
991,frequent_pattern_graph_miner.py::get_distinct_edge::27,"def get_distinct_edge(edge_array):
    """"""
    Return Distinct edges from edge array of multiple graphs
    >>> sorted(get_distinct_edge(edge_array))
    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
    """"""
    distinct_edge = set()
    for row in edge_array:
        for item in row:
            distinct_edge.add(item[0])
    return list(distinct_edge)",data\repos\Python\graphs\frequent_pattern_graph_miner.py,get_distinct_edge,93
992,frequent_pattern_graph_miner.py::get_bitcode::40,"def get_bitcode(edge_array, distinct_edge):
    """"""
    Return bitcode of distinct_edge
    """"""
    bitcode = [""0""] * len(edge_array)
    for i, row in enumerate(edge_array):
        for item in row:
            if distinct_edge in item[0]:
                bitcode[i] = ""1""
                break
    return """".join(bitcode)",data\repos\Python\graphs\frequent_pattern_graph_miner.py,get_bitcode,78
993,frequent_pattern_graph_miner.py::get_frequency_table::53,"def get_frequency_table(edge_array):
    """"""
    Returns Frequency Table
    """"""
    distinct_edge = get_distinct_edge(edge_array)
    frequency_table = {}

    for item in distinct_edge:
        bit = get_bitcode(edge_array, item)
        # print('bit',bit)
        # bt=''.join(bit)
        s = bit.count(""1"")
        frequency_table[item] = [s, bit]
    # Store [Distinct edge, WT(Bitcode), Bitcode] in descending order
    sorted_frequency_table = [
        [k, v[0], v[1]]
        for k, v in sorted(frequency_table.items(), key=lambda v: v[1][0], reverse=True)
    ]
    return sorted_frequency_table",data\repos\Python\graphs\frequent_pattern_graph_miner.py,get_frequency_table,153
994,frequent_pattern_graph_miner.py::get_nodes::74,"def get_nodes(frequency_table):
    """"""
    Returns nodes
    format nodes={bitcode:edges that represent the bitcode}
    >>> get_nodes([['ab', 5, '11111'], ['ac', 5, '11111'], ['df', 5, '11111'],
    ...            ['bd', 5, '11111'], ['bc', 5, '11111']])
    {'11111': ['ab', 'ac', 'df', 'bd', 'bc']}
    """"""
    nodes = {}
    for _, item in enumerate(frequency_table):
        nodes.setdefault(item[2], []).append(item[0])
    return nodes",data\repos\Python\graphs\frequent_pattern_graph_miner.py,get_nodes,137
995,frequent_pattern_graph_miner.py::get_cluster::88,"def get_cluster(nodes):
    """"""
    Returns cluster
    format cluster:{WT(bitcode):nodes with same WT}
    """"""
    cluster = {}
    for key, value in nodes.items():
        cluster.setdefault(key.count(""1""), {})[key] = value
    return cluster",data\repos\Python\graphs\frequent_pattern_graph_miner.py,get_cluster,57
996,frequent_pattern_graph_miner.py::get_support::99,"def get_support(cluster):
    """"""
    Returns support
    >>> get_support({5: {'11111': ['ab', 'ac', 'df', 'bd', 'bc']},
    ...              4: {'11101': ['ef', 'eg', 'de', 'fg'], '11011': ['cd']},
    ...              3: {'11001': ['ad'], '10101': ['dg']},
    ...              2: {'10010': ['dh', 'bh'], '11000': ['be'], '10100': ['gh'],
    ...                  '10001': ['ce']},
    ...              1: {'00100': ['fh', 'eh'], '10000': ['hi']}})
    [100.0, 80.0, 60.0, 40.0, 20.0]
    """"""
    return [i * 100 / len(cluster) for i in cluster]",data\repos\Python\graphs\frequent_pattern_graph_miner.py,get_support,194
997,frequent_pattern_graph_miner.py::print_all::113,"def print_all() -> None:
    print(""\nNodes\n"")
    for key, value in nodes.items():
        print(key, value)
    print(""\nSupport\n"")
    print(support)
    print(""\n Cluster \n"")
    for key, value in sorted(cluster.items(), reverse=True):
        print(key, value)
    print(""\n Graph\n"")
    for key, value in graph.items():
        print(key, value)
    print(""\n Edge List of Frequent subgraphs \n"")
    for edge_list in freq_subgraph_edge_list:
        print(edge_list)",data\repos\Python\graphs\frequent_pattern_graph_miner.py,print_all,120
998,frequent_pattern_graph_miner.py::create_edge::130,"def create_edge(nodes, graph, cluster, c1):
    """"""
    create edge between the nodes
    """"""
    for i in cluster[c1]:
        count = 0
        c2 = c1 + 1
        while c2 < max(cluster.keys()):
            for j in cluster[c2]:
                """"""
                creates edge only if the condition satisfies
                """"""
                if int(i, 2) & int(j, 2) == int(i, 2):
                    if tuple(nodes[i]) in graph:
                        graph[tuple(nodes[i])].append(nodes[j])
                    else:
                        graph[tuple(nodes[i])] = [nodes[j]]
                    count += 1
            if count == 0:
                c2 = c2 + 1
            else:
                break",data\repos\Python\graphs\frequent_pattern_graph_miner.py,create_edge,163
999,frequent_pattern_graph_miner.py::construct_graph::154,"def construct_graph(cluster, nodes):
    x = cluster[max(cluster.keys())]
    cluster[max(cluster.keys()) + 1] = ""Header""
    graph = {}
    for i in x:
        if ([""Header""],) in graph:
            graph[([""Header""],)].append(x[i])
        else:
            graph[([""Header""],)] = [x[i]]
    for i in x:
        graph[(x[i],)] = [[""Header""]]
    i = 1
    while i < max(cluster) - 1:
        create_edge(nodes, graph, cluster, i)
        i = i + 1
    return graph",data\repos\Python\graphs\frequent_pattern_graph_miner.py,construct_graph,132
1000,frequent_pattern_graph_miner.py::my_dfs::172,"def my_dfs(graph, start, end, path=None):
    """"""
    find different DFS walk from given node to Header node
    """"""
    path = (path or []) + [start]
    if start == end:
        paths.append(path)
    for node in graph[start]:
        if tuple(node) not in path:
            my_dfs(graph, tuple(node), end, path)",data\repos\Python\graphs\frequent_pattern_graph_miner.py,my_dfs,80
1001,frequent_pattern_graph_miner.py::find_freq_subgraph_given_support::184,"def find_freq_subgraph_given_support(s, cluster, graph):
    """"""
    find edges of multiple frequent subgraphs
    """"""
    k = int(s / 100 * (len(cluster) - 1))
    for i in cluster[k]:
        my_dfs(graph, tuple(cluster[k][i]), ([""Header""],))",data\repos\Python\graphs\frequent_pattern_graph_miner.py,find_freq_subgraph_given_support,67
1002,frequent_pattern_graph_miner.py::freq_subgraphs_edge_list::193,"def freq_subgraphs_edge_list(paths):
    """"""
    returns Edge list for frequent subgraphs
    """"""
    freq_sub_el = []
    for edges in paths:
        el = []
        for j in range(len(edges) - 1):
            temp = list(edges[j])
            for e in temp:
                edge = (e[0], e[1])
                el.append(edge)
        freq_sub_el.append(el)
    return freq_sub_el",data\repos\Python\graphs\frequent_pattern_graph_miner.py,freq_subgraphs_edge_list,91
1003,frequent_pattern_graph_miner.py::preprocess::209,"def preprocess(edge_array):
    """"""
    Preprocess the edge array
    >>> preprocess([['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12',
    ...              'cd-e2', 'ce-e4', 'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3',
    ...              'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3']])

    """"""
    for i in range(len(edge_array)):
        for j in range(len(edge_array[i])):
            t = edge_array[i][j].split(""-"")
            edge_array[i][j] = t",data\repos\Python\graphs\frequent_pattern_graph_miner.py,preprocess,157
1004,gale_shapley_bigraph.py::stable_matching::4,"def stable_matching(
    donor_pref: list[list[int]], recipient_pref: list[list[int]]
) -> list[int]:
    """"""
    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects
    prefer each other over their partner.  The function accepts the preferences of
    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and
    returns a list where the index position corresponds to the donor and value at the
    index is the organ recipient.

    To better understand the algorithm, see also:
    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).
    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).

    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]
    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]
    >>> stable_matching(donor_pref, recipient_pref)
    [1, 2, 3, 0]
    """"""
    assert len(donor_pref) == len(recipient_pref)

    n = len(donor_pref)
    unmatched_donors = list(range(n))
    donor_record = [-1] * n  # who the donor has donated to
    rec_record = [-1] * n  # who the recipient has received from
    num_donations = [0] * n

    while unmatched_donors:
        donor = unmatched_donors[0]
        donor_preference = donor_pref[donor]
        recipient = donor_preference[num_donations[donor]]
        num_donations[donor] += 1
        rec_preference = recipient_pref[recipient]
        prev_donor = rec_record[recipient]

        if prev_donor != -1:
            if rec_preference.index(prev_donor) > rec_preference.index(donor):
                rec_record[recipient] = donor
                donor_record[donor] = recipient
                unmatched_donors.append(prev_donor)
                unmatched_donors.remove(donor)
        else:
            rec_record[recipient] = donor
            donor_record[donor] = recipient
            unmatched_donors.remove(donor)
    return donor_record",data\repos\Python\graphs\gale_shapley_bigraph.py,stable_matching,543
1005,graphs_floyd_warshall.py::floyd_warshall::19,"def floyd_warshall(graph, v):
    """"""
    :param graph: 2D array calculated from weight[edge[i, j]]
    :type graph: List[List[float]]
    :param v: number of vertices
    :type v: int
    :return: shortest distance between all vertex pairs
    distance[u][v] will contain the shortest distance from vertex u to v.

    1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).
    3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +
        distance[k][j]) for each possible pair i, j of vertices.
    4. The above is repeated for each vertex k in the graph.
    5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is
        updated to the next vertex[i][k].
    """"""

    dist = [[float(""inf"") for _ in range(v)] for _ in range(v)]

    for i in range(v):
        for j in range(v):
            dist[i][j] = graph[i][j]

            # check vertex k against all other vertices (i, j)
    for k in range(v):
        # looping through rows of graph array
        for i in range(v):
            # looping through columns of graph array
            for j in range(v):
                if (
                    dist[i][k] != float(""inf"")
                    and dist[k][j] != float(""inf"")
                    and dist[i][k] + dist[k][j] < dist[i][j]
                ):
                    dist[i][j] = dist[i][k] + dist[k][j]

    _print_dist(dist, v)
    return dist, v",data\repos\Python\graphs\graphs_floyd_warshall.py,floyd_warshall,377
1006,graph_adjacency_list.py::add_vertex::60,"    def add_vertex(self, vertex: T) -> None:
        """"""
        Adds a vertex to the graph. If the given vertex already exists,
        a ValueError will be thrown.

        >>> g = GraphAdjacencyList(vertices=[], edges=[], directed=False)
        >>> g.add_vertex(""A"")
        >>> g.adj_list
        {'A': []}
        >>> g.add_vertex(""A"")
        Traceback (most recent call last):
        ...
        ValueError: Incorrect input: A is already in the graph.
        """"""
        if self.contains_vertex(vertex):
            msg = f""Incorrect input: {vertex} is already in the graph.""
            raise ValueError(msg)
        self.adj_list[vertex] = []",data\repos\Python\graphs\graph_adjacency_list.py,add_vertex,143
1007,graph_adjacency_list.py::add_edge::79,"    def add_edge(self, source_vertex: T, destination_vertex: T) -> None:
        """"""
        Creates an edge from source vertex to destination vertex. If any
        given vertex doesn't exist or the edge already exists, a ValueError
        will be thrown.
        """"""
        if not (
            self.contains_vertex(source_vertex)
            and self.contains_vertex(destination_vertex)
        ):
            msg = (
                f""Incorrect input: Either {source_vertex} or ""
                f""{destination_vertex} does not exist""
            )
            raise ValueError(msg)
        if self.contains_edge(source_vertex, destination_vertex):
            msg = (
                ""Incorrect input: The edge already exists between ""
                f""{source_vertex} and {destination_vertex}""
            )
            raise ValueError(msg)

        # add the destination vertex to the list associated with the source vertex
        # and vice versa if not directed
        self.adj_list[source_vertex].append(destination_vertex)
        if not self.directed:
            self.adj_list[destination_vertex].append(source_vertex)",data\repos\Python\graphs\graph_adjacency_list.py,add_edge,210
1008,graph_adjacency_list.py::remove_vertex::107,"    def remove_vertex(self, vertex: T) -> None:
        """"""
        Removes the given vertex from the graph and deletes all incoming and
        outgoing edges from the given vertex as well. If the given vertex
        does not exist, a ValueError will be thrown.
        """"""
        if not self.contains_vertex(vertex):
            msg = f""Incorrect input: {vertex} does not exist in this graph.""
            raise ValueError(msg)

        if not self.directed:
            # If not directed, find all neighboring vertices and delete all references
            # of edges connecting to the given vertex
            for neighbor in self.adj_list[vertex]:
                self.adj_list[neighbor].remove(vertex)
        else:
            # If directed, search all neighbors of all vertices and delete all
            # references of edges connecting to the given vertex
            for edge_list in self.adj_list.values():
                if vertex in edge_list:
                    edge_list.remove(vertex)

        # Finally, delete the given vertex and all of its outgoing edge references
        self.adj_list.pop(vertex)",data\repos\Python\graphs\graph_adjacency_list.py,remove_vertex,214
1009,graph_adjacency_list.py::remove_edge::132,"    def remove_edge(self, source_vertex: T, destination_vertex: T) -> None:
        """"""
        Removes the edge between the two vertices. If any given vertex
        doesn't exist or the edge does not exist, a ValueError will be thrown.
        """"""
        if not (
            self.contains_vertex(source_vertex)
            and self.contains_vertex(destination_vertex)
        ):
            msg = (
                f""Incorrect input: Either {source_vertex} or ""
                f""{destination_vertex} does not exist""
            )
            raise ValueError(msg)
        if not self.contains_edge(source_vertex, destination_vertex):
            msg = (
                ""Incorrect input: The edge does NOT exist between ""
                f""{source_vertex} and {destination_vertex}""
            )
            raise ValueError(msg)

        # remove the destination vertex from the list associated with the source
        # vertex and vice versa if not directed
        self.adj_list[source_vertex].remove(destination_vertex)
        if not self.directed:
            self.adj_list[destination_vertex].remove(source_vertex)",data\repos\Python\graphs\graph_adjacency_list.py,remove_edge,209
1010,graph_adjacency_list.py::contains_vertex::159,"    def contains_vertex(self, vertex: T) -> bool:
        """"""
        Returns True if the graph contains the vertex, False otherwise.
        """"""
        return vertex in self.adj_list",data\repos\Python\graphs\graph_adjacency_list.py,contains_vertex,37
1011,graph_adjacency_list.py::contains_edge::165,"    def contains_edge(self, source_vertex: T, destination_vertex: T) -> bool:
        """"""
        Returns True if the graph contains the edge from the source_vertex to the
        destination_vertex, False otherwise. If any given vertex doesn't exist, a
        ValueError will be thrown.
        """"""
        if not (
            self.contains_vertex(source_vertex)
            and self.contains_vertex(destination_vertex)
        ):
            msg = (
                f""Incorrect input: Either {source_vertex} ""
                f""or {destination_vertex} does not exist.""
            )
            raise ValueError(msg)

        return destination_vertex in self.adj_list[source_vertex]",data\repos\Python\graphs\graph_adjacency_list.py,contains_edge,129
1012,graph_adjacency_list.py::test_init_check::278,"    def test_init_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        # test graph initialization with vertices and edges
        for num in random_vertices:
            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, num
            )

        for edge in random_edges:
            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, edge
            )
        assert not undirected_graph.directed
        assert directed_graph.directed",data\repos\Python\graphs\graph_adjacency_list.py,test_init_check,130
1013,graph_adjacency_list.py::test_contains_vertex::299,"    def test_contains_vertex(self) -> None:
        random_vertices: list[int] = random.sample(range(101), 20)

        # Build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyList(
            vertices=random_vertices, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyList(
            vertices=random_vertices, edges=[], directed=True
        )

        # Test contains_vertex
        for num in range(101):
            assert (num in random_vertices) == undirected_graph.contains_vertex(num)
            assert (num in random_vertices) == directed_graph.contains_vertex(num)",data\repos\Python\graphs\graph_adjacency_list.py,test_contains_vertex,122
1014,graph_adjacency_list.py::test_add_vertices::315,"    def test_add_vertices(self) -> None:
        random_vertices: list[int] = random.sample(range(101), 20)

        # build empty graphs
        undirected_graph: GraphAdjacencyList = GraphAdjacencyList(
            vertices=[], edges=[], directed=False
        )
        directed_graph: GraphAdjacencyList = GraphAdjacencyList(
            vertices=[], edges=[], directed=True
        )

        # run add_vertex
        for num in random_vertices:
            undirected_graph.add_vertex(num)

        for num in random_vertices:
            directed_graph.add_vertex(num)

        # test add_vertex worked
        for num in random_vertices:
            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, num
            )",data\repos\Python\graphs\graph_adjacency_list.py,test_add_vertices,152
1015,graph_adjacency_list.py::test_remove_vertices::339,"    def test_remove_vertices(self) -> None:
        random_vertices: list[int] = random.sample(range(101), 20)

        # build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyList(
            vertices=random_vertices, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyList(
            vertices=random_vertices, edges=[], directed=True
        )

        # test remove_vertex worked
        for num in random_vertices:
            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, num
            )

            undirected_graph.remove_vertex(num)
            directed_graph.remove_vertex(num)

            self.__assert_graph_vertex_does_not_exist_check(
                undirected_graph, directed_graph, num
            )",data\repos\Python\graphs\graph_adjacency_list.py,test_remove_vertices,150
1016,graph_adjacency_list.py::test_add_and_remove_vertices_repeatedly::363,"    def test_add_and_remove_vertices_repeatedly(self) -> None:
        random_vertices1: list[int] = random.sample(range(51), 20)
        random_vertices2: list[int] = random.sample(range(51, 101), 20)

        # build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyList(
            vertices=random_vertices1, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyList(
            vertices=random_vertices1, edges=[], directed=True
        )

        # test adding and removing vertices
        for i, _ in enumerate(random_vertices1):
            undirected_graph.add_vertex(random_vertices2[i])
            directed_graph.add_vertex(random_vertices2[i])

            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, random_vertices2[i]
            )

            undirected_graph.remove_vertex(random_vertices1[i])
            directed_graph.remove_vertex(random_vertices1[i])

            self.__assert_graph_vertex_does_not_exist_check(
                undirected_graph, directed_graph, random_vertices1[i]
            )

        # remove all vertices
        for i, _ in enumerate(random_vertices1):
            undirected_graph.remove_vertex(random_vertices2[i])
            directed_graph.remove_vertex(random_vertices2[i])

            self.__assert_graph_vertex_does_not_exist_check(
                undirected_graph, directed_graph, random_vertices2[i]
            )",data\repos\Python\graphs\graph_adjacency_list.py,test_add_and_remove_vertices_repeatedly,281
1017,graph_adjacency_list.py::test_contains_edge::400,"    def test_contains_edge(self) -> None:
        # generate graphs and graph input
        vertex_count = 20
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(vertex_count, 0, 100, 4)

        # generate all possible edges for testing
        all_possible_edges: list[list[int]] = []
        for i in range(vertex_count - 1):
            for j in range(i + 1, vertex_count):
                all_possible_edges.append([random_vertices[i], random_vertices[j]])
                all_possible_edges.append([random_vertices[j], random_vertices[i]])

        # test contains_edge function
        for edge in all_possible_edges:
            if edge in random_edges:
                self.__assert_graph_edge_exists_check(
                    undirected_graph, directed_graph, edge
                )
            elif [edge[1], edge[0]] in random_edges:
                # since this edge exists for undirected but the reverse
                # may not exist for directed
                self.__assert_graph_edge_exists_check(
                    undirected_graph, directed_graph, [edge[1], edge[0]]
                )
            else:
                self.__assert_graph_edge_does_not_exist_check(
                    undirected_graph, directed_graph, edge
                )",data\repos\Python\graphs\graph_adjacency_list.py,test_contains_edge,269
1018,graph_adjacency_list.py::test_add_edge::434,"    def test_add_edge(self) -> None:
        # generate graph input
        random_vertices: list[int] = random.sample(range(101), 15)
        random_edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)

        # build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyList(
            vertices=random_vertices, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyList(
            vertices=random_vertices, edges=[], directed=True
        )

        # run and test add_edge
        for edge in random_edges:
            undirected_graph.add_edge(edge[0], edge[1])
            directed_graph.add_edge(edge[0], edge[1])
            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, edge
            )",data\repos\Python\graphs\graph_adjacency_list.py,test_add_edge,166
1019,graph_adjacency_list.py::test_remove_edge::455,"    def test_remove_edge(self) -> None:
        # generate graph input and graphs
        (
            undirected_graph,
            directed_graph,
            _random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        # run and test remove_edge
        for edge in random_edges:
            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, edge
            )
            undirected_graph.remove_edge(edge[0], edge[1])
            directed_graph.remove_edge(edge[0], edge[1])
            self.__assert_graph_edge_does_not_exist_check(
                undirected_graph, directed_graph, edge
            )",data\repos\Python\graphs\graph_adjacency_list.py,test_remove_edge,144
1020,graph_adjacency_list.py::test_add_and_remove_edges_repeatedly::475,"    def test_add_and_remove_edges_repeatedly(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        # make some more edge options!
        more_random_edges: list[list[int]] = []

        while len(more_random_edges) != len(random_edges):
            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)
            for edge in edges:
                if len(more_random_edges) == len(random_edges):
                    break
                elif edge not in more_random_edges and edge not in random_edges:
                    more_random_edges.append(edge)

        for i, _ in enumerate(random_edges):
            undirected_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])
            directed_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])

            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, more_random_edges[i]
            )

            undirected_graph.remove_edge(random_edges[i][0], random_edges[i][1])
            directed_graph.remove_edge(random_edges[i][0], random_edges[i][1])

            self.__assert_graph_edge_does_not_exist_check(
                undirected_graph, directed_graph, random_edges[i]
            )",data\repos\Python\graphs\graph_adjacency_list.py,test_add_and_remove_edges_repeatedly,284
1021,graph_adjacency_list.py::test_add_vertex_exception_check::509,"    def test_add_vertex_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            _random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for vertex in random_vertices:
            with pytest.raises(ValueError):
                undirected_graph.add_vertex(vertex)
            with pytest.raises(ValueError):
                directed_graph.add_vertex(vertex)",data\repos\Python\graphs\graph_adjacency_list.py,test_add_vertex_exception_check,86
1022,graph_adjacency_list.py::test_remove_vertex_exception_check::523,"    def test_remove_vertex_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            _random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for i in range(101):
            if i not in random_vertices:
                with pytest.raises(ValueError):
                    undirected_graph.remove_vertex(i)
                with pytest.raises(ValueError):
                    directed_graph.remove_vertex(i)",data\repos\Python\graphs\graph_adjacency_list.py,test_remove_vertex_exception_check,95
1023,graph_adjacency_list.py::test_add_edge_exception_check::538,"    def test_add_edge_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            _random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for edge in random_edges:
            with pytest.raises(ValueError):
                undirected_graph.add_edge(edge[0], edge[1])
            with pytest.raises(ValueError):
                directed_graph.add_edge(edge[0], edge[1])",data\repos\Python\graphs\graph_adjacency_list.py,test_add_edge_exception_check,98
1024,graph_adjacency_list.py::test_remove_edge_exception_check::552,"    def test_remove_edge_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        more_random_edges: list[list[int]] = []

        while len(more_random_edges) != len(random_edges):
            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)
            for edge in edges:
                if len(more_random_edges) == len(random_edges):
                    break
                elif edge not in more_random_edges and edge not in random_edges:
                    more_random_edges.append(edge)

        for edge in more_random_edges:
            with pytest.raises(ValueError):
                undirected_graph.remove_edge(edge[0], edge[1])
            with pytest.raises(ValueError):
                directed_graph.remove_edge(edge[0], edge[1])",data\repos\Python\graphs\graph_adjacency_list.py,test_remove_edge_exception_check,185
1025,graph_adjacency_list.py::test_contains_edge_exception_check::576,"    def test_contains_edge_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            _random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for vertex in random_vertices:
            with pytest.raises(ValueError):
                undirected_graph.contains_edge(vertex, 102)
            with pytest.raises(ValueError):
                directed_graph.contains_edge(vertex, 102)

        with pytest.raises(ValueError):
            undirected_graph.contains_edge(103, 102)
        with pytest.raises(ValueError):
            directed_graph.contains_edge(103, 102)",data\repos\Python\graphs\graph_adjacency_list.py,test_contains_edge_exception_check,127
1026,graph_adjacency_matrix.py::add_edge::61,"    def add_edge(self, source_vertex: T, destination_vertex: T) -> None:
        """"""
        Creates an edge from source vertex to destination vertex. If any
        given vertex doesn't exist or the edge already exists, a ValueError
        will be thrown.
        """"""
        if not (
            self.contains_vertex(source_vertex)
            and self.contains_vertex(destination_vertex)
        ):
            msg = (
                f""Incorrect input: Either {source_vertex} or ""
                f""{destination_vertex} does not exist""
            )
            raise ValueError(msg)
        if self.contains_edge(source_vertex, destination_vertex):
            msg = (
                ""Incorrect input: The edge already exists between ""
                f""{source_vertex} and {destination_vertex}""
            )
            raise ValueError(msg)

        # Get the indices of the corresponding vertices and set their edge value to 1.
        u: int = self.vertex_to_index[source_vertex]
        v: int = self.vertex_to_index[destination_vertex]
        self.adj_matrix[u][v] = 1
        if not self.directed:
            self.adj_matrix[v][u] = 1",data\repos\Python\graphs\graph_adjacency_matrix.py,add_edge,229
1027,graph_adjacency_matrix.py::remove_edge::90,"    def remove_edge(self, source_vertex: T, destination_vertex: T) -> None:
        """"""
        Removes the edge between the two vertices. If any given vertex
        doesn't exist or the edge does not exist, a ValueError will be thrown.
        """"""
        if not (
            self.contains_vertex(source_vertex)
            and self.contains_vertex(destination_vertex)
        ):
            msg = (
                f""Incorrect input: Either {source_vertex} or ""
                f""{destination_vertex} does not exist""
            )
            raise ValueError(msg)
        if not self.contains_edge(source_vertex, destination_vertex):
            msg = (
                ""Incorrect input: The edge does NOT exist between ""
                f""{source_vertex} and {destination_vertex}""
            )
            raise ValueError(msg)

        # Get the indices of the corresponding vertices and set their edge value to 0.
        u: int = self.vertex_to_index[source_vertex]
        v: int = self.vertex_to_index[destination_vertex]
        self.adj_matrix[u][v] = 0
        if not self.directed:
            self.adj_matrix[v][u] = 0",data\repos\Python\graphs\graph_adjacency_matrix.py,remove_edge,228
1028,graph_adjacency_matrix.py::add_vertex::118,"    def add_vertex(self, vertex: T) -> None:
        """"""
        Adds a vertex to the graph. If the given vertex already exists,
        a ValueError will be thrown.
        """"""
        if self.contains_vertex(vertex):
            msg = f""Incorrect input: {vertex} already exists in this graph.""
            raise ValueError(msg)

        # build column for vertex
        for row in self.adj_matrix:
            row.append(0)

        # build row for vertex and update other data structures
        self.adj_matrix.append([0] * (len(self.adj_matrix) + 1))
        self.vertex_to_index[vertex] = len(self.adj_matrix) - 1",data\repos\Python\graphs\graph_adjacency_matrix.py,add_vertex,136
1029,graph_adjacency_matrix.py::remove_vertex::135,"    def remove_vertex(self, vertex: T) -> None:
        """"""
        Removes the given vertex from the graph and deletes all incoming and
        outgoing edges from the given vertex as well. If the given vertex
        does not exist, a ValueError will be thrown.
        """"""
        if not self.contains_vertex(vertex):
            msg = f""Incorrect input: {vertex} does not exist in this graph.""
            raise ValueError(msg)

        # first slide up the rows by deleting the row corresponding to
        # the vertex being deleted.
        start_index = self.vertex_to_index[vertex]
        self.adj_matrix.pop(start_index)

        # next, slide the columns to the left by deleting the values in
        # the column corresponding to the vertex being deleted
        for lst in self.adj_matrix:
            lst.pop(start_index)

        # final clean up
        self.vertex_to_index.pop(vertex)

        # decrement indices for vertices shifted by the deleted vertex in the adj matrix
        for inner_vertex in self.vertex_to_index:
            if self.vertex_to_index[inner_vertex] >= start_index:
                self.vertex_to_index[inner_vertex] = (
                    self.vertex_to_index[inner_vertex] - 1
                )",data\repos\Python\graphs\graph_adjacency_matrix.py,remove_vertex,248
1030,graph_adjacency_matrix.py::contains_vertex::165,"    def contains_vertex(self, vertex: T) -> bool:
        """"""
        Returns True if the graph contains the vertex, False otherwise.
        """"""
        return vertex in self.vertex_to_index",data\repos\Python\graphs\graph_adjacency_matrix.py,contains_vertex,38
1031,graph_adjacency_matrix.py::contains_edge::171,"    def contains_edge(self, source_vertex: T, destination_vertex: T) -> bool:
        """"""
        Returns True if the graph contains the edge from the source_vertex to the
        destination_vertex, False otherwise. If any given vertex doesn't exist, a
        ValueError will be thrown.
        """"""
        if not (
            self.contains_vertex(source_vertex)
            and self.contains_vertex(destination_vertex)
        ):
            msg = (
                f""Incorrect input: Either {source_vertex} ""
                f""or {destination_vertex} does not exist.""
            )
            raise ValueError(msg)

        u = self.vertex_to_index[source_vertex]
        v = self.vertex_to_index[destination_vertex]
        return self.adj_matrix[u][v] == 1",data\repos\Python\graphs\graph_adjacency_matrix.py,contains_edge,151
1032,graph_adjacency_matrix.py::clear_graph::191,"    def clear_graph(self) -> None:
        """"""
        Clears all vertices and edges.
        """"""
        self.vertex_to_index = {}
        self.adj_matrix = []",data\repos\Python\graphs\graph_adjacency_matrix.py,clear_graph,33
1033,graph_adjacency_matrix.py::test_init_check::289,"    def test_init_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        # test graph initialization with vertices and edges
        for num in random_vertices:
            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, num
            )

        for edge in random_edges:
            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, edge
            )

        assert not undirected_graph.directed
        assert directed_graph.directed",data\repos\Python\graphs\graph_adjacency_matrix.py,test_init_check,130
1034,graph_adjacency_matrix.py::test_contains_vertex::311,"    def test_contains_vertex(self) -> None:
        random_vertices: list[int] = random.sample(range(101), 20)

        # Build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyMatrix(
            vertices=random_vertices, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyMatrix(
            vertices=random_vertices, edges=[], directed=True
        )

        # Test contains_vertex
        for num in range(101):
            assert (num in random_vertices) == undirected_graph.contains_vertex(num)
            assert (num in random_vertices) == directed_graph.contains_vertex(num)",data\repos\Python\graphs\graph_adjacency_matrix.py,test_contains_vertex,122
1035,graph_adjacency_matrix.py::test_add_vertices::327,"    def test_add_vertices(self) -> None:
        random_vertices: list[int] = random.sample(range(101), 20)

        # build empty graphs
        undirected_graph: GraphAdjacencyMatrix = GraphAdjacencyMatrix(
            vertices=[], edges=[], directed=False
        )
        directed_graph: GraphAdjacencyMatrix = GraphAdjacencyMatrix(
            vertices=[], edges=[], directed=True
        )

        # run add_vertex
        for num in random_vertices:
            undirected_graph.add_vertex(num)

        for num in random_vertices:
            directed_graph.add_vertex(num)

        # test add_vertex worked
        for num in random_vertices:
            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, num
            )",data\repos\Python\graphs\graph_adjacency_matrix.py,test_add_vertices,152
1036,graph_adjacency_matrix.py::test_remove_vertices::351,"    def test_remove_vertices(self) -> None:
        random_vertices: list[int] = random.sample(range(101), 20)

        # build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyMatrix(
            vertices=random_vertices, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyMatrix(
            vertices=random_vertices, edges=[], directed=True
        )

        # test remove_vertex worked
        for num in random_vertices:
            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, num
            )

            undirected_graph.remove_vertex(num)
            directed_graph.remove_vertex(num)

            self.__assert_graph_vertex_does_not_exist_check(
                undirected_graph, directed_graph, num
            )",data\repos\Python\graphs\graph_adjacency_matrix.py,test_remove_vertices,150
1037,graph_adjacency_matrix.py::test_add_and_remove_vertices_repeatedly::375,"    def test_add_and_remove_vertices_repeatedly(self) -> None:
        random_vertices1: list[int] = random.sample(range(51), 20)
        random_vertices2: list[int] = random.sample(range(51, 101), 20)

        # build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyMatrix(
            vertices=random_vertices1, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyMatrix(
            vertices=random_vertices1, edges=[], directed=True
        )

        # test adding and removing vertices
        for i, _ in enumerate(random_vertices1):
            undirected_graph.add_vertex(random_vertices2[i])
            directed_graph.add_vertex(random_vertices2[i])

            self.__assert_graph_vertex_exists_check(
                undirected_graph, directed_graph, random_vertices2[i]
            )

            undirected_graph.remove_vertex(random_vertices1[i])
            directed_graph.remove_vertex(random_vertices1[i])

            self.__assert_graph_vertex_does_not_exist_check(
                undirected_graph, directed_graph, random_vertices1[i]
            )

        # remove all vertices
        for i, _ in enumerate(random_vertices1):
            undirected_graph.remove_vertex(random_vertices2[i])
            directed_graph.remove_vertex(random_vertices2[i])

            self.__assert_graph_vertex_does_not_exist_check(
                undirected_graph, directed_graph, random_vertices2[i]
            )",data\repos\Python\graphs\graph_adjacency_matrix.py,test_add_and_remove_vertices_repeatedly,281
1038,graph_adjacency_matrix.py::test_contains_edge::412,"    def test_contains_edge(self) -> None:
        # generate graphs and graph input
        vertex_count = 20
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(vertex_count, 0, 100, 4)

        # generate all possible edges for testing
        all_possible_edges: list[list[int]] = []
        for i in range(vertex_count - 1):
            for j in range(i + 1, vertex_count):
                all_possible_edges.append([random_vertices[i], random_vertices[j]])
                all_possible_edges.append([random_vertices[j], random_vertices[i]])

        # test contains_edge function
        for edge in all_possible_edges:
            if edge in random_edges:
                self.__assert_graph_edge_exists_check(
                    undirected_graph, directed_graph, edge
                )
            elif [edge[1], edge[0]] in random_edges:
                # since this edge exists for undirected but the reverse may
                # not exist for directed
                self.__assert_graph_edge_exists_check(
                    undirected_graph, directed_graph, [edge[1], edge[0]]
                )
            else:
                self.__assert_graph_edge_does_not_exist_check(
                    undirected_graph, directed_graph, edge
                )",data\repos\Python\graphs\graph_adjacency_matrix.py,test_contains_edge,269
1039,graph_adjacency_matrix.py::test_add_edge::446,"    def test_add_edge(self) -> None:
        # generate graph input
        random_vertices: list[int] = random.sample(range(101), 15)
        random_edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)

        # build graphs WITHOUT edges
        undirected_graph = GraphAdjacencyMatrix(
            vertices=random_vertices, edges=[], directed=False
        )
        directed_graph = GraphAdjacencyMatrix(
            vertices=random_vertices, edges=[], directed=True
        )

        # run and test add_edge
        for edge in random_edges:
            undirected_graph.add_edge(edge[0], edge[1])
            directed_graph.add_edge(edge[0], edge[1])
            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, edge
            )",data\repos\Python\graphs\graph_adjacency_matrix.py,test_add_edge,166
1040,graph_adjacency_matrix.py::test_remove_edge::467,"    def test_remove_edge(self) -> None:
        # generate graph input and graphs
        (
            undirected_graph,
            directed_graph,
            _random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        # run and test remove_edge
        for edge in random_edges:
            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, edge
            )
            undirected_graph.remove_edge(edge[0], edge[1])
            directed_graph.remove_edge(edge[0], edge[1])
            self.__assert_graph_edge_does_not_exist_check(
                undirected_graph, directed_graph, edge
            )",data\repos\Python\graphs\graph_adjacency_matrix.py,test_remove_edge,144
1041,graph_adjacency_matrix.py::test_add_and_remove_edges_repeatedly::487,"    def test_add_and_remove_edges_repeatedly(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        # make some more edge options!
        more_random_edges: list[list[int]] = []

        while len(more_random_edges) != len(random_edges):
            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)
            for edge in edges:
                if len(more_random_edges) == len(random_edges):
                    break
                elif edge not in more_random_edges and edge not in random_edges:
                    more_random_edges.append(edge)

        for i, _ in enumerate(random_edges):
            undirected_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])
            directed_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])

            self.__assert_graph_edge_exists_check(
                undirected_graph, directed_graph, more_random_edges[i]
            )

            undirected_graph.remove_edge(random_edges[i][0], random_edges[i][1])
            directed_graph.remove_edge(random_edges[i][0], random_edges[i][1])

            self.__assert_graph_edge_does_not_exist_check(
                undirected_graph, directed_graph, random_edges[i]
            )",data\repos\Python\graphs\graph_adjacency_matrix.py,test_add_and_remove_edges_repeatedly,284
1042,graph_adjacency_matrix.py::test_add_vertex_exception_check::521,"    def test_add_vertex_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            _random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for vertex in random_vertices:
            with pytest.raises(ValueError):
                undirected_graph.add_vertex(vertex)
            with pytest.raises(ValueError):
                directed_graph.add_vertex(vertex)",data\repos\Python\graphs\graph_adjacency_matrix.py,test_add_vertex_exception_check,86
1043,graph_adjacency_matrix.py::test_remove_vertex_exception_check::535,"    def test_remove_vertex_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            _random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for i in range(101):
            if i not in random_vertices:
                with pytest.raises(ValueError):
                    undirected_graph.remove_vertex(i)
                with pytest.raises(ValueError):
                    directed_graph.remove_vertex(i)",data\repos\Python\graphs\graph_adjacency_matrix.py,test_remove_vertex_exception_check,95
1044,graph_adjacency_matrix.py::test_add_edge_exception_check::550,"    def test_add_edge_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            _random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for edge in random_edges:
            with pytest.raises(ValueError):
                undirected_graph.add_edge(edge[0], edge[1])
            with pytest.raises(ValueError):
                directed_graph.add_edge(edge[0], edge[1])",data\repos\Python\graphs\graph_adjacency_matrix.py,test_add_edge_exception_check,98
1045,graph_adjacency_matrix.py::test_remove_edge_exception_check::564,"    def test_remove_edge_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        more_random_edges: list[list[int]] = []

        while len(more_random_edges) != len(random_edges):
            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)
            for edge in edges:
                if len(more_random_edges) == len(random_edges):
                    break
                elif edge not in more_random_edges and edge not in random_edges:
                    more_random_edges.append(edge)

        for edge in more_random_edges:
            with pytest.raises(ValueError):
                undirected_graph.remove_edge(edge[0], edge[1])
            with pytest.raises(ValueError):
                directed_graph.remove_edge(edge[0], edge[1])",data\repos\Python\graphs\graph_adjacency_matrix.py,test_remove_edge_exception_check,185
1046,graph_adjacency_matrix.py::test_contains_edge_exception_check::588,"    def test_contains_edge_exception_check(self) -> None:
        (
            undirected_graph,
            directed_graph,
            random_vertices,
            _random_edges,
        ) = self.__generate_graphs(20, 0, 100, 4)

        for vertex in random_vertices:
            with pytest.raises(ValueError):
                undirected_graph.contains_edge(vertex, 102)
            with pytest.raises(ValueError):
                directed_graph.contains_edge(vertex, 102)

        with pytest.raises(ValueError):
            undirected_graph.contains_edge(103, 102)
        with pytest.raises(ValueError):
            directed_graph.contains_edge(103, 102)",data\repos\Python\graphs\graph_adjacency_matrix.py,test_contains_edge_exception_check,127
1047,graph_list.py::add_edge::84,"    def add_edge(
        self, source_vertex: T, destination_vertex: T
    ) -> GraphAdjacencyList[T]:
        """"""
        Connects vertices together. Creates and Edge from source vertex to destination
        vertex.
        Vertices will be created if not found in graph
        """"""

        if not self.directed:  # For undirected graphs
            # if both source vertex and destination vertex are both present in the
            # adjacency list, add destination vertex to source vertex list of adjacent
            # vertices and add source vertex to destination vertex list of adjacent
            # vertices.
            if source_vertex in self.adj_list and destination_vertex in self.adj_list:
                self.adj_list[source_vertex].append(destination_vertex)
                self.adj_list[destination_vertex].append(source_vertex)
            # if only source vertex is present in adjacency list, add destination vertex
            # to source vertex list of adjacent vertices, then create a new vertex with
            # destination vertex as key and assign a list containing the source vertex
            # as it's first adjacent vertex.
            elif source_vertex in self.adj_list:
                self.adj_list[source_vertex].append(destination_vertex)
                self.adj_list[destination_vertex] = [source_vertex]
            # if only destination vertex is present in adjacency list, add source vertex
            # to destination vertex list of adjacent vertices, then create a new vertex
            # with source vertex as key and assign a list containing the source vertex
            # as it's first adjacent vertex.
            elif destination_vertex in self.adj_list:
                self.adj_list[destination_vertex].append(source_vertex)
                self.adj_list[source_vertex] = [destination_vertex]
            # if both source vertex and destination vertex are not present in adjacency
            # list, create a new vertex with source vertex as key and assign a list
            # containing the destination vertex as it's first adjacent vertex also
            # create a new vertex with destination vertex as key and assign a list
            # containing the source vertex as it's first adjacent vertex.
            else:
                self.adj_list[source_vertex] = [destination_vertex]
                self.adj_list[destination_vertex] = [source_vertex]
        # For directed graphs
        # if both source vertex and destination vertex are present in adjacency
        # list, add destination vertex to source vertex list of adjacent vertices.
        elif source_vertex in self.adj_list and destination_vertex in self.adj_list:
            self.adj_list[source_vertex].append(destination_vertex)
        # if only source vertex is present in adjacency list, add destination
        # vertex to source vertex list of adjacent vertices and create a new vertex
        # with destination vertex as key, which has no adjacent vertex
        elif source_vertex in self.adj_list:
            self.adj_list[source_vertex].append(destination_vertex)
            self.adj_list[destination_vertex] = []
        # if only destination vertex is present in adjacency list, create a new
        # vertex with source vertex as key and assign a list containing destination
        # vertex as first adjacent vertex
        elif destination_vertex in self.adj_list:
            self.adj_list[source_vertex] = [destination_vertex]
        # if both source vertex and destination vertex are not present in adjacency
        # list, create a new vertex with source vertex as key and a list containing
        # destination vertex as it's first adjacent vertex. Then create a new vertex
        # with destination vertex as key, which has no adjacent vertex
        else:
            self.adj_list[source_vertex] = [destination_vertex]
            self.adj_list[destination_vertex] = []

        return self",data\repos\Python\graphs\graph_list.py,add_edge,735
1048,greedy_best_first.py::calculate_heuristic::74,"    def calculate_heuristic(self) -> float:
        """"""
        The heuristic here is the Manhattan Distance
        Could elaborate to offer more than one choice
        """"""
        dx = abs(self.pos_x - self.goal_x)
        dy = abs(self.pos_y - self.goal_y)
        return dx + dy",data\repos\Python\graphs\greedy_best_first.py,calculate_heuristic,62
1049,greedy_best_first.py::search::119,"    def search(self) -> Path | None:
        """"""
        Search for the path,
        if a path is not found, only the starting position is returned
        """"""
        while self.open_nodes:
            # Open Nodes are sorted using __lt__
            self.open_nodes.sort()
            current_node = self.open_nodes.pop(0)

            if current_node.pos == self.target.pos:
                self.reached = True
                return self.retrace_path(current_node)

            self.closed_nodes.append(current_node)
            successors = self.get_successors(current_node)

            for child_node in successors:
                if child_node in self.closed_nodes:
                    continue

                if child_node not in self.open_nodes:
                    self.open_nodes.append(child_node)

        if not self.reached:
            return [self.start.pos]
        return None",data\repos\Python\graphs\greedy_best_first.py,search,166
1050,greedy_best_first.py::get_successors::147,"    def get_successors(self, parent: Node) -> list[Node]:
        """"""
        Returns a list of successors (both in the grid and free spaces)
        """"""
        return [
            Node(
                pos_x,
                pos_y,
                self.target.pos_x,
                self.target.pos_y,
                parent.g_cost + 1,
                parent,
            )
            for action in delta
            if (
                0 <= (pos_x := parent.pos_x + action[1]) < len(self.grid[0])
                and 0 <= (pos_y := parent.pos_y + action[0]) < len(self.grid)
                and self.grid[pos_y][pos_x] == 0
            )
        ]",data\repos\Python\graphs\greedy_best_first.py,get_successors,146
1051,greedy_best_first.py::retrace_path::168,"    def retrace_path(self, node: Node | None) -> Path:
        """"""
        Retrace the path from parents to parents until start node
        """"""
        current_node = node
        path = []
        while current_node is not None:
            path.append((current_node.pos_y, current_node.pos_x))
            current_node = current_node.parent
        path.reverse()
        return path",data\repos\Python\graphs\greedy_best_first.py,retrace_path,80
1052,greedy_min_vertex_cover.py::greedy_min_vertex_cover::12,"def greedy_min_vertex_cover(graph: dict) -> set[int]:
    """"""
    Greedy APX Algorithm for min Vertex Cover
    @input: graph (graph stored in an adjacency list where each vertex
            is represented with an integer)
    @example:
    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}
    >>> greedy_min_vertex_cover(graph)
    {0, 1, 2, 4}
    """"""
    # queue used to store nodes and their rank
    queue: list[list] = []

    # for each node and his adjacency list add them and the rank of the node to queue
    # using heapq module the queue will be filled like a Priority Queue
    # heapq works with a min priority queue, so I used -1*len(v) to build it
    for key, value in graph.items():
        # O(log(n))
        heapq.heappush(queue, [-1 * len(value), (key, value)])

    # chosen_vertices = set of chosen vertices
    chosen_vertices = set()

    # while queue isn't empty and there are still edges
    #   (queue[0][0] is the rank of the node with max rank)
    while queue and queue[0][0] != 0:
        # extract vertex with max rank from queue and add it to chosen_vertices
        argmax = heapq.heappop(queue)[1][0]
        chosen_vertices.add(argmax)

        # Remove all arcs adjacent to argmax
        for elem in queue:
            # if v haven't adjacent node, skip
            if elem[0] == 0:
                continue
            # if argmax is reachable from elem
            # remove argmax from elem's adjacent list and update his rank
            if argmax in elem[1][1]:
                index = elem[1][1].index(argmax)
                del elem[1][1][index]
                elem[0] += 1
        # re-order the queue
        heapq.heapify(queue)
    return chosen_vertices",data\repos\Python\graphs\greedy_min_vertex_cover.py,greedy_min_vertex_cover,466
1053,g_topological_sort.py::print_stack::21,"def print_stack(stack, clothes):
    order = 1
    while stack:
        current_clothing = stack.pop()
        print(order, clothes[current_clothing])
        order += 1",data\repos\Python\graphs\g_topological_sort.py,print_stack,41
1054,g_topological_sort.py::depth_first_search::29,"def depth_first_search(u, visited, graph):
    visited[u] = 1
    for v in graph[u]:
        if not visited[v]:
            depth_first_search(v, visited, graph)

    stack.append(u)",data\repos\Python\graphs\g_topological_sort.py,depth_first_search,46
1055,g_topological_sort.py::topological_sort::38,"def topological_sort(graph, visited):
    for v in range(len(graph)):
        if not visited[v]:
            depth_first_search(v, visited, graph)",data\repos\Python\graphs\g_topological_sort.py,topological_sort,32
1056,kahns_algorithm_long.py::longest_distance::2,"def longest_distance(graph):
    indegree = [0] * len(graph)
    queue = []
    long_dist = [1] * len(graph)

    for values in graph.values():
        for i in values:
            indegree[i] += 1

    for i in range(len(indegree)):
        if indegree[i] == 0:
            queue.append(i)

    while queue:
        vertex = queue.pop(0)
        for x in graph[vertex]:
            indegree[x] -= 1

            long_dist[x] = max(long_dist[x], long_dist[vertex] + 1)

            if indegree[x] == 0:
                queue.append(x)

    print(max(long_dist))",data\repos\Python\graphs\kahns_algorithm_long.py,longest_distance,145
1057,kahns_algorithm_topo.py::topological_sort::1,"def topological_sort(graph: dict[int, list[int]]) -> list[int] | None:
    """"""
    Perform topological sorting of a Directed Acyclic Graph (DAG)
    using Kahn's Algorithm via Breadth-First Search (BFS).

    Topological sorting is a linear ordering of vertices in a graph such that for
    every directed edge u  v, vertex u comes before vertex v in the ordering.

    Parameters:
    graph: Adjacency list representing the directed graph where keys are
           vertices, and values are lists of adjacent vertices.

    Returns:
    The topologically sorted order of vertices if the graph is a DAG.
    Returns None if the graph contains a cycle.

    Example:
    >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}
    >>> topological_sort(graph)
    [0, 1, 2, 3, 4, 5]

    >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}
    >>> topological_sort(graph_with_cycle)
    """"""

    indegree = [0] * len(graph)
    queue = []
    topo_order = []
    processed_vertices_count = 0

    # Calculate the indegree of each vertex
    for values in graph.values():
        for i in values:
            indegree[i] += 1

    # Add all vertices with 0 indegree to the queue
    for i in range(len(indegree)):
        if indegree[i] == 0:
            queue.append(i)

    # Perform BFS
    while queue:
        vertex = queue.pop(0)
        processed_vertices_count += 1
        topo_order.append(vertex)

        # Traverse neighbors
        for neighbor in graph[vertex]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)

    if processed_vertices_count != len(graph):
        return None  # no topological ordering exists due to cycle
    return topo_order  # valid topological ordering",data\repos\Python\graphs\kahns_algorithm_topo.py,topological_sort,450
1058,karger.py::partition_graph::25,"def partition_graph(graph: dict[str, list[str]]) -> set[tuple[str, str]]:
    """"""
    Partitions a graph using Karger's Algorithm. Implemented from
    pseudocode found here:
    https://en.wikipedia.org/wiki/Karger%27s_algorithm.
    This function involves random choices, meaning it will not give
    consistent outputs.

    Args:
        graph: A dictionary containing adacency lists for the graph.
            Nodes must be strings.

    Returns:
        The cutset of the cut found by Karger's Algorithm.

    >>> graph = {'0':['1'], '1':['0']}
    >>> partition_graph(graph)
    {('0', '1')}
    """"""
    # Dict that maps contracted nodes to a list of all the nodes it ""contains.""
    contracted_nodes = {node: {node} for node in graph}

    graph_copy = {node: graph[node][:] for node in graph}

    while len(graph_copy) > 2:
        # Choose a random edge.
        u = random.choice(list(graph_copy.keys()))
        v = random.choice(graph_copy[u])

        # Contract edge (u, v) to new node uv
        uv = u + v
        uv_neighbors = list(set(graph_copy[u] + graph_copy[v]))
        uv_neighbors.remove(u)
        uv_neighbors.remove(v)
        graph_copy[uv] = uv_neighbors
        for neighbor in uv_neighbors:
            graph_copy[neighbor].append(uv)

        contracted_nodes[uv] = set(contracted_nodes[u].union(contracted_nodes[v]))

        # Remove nodes u and v.
        del graph_copy[u]
        del graph_copy[v]
        for neighbor in uv_neighbors:
            if u in graph_copy[neighbor]:
                graph_copy[neighbor].remove(u)
            if v in graph_copy[neighbor]:
                graph_copy[neighbor].remove(v)

    # Find cutset.
    groups = [contracted_nodes[node] for node in graph_copy]
    return {
        (node, neighbor)
        for node in groups[0]
        for neighbor in graph[node]
        if neighbor in groups[1]
    }",data\repos\Python\graphs\karger.py,partition_graph,438
1059,lanczos_eigenvectors.py::validate_adjacency_list::32,"def validate_adjacency_list(graph: list[list[int | None]]) -> None:
    """"""Validates the adjacency list format for the graph.

    Args:
        graph: A list of lists where each sublist contains the neighbors of a node.

    Raises:
        ValueError: If the graph is not a list of lists, or if any node has
                    invalid neighbors (e.g., out-of-range or non-integer values).

    >>> validate_adjacency_list([[1, 2], [0], [0, 1]])
    >>> validate_adjacency_list([[]])  # No neighbors, valid case
    >>> validate_adjacency_list([[1], [2], [-1]])  # Invalid neighbor
    Traceback (most recent call last):
        ...
    ValueError: Invalid neighbor -1 in node 2 adjacency list.
    """"""
    if not isinstance(graph, list):
        raise ValueError(""Graph should be a list of lists."")

    for node_index, neighbors in enumerate(graph):
        if not isinstance(neighbors, list):
            no_neighbors_message: str = (
                f""Node {node_index} should have a list of neighbors.""
            )
            raise ValueError(no_neighbors_message)
        for neighbor_index in neighbors:
            if (
                not isinstance(neighbor_index, int)
                or neighbor_index < 0
                or neighbor_index >= len(graph)
            ):
                invalid_neighbor_message: str = (
                    f""Invalid neighbor {neighbor_index} in node {node_index} ""
                    f""adjacency list.""
                )
                raise ValueError(invalid_neighbor_message)",data\repos\Python\graphs\lanczos_eigenvectors.py,validate_adjacency_list,320
1060,lanczos_eigenvectors.py::lanczos_iteration::71,"def lanczos_iteration(
    graph: list[list[int | None]], num_eigenvectors: int
) -> tuple[np.ndarray, np.ndarray]:
    """"""Constructs the tridiagonal matrix and orthonormal basis vectors using the
    Lanczos method.

    Args:
        graph: The graph represented as a list of adjacency lists.
        num_eigenvectors: The number of largest eigenvalues and eigenvectors
                          to approximate.

    Returns:
        A tuple containing:
            - tridiagonal_matrix: A (num_eigenvectors x num_eigenvectors) symmetric
                                  matrix.
            - orthonormal_basis: A (num_nodes x num_eigenvectors) matrix of orthonormal
                                 basis vectors.

    Raises:
        ValueError: If num_eigenvectors is less than 1 or greater than the number of
                    nodes.

    >>> graph = [[1, 2], [0, 2], [0, 1]]
    >>> T, Q = lanczos_iteration(graph, 2)
    >>> T.shape == (2, 2) and Q.shape == (3, 2)
    True
    """"""
    num_nodes: int = len(graph)
    if not (1 <= num_eigenvectors <= num_nodes):
        raise ValueError(
            ""Number of eigenvectors must be between 1 and the number of ""
            ""nodes in the graph.""
        )

    orthonormal_basis: np.ndarray = np.zeros((num_nodes, num_eigenvectors))
    tridiagonal_matrix: np.ndarray = np.zeros((num_eigenvectors, num_eigenvectors))

    rng = np.random.default_rng()
    initial_vector: np.ndarray = rng.random(num_nodes)
    initial_vector /= np.sqrt(np.dot(initial_vector, initial_vector))
    orthonormal_basis[:, 0] = initial_vector

    prev_beta: float = 0.0
    for iter_index in range(num_eigenvectors):
        result_vector: np.ndarray = multiply_matrix_vector(
            graph, orthonormal_basis[:, iter_index]
        )
        if iter_index > 0:
            result_vector -= prev_beta * orthonormal_basis[:, iter_index - 1]
        alpha_value: float = np.dot(orthonormal_basis[:, iter_index], result_vector)
        result_vector -= alpha_value * orthonormal_basis[:, iter_index]

        prev_beta = np.sqrt(np.dot(result_vector, result_vector))
        if iter_index < num_eigenvectors - 1 and prev_beta > 1e-10:
            orthonormal_basis[:, iter_index + 1] = result_vector / prev_beta
        tridiagonal_matrix[iter_index, iter_index] = alpha_value
        if iter_index < num_eigenvectors - 1:
            tridiagonal_matrix[iter_index, iter_index + 1] = prev_beta
            tridiagonal_matrix[iter_index + 1, iter_index] = prev_beta
    return tridiagonal_matrix, orthonormal_basis",data\repos\Python\graphs\lanczos_eigenvectors.py,lanczos_iteration,632
1061,lanczos_eigenvectors.py::multiply_matrix_vector::133,"def multiply_matrix_vector(
    graph: list[list[int | None]], vector: np.ndarray
) -> np.ndarray:
    """"""Performs multiplication of a graph's adjacency list representation with a vector.

    Args:
        graph: The adjacency list of the graph.
        vector: A 1D numpy array representing the vector to multiply.

    Returns:
        A numpy array representing the product of the adjacency list and the vector.

    Raises:
        ValueError: If the vector's length does not match the number of nodes in the
                    graph.

    >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([1, 1, 1]))
    array([2., 2., 2.])
    >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([0, 1, 0]))
    array([1., 0., 1.])
    """"""
    num_nodes: int = len(graph)
    if vector.shape[0] != num_nodes:
        raise ValueError(""Vector length must match the number of nodes in the graph."")

    result: np.ndarray = np.zeros(num_nodes)
    for node_index, neighbors in enumerate(graph):
        for neighbor_index in neighbors:
            result[node_index] += vector[neighbor_index]
    return result",data\repos\Python\graphs\lanczos_eigenvectors.py,multiply_matrix_vector,282
1062,lanczos_eigenvectors.py::find_lanczos_eigenvectors::165,"def find_lanczos_eigenvectors(
    graph: list[list[int | None]], num_eigenvectors: int
) -> tuple[np.ndarray, np.ndarray]:
    """"""Computes the largest eigenvalues and their corresponding eigenvectors using the
    Lanczos method.

    Args:
        graph: The graph as a list of adjacency lists.
        num_eigenvectors: Number of largest eigenvalues and eigenvectors to compute.

    Returns:
        A tuple containing:
            - eigenvalues: 1D array of the largest eigenvalues in descending order.
            - eigenvectors: 2D array where each column is an eigenvector corresponding
                            to an eigenvalue.

    Raises:
        ValueError: If the graph format is invalid or num_eigenvectors is out of bounds.

    >>> eigenvalues, eigenvectors = find_lanczos_eigenvectors(
    ...     [[1, 2], [0, 2], [0, 1]], 2
    ... )
    >>> len(eigenvalues) == 2 and eigenvectors.shape[1] == 2
    True
    """"""
    validate_adjacency_list(graph)
    tridiagonal_matrix, orthonormal_basis = lanczos_iteration(graph, num_eigenvectors)
    eigenvalues, eigenvectors = np.linalg.eigh(tridiagonal_matrix)
    return eigenvalues[::-1], np.dot(orthonormal_basis, eigenvectors[:, ::-1])",data\repos\Python\graphs\lanczos_eigenvectors.py,find_lanczos_eigenvectors,308
1063,lanczos_eigenvectors.py::main::196,"def main() -> None:
    """"""
    Main driver function for testing the implementation with doctests.
    """"""
    import doctest

    doctest.testmod()",data\repos\Python\graphs\lanczos_eigenvectors.py,main,34
1064,markov_chain.py::get_transitions::41,"def get_transitions(
    start: str, transitions: list[tuple[str, str, float]], steps: int
) -> dict[str, int]:
    """"""
    Running Markov Chain algorithm and calculating the number of times each node is
    visited

    >>> transitions = [
    ... ('a', 'a', 0.9),
    ... ('a', 'b', 0.075),
    ... ('a', 'c', 0.025),
    ... ('b', 'a', 0.15),
    ... ('b', 'b', 0.8),
    ... ('b', 'c', 0.05),
    ... ('c', 'a', 0.25),
    ... ('c', 'b', 0.25),
    ... ('c', 'c', 0.5)
    ... ]

    >>> result = get_transitions('a', transitions, 5000)

    >>> result['a'] > result['b'] > result['c']
    True
    """"""

    graph = MarkovChainGraphUndirectedUnweighted()

    for node1, node2, probability in transitions:
        graph.add_transition_probability(node1, node2, probability)

    visited = Counter(graph.get_nodes())
    node = start

    for _ in range(steps):
        node = graph.transition(node)
        visited[node] += 1

    return visited",data\repos\Python\graphs\markov_chain.py,get_transitions,290
1065,markov_chain.py::add_transition_probability::18,"    def add_transition_probability(
        self, node1: str, node2: str, probability: float
    ) -> None:
        if node1 not in self.connections:
            self.add_node(node1)
        if node2 not in self.connections:
            self.add_node(node2)
        self.connections[node1][node2] = probability",data\repos\Python\graphs\markov_chain.py,add_transition_probability,71
1066,markov_chain.py::transition::30,"    def transition(self, node: str) -> str:
        current_probability = 0
        random_value = random()

        for dest in self.connections[node]:
            current_probability += self.connections[node][dest]
            if current_probability > random_value:
                return dest
        return """"",data\repos\Python\graphs\markov_chain.py,transition,58
1067,matching_min_vertex_cover.py::matching_min_vertex_cover::11,"def matching_min_vertex_cover(graph: dict) -> set:
    """"""
    APX Algorithm for min Vertex Cover using Matching Approach
    @input: graph (graph stored in an adjacency list where each vertex
            is represented as an integer)
    @example:
    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}
    >>> matching_min_vertex_cover(graph)
    {0, 1, 2, 4}
    """"""
    # chosen_vertices = set of chosen vertices
    chosen_vertices = set()
    # edges = list of graph's edges
    edges = get_edges(graph)

    # While there are still elements in edges list, take an arbitrary edge
    # (from_node, to_node) and add his extremity to chosen_vertices and then
    # remove all arcs adjacent to the from_node and to_node
    while edges:
        from_node, to_node = edges.pop()
        chosen_vertices.add(from_node)
        chosen_vertices.add(to_node)
        for edge in edges.copy():
            if from_node in edge or to_node in edge:
                edges.discard(edge)
    return chosen_vertices",data\repos\Python\graphs\matching_min_vertex_cover.py,matching_min_vertex_cover,271
1068,matching_min_vertex_cover.py::get_edges::39,"def get_edges(graph: dict) -> set:
    """"""
    Return a set of couples that represents all of the edges.
    @input: graph (graph stored in an adjacency list where each vertex is
            represented as an integer)
    @example:
    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}
    >>> get_edges(graph)
    {(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}
    """"""
    edges = set()
    for from_node, to_nodes in graph.items():
        for to_node in to_nodes:
            edges.add((from_node, to_node))
    return edges",data\repos\Python\graphs\matching_min_vertex_cover.py,get_edges,195
1069,minimum_path_sum.py::min_path_sum::1,"def min_path_sum(grid: list) -> int:
    """"""
    Find the path from top left to bottom right of array of numbers
    with the lowest possible sum and return the sum along this path.
    >>> min_path_sum([
    ...     [1, 3, 1],
    ...     [1, 5, 1],
    ...     [4, 2, 1],
    ... ])
    7

    >>> min_path_sum([
    ...     [1, 0, 5, 6, 7],
    ...     [8, 9, 0, 4, 2],
    ...     [4, 4, 4, 5, 1],
    ...     [9, 6, 3, 1, 0],
    ...     [8, 4, 3, 2, 7],
    ... ])
    20

    >>> min_path_sum(None)
    Traceback (most recent call last):
        ...
    TypeError: The grid does not contain the appropriate information

    >>> min_path_sum([[]])
    Traceback (most recent call last):
        ...
    TypeError: The grid does not contain the appropriate information
    """"""

    if not grid or not grid[0]:
        raise TypeError(""The grid does not contain the appropriate information"")

    for cell_n in range(1, len(grid[0])):
        grid[0][cell_n] += grid[0][cell_n - 1]
    row_above = grid[0]

    for row_n in range(1, len(grid)):
        current_row = grid[row_n]
        grid[row_n] = fill_row(current_row, row_above)
        row_above = grid[row_n]

    return grid[-1][-1]",data\repos\Python\graphs\minimum_path_sum.py,min_path_sum,371
1070,minimum_path_sum.py::fill_row::47,"def fill_row(current_row: list, row_above: list) -> list:
    """"""
    >>> fill_row([2, 2, 2], [1, 2, 3])
    [3, 4, 5]
    """"""

    current_row[0] += row_above[0]
    for cell_n in range(1, len(current_row)):
        current_row[cell_n] += min(current_row[cell_n - 1], row_above[cell_n])

    return current_row",data\repos\Python\graphs\minimum_path_sum.py,fill_row,102
1071,minimum_spanning_tree_boruvka.py::add_vertex::11,"    def add_vertex(self, vertex):
        """"""
        Adds a vertex to the graph

        """"""
        if vertex not in self.adjacency:
            self.adjacency[vertex] = {}
            self.num_vertices += 1",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,add_vertex,44
1072,minimum_spanning_tree_boruvka.py::add_edge::20,"    def add_edge(self, head, tail, weight):
        """"""
        Adds an edge to the graph

        """"""

        self.add_vertex(head)
        self.add_vertex(tail)

        if head == tail:
            return

        self.adjacency[head][tail] = weight
        self.adjacency[tail][head] = weight",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,add_edge,69
1073,minimum_spanning_tree_boruvka.py::distinct_weight::35,"    def distinct_weight(self):
        """"""
        For Boruvks's algorithm the weights should be distinct
        Converts the weights to be distinct

        """"""
        edges = self.get_edges()
        for edge in edges:
            head, tail, weight = edge
            edges.remove((tail, head, weight))
        for i in range(len(edges)):
            edges[i] = list(edges[i])

        edges.sort(key=lambda e: e[2])
        for i in range(len(edges) - 1):
            if edges[i][2] >= edges[i + 1][2]:
                edges[i + 1][2] = edges[i][2] + 1
        for edge in edges:
            head, tail, weight = edge
            self.adjacency[head][tail] = weight
            self.adjacency[tail][head] = weight",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,distinct_weight,176
1074,minimum_spanning_tree_boruvka.py::get_edges::68,"    def get_edges(self):
        """"""
        Returna all edges in the graph
        """"""
        output = []
        for tail in self.adjacency:
            for head in self.adjacency[tail]:
                output.append((tail, head, self.adjacency[head][tail]))
        return output",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,get_edges,60
1075,minimum_spanning_tree_boruvka.py::build::85,"    def build(vertices=None, edges=None):
        """"""
        Builds a graph from the given set of vertices and edges

        """"""
        g = Graph()
        if vertices is None:
            vertices = []
        if edges is None:
            edge = []
        for vertex in vertices:
            g.add_vertex(vertex)
        for edge in edges:
            g.add_edge(*edge)
        return g",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,build,79
1076,minimum_spanning_tree_boruvka.py::boruvka_mst::150,"    def boruvka_mst(graph):
        """"""
        Implementation of Boruvka's algorithm
        >>> g = Graph()
        >>> g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 1],[2, 3, 1]])
        >>> g.distinct_weight()
        >>> bg = Graph.boruvka_mst(g)
        >>> print(bg)
        1 -> 0 == 1
        2 -> 0 == 2
        0 -> 1 == 1
        0 -> 2 == 2
        3 -> 2 == 3
        2 -> 3 == 3
        """"""
        num_components = graph.num_vertices

        union_find = Graph.UnionFind()
        mst_edges = []
        while num_components > 1:
            cheap_edge = {}
            for vertex in graph.get_vertices():
                cheap_edge[vertex] = -1

            edges = graph.get_edges()
            for edge in edges:
                head, tail, weight = edge
                edges.remove((tail, head, weight))
            for edge in edges:
                head, tail, weight = edge
                set1 = union_find.find(head)
                set2 = union_find.find(tail)
                if set1 != set2:
                    if cheap_edge[set1] == -1 or cheap_edge[set1][2] > weight:
                        cheap_edge[set1] = [head, tail, weight]

                    if cheap_edge[set2] == -1 or cheap_edge[set2][2] > weight:
                        cheap_edge[set2] = [head, tail, weight]
            for head_tail_weight in cheap_edge.values():
                if head_tail_weight != -1:
                    head, tail, weight = head_tail_weight
                    if union_find.find(head) != union_find.find(tail):
                        union_find.union(head, tail)
                        mst_edges.append(head_tail_weight)
                        num_components = num_components - 1
        mst = Graph.build(edges=mst_edges)
        return mst",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,boruvka_mst,446
1077,minimum_spanning_tree_boruvka.py::make_set::113,"        def make_set(self, item):
            if item in self.parent:
                return self.find(item)

            self.parent[item] = item
            self.rank[item] = 0
            return item",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,make_set,41
1078,minimum_spanning_tree_boruvka.py::find::121,"        def find(self, item):
            if item not in self.parent:
                return self.make_set(item)
            if item != self.parent[item]:
                self.parent[item] = self.find(self.parent[item])
            return self.parent[item]",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,find,48
1079,minimum_spanning_tree_boruvka.py::union::128,"        def union(self, item1, item2):
            root1 = self.find(item1)
            root2 = self.find(item2)

            if root1 == root2:
                return root1

            if self.rank[root1] > self.rank[root2]:
                self.parent[root2] = root1
                return root1

            if self.rank[root1] < self.rank[root2]:
                self.parent[root1] = root2
                return root2

            if self.rank[root1] == self.rank[root2]:
                self.rank[root1] += 1
                self.parent[root2] = root1
                return root1
            return None",data\repos\Python\graphs\minimum_spanning_tree_boruvka.py,union,139
1080,minimum_spanning_tree_kruskal.py::kruskal::1,"def kruskal(
    num_nodes: int, edges: list[tuple[int, int, int]]
) -> list[tuple[int, int, int]]:
    """"""
    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)])
    [(2, 3, 1), (0, 1, 3), (1, 2, 5)]

    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)])
    [(2, 3, 1), (0, 2, 1), (0, 1, 3)]

    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2),
    ... (2, 1, 1)])
    [(2, 3, 1), (0, 2, 1), (2, 1, 1)]
    """"""
    edges = sorted(edges, key=lambda edge: edge[2])

    parent = list(range(num_nodes))

    def find_parent(i):
        if i != parent[i]:
            parent[i] = find_parent(parent[i])
        return parent[i]

    minimum_spanning_tree_cost = 0
    minimum_spanning_tree = []

    for edge in edges:
        parent_a = find_parent(edge[0])
        parent_b = find_parent(edge[1])
        if parent_a != parent_b:
            minimum_spanning_tree_cost += edge[2]
            minimum_spanning_tree.append(edge)
            parent[parent_a] = parent_b

    return minimum_spanning_tree",data\repos\Python\graphs\minimum_spanning_tree_kruskal.py,kruskal,408
1081,minimum_spanning_tree_kruskal2.py::make_set::22,"    def make_set(self, data: T) -> None:
        # create a new set with x as its member
        self.map[data] = DisjointSetTreeNode(data)",data\repos\Python\graphs\minimum_spanning_tree_kruskal2.py,make_set,37
1082,minimum_spanning_tree_kruskal2.py::find_set::26,"    def find_set(self, data: T) -> DisjointSetTreeNode[T]:
        # find the set x belongs to (with path-compression)
        elem_ref = self.map[data]
        if elem_ref != elem_ref.parent:
            elem_ref.parent = self.find_set(elem_ref.parent.data)
        return elem_ref.parent",data\repos\Python\graphs\minimum_spanning_tree_kruskal2.py,find_set,66
1083,minimum_spanning_tree_kruskal2.py::link::33,"    def link(
        self, node1: DisjointSetTreeNode[T], node2: DisjointSetTreeNode[T]
    ) -> None:
        # helper function for union operation
        if node1.rank > node2.rank:
            node2.parent = node1
        else:
            node1.parent = node2
            if node1.rank == node2.rank:
                node2.rank += 1",data\repos\Python\graphs\minimum_spanning_tree_kruskal2.py,link,84
1084,minimum_spanning_tree_kruskal2.py::union::44,"    def union(self, data1: T, data2: T) -> None:
        # merge 2 disjoint sets
        self.link(self.find_set(data1), self.find_set(data2))",data\repos\Python\graphs\minimum_spanning_tree_kruskal2.py,union,41
1085,minimum_spanning_tree_kruskal2.py::add_node::54,"    def add_node(self, node: T) -> None:
        # add a node ONLY if its not present in the graph
        if node not in self.connections:
            self.connections[node] = {}",data\repos\Python\graphs\minimum_spanning_tree_kruskal2.py,add_node,42
1086,minimum_spanning_tree_kruskal2.py::add_edge::59,"    def add_edge(self, node1: T, node2: T, weight: int) -> None:
        # add an edge with the given weight
        self.add_node(node1)
        self.add_node(node2)
        self.connections[node1][node2] = weight
        self.connections[node2][node1] = weight",data\repos\Python\graphs\minimum_spanning_tree_kruskal2.py,add_edge,70
1087,minimum_spanning_tree_kruskal2.py::kruskal::66,"    def kruskal(self) -> GraphUndirectedWeighted[T]:
        # Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph
        """"""
        Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm

        Example:
        >>> g1 = GraphUndirectedWeighted[int]()
        >>> g1.add_edge(1, 2, 1)
        >>> g1.add_edge(2, 3, 2)
        >>> g1.add_edge(3, 4, 1)
        >>> g1.add_edge(3, 5, 100) # Removed in MST
        >>> g1.add_edge(4, 5, 5)
        >>> assert 5 in g1.connections[3]
        >>> mst = g1.kruskal()
        >>> assert 5 not in mst.connections[3]

        >>> g2 = GraphUndirectedWeighted[str]()
        >>> g2.add_edge('A', 'B', 1)
        >>> g2.add_edge('B', 'C', 2)
        >>> g2.add_edge('C', 'D', 1)
        >>> g2.add_edge('C', 'E', 100) # Removed in MST
        >>> g2.add_edge('D', 'E', 5)
        >>> assert 'E' in g2.connections[""C""]
        >>> mst = g2.kruskal()
        >>> assert 'E' not in mst.connections['C']
        """"""

        # getting the edges in ascending order of weights
        edges = []
        seen = set()
        for start in self.connections:
            for end in self.connections[start]:
                if (start, end) not in seen:
                    seen.add((end, start))
                    edges.append((start, end, self.connections[start][end]))
        edges.sort(key=lambda x: x[2])

        # creating the disjoint set
        disjoint_set = DisjointSetTree[T]()
        for node in self.connections:
            disjoint_set.make_set(node)

        # MST generation
        num_edges = 0
        index = 0
        graph = GraphUndirectedWeighted[T]()
        while num_edges < len(self.connections) - 1:
            u, v, w = edges[index]
            index += 1
            parent_u = disjoint_set.find_set(u)
            parent_v = disjoint_set.find_set(v)
            if parent_u != parent_v:
                num_edges += 1
                graph.add_edge(u, v, w)
                disjoint_set.union(u, v)
        return graph",data\repos\Python\graphs\minimum_spanning_tree_kruskal2.py,kruskal,542
1088,minimum_spanning_tree_prims.py::prisms_algorithm::75,"def prisms_algorithm(adjacency_list):
    """"""
    >>> adjacency_list = {0: [[1, 1], [3, 3]],
    ...                   1: [[0, 1], [2, 6], [3, 5], [4, 1]],
    ...                   2: [[1, 6], [4, 5], [5, 2]],
    ...                   3: [[0, 3], [1, 5], [4, 1]],
    ...                   4: [[1, 1], [2, 5], [3, 1], [5, 4]],
    ...                   5: [[2, 2], [4, 4]]}
    >>> prisms_algorithm(adjacency_list)
    [(0, 1), (1, 4), (4, 3), (4, 5), (5, 2)]
    """"""

    heap = Heap()

    visited = [0] * len(adjacency_list)
    nbr_tv = [-1] * len(adjacency_list)  # Neighboring Tree Vertex of selected vertex
    # Minimum Distance of explored vertex with neighboring vertex of partial tree
    # formed in graph
    distance_tv = []  # Heap of Distance of vertices from their neighboring vertex
    positions = []

    for vertex in range(len(adjacency_list)):
        distance_tv.append(sys.maxsize)
        positions.append(vertex)
        heap.node_position.append(vertex)

    tree_edges = []
    visited[0] = 1
    distance_tv[0] = sys.maxsize
    for neighbor, distance in adjacency_list[0]:
        nbr_tv[neighbor] = 0
        distance_tv[neighbor] = distance
    heap.heapify(distance_tv, positions)

    for _ in range(1, len(adjacency_list)):
        vertex = heap.delete_minimum(distance_tv, positions)
        if visited[vertex] == 0:
            tree_edges.append((nbr_tv[vertex], vertex))
            visited[vertex] = 1
            for neighbor, distance in adjacency_list[vertex]:
                if (
                    visited[neighbor] == 0
                    and distance < distance_tv[heap.get_position(neighbor)]
                ):
                    distance_tv[heap.get_position(neighbor)] = distance
                    heap.bottom_to_top(
                        distance, heap.get_position(neighbor), distance_tv, positions
                    )
                    nbr_tv[neighbor] = vertex
    return tree_edges",data\repos\Python\graphs\minimum_spanning_tree_prims.py,prisms_algorithm,512
1089,minimum_spanning_tree_prims.py::top_to_bottom::15,"    def top_to_bottom(self, heap, start, size, positions):
        if start > size // 2 - 1:
            return
        else:
            if 2 * start + 2 >= size:  # noqa: SIM114
                smallest_child = 2 * start + 1
            elif heap[2 * start + 1] < heap[2 * start + 2]:
                smallest_child = 2 * start + 1
            else:
                smallest_child = 2 * start + 2
            if heap[smallest_child] < heap[start]:
                temp, temp1 = heap[smallest_child], positions[smallest_child]
                heap[smallest_child], positions[smallest_child] = (
                    heap[start],
                    positions[start],
                )
                heap[start], positions[start] = temp, temp1

                temp = self.get_position(positions[smallest_child])
                self.set_position(
                    positions[smallest_child], self.get_position(positions[start])
                )
                self.set_position(positions[start], temp)

                self.top_to_bottom(heap, smallest_child, size, positions)",data\repos\Python\graphs\minimum_spanning_tree_prims.py,top_to_bottom,238
1090,minimum_spanning_tree_prims.py::bottom_to_top::42,"    def bottom_to_top(self, val, index, heap, position):
        temp = position[index]

        while index != 0:
            parent = int((index - 2) / 2) if index % 2 == 0 else int((index - 1) / 2)

            if val < heap[parent]:
                heap[index] = heap[parent]
                position[index] = position[parent]
                self.set_position(position[parent], index)
            else:
                heap[index] = val
                position[index] = temp
                self.set_position(temp, index)
                break
            index = parent
        else:
            heap[0] = val
            position[0] = temp
            self.set_position(temp, 0)",data\repos\Python\graphs\minimum_spanning_tree_prims.py,bottom_to_top,155
1091,minimum_spanning_tree_prims.py::heapify::63,"    def heapify(self, heap, positions):
        start = len(heap) // 2 - 1
        for i in range(start, -1, -1):
            self.top_to_bottom(heap, i, len(heap), positions)",data\repos\Python\graphs\minimum_spanning_tree_prims.py,heapify,50
1092,minimum_spanning_tree_prims.py::delete_minimum::68,"    def delete_minimum(self, heap, positions):
        temp = positions[0]
        heap[0] = sys.maxsize
        self.top_to_bottom(heap, 0, len(heap), positions)
        return temp",data\repos\Python\graphs\minimum_spanning_tree_prims.py,delete_minimum,45
1093,minimum_spanning_tree_prims2.py::get_parent_position::18,"def get_parent_position(position: int) -> int:
    """"""
    heap helper function get the position of the parent of the current node

    >>> get_parent_position(1)
    0
    >>> get_parent_position(2)
    0
    """"""
    return (position - 1) // 2",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,get_parent_position,65
1094,minimum_spanning_tree_prims2.py::get_child_left_position::30,"def get_child_left_position(position: int) -> int:
    """"""
    heap helper function get the position of the left child of the current node

    >>> get_child_left_position(0)
    1
    """"""
    return (2 * position) + 1",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,get_child_left_position,55
1095,minimum_spanning_tree_prims2.py::get_child_right_position::40,"def get_child_right_position(position: int) -> int:
    """"""
    heap helper function get the position of the right child of the current node

    >>> get_child_right_position(0)
    2
    """"""
    return (2 * position) + 2",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,get_child_right_position,55
1096,minimum_spanning_tree_prims2.py::prims_algo::220,"def prims_algo[T](
    graph: GraphUndirectedWeighted[T],
) -> tuple[dict[T, int], dict[T, T | None]]:
    """"""
    >>> graph = GraphUndirectedWeighted()

    >>> graph.add_edge(""a"", ""b"", 3)
    >>> graph.add_edge(""b"", ""c"", 10)
    >>> graph.add_edge(""c"", ""d"", 5)
    >>> graph.add_edge(""a"", ""c"", 15)
    >>> graph.add_edge(""b"", ""d"", 100)

    >>> dist, parent = prims_algo(graph)

    >>> abs(dist[""a""] - dist[""b""])
    3
    >>> abs(dist[""d""] - dist[""b""])
    15
    >>> abs(dist[""a""] - dist[""c""])
    13
    """"""
    # prim's algorithm for minimum spanning tree
    dist: dict[T, int] = dict.fromkeys(graph.connections, maxsize)
    parent: dict[T, T | None] = dict.fromkeys(graph.connections)

    priority_queue: MinPriorityQueue[T] = MinPriorityQueue()
    for node, weight in dist.items():
        priority_queue.push(node, weight)

    if priority_queue.is_empty():
        return dist, parent

    # initialization
    node = priority_queue.extract_min()
    dist[node] = 0
    for neighbour in graph.connections[node]:
        if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:
            dist[neighbour] = dist[node] + graph.connections[node][neighbour]
            priority_queue.update_key(neighbour, dist[neighbour])
            parent[neighbour] = node

    # running prim's algorithm
    while not priority_queue.is_empty():
        node = priority_queue.extract_min()
        for neighbour in graph.connections[node]:
            if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:
                dist[neighbour] = dist[node] + graph.connections[node][neighbour]
                priority_queue.update_key(neighbour, dist[neighbour])
                parent[neighbour] = node
    return dist, parent",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,prims_algo,446
1097,minimum_spanning_tree_prims2.py::push::101,"    def push(self, elem: T, weight: int) -> None:
        # Add an element with given priority to the queue
        self.heap.append((elem, weight))
        self.position_map[elem] = self.elements
        self.elements += 1
        self._bubble_up(elem)",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,push,62
1098,minimum_spanning_tree_prims2.py::extract_min::108,"    def extract_min(self) -> T:
        # Remove and return the element with lowest weight (highest priority)
        if self.elements > 1:
            self._swap_nodes(0, self.elements - 1)
        elem, _ = self.heap.pop()
        del self.position_map[elem]
        self.elements -= 1
        if self.elements > 0:
            bubble_down_elem, _ = self.heap[0]
            self._bubble_down(bubble_down_elem)
        return elem",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,extract_min,102
1099,minimum_spanning_tree_prims2.py::update_key::120,"    def update_key(self, elem: T, weight: int) -> None:
        # Update the weight of the given key
        position = self.position_map[elem]
        self.heap[position] = (elem, weight)
        if position > 0:
            parent_position = get_parent_position(position)
            _, parent_weight = self.heap[parent_position]
            if parent_weight > weight:
                self._bubble_up(elem)
            else:
                self._bubble_down(elem)
        else:
            self._bubble_down(elem)",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,update_key,107
1100,minimum_spanning_tree_prims2.py::add_node::206,"    def add_node(self, node: T) -> None:
        # Add a node in the graph if it is not in the graph
        if node not in self.connections:
            self.connections[node] = {}
            self.nodes += 1",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,add_node,50
1101,minimum_spanning_tree_prims2.py::add_edge::212,"    def add_edge(self, node1: T, node2: T, weight: int) -> None:
        # Add an edge between 2 nodes in the graph
        self.add_node(node1)
        self.add_node(node2)
        self.connections[node1][node2] = weight
        self.connections[node2][node1] = weight",data\repos\Python\graphs\minimum_spanning_tree_prims2.py,add_edge,73
1102,multi_heuristic_astar.py::consistent_heuristic::59,"def consistent_heuristic(p: TPos, goal: TPos):
    # euclidean distance
    a = np.array(p)
    b = np.array(goal)
    return np.linalg.norm(a - b)",data\repos\Python\graphs\multi_heuristic_astar.py,consistent_heuristic,43
1103,multi_heuristic_astar.py::heuristic_2::66,"def heuristic_2(p: TPos, goal: TPos):
    # integer division by time variable
    return consistent_heuristic(p, goal) // t",data\repos\Python\graphs\multi_heuristic_astar.py,heuristic_2,33
1104,multi_heuristic_astar.py::heuristic_1::71,"def heuristic_1(p: TPos, goal: TPos):
    # manhattan distance
    return abs(p[0] - goal[0]) + abs(p[1] - goal[1])",data\repos\Python\graphs\multi_heuristic_astar.py,heuristic_1,43
1105,multi_heuristic_astar.py::key::76,"def key(start: TPos, i: int, goal: TPos, g_function: dict[TPos, float]):
    ans = g_function[start] + W1 * heuristics[i](start, goal)
    return ans",data\repos\Python\graphs\multi_heuristic_astar.py,key,49
1106,multi_heuristic_astar.py::do_something::81,"def do_something(back_pointer, goal, start):
    grid = np.char.chararray((n, n))
    for i in range(n):
        for j in range(n):
            grid[i][j] = ""*""

    for i in range(n):
        for j in range(n):
            if (j, (n - 1) - i) in blocks:
                grid[i][j] = ""#""

    grid[0][(n - 1)] = ""-""
    x = back_pointer[goal]
    while x != start:
        (x_c, y_c) = x
        # print(x)
        grid[(n - 1) - y_c][x_c] = ""-""
        x = back_pointer[x]
    grid[(n - 1)][0] = ""-""

    for i in range(n):
        for j in range(n):
            if (i, j) == (0, n - 1):
                print(grid[i][j], end="" "")
                print(""<-- End position"", end="" "")
            else:
                print(grid[i][j], end="" "")
        print()
    print(""^"")
    print(""Start position"")
    print()
    print(""# is an obstacle"")
    print(""- is the path taken by algorithm"")
    print(""PATH TAKEN BY THE ALGORITHM IS:-"")
    x = back_pointer[goal]
    while x != start:
        print(x, end="" "")
        x = back_pointer[x]
    print(x)
    sys.exit()",data\repos\Python\graphs\multi_heuristic_astar.py,do_something,311
1107,multi_heuristic_astar.py::valid::123,"def valid(p: TPos):
    if p[0] < 0 or p[0] > n - 1:
        return False
    return not (p[1] < 0 or p[1] > n - 1)",data\repos\Python\graphs\multi_heuristic_astar.py,valid,53
1108,multi_heuristic_astar.py::expand_state::129,"def expand_state(
    s,
    j,
    visited,
    g_function,
    close_list_anchor,
    close_list_inad,
    open_list,
    back_pointer,
):
    for itera in range(n_heuristic):
        open_list[itera].remove_element(s)
    # print(""s"", s)
    # print(""j"", j)
    (x, y) = s
    left = (x - 1, y)
    right = (x + 1, y)
    up = (x, y + 1)
    down = (x, y - 1)

    for neighbours in [left, right, up, down]:
        if neighbours not in blocks:
            if valid(neighbours) and neighbours not in visited:
                # print(""neighbour"", neighbours)
                visited.add(neighbours)
                back_pointer[neighbours] = -1
                g_function[neighbours] = float(""inf"")

            if valid(neighbours) and g_function[neighbours] > g_function[s] + 1:
                g_function[neighbours] = g_function[s] + 1
                back_pointer[neighbours] = s
                if neighbours not in close_list_anchor:
                    open_list[0].put(neighbours, key(neighbours, 0, goal, g_function))
                    if neighbours not in close_list_inad:
                        for var in range(1, n_heuristic):
                            if key(neighbours, var, goal, g_function) <= W2 * key(
                                neighbours, 0, goal, g_function
                            ):
                                open_list[j].put(
                                    neighbours, key(neighbours, var, goal, g_function)
                                )",data\repos\Python\graphs\multi_heuristic_astar.py,expand_state,353
1109,multi_heuristic_astar.py::make_common_ground::172,"def make_common_ground():
    some_list = []
    for x in range(1, 5):
        for y in range(1, 6):
            some_list.append((x, y))

    for x in range(15, 20):
        some_list.append((x, 17))

    for x in range(10, 19):
        for y in range(1, 15):
            some_list.append((x, y))

    # L block
    for x in range(1, 4):
        for y in range(12, 19):
            some_list.append((x, y))
    for x in range(3, 13):
        for y in range(16, 19):
            some_list.append((x, y))
    return some_list",data\repos\Python\graphs\multi_heuristic_astar.py,make_common_ground,164
1110,multi_heuristic_astar.py::multi_a_star::236,"def multi_a_star(start: TPos, goal: TPos, n_heuristic: int):
    g_function = {start: 0, goal: float(""inf"")}
    back_pointer = {start: -1, goal: -1}
    open_list = []
    visited = set()

    for i in range(n_heuristic):
        open_list.append(PriorityQueue())
        open_list[i].put(start, key(start, i, goal, g_function))

    close_list_anchor: list[int] = []
    close_list_inad: list[int] = []
    while open_list[0].minkey() < float(""inf""):
        for i in range(1, n_heuristic):
            # print(open_list[0].minkey(), open_list[i].minkey())
            if open_list[i].minkey() <= W2 * open_list[0].minkey():
                global t
                t += 1
                if g_function[goal] <= open_list[i].minkey():
                    if g_function[goal] < float(""inf""):
                        do_something(back_pointer, goal, start)
                else:
                    _, get_s = open_list[i].top_show()
                    visited.add(get_s)
                    expand_state(
                        get_s,
                        i,
                        visited,
                        g_function,
                        close_list_anchor,
                        close_list_inad,
                        open_list,
                        back_pointer,
                    )
                    close_list_inad.append(get_s)
            elif g_function[goal] <= open_list[0].minkey():
                if g_function[goal] < float(""inf""):
                    do_something(back_pointer, goal, start)
            else:
                get_s = open_list[0].top_show()
                visited.add(get_s)
                expand_state(
                    get_s,
                    0,
                    visited,
                    g_function,
                    close_list_anchor,
                    close_list_inad,
                    open_list,
                    back_pointer,
                )
                close_list_anchor.append(get_s)
    print(""No path found to goal"")
    print()
    for i in range(n - 1, -1, -1):
        for j in range(n):
            if (j, i) in blocks:
                print(""#"", end="" "")
            elif (j, i) in back_pointer:
                if (j, i) == (n - 1, n - 1):
                    print(""*"", end="" "")
                else:
                    print(""-"", end="" "")
            else:
                print(""*"", end="" "")
            if (j, i) == (n - 1, n - 1):
                print(""<-- End position"", end="" "")
        print()
    print(""^"")
    print(""Start position"")
    print()
    print(""# is an obstacle"")
    print(""- is the path taken by algorithm"")",data\repos\Python\graphs\multi_heuristic_astar.py,multi_a_star,578
1111,multi_heuristic_astar.py::minkey::14,"    def minkey(self):
        if not self.empty():
            return self.elements[0][0]
        else:
            return float(""inf"")",data\repos\Python\graphs\multi_heuristic_astar.py,minkey,30
1112,multi_heuristic_astar.py::put::23,"    def put(self, item, priority):
        if item not in self.set:
            heapq.heappush(self.elements, (priority, item))
            self.set.add(item)
        else:
            # update
            # print(""update"", item)
            temp = []
            (pri, x) = heapq.heappop(self.elements)
            while x != item:
                temp.append((pri, x))
                (pri, x) = heapq.heappop(self.elements)
            temp.append((priority, item))
            for pro, xxx in temp:
                heapq.heappush(self.elements, (pro, xxx))",data\repos\Python\graphs\multi_heuristic_astar.py,put,126
1113,multi_heuristic_astar.py::remove_element::39,"    def remove_element(self, item):
        if item in self.set:
            self.set.remove(item)
            temp = []
            (pro, x) = heapq.heappop(self.elements)
            while x != item:
                temp.append((pro, x))
                (pro, x) = heapq.heappop(self.elements)
            for prito, yyy in temp:
                heapq.heappush(self.elements, (prito, yyy))",data\repos\Python\graphs\multi_heuristic_astar.py,remove_element,92
1114,multi_heuristic_astar.py::get::53,"    def get(self):
        (priority, item) = heapq.heappop(self.elements)
        self.set.remove(item)
        return (priority, item)",data\repos\Python\graphs\multi_heuristic_astar.py,get,32
1115,page_rank.py::page_rank::34,"def page_rank(nodes, limit=3, d=0.85):
    ranks = {}
    for node in nodes:
        ranks[node.name] = 1

    outbounds = {}
    for node in nodes:
        outbounds[node.name] = len(node.outbound)

    for i in range(limit):
        print(f""======= Iteration {i + 1} ======="")
        for _, node in enumerate(nodes):
            ranks[node.name] = (1 - d) + d * sum(
                ranks[ib] / outbounds[ib] for ib in node.inbound
            )
        print(ranks)",data\repos\Python\graphs\page_rank.py,page_rank,128
1116,page_rank.py::main::52,"def main():
    names = list(input(""Enter Names of the Nodes: "").split())

    nodes = [Node(name) for name in names]

    for ri, row in enumerate(graph):
        for ci, col in enumerate(row):
            if col == 1:
                nodes[ci].add_inbound(names[ri])
                nodes[ri].add_outbound(names[ci])

    print(""======= Nodes ======="")
    for node in nodes:
        print(node)

    page_rank(nodes)",data\repos\Python\graphs\page_rank.py,main,101
1117,prim.py::connect::47,"def connect(graph, a, b, edge):
    # add the neighbors:
    graph[a - 1].add_neighbor(graph[b - 1])
    graph[b - 1].add_neighbor(graph[a - 1])
    # add the edges:
    graph[a - 1].add_edge(graph[b - 1], edge)
    graph[b - 1].add_edge(graph[a - 1], edge)",data\repos\Python\graphs\prim.py,connect,86
1118,prim.py::prim::56,"def prim(graph: list, root: Vertex) -> list:
    """"""Prim's Algorithm.

    Runtime:
        O(mn) with `m` edges and `n` vertices

    Return:
        List with the edges of a Minimum Spanning Tree

    Usage:
        prim(graph, graph[0])
    """"""
    a = []
    for u in graph:
        u.key = math.inf
        u.pi = None
    root.key = 0
    q = graph[:]
    while q:
        u = min(q)
        q.remove(u)
        for v in u.neighbors:
            if (v in q) and (u.edges[v.id] < v.key):
                v.pi = u
                v.key = u.edges[v.id]
    for i in range(1, len(graph)):
        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))
    return a",data\repos\Python\graphs\prim.py,prim,195
1119,prim.py::prim_heap::86,"def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:
    """"""Prim's Algorithm with min heap.

    Runtime:
        O((m + n)log n) with `m` edges and `n` vertices

    Yield:
        Edges of a Minimum Spanning Tree

    Usage:
        prim(graph, graph[0])
    """"""
    for u in graph:
        u.key = math.inf
        u.pi = None
    root.key = 0

    h = list(graph)
    hq.heapify(h)

    while h:
        u = hq.heappop(h)
        for v in u.neighbors:
            if (v in h) and (u.edges[v.id] < v.key):
                v.pi = u
                v.key = u.edges[v.id]
                hq.heapify(h)

    for i in range(1, len(graph)):
        yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)",data\repos\Python\graphs\prim.py,prim_heap,210
1120,prim.py::test_vector::118,"def test_vector() -> None:
    """"""
    # Creates a list to store x vertices.
    >>> x = 5
    >>> G = [Vertex(n) for n in range(x)]

    >>> connect(G, 1, 2, 15)
    >>> connect(G, 1, 3, 12)
    >>> connect(G, 2, 4, 13)
    >>> connect(G, 2, 5, 5)
    >>> connect(G, 3, 2, 6)
    >>> connect(G, 3, 4, 6)
    >>> connect(G, 0, 0, 0)  # Generate the minimum spanning tree:
    >>> G_heap = G[:]
    >>> MST = prim(G, G[0])
    >>> MST_heap = prim_heap(G, G[0])
    >>> for i in MST:
    ...     print(i)
    (2, 3)
    (3, 1)
    (4, 3)
    (5, 2)
    >>> for i in MST_heap:
    ...     print(i)
    (2, 3)
    (3, 1)
    (4, 3)
    (5, 2)
    """"""",data\repos\Python\graphs\prim.py,test_vector,262
1121,random_graph_generator.py::random_graph::12,"def random_graph(
    vertices_number: int, probability: float, directed: bool = False
) -> dict:
    """"""
    Generate a random graph
    @input: vertices_number (number of vertices),
            probability (probability that a generic edge (u,v) exists),
            directed (if True: graph will be a directed graph,
                      otherwise it will be an undirected graph)
    @examples:
    >>> random.seed(1)
    >>> random_graph(4, 0.5)
    {0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]}
    >>> random.seed(1)
    >>> random_graph(4, 0.5, True)
    {0: [1], 1: [2, 3], 2: [3], 3: []}
    """"""
    graph: dict = {i: [] for i in range(vertices_number)}

    # if probability is greater or equal than 1, then generate a complete graph
    if probability >= 1:
        return complete_graph(vertices_number)
    # if probability is lower or equal than 0, then return a graph without edges
    if probability <= 0:
        return graph

    # for each couple of nodes, add an edge from u to v
    # if the number randomly generated is greater than probability probability
    for i in range(vertices_number):
        for j in range(i + 1, vertices_number):
            if random.random() < probability:
                graph[i].append(j)
                if not directed:
                    # if the graph is undirected, add an edge in from j to i, either
                    graph[j].append(i)
    return graph",data\repos\Python\graphs\random_graph_generator.py,random_graph,368
1122,random_graph_generator.py::complete_graph::50,"def complete_graph(vertices_number: int) -> dict:
    """"""
    Generate a complete graph with vertices_number vertices.
    @input: vertices_number (number of vertices),
            directed (False if the graph is undirected, True otherwise)
    @example:
    >>> complete_graph(3)
    {0: [1, 2], 1: [0, 2], 2: [0, 1]}
    """"""
    return {
        i: [j for j in range(vertices_number) if i != j] for i in range(vertices_number)
    }",data\repos\Python\graphs\random_graph_generator.py,complete_graph,118
1123,scc_kosaraju.py::dfs::4,"def dfs(u):
    global graph, reversed_graph, scc, component, visit, stack
    if visit[u]:
        return
    visit[u] = True
    for v in graph[u]:
        dfs(v)
    stack.append(u)",data\repos\Python\graphs\scc_kosaraju.py,dfs,51
1124,scc_kosaraju.py::dfs2::14,"def dfs2(u):
    global graph, reversed_graph, scc, component, visit, stack
    if visit[u]:
        return
    visit[u] = True
    component.append(u)
    for v in reversed_graph[u]:
        dfs2(v)",data\repos\Python\graphs\scc_kosaraju.py,dfs2,54
1125,scc_kosaraju.py::kosaraju::24,"def kosaraju():
    global graph, reversed_graph, scc, component, visit, stack
    for i in range(n):
        dfs(i)
    visit = [False] * n
    for i in stack[::-1]:
        if visit[i]:
            continue
        component = []
        dfs2(i)
        scc.append(component)
    return scc",data\repos\Python\graphs\scc_kosaraju.py,kosaraju,76
1126,strongly_connected_components.py::topology_sort::13,"def topology_sort(
    graph: dict[int, list[int]], vert: int, visited: list[bool]
) -> list[int]:
    """"""
    Use depth first search to sort graph
    At this time graph is the same as input
    >>> topology_sort(test_graph_1, 0, 5 * [False])
    [1, 2, 4, 3, 0]
    >>> topology_sort(test_graph_2, 0, 6 * [False])
    [2, 1, 5, 4, 3, 0]
    """"""

    visited[vert] = True
    order = []

    for neighbour in graph[vert]:
        if not visited[neighbour]:
            order += topology_sort(graph, neighbour, visited)

    order.append(vert)

    return order",data\repos\Python\graphs\strongly_connected_components.py,topology_sort,171
1127,strongly_connected_components.py::find_components::37,"def find_components(
    reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]
) -> list[int]:
    """"""
    Use depth first search to find strongly connected
    vertices. Now graph is reversed
    >>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])
    [0, 1, 2]
    >>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])
    [0, 2, 1]
    """"""

    visited[vert] = True
    component = [vert]

    for neighbour in reversed_graph[vert]:
        if not visited[neighbour]:
            component += find_components(reversed_graph, neighbour, visited)

    return component",data\repos\Python\graphs\strongly_connected_components.py,find_components,183
1128,strongly_connected_components.py::strongly_connected_components::59,"def strongly_connected_components(graph: dict[int, list[int]]) -> list[list[int]]:
    """"""
    This function takes graph as a parameter
    and then returns the list of strongly connected components
    >>> strongly_connected_components(test_graph_1)
    [[0, 1, 2], [3], [4]]
    >>> strongly_connected_components(test_graph_2)
    [[0, 2, 1], [3, 5, 4]]
    """"""

    visited = len(graph) * [False]
    reversed_graph: dict[int, list[int]] = {vert: [] for vert in range(len(graph))}

    for vert, neighbours in graph.items():
        for neighbour in neighbours:
            reversed_graph[neighbour].append(vert)

    order = []
    for i, was_visited in enumerate(visited):
        if not was_visited:
            order += topology_sort(graph, i, visited)

    components_list = []
    visited = len(graph) * [False]

    for i in range(len(graph)):
        vert = order[len(graph) - i - 1]
        if not visited[vert]:
            component = find_components(reversed_graph, vert, visited)
            components_list.append(component)

    return components_list",data\repos\Python\graphs\strongly_connected_components.py,strongly_connected_components,253
1129,tarjans_scc.py::tarjan::4,"def tarjan(g: list[list[int]]) -> list[list[int]]:
    """"""
    Tarjan's algo for finding strongly connected components in a directed graph

    Uses two main attributes of each node to track reachability, the index of that node
    within a component(index), and the lowest index reachable from that node(lowlink).

    We then perform a dfs of the each component making sure to update these parameters
    for each node and saving the nodes we visit on the way.

    If ever we find that the lowest reachable node from a current node is equal to the
    index of the current node then it must be the root of a strongly connected
    component and so we save it and it's equireachable vertices as a strongly
    connected component.

    Complexity: strong_connect() is called at most once for each node and has a
    complexity of O(|E|) as it is DFS.
    Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)

    >>> tarjan([[2, 3, 4], [2, 3, 4], [0, 1, 3], [0, 1, 2], [1]])
    [[4, 3, 1, 2, 0]]
    >>> tarjan([[], [], [], []])
    [[0], [1], [2], [3]]
    >>> a = [0, 1, 2, 3, 4, 5, 4]
    >>> b = [1, 0, 3, 2, 5, 4, 0]
    >>> n = 7
    >>> sorted(tarjan(create_graph(n, list(zip(a, b))))) == sorted(
    ...     tarjan(create_graph(n, list(zip(a[::-1], b[::-1])))))
    True
    >>> a = [0, 1, 2, 3, 4, 5, 6]
    >>> b = [0, 1, 2, 3, 4, 5, 6]
    >>> sorted(tarjan(create_graph(n, list(zip(a, b)))))
    [[0], [1], [2], [3], [4], [5], [6]]
    """"""

    n = len(g)
    stack: deque[int] = deque()
    on_stack = [False for _ in range(n)]
    index_of = [-1 for _ in range(n)]
    lowlink_of = index_of[:]

    def strong_connect(v: int, index: int, components: list[list[int]]) -> int:
        index_of[v] = index  # the number when this node is seen
        lowlink_of[v] = index  # lowest rank node reachable from here
        index += 1
        stack.append(v)
        on_stack[v] = True

        for w in g[v]:
            if index_of[w] == -1:
                index = strong_connect(w, index, components)
                lowlink_of[v] = (
                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]
                )
            elif on_stack[w]:
                lowlink_of[v] = (
                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]
                )

        if lowlink_of[v] == index_of[v]:
            component = []
            w = stack.pop()
            on_stack[w] = False
            component.append(w)
            while w != v:
                w = stack.pop()
                on_stack[w] = False
                component.append(w)
            components.append(component)
        return index

    components: list[list[int]] = []
    for v in range(n):
        if index_of[v] == -1:
            strong_connect(v, 0, components)

    return components",data\repos\Python\graphs\tarjans_scc.py,tarjan,815
1130,tarjans_scc.py::create_graph::83,"def create_graph(n: int, edges: list[tuple[int, int]]) -> list[list[int]]:
    """"""
    >>> n = 7
    >>> source = [0, 0, 1, 2, 3, 3, 4, 4, 6]
    >>> target = [1, 3, 2, 0, 1, 4, 5, 6, 5]
    >>> edges = list(zip(source, target))
    >>> create_graph(n, edges)
    [[1, 3], [2], [0], [1, 4], [5, 6], [], [5]]
    """"""
    g: list[list[int]] = [[] for _ in range(n)]
    for u, v in edges:
        g[u].append(v)
    return g",data\repos\Python\graphs\tarjans_scc.py,create_graph,174
1131,tarjans_scc.py::strong_connect::45,"    def strong_connect(v: int, index: int, components: list[list[int]]) -> int:
        index_of[v] = index  # the number when this node is seen
        lowlink_of[v] = index  # lowest rank node reachable from here
        index += 1
        stack.append(v)
        on_stack[v] = True

        for w in g[v]:
            if index_of[w] == -1:
                index = strong_connect(w, index, components)
                lowlink_of[v] = (
                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]
                )
            elif on_stack[w]:
                lowlink_of[v] = (
                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]
                )

        if lowlink_of[v] == index_of[v]:
            component = []
            w = stack.pop()
            on_stack[w] = False
            component.append(w)
            while w != v:
                w = stack.pop()
                on_stack[w] = False
                component.append(w)
            components.append(component)
        return index",data\repos\Python\graphs\tarjans_scc.py,strong_connect,244
1132,best_time_to_buy_and_sell_stock.py::max_profit::18,"def max_profit(prices: list[int]) -> int:
    """"""
    >>> max_profit([7, 1, 5, 3, 6, 4])
    5
    >>> max_profit([7, 6, 4, 3, 1])
    0
    """"""
    if not prices:
        return 0

    min_price = prices[0]
    max_profit: int = 0

    for price in prices:
        min_price = min(price, min_price)
        max_profit = max(price - min_price, max_profit)

    return max_profit",data\repos\Python\greedy_methods\best_time_to_buy_and_sell_stock.py,max_profit,125
1133,fractional_cover_problem.py::fractional_cover::33,"def fractional_cover(items: list[Item], capacity: int) -> float:
    """"""
    Solve the Fractional Cover Problem.

    Args:
        items: A list of items, where each item has weight and value attributes.
        capacity: The maximum weight capacity of the knapsack.

    Returns:
        The maximum value that can be obtained by selecting fractions of items to cover
        the knapsack's capacity.

    Raises:
        ValueError: If capacity is negative.

    Examples:
    >>> fractional_cover((Item(10, 60), Item(20, 100), Item(30, 120)), capacity=50)
    240.0

    >>> fractional_cover([Item(20, 100), Item(30, 120), Item(10, 60)], capacity=25)
    135.0

    >>> fractional_cover([Item(10, 60), Item(20, 100), Item(30, 120)], capacity=60)
    280.0

    >>> fractional_cover(items=[Item(5, 30), Item(10, 60), Item(15, 90)], capacity=30)
    180.0

    >>> fractional_cover(items=[], capacity=50)
    0.0

    >>> fractional_cover(items=[Item(10, 60)], capacity=5)
    30.0

    >>> fractional_cover(items=[Item(10, 60)], capacity=1)
    6.0

    >>> fractional_cover(items=[Item(10, 60)], capacity=0)
    0.0

    >>> fractional_cover(items=[Item(10, 60)], capacity=-1)
    Traceback (most recent call last):
        ...
    ValueError: Capacity cannot be negative
    """"""
    if capacity < 0:
        raise ValueError(""Capacity cannot be negative"")

    total_value = 0.0
    remaining_capacity = capacity

    # Sort the items by their value-to-weight ratio in descending order
    for item in sorted(items, key=attrgetter(""ratio""), reverse=True):
        if remaining_capacity == 0:
            break

        weight_taken = min(item.weight, remaining_capacity)
        total_value += weight_taken * item.ratio
        remaining_capacity -= weight_taken

    return total_value",data\repos\Python\greedy_methods\fractional_cover_problem.py,fractional_cover,475
1134,fractional_cover_problem.py::ratio::13,"    def ratio(self) -> float:
        """"""
        Return the value-to-weight ratio for the item.

        Returns:
            float: The value-to-weight ratio for the item.

        Examples:
        >>> Item(10, 65).ratio
        6.5

        >>> Item(20, 100).ratio
        5.0

        >>> Item(30, 120).ratio
        4.0
        """"""
        return self.value / self.weight",data\repos\Python\greedy_methods\fractional_cover_problem.py,ratio,99
1135,fractional_knapsack.py::frac_knapsack::5,"def frac_knapsack(vl, wt, w, n):
    """"""
    >>> frac_knapsack([60, 100, 120], [10, 20, 30], 50, 3)
    240.0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10, 4)
    105.0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 4)
    95.0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6], 8, 4)
    60.0
    >>> frac_knapsack([10, 40, 30], [5, 4, 6, 3], 8, 4)
    60.0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 0, 4)
    0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 0)
    95.0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], -8, 4)
    0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, -4)
    95.0
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 800, 4)
    130
    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 400)
    95.0
    >>> frac_knapsack(""ABCD"", [5, 4, 6, 3], 8, 400)
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for /: 'str' and 'int'
    """"""

    r = sorted(zip(vl, wt), key=lambda x: x[0] / x[1], reverse=True)
    vl, wt = [i[0] for i in r], [i[1] for i in r]
    acc = list(accumulate(wt))
    k = bisect(acc, w)
    return (
        0
        if k == 0
        else sum(vl[:k]) + (w - acc[k - 1]) * (vl[k]) / (wt[k])
        if k != n
        else sum(vl[:k])
    )",data\repos\Python\greedy_methods\fractional_knapsack.py,frac_knapsack,659
1136,fractional_knapsack_2.py::fractional_knapsack::8,"def fractional_knapsack(
    value: list[int], weight: list[int], capacity: int
) -> tuple[float, list[float]]:
    """"""
    >>> value = [1, 3, 5, 7, 9]
    >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]
    >>> fractional_knapsack(value, weight, 5)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 15)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 25)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 26)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, -1)
    (-90.0, [0, 0, 0, 0, -10.0])
    >>> fractional_knapsack([1, 3, 5, 7], weight, 30)
    (16, [1, 1, 1, 1])
    >>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack([], [], 30)
    (0, [])
    """"""
    index = list(range(len(value)))
    ratio = [v / w for v, w in zip(value, weight)]
    index.sort(key=lambda i: ratio[i], reverse=True)

    max_value: float = 0
    fractions: list[float] = [0] * len(value)
    for i in index:
        if weight[i] <= capacity:
            fractions[i] = 1
            max_value += value[i]
            capacity -= weight[i]
        else:
            fractions[i] = capacity / weight[i]
            max_value += value[i] * capacity / weight[i]
            break

    return max_value, fractions",data\repos\Python\greedy_methods\fractional_knapsack_2.py,fractional_knapsack,495
1137,gas_station.py::get_gas_stations::36,"def get_gas_stations(
    gas_quantities: list[int], costs: list[int]
) -> tuple[GasStation, ...]:
    """"""
    This function returns a tuple of gas stations.

    Args:
        gas_quantities: Amount of gas available at each station
        costs: The cost of gas required to move from one station to the next

    Returns:
        A tuple of gas stations

    >>> gas_stations = get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])
    >>> len(gas_stations)
    5
    >>> gas_stations[0]
    GasStation(gas_quantity=1, cost=3)
    >>> gas_stations[-1]
    GasStation(gas_quantity=5, cost=2)
    """"""
    return tuple(
        GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)
    )",data\repos\Python\greedy_methods\gas_station.py,get_gas_stations,205
1138,gas_station.py::can_complete_journey::62,"def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:
    """"""
    This function returns the index from which to start the journey
    in order to reach the end.

    Args:
        gas_quantities [list]: Amount of gas available at each station
        cost [list]: The cost of gas required to move from one station to the next

    Returns:
        start [int]: start index needed to complete the journey

    Examples:
    >>> can_complete_journey(get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]))
    3
    >>> can_complete_journey(get_gas_stations([2, 3, 4], [3, 4, 3]))
    -1
    """"""
    total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)
    total_cost = sum(gas_station.cost for gas_station in gas_stations)
    if total_gas < total_cost:
        return -1

    start = 0
    net = 0
    for i, gas_station in enumerate(gas_stations):
        net += gas_station.gas_quantity - gas_station.cost
        if net < 0:
            start = i + 1
            net = 0
    return start",data\repos\Python\greedy_methods\gas_station.py,can_complete_journey,288
1139,minimum_coin_change.py::find_minimum_change::44,"def find_minimum_change(denominations: list[int], value: str) -> list[int]:
    """"""
    Find the minimum change from the given denominations and value
    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)
    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]
    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)
    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]
    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)
    []
    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)
    []
    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)
    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]
    """"""
    total_value = int(value)

    # Initialize Result
    answer = []

    # Traverse through all denomination
    for denomination in reversed(denominations):
        # Find denominations
        while int(total_value) >= int(denomination):
            total_value -= int(denomination)
            answer.append(denomination)  # Append the ""answers"" array

    return answer",data\repos\Python\greedy_methods\minimum_coin_change.py,find_minimum_change,424
1140,minimum_waiting_time.py::minimum_waiting_time::16,"def minimum_waiting_time(queries: list[int]) -> int:
    """"""
    This function takes a list of query times and returns the minimum waiting time
    for all queries to be completed.

    Args:
        queries: A list of queries measured in picoseconds

    Returns:
        total_waiting_time: Minimum waiting time measured in picoseconds

    Examples:
    >>> minimum_waiting_time([3, 2, 1, 2, 6])
    17
    >>> minimum_waiting_time([3, 2, 1])
    4
    >>> minimum_waiting_time([1, 2, 3, 4])
    10
    >>> minimum_waiting_time([5, 5, 5, 5])
    30
    >>> minimum_waiting_time([])
    0
    """"""
    n = len(queries)
    if n in (0, 1):
        return 0
    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))",data\repos\Python\greedy_methods\minimum_waiting_time.py,minimum_waiting_time,214
1141,optimal_merge_pattern.py::optimal_merge_pattern::23,"def optimal_merge_pattern(files: list) -> float:
    """"""Function to merge all the files with optimum cost

    Args:
        files [list]: A list of sizes of different files to be merged

    Returns:
        optimal_merge_cost [int]: Optimal cost to merge all those files

    Examples:
    >>> optimal_merge_pattern([2, 3, 4])
    14
    >>> optimal_merge_pattern([5, 10, 20, 30, 30])
    205
    >>> optimal_merge_pattern([8, 8, 8, 8, 8])
    96
    """"""
    optimal_merge_cost = 0
    while len(files) > 1:
        temp = 0
        # Consider two files with minimum cost to be merged
        for _ in range(2):
            min_index = files.index(min(files))
            temp += files[min_index]
            files.pop(min_index)
        files.append(temp)
        optimal_merge_cost += temp
    return optimal_merge_cost",data\repos\Python\greedy_methods\optimal_merge_pattern.py,optimal_merge_pattern,214
1142,smallest_range.py::smallest_range::10,"def smallest_range(nums: list[list[int]]) -> list[int]:
    """"""
    Find the smallest range from each list in nums.

    Uses min heap for efficiency. The range includes at least one number from each list.

    Args:
        `nums`: List of k sorted integer lists.

    Returns:
        list: Smallest range as a two-element list.

    Examples:

    >>> smallest_range([[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]])
    [20, 24]
    >>> smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]])
    [1, 1]
    >>> smallest_range(((1, 2, 3), (1, 2, 3), (1, 2, 3)))
    [1, 1]
    >>> smallest_range(((-3, -2, -1), (0, 0, 0), (1, 2, 3)))
    [-1, 1]
    >>> smallest_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    [3, 7]
    >>> smallest_range([[0, 0, 0], [0, 0, 0], [0, 0, 0]])
    [0, 0]
    >>> smallest_range([[], [], []])
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    """"""

    min_heap: list[tuple[int, int, int]] = []
    current_max = -maxsize - 1

    for i, items in enumerate(nums):
        heappush(min_heap, (items[0], i, 0))
        current_max = max(current_max, items[0])

    # Initialize smallest_range with large integer values
    smallest_range = [-maxsize - 1, maxsize]

    while min_heap:
        current_min, list_index, element_index = heappop(min_heap)

        if current_max - current_min < smallest_range[1] - smallest_range[0]:
            smallest_range = [current_min, current_max]

        if element_index == len(nums[list_index]) - 1:
            break

        next_element = nums[list_index][element_index + 1]
        heappush(min_heap, (next_element, list_index, element_index + 1))
        current_max = max(current_max, next_element)

    return smallest_range",data\repos\Python\greedy_methods\smallest_range.py,smallest_range,553
1143,adler32.py::adler32::14,"def adler32(plain_text: str) -> int:
    """"""
    Function implements adler-32 hash.
    Iterates and evaluates a new value for each character

    >>> adler32('Algorithms')
    363791387

    >>> adler32('go adler em all')
    708642122
    """"""
    a = 1
    b = 0
    for plain_chr in plain_text:
        a = (a + ord(plain_chr)) % MOD_ADLER
        b = (b + a) % MOD_ADLER
    return (b << 16) | a",data\repos\Python\hashes\adler32.py,adler32,132
1144,chaos_machine.py::push::16,"def push(seed):
    global buffer_space, params_space, machine_time, K, m, t

    # Choosing Dynamical Systems (All)
    for key, value in enumerate(buffer_space):
        # Evolution Parameter
        e = float(seed / value)

        # Control Theory: Orbit Change
        value = (buffer_space[(key + 1) % m] + e) % 1

        # Control Theory: Trajectory Change
        r = (params_space[key] + e) % 1 + 3

        # Modification (Transition Function) - Jumps
        buffer_space[key] = round(float(r * value * (1 - value)), 10)
        params_space[key] = r  # Saving to Parameters Space

    # Logistic Map
    assert max(buffer_space) < 1
    assert max(params_space) < 4

    # Machine Time
    machine_time += 1",data\repos\Python\hashes\chaos_machine.py,push,191
1145,chaos_machine.py::pull::42,"def pull():
    global buffer_space, params_space, machine_time, K, m, t

    # PRNG (Xorshift by George Marsaglia)
    def xorshift(x, y):
        x ^= y >> 13
        y ^= x << 17
        x ^= y >> 5
        return x

    # Choosing Dynamical Systems (Increment)
    key = machine_time % m

    # Evolution (Time Length)
    for _ in range(t):
        # Variables (Position + Parameters)
        r = params_space[key]
        value = buffer_space[key]

        # Modification (Transition Function) - Flow
        buffer_space[key] = round(float(r * value * (1 - value)), 10)
        params_space[key] = (machine_time * 0.01 + r * 1.01) % 1 + 3

    # Choosing Chaotic Data
    x = int(buffer_space[(key + 2) % m] * (10**10))
    y = int(buffer_space[(key - 2) % m] * (10**10))

    # Machine Time
    machine_time += 1

    return xorshift(x, y) % 0xFFFFFFFF",data\repos\Python\hashes\chaos_machine.py,pull,255
1146,chaos_machine.py::reset::75,"def reset():
    global buffer_space, params_space, machine_time, K, m, t

    buffer_space = K
    params_space = [0] * m
    machine_time = 0",data\repos\Python\hashes\chaos_machine.py,reset,42
1147,chaos_machine.py::xorshift::46,"    def xorshift(x, y):
        x ^= y >> 13
        y ^= x << 17
        x ^= y >> 5
        return x",data\repos\Python\hashes\chaos_machine.py,xorshift,35
1148,djb2.py::djb2::21,"def djb2(s: str) -> int:
    """"""
    Implementation of djb2 hash algorithm that
    is popular because of it's magic constants.

    >>> djb2('Algorithms')
    3782405311

    >>> djb2('scramble bits')
    1609059040
    """"""
    hash_value = 5381
    for x in s:
        hash_value = ((hash_value << 5) + hash_value) + ord(x)
    return hash_value & 0xFFFFFFFF",data\repos\Python\hashes\djb2.py,djb2,110
1149,elf.py::elf_hash::1,"def elf_hash(data: str) -> int:
    """"""
    Implementation of ElfHash Algorithm, a variant of PJW hash function.

    >>> elf_hash('lorem ipsum')
    253956621
    """"""
    hash_ = x = 0
    for letter in data:
        hash_ = (hash_ << 4) + ord(letter)
        x = hash_ & 0xF0000000
        if x != 0:
            hash_ ^= x >> 24
        hash_ &= ~x
    return hash_",data\repos\Python\hashes\elf.py,elf_hash,114
1150,enigma_machine.py::rotator::10,"def rotator():
    global gear_one_pos
    global gear_two_pos
    global gear_three_pos
    i = gear_one[0]
    gear_one.append(i)
    del gear_one[0]
    gear_one_pos += 1
    if gear_one_pos % len(alphabets) == 0:
        i = gear_two[0]
        gear_two.append(i)
        del gear_two[0]
        gear_two_pos += 1
        if gear_two_pos % len(alphabets) == 0:
            i = gear_three[0]
            gear_three.append(i)
            del gear_three[0]
            gear_three_pos += 1",data\repos\Python\hashes\enigma_machine.py,rotator,140
1151,enigma_machine.py::engine::30,"def engine(input_character):
    target = alphabets.index(input_character)
    target = gear_one[target]
    target = gear_two[target]
    target = gear_three[target]
    target = reflector[target]
    target = gear_three.index(target)
    target = gear_two.index(target)
    target = gear_one.index(target)
    code.append(alphabets[target])
    rotator()",data\repos\Python\hashes\enigma_machine.py,engine,80
1152,fletcher16.py::fletcher16::13,"def fletcher16(text: str) -> int:
    """"""
    Loop through every character in the data and add to two sums.

    >>> fletcher16('hello world')
    6752
    >>> fletcher16('onethousandfourhundredthirtyfour')
    28347
    >>> fletcher16('The quick brown fox jumps over the lazy dog.')
    5655
    """"""
    data = bytes(text, ""ascii"")
    sum1 = 0
    sum2 = 0
    for character in data:
        sum1 = (sum1 + character) % 255
        sum2 = (sum1 + sum2) % 255
    return (sum2 << 8) | sum1",data\repos\Python\hashes\fletcher16.py,fletcher16,155
1153,hamming_code.py::text_to_bits::52,"def text_to_bits(text, encoding=""utf-8"", errors=""surrogatepass""):
    """"""
    >>> text_to_bits(""msg"")
    '011011010111001101100111'
    """"""
    bits = bin(int.from_bytes(text.encode(encoding, errors), ""big""))[2:]
    return bits.zfill(8 * ((len(bits) + 7) // 8))",data\repos\Python\hashes\hamming_code.py,text_to_bits,80
1154,hamming_code.py::text_from_bits::61,"def text_from_bits(bits, encoding=""utf-8"", errors=""surrogatepass""):
    """"""
    >>> text_from_bits('011011010111001101100111')
    'msg'
    """"""
    n = int(bits, 2)
    return n.to_bytes((n.bit_length() + 7) // 8, ""big"").decode(encoding, errors) or ""\0""",data\repos\Python\hashes\hamming_code.py,text_from_bits,80
1155,hamming_code.py::emitter_converter::71,"def emitter_converter(size_par, data):
    """"""
    :param size_par: how many parity bits the message must have
    :param data:  information bits
    :return: message to be transmitted by unreliable medium
            - bits of information merged with parity bits

    >>> emitter_converter(4, ""101010111111"")
    ['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1']
    >>> emitter_converter(5, ""101010111111"")
    Traceback (most recent call last):
        ...
    ValueError: size of parity don't match with size of data
    """"""
    if size_par + len(data) <= 2**size_par - (len(data) - 1):
        raise ValueError(""size of parity don't match with size of data"")

    data_out = []
    parity = []
    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]

    # sorted information data for the size of the output data
    data_ord = []
    # data position template + parity
    data_out_gab = []
    # parity bit counter
    qtd_bp = 0
    # counter position of data bits
    cont_data = 0

    for x in range(1, size_par + len(data) + 1):
        # Performs a template of bit positions - who should be given,
        # and who should be parity
        if qtd_bp < size_par:
            if (np.log(x) / np.log(2)).is_integer():
                data_out_gab.append(""P"")
                qtd_bp = qtd_bp + 1
            else:
                data_out_gab.append(""D"")
        else:
            data_out_gab.append(""D"")

        # Sorts the data to the new output size
        if data_out_gab[-1] == ""D"":
            data_ord.append(data[cont_data])
            cont_data += 1
        else:
            data_ord.append(None)

    # Calculates parity
    qtd_bp = 0  # parity bit counter
    for bp in range(1, size_par + 1):
        # Bit counter one for a given parity
        cont_bo = 0
        # counter to control the loop reading
        for cont_loop, x in enumerate(data_ord):
            if x is not None:
                try:
                    aux = (bin_pos[cont_loop])[-1 * (bp)]
                except IndexError:
                    aux = ""0""
                if aux == ""1"" and x == ""1"":
                    cont_bo += 1
        parity.append(cont_bo % 2)

        qtd_bp += 1

    # Mount the message
    cont_bp = 0  # parity bit counter
    for x in range(size_par + len(data)):
        if data_ord[x] is None:
            data_out.append(str(parity[cont_bp]))
            cont_bp += 1
        else:
            data_out.append(data_ord[x])

    return data_out",data\repos\Python\hashes\hamming_code.py,emitter_converter,667
1156,hamming_code.py::receptor_converter::150,"def receptor_converter(size_par, data):
    """"""
    >>> receptor_converter(4, ""1111010010111111"")
    (['1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1'], True)
    """"""
    # data position template + parity
    data_out_gab = []
    # Parity bit counter
    qtd_bp = 0
    # Counter p data bit reading
    cont_data = 0
    # list of parity received
    parity_received = []
    data_output = []

    for i, item in enumerate(data, 1):
        # Performs a template of bit positions - who should be given,
        #  and who should be parity
        if qtd_bp < size_par and (np.log(i) / np.log(2)).is_integer():
            data_out_gab.append(""P"")
            qtd_bp = qtd_bp + 1
        else:
            data_out_gab.append(""D"")

        # Sorts the data to the new output size
        if data_out_gab[-1] == ""D"":
            data_output.append(item)
        else:
            parity_received.append(item)

    # -----------calculates the parity with the data
    data_out = []
    parity = []
    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data_output) + 1)]

    #  sorted information data for the size of the output data
    data_ord = []
    # Data position feedback + parity
    data_out_gab = []
    # Parity bit counter
    qtd_bp = 0
    # Counter p data bit reading
    cont_data = 0

    for x in range(1, size_par + len(data_output) + 1):
        # Performs a template position of bits - who should be given,
        # and who should be parity
        if qtd_bp < size_par and (np.log(x) / np.log(2)).is_integer():
            data_out_gab.append(""P"")
            qtd_bp = qtd_bp + 1
        else:
            data_out_gab.append(""D"")

        # Sorts the data to the new output size
        if data_out_gab[-1] == ""D"":
            data_ord.append(data_output[cont_data])
            cont_data += 1
        else:
            data_ord.append(None)

    # Calculates parity
    qtd_bp = 0  # parity bit counter
    for bp in range(1, size_par + 1):
        # Bit counter one for a certain parity
        cont_bo = 0
        for cont_loop, x in enumerate(data_ord):
            if x is not None:
                try:
                    aux = (bin_pos[cont_loop])[-1 * (bp)]
                except IndexError:
                    aux = ""0""
                if aux == ""1"" and x == ""1"":
                    cont_bo += 1
        parity.append(str(cont_bo % 2))

        qtd_bp += 1

    # Mount the message
    cont_bp = 0  # Parity bit counter
    for x in range(size_par + len(data_output)):
        if data_ord[x] is None:
            data_out.append(str(parity[cont_bp]))
            cont_bp += 1
        else:
            data_out.append(data_ord[x])

    ack = parity_received == parity
    return data_output, ack",data\repos\Python\hashes\hamming_code.py,receptor_converter,737
1157,luhn.py::is_luhn::6,"def is_luhn(string: str) -> bool:
    """"""
    Perform Luhn validation on an input string
    Algorithm:
    * Double every other digit starting from 2nd last digit.
    * Subtract 9 if number is greater than 9.
    * Sum the numbers
    *
    >>> test_cases = (79927398710, 79927398711, 79927398712, 79927398713,
    ...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718,
    ...     79927398719)
    >>> [is_luhn(str(test_case)) for test_case in test_cases]
    [False, False, False, True, False, False, False, False, False, False]
    """"""
    check_digit: int
    _vector: list[str] = list(string)
    __vector, check_digit = _vector[:-1], int(_vector[-1])
    vector: list[int] = [int(digit) for digit in __vector]

    vector.reverse()
    for i, digit in enumerate(vector):
        if i & 1 == 0:
            doubled: int = digit * 2
            if doubled > 9:
                doubled -= 9
            check_digit += doubled
        else:
            check_digit += digit

    return check_digit % 10 == 0",data\repos\Python\hashes\luhn.py,is_luhn,297
1158,md5.py::to_little_endian::18,"def to_little_endian(string_32: bytes) -> bytes:
    """"""
    Converts the given string to little-endian in groups of 8 chars.

    Arguments:
        string_32 {[string]} -- [32-char string]

    Raises:
        ValueError -- [input is not 32 char]

    Returns:
        32-char little-endian string
    >>> to_little_endian(b'1234567890abcdfghijklmnopqrstuvw')
    b'pqrstuvwhijklmno90abcdfg12345678'
    >>> to_little_endian(b'1234567890')
    Traceback (most recent call last):
    ...
    ValueError: Input must be of length 32
    """"""
    if len(string_32) != 32:
        raise ValueError(""Input must be of length 32"")

    little_endian = b""""
    for i in [3, 2, 1, 0]:
        little_endian += string_32[8 * i : 8 * i + 8]
    return little_endian",data\repos\Python\hashes\md5.py,to_little_endian,218
1159,md5.py::reformat_hex::46,"def reformat_hex(i: int) -> bytes:
    """"""
    Converts the given non-negative integer to hex string.

    Example: Suppose the input is the following:
        i = 1234

        The input is 0x000004d2 in hex, so the little-endian hex string is
        ""d2040000"".

    Arguments:
        i {[int]} -- [integer]

    Raises:
        ValueError -- [input is negative]

    Returns:
        8-char little-endian hex string

    >>> reformat_hex(1234)
    b'd2040000'
    >>> reformat_hex(666)
    b'9a020000'
    >>> reformat_hex(0)
    b'00000000'
    >>> reformat_hex(1234567890)
    b'd2029649'
    >>> reformat_hex(1234567890987654321)
    b'b11c6cb1'
    >>> reformat_hex(-1)
    Traceback (most recent call last):
    ...
    ValueError: Input must be non-negative
    """"""
    if i < 0:
        raise ValueError(""Input must be non-negative"")

    hex_rep = format(i, ""08x"")[-8:]
    little_endian_hex = b""""
    for j in [3, 2, 1, 0]:
        little_endian_hex += hex_rep[2 * j : 2 * j + 2].encode(""utf-8"")
    return little_endian_hex",data\repos\Python\hashes\md5.py,reformat_hex,310
1160,md5.py::preprocess::90,"def preprocess(message: bytes) -> bytes:
    """"""
    Preprocesses the message string:
    - Convert message to bit string
    - Pad bit string to a multiple of 512 chars:
        - Append a 1
        - Append 0's until length = 448 (mod 512)
        - Append length of original message (64 chars)

    Example: Suppose the input is the following:
        message = ""a""

        The message bit string is ""01100001"", which is 8 bits long. Thus, the
        bit string needs 439 bits of padding so that
        (bit_string + ""1"" + padding) = 448 (mod 512).
        The message length is ""000010000...0"" in 64-bit little-endian binary.
        The combined bit string is then 512 bits long.

    Arguments:
        message {[string]} -- [message string]

    Returns:
        processed bit string padded to a multiple of 512 chars

    >>> preprocess(b""a"") == (b""01100001"" + b""1"" +
    ...                     (b""0"" * 439) + b""00001000"" + (b""0"" * 56))
    True
    >>> preprocess(b"""") == b""1"" + (b""0"" * 447) + (b""0"" * 64)
    True
    """"""
    bit_string = b""""
    for char in message:
        bit_string += format(char, ""08b"").encode(""utf-8"")
    start_len = format(len(bit_string), ""064b"").encode(""utf-8"")

    # Pad bit_string to a multiple of 512 chars
    bit_string += b""1""
    while len(bit_string) % 512 != 448:
        bit_string += b""0""
    bit_string += to_little_endian(start_len[32:]) + to_little_endian(start_len[:32])

    return bit_string",data\repos\Python\hashes\md5.py,preprocess,410
1161,md5.py::get_block_words::134,"def get_block_words(bit_string: bytes) -> Generator[list[int]]:
    """"""
    Splits bit string into blocks of 512 chars and yields each block as a list
    of 32-bit words

    Example: Suppose the input is the following:
        bit_string =
            ""000000000...0"" +  # 0x00 (32 bits, padded to the right)
            ""000000010...0"" +  # 0x01 (32 bits, padded to the right)
            ""000000100...0"" +  # 0x02 (32 bits, padded to the right)
            ""000000110...0"" +  # 0x03 (32 bits, padded to the right)
            ...
            ""000011110...0""    # 0x0a (32 bits, padded to the right)

        Then len(bit_string) == 512, so there'll be 1 block. The block is split
        into 32-bit words, and each word is converted to little endian. The
        first word is interpreted as 0 in decimal, the second word is
        interpreted as 1 in decimal, etc.

        Thus, block_words == [[0, 1, 2, 3, ..., 15]].

    Arguments:
        bit_string {[string]} -- [bit string with multiple of 512 as length]

    Raises:
        ValueError -- [length of bit string isn't multiple of 512]

    Yields:
        a list of 16 32-bit words

    >>> test_string = ("""".join(format(n << 24, ""032b"") for n in range(16))
    ...                  .encode(""utf-8""))
    >>> list(get_block_words(test_string))
    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]]
    >>> list(get_block_words(test_string * 4)) == [list(range(16))] * 4
    True
    >>> list(get_block_words(b""1"" * 512)) == [[4294967295] * 16]
    True
    >>> list(get_block_words(b""""))
    []
    >>> list(get_block_words(b""1111""))
    Traceback (most recent call last):
    ...
    ValueError: Input must have length that's a multiple of 512
    """"""
    if len(bit_string) % 512 != 0:
        raise ValueError(""Input must have length that's a multiple of 512"")

    for pos in range(0, len(bit_string), 512):
        block = bit_string[pos : pos + 512]
        block_words = []
        for i in range(0, 512, 32):
            block_words.append(int(to_little_endian(block[i : i + 32]), 2))
        yield block_words",data\repos\Python\hashes\md5.py,get_block_words,618
1162,md5.py::not_32::190,"def not_32(i: int) -> int:
    """"""
    Perform bitwise NOT on given int.

    Arguments:
        i {[int]} -- [given int]

    Raises:
        ValueError -- [input is negative]

    Returns:
        Result of bitwise NOT on i

    >>> not_32(34)
    4294967261
    >>> not_32(1234)
    4294966061
    >>> not_32(4294966061)
    1234
    >>> not_32(0)
    4294967295
    >>> not_32(1)
    4294967294
    >>> not_32(-1)
    Traceback (most recent call last):
    ...
    ValueError: Input must be non-negative
    """"""
    if i < 0:
        raise ValueError(""Input must be non-negative"")

    i_str = format(i, ""032b"")
    new_str = """"
    for c in i_str:
        new_str += ""1"" if c == ""0"" else ""0""
    return int(new_str, 2)",data\repos\Python\hashes\md5.py,not_32,229
1163,md5.py::sum_32::228,"def sum_32(a: int, b: int) -> int:
    """"""
    Add two numbers as 32-bit ints.

    Arguments:
        a {[int]} -- [first given int]
        b {[int]} -- [second given int]

    Returns:
        (a + b) as an unsigned 32-bit int

    >>> sum_32(1, 1)
    2
    >>> sum_32(2, 3)
    5
    >>> sum_32(0, 0)
    0
    >>> sum_32(-1, -1)
    4294967294
    >>> sum_32(4294967295, 1)
    0
    """"""
    return (a + b) % 2**32",data\repos\Python\hashes\md5.py,sum_32,164
1164,md5.py::left_rotate_32::253,"def left_rotate_32(i: int, shift: int) -> int:
    """"""
    Rotate the bits of a given int left by a given amount.

    Arguments:
        i {[int]} -- [given int]
        shift {[int]} -- [shift amount]

    Raises:
        ValueError -- [either given int or shift is negative]

    Returns:
        `i` rotated to the left by `shift` bits

    >>> left_rotate_32(1234, 1)
    2468
    >>> left_rotate_32(1111, 4)
    17776
    >>> left_rotate_32(2147483648, 1)
    1
    >>> left_rotate_32(2147483648, 3)
    4
    >>> left_rotate_32(4294967295, 4)
    4294967295
    >>> left_rotate_32(1234, 0)
    1234
    >>> left_rotate_32(0, 0)
    0
    >>> left_rotate_32(-1, 0)
    Traceback (most recent call last):
    ...
    ValueError: Input must be non-negative
    >>> left_rotate_32(0, -1)
    Traceback (most recent call last):
    ...
    ValueError: Shift must be non-negative
    """"""
    if i < 0:
        raise ValueError(""Input must be non-negative"")
    if shift < 0:
        raise ValueError(""Shift must be non-negative"")
    return ((i << shift) ^ (i >> (32 - shift))) % 2**32",data\repos\Python\hashes\md5.py,left_rotate_32,338
1165,md5.py::md5_me::297,"def md5_me(message: bytes) -> bytes:
    """"""
    Returns the 32-char MD5 hash of a given message.

    Reference: https://en.wikipedia.org/wiki/MD5#Algorithm

    Arguments:
        message {[string]} -- [message]

    Returns:
        32-char MD5 hash string

    >>> md5_me(b"""")
    b'd41d8cd98f00b204e9800998ecf8427e'
    >>> md5_me(b""The quick brown fox jumps over the lazy dog"")
    b'9e107d9d372bb6826bd81d3542a419d6'
    >>> md5_me(b""The quick brown fox jumps over the lazy dog."")
    b'e4d909c290d0fb1ca068ffaddf22cbd0'

    >>> import hashlib
    >>> from string import ascii_letters
    >>> msgs = [b"""", ascii_letters.encode(""utf-8""), """".encode(""utf-8""),
    ...         b""The quick brown fox jumps over the lazy dog.""]
    >>> all(md5_me(msg) == hashlib.md5(msg).hexdigest().encode(""utf-8"") for msg in msgs)
    True
    """"""

    # Convert to bit string, add padding and append message length
    bit_string = preprocess(message)

    added_consts = [int(2**32 * abs(sin(i + 1))) for i in range(64)]

    # Starting states
    a0 = 0x67452301
    b0 = 0xEFCDAB89
    c0 = 0x98BADCFE
    d0 = 0x10325476

    shift_amounts = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
    ]

    # Process bit string in chunks, each with 16 32-char words
    for block_words in get_block_words(bit_string):
        a = a0
        b = b0
        c = c0
        d = d0

        # Hash current chunk
        for i in range(64):
            if i <= 15:
                # f = (b & c) | (not_32(b) & d)     # Alternate definition for f
                f = d ^ (b & (c ^ d))
                g = i
            elif i <= 31:
                # f = (d & b) | (not_32(d) & c)     # Alternate definition for f
                f = c ^ (d & (b ^ c))
                g = (5 * i + 1) % 16
            elif i <= 47:
                f = b ^ c ^ d
                g = (3 * i + 5) % 16
            else:
                f = c ^ (b | not_32(d))
                g = (7 * i) % 16
            f = (f + a + added_consts[i] + block_words[g]) % 2**32
            a = d
            d = c
            c = b
            b = sum_32(b, left_rotate_32(f, shift_amounts[i]))

        # Add hashed chunk to running total
        a0 = sum_32(a0, a)
        b0 = sum_32(b0, b)
        c0 = sum_32(c0, c)
        d0 = sum_32(d0, d)

    digest = reformat_hex(a0) + reformat_hex(b0) + reformat_hex(c0) + reformat_hex(d0)
    return digest",data\repos\Python\hashes\md5.py,md5_me,1006
1166,sdbm.py::sdbm::22,"def sdbm(plain_text: str) -> int:
    """"""
    Function implements sdbm hash, easy to use, great for bits scrambling.
    iterates over each character in the given string and applies function to each of
    them.

    >>> sdbm('Algorithms')
    1462174910723540325254304520539387479031000036

    >>> sdbm('scramble bits')
    730247649148944819640658295400555317318720608290373040936089
    """"""
    hash_value = 0
    for plain_chr in plain_text:
        hash_value = (
            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value
        )
    return hash_value",data\repos\Python\hashes\sdbm.py,sdbm,168
1167,sha1.py::test_sha1_hash::133,"def test_sha1_hash():
    msg = b""Test String""
    assert SHA1Hash(msg).final_hash() == hashlib.sha1(msg).hexdigest()  # noqa: S324",data\repos\Python\hashes\sha1.py,test_sha1_hash,38
1168,sha1.py::main::138,"def main():
    """"""
    Provides option 'string' or 'file' to take input and prints the calculated SHA1
    hash. unittest.main() has been commented out because we probably don't want to run
    the test each time.
    """"""
    # unittest.main()
    parser = argparse.ArgumentParser(description=""Process some strings or files"")
    parser.add_argument(
        ""--string"",
        dest=""input_string"",
        default=""Hello World!! Welcome to Cryptography"",
        help=""Hash the string"",
    )
    parser.add_argument(""--file"", dest=""input_file"", help=""Hash contents of a file"")
    args = parser.parse_args()
    input_string = args.input_string
    # In any case hash input should be a bytestring
    if args.input_file:
        with open(args.input_file, ""rb"") as f:
            hash_input = f.read()
    else:
        hash_input = bytes(input_string, ""utf-8"")
    print(SHA1Hash(hash_input).final_hash())",data\repos\Python\hashes\sha1.py,main,208
1169,sha1.py::rotate::53,"    def rotate(n, b):
        """"""
        Static method to be used inside other methods. Left rotates n by b.
        >>> SHA1Hash('').rotate(12,2)
        48
        """"""
        return ((n << b) | (n >> (32 - b))) & 0xFFFFFFFF",data\repos\Python\hashes\sha1.py,rotate,63
1170,sha1.py::padding::61,"    def padding(self):
        """"""
        Pads the input message with zeros so that padded_data has 64 bytes or 512 bits
        """"""
        padding = b""\x80"" + b""\x00"" * (63 - (len(self.data) + 8) % 64)
        padded_data = self.data + padding + struct.pack("">Q"", 8 * len(self.data))
        return padded_data",data\repos\Python\hashes\sha1.py,padding,86
1171,sha1.py::split_blocks::69,"    def split_blocks(self):
        """"""
        Returns a list of bytestrings each of length 64
        """"""
        return [
            self.padded_data[i : i + 64] for i in range(0, len(self.padded_data), 64)
        ]",data\repos\Python\hashes\sha1.py,split_blocks,58
1172,sha1.py::expand_block::78,"    def expand_block(self, block):
        """"""
        Takes a bytestring-block of length 64, unpacks it to a list of integers and
        returns a list of 80 integers after some bit operations
        """"""
        w = list(struct.unpack("">16L"", block)) + [0] * 64
        for i in range(16, 80):
            w[i] = self.rotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1)
        return w",data\repos\Python\hashes\sha1.py,expand_block,119
1173,sha1.py::final_hash::88,"    def final_hash(self):
        """"""
        Calls all the other methods to process the input. Pads the data, then splits
        into blocks and then does a series of operations for each block (including
        expansion).
        For each block, the variable h that was initialized is copied to a,b,c,d,e
        and these 5 variables a,b,c,d,e undergo several changes. After all the blocks
        are processed, these 5 variables are pairwise added to h ie a to h[0], b to h[1]
        and so on. This h becomes our final hash which is returned.
        """"""
        self.padded_data = self.padding()
        self.blocks = self.split_blocks()
        for block in self.blocks:
            expanded_block = self.expand_block(block)
            a, b, c, d, e = self.h
            for i in range(80):
                if 0 <= i < 20:
                    f = (b & c) | ((~b) & d)
                    k = 0x5A827999
                elif 20 <= i < 40:
                    f = b ^ c ^ d
                    k = 0x6ED9EBA1
                elif 40 <= i < 60:
                    f = (b & c) | (b & d) | (c & d)
                    k = 0x8F1BBCDC
                elif 60 <= i < 80:
                    f = b ^ c ^ d
                    k = 0xCA62C1D6
                a, b, c, d, e = (
                    self.rotate(a, 5) + f + e + k + expanded_block[i] & 0xFFFFFFFF,
                    a,
                    self.rotate(b, 30),
                    c,
                    d,
                )
            self.h = (
                self.h[0] + a & 0xFFFFFFFF,
                self.h[1] + b & 0xFFFFFFFF,
                self.h[2] + c & 0xFFFFFFFF,
                self.h[3] + d & 0xFFFFFFFF,
                self.h[4] + e & 0xFFFFFFFF,
            )
        return (""{:08x}"" * 5).format(*self.h)",data\repos\Python\hashes\sha1.py,final_hash,469
1174,sha256.py::main::209,"def main() -> None:
    """"""
    Provides option 'string' or 'file' to take input
    and prints the calculated SHA-256 hash
    """"""

    # unittest.main()

    import doctest

    doctest.testmod()

    parser = argparse.ArgumentParser()
    parser.add_argument(
        ""-s"",
        ""--string"",
        dest=""input_string"",
        default=""Hello World!! Welcome to Cryptography"",
        help=""Hash the string"",
    )
    parser.add_argument(
        ""-f"", ""--file"", dest=""input_file"", help=""Hash contents of a file""
    )

    args = parser.parse_args()

    input_string = args.input_string

    # hash input should be a bytestring
    if args.input_file:
        with open(args.input_file, ""rb"") as f:
            hash_input = f.read()
    else:
        hash_input = bytes(input_string, ""utf-8"")

    print(SHA256(hash_input).hash)",data\repos\Python\hashes\sha256.py,main,200
1175,sha256.py::preprocessing::121,"    def preprocessing(data: bytes) -> bytes:
        padding = b""\x80"" + (b""\x00"" * (63 - (len(data) + 8) % 64))
        big_endian_integer = struct.pack("">Q"", (len(data) * 8))
        return data + padding + big_endian_integer",data\repos\Python\hashes\sha256.py,preprocessing,68
1176,sha256.py::final_hash::126,"    def final_hash(self) -> None:
        # Convert into blocks of 64 bytes
        self.blocks = [
            self.preprocessed_data[x : x + 64]
            for x in range(0, len(self.preprocessed_data), 64)
        ]

        for block in self.blocks:
            # Convert the given block into a list of 4 byte integers
            words = list(struct.unpack("">16L"", block))
            # add 48 0-ed integers
            words += [0] * 48

            a, b, c, d, e, f, g, h = self.hashes

            for index in range(64):
                if index > 15:
                    # modify the zero-ed indexes at the end of the array
                    s0 = (
                        self.ror(words[index - 15], 7)
                        ^ self.ror(words[index - 15], 18)
                        ^ (words[index - 15] >> 3)
                    )
                    s1 = (
                        self.ror(words[index - 2], 17)
                        ^ self.ror(words[index - 2], 19)
                        ^ (words[index - 2] >> 10)
                    )

                    words[index] = (
                        words[index - 16] + s0 + words[index - 7] + s1
                    ) % 0x100000000

                # Compression
                s1 = self.ror(e, 6) ^ self.ror(e, 11) ^ self.ror(e, 25)
                ch = (e & f) ^ ((~e & (0xFFFFFFFF)) & g)
                temp1 = (
                    h + s1 + ch + self.round_constants[index] + words[index]
                ) % 0x100000000
                s0 = self.ror(a, 2) ^ self.ror(a, 13) ^ self.ror(a, 22)
                maj = (a & b) ^ (a & c) ^ (b & c)
                temp2 = (s0 + maj) % 0x100000000

                h, g, f, e, d, c, b, a = (
                    g,
                    f,
                    e,
                    ((d + temp1) % 0x100000000),
                    c,
                    b,
                    a,
                    ((temp1 + temp2) % 0x100000000),
                )

            mutated_hash_values = [a, b, c, d, e, f, g, h]

            # Modify final values
            self.hashes = [
                ((element + mutated_hash_values[index]) % 0x100000000)
                for index, element in enumerate(self.hashes)
            ]

        self.hash = """".join([hex(value)[2:].zfill(8) for value in self.hashes])",data\repos\Python\hashes\sha256.py,final_hash,601
1177,sha256.py::ror::190,"    def ror(self, value: int, rotations: int) -> int:
        """"""
        Right rotate a given unsigned number by a certain amount of rotations
        """"""
        return 0xFFFFFFFF & (value << (32 - rotations)) | (value >> rotations)",data\repos\Python\hashes\sha256.py,ror,55
1178,sha256.py::test_match_hashes::202,"    def test_match_hashes(self) -> None:
        import hashlib

        msg = bytes(""Test String"", ""utf-8"")
        assert SHA256(msg).hash == hashlib.sha256(msg).hexdigest()",data\repos\Python\hashes\sha256.py,test_match_hashes,42
1179,greedy_knapsack.py::calc_profit::20,"def calc_profit(profit: list, weight: list, max_weight: int) -> int:
    """"""
    Function description is as follows-
    :param profit: Take a list of profits
    :param weight: Take a list of weight if bags corresponding to the profits
    :param max_weight: Maximum weight that could be carried
    :return: Maximum expected gain

    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)
    6
    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)
    27
    """"""
    if len(profit) != len(weight):
        raise ValueError(""The length of profit and weight must be same."")
    if max_weight <= 0:
        raise ValueError(""max_weight must greater than zero."")
    if any(p < 0 for p in profit):
        raise ValueError(""Profit can not be negative."")
    if any(w < 0 for w in weight):
        raise ValueError(""Weight can not be negative."")

    # List created to store profit gained for the 1kg in case of each weight
    # respectively.  Calculate and append profit/weight for each element.
    profit_by_weight = [p / w for p, w in zip(profit, weight)]

    # Creating a copy of the list and sorting profit/weight in ascending order
    sorted_profit_by_weight = sorted(profit_by_weight)

    # declaring useful variables
    length = len(sorted_profit_by_weight)
    limit = 0
    gain = 0
    i = 0

    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length
    while limit <= max_weight and i < length:
        # flag value for encountered greatest element in sorted_profit_by_weight
        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]
        """"""
        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.
        This will give the index of the first encountered element which is same as of
        biggest_profit_by_weight.  There may be one or more values same as that of
        biggest_profit_by_weight but index always encounter the very first element
        only.  To curb this alter the values in profit_by_weight once they are used
        here it is done to -1 because neither profit nor weight can be in negative.
        """"""
        index = profit_by_weight.index(biggest_profit_by_weight)
        profit_by_weight[index] = -1

        # check if the weight encountered is less than the total weight
        # encountered before.
        if max_weight - limit >= weight[index]:
            limit += weight[index]
            # Adding profit gained for the given weight 1 ===
            # weight[index]/weight[index]
            gain += 1 * profit[index]
        else:
            # Since the weight encountered is greater than limit, therefore take the
            # required number of remaining kgs and calculate profit for it.
            # weight remaining / weight[index]
            gain += (max_weight - limit) / weight[index] * profit[index]
            break
        i += 1
    return gain",data\repos\Python\knapsack\greedy_knapsack.py,calc_profit,670
1180,knapsack.py::knapsack::10,"def knapsack(
    capacity: int,
    weights: list[int],
    values: list[int],
    counter: int,
    allow_repetition=False,
) -> int:
    """"""
    Returns the maximum value that can be put in a knapsack of a capacity cap,
    whereby each weight w has a specific value val
    with option to allow repetitive selection of items

    >>> cap = 50
    >>> val = [60, 100, 120]
    >>> w = [10, 20, 30]
    >>> c = len(val)
    >>> knapsack(cap, w, val, c)
    220

    Given the repetition is NOT allowed,
    the result is 220 cause the values of 100 and 120 got the weight of 50
    which is the limit of the capacity.
    >>> knapsack(cap, w, val, c, True)
    300

    Given the repetition is allowed,
    the result is 300 cause the values of 60*5 (pick 5 times)
    got the weight of 10*5 which is the limit of the capacity.
    """"""

    @lru_cache
    def knapsack_recur(capacity: int, counter: int) -> int:
        # Base Case
        if counter == 0 or capacity == 0:
            return 0

        # If weight of the nth item is more than Knapsack of capacity,
        #   then this item cannot be included in the optimal solution,
        # else return the maximum of two cases:
        #   (1) nth item included only once (0-1), if allow_repetition is False
        #       nth item included one or more times (0-N), if allow_repetition is True
        #   (2) not included
        if weights[counter - 1] > capacity:
            return knapsack_recur(capacity, counter - 1)
        else:
            left_capacity = capacity - weights[counter - 1]
            new_value_included = values[counter - 1] + knapsack_recur(
                left_capacity, counter - 1 if not allow_repetition else counter
            )
            without_new_value = knapsack_recur(capacity, counter - 1)
            return max(new_value_included, without_new_value)

    return knapsack_recur(capacity, counter)",data\repos\Python\knapsack\knapsack.py,knapsack,501
1181,knapsack.py::knapsack_recur::41,"    def knapsack_recur(capacity: int, counter: int) -> int:
        # Base Case
        if counter == 0 or capacity == 0:
            return 0

        # If weight of the nth item is more than Knapsack of capacity,
        #   then this item cannot be included in the optimal solution,
        # else return the maximum of two cases:
        #   (1) nth item included only once (0-1), if allow_repetition is False
        #       nth item included one or more times (0-N), if allow_repetition is True
        #   (2) not included
        if weights[counter - 1] > capacity:
            return knapsack_recur(capacity, counter - 1)
        else:
            left_capacity = capacity - weights[counter - 1]
            new_value_included = values[counter - 1] + knapsack_recur(
                left_capacity, counter - 1 if not allow_repetition else counter
            )
            without_new_value = knapsack_recur(capacity, counter - 1)
            return max(new_value_included, without_new_value)",data\repos\Python\knapsack\knapsack.py,knapsack_recur,243
1182,recursive_approach_knapsack.py::knapsack::20,"def knapsack(
    weights: list, values: list, number_of_items: int, max_weight: int, index: int
) -> int:
    """"""
    Function description is as follows-
    :param weights: Take a list of weights
    :param values: Take a list of profits corresponding to the weights
    :param number_of_items: number of items available to pick from
    :param max_weight: Maximum weight that could be carried
    :param index: the element we are looking at
    :return: Maximum expected gain
    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)
    13
    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)
    27
    """"""
    if index == number_of_items:
        return 0
    ans1 = 0
    ans2 = 0
    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)
    if weights[index] <= max_weight:
        ans2 = values[index] + knapsack(
            weights, values, number_of_items, max_weight - weights[index], index + 1
        )
    return max(ans1, ans2)",data\repos\Python\knapsack\recursive_approach_knapsack.py,knapsack,297
1183,gaussian_elimination.py::retroactive_resolution::11,"def retroactive_resolution(
    coefficients: NDArray[float64], vector: NDArray[float64]
) -> NDArray[float64]:
    """"""
    This function performs a retroactive linear system resolution
    for triangular matrix

    Examples:
        1.
            * 2x1 + 2x2 - 1x3 = 5
            * 0x1 - 2x2 - 1x3 = -7
            * 0x1 + 0x2 + 5x3 = 15
        2.
            * 2x1 + 2x2 = -1
            * 0x1 - 2x2 = -1

    >>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])
    array([[2.],
           [2.],
           [3.]])
    >>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])
    array([[-1. ],
           [ 0.5]])
    """"""

    rows, _columns = np.shape(coefficients)

    x: NDArray[float64] = np.zeros((rows, 1), dtype=float)
    for row in reversed(range(rows)):
        total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])
        x[row, 0] = (vector[row][0] - total[0]) / coefficients[row, row]

    return x",data\repos\Python\linear_algebra\gaussian_elimination.py,retroactive_resolution,331
1184,gaussian_elimination.py::gaussian_elimination::46,"def gaussian_elimination(
    coefficients: NDArray[float64], vector: NDArray[float64]
) -> NDArray[float64]:
    """"""
    This function performs Gaussian elimination method

    Examples:
        1.
            * 1x1 - 4x2 - 2x3 = -2
            * 5x1 + 2x2 - 2x3 = -3
            * 1x1 - 1x2 + 0x3 = 4
        2.
            * 1x1 + 2x2 = 5
            * 5x1 + 2x2 = 5

    >>> gaussian_elimination([[1, -4, -2], [5, 2, -2], [1, -1, 0]], [[-2], [-3], [4]])
    array([[ 2.3 ],
           [-1.7 ],
           [ 5.55]])
    >>> gaussian_elimination([[1, 2], [5, 2]], [[5], [5]])
    array([[0. ],
           [2.5]])
    """"""
    # coefficients must to be a square matrix so we need to check first
    rows, columns = np.shape(coefficients)
    if rows != columns:
        return np.array((), dtype=float)

    # augmented matrix
    augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)
    augmented_mat = augmented_mat.astype(""float64"")

    # scale the matrix leaving it triangular
    for row in range(rows - 1):
        pivot = augmented_mat[row, row]
        for col in range(row + 1, columns):
            factor = augmented_mat[col, row] / pivot
            augmented_mat[col, :] -= factor * augmented_mat[row, :]

    x = retroactive_resolution(
        augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]
    )

    return x",data\repos\Python\linear_algebra\gaussian_elimination.py,gaussian_elimination,415
1185,jacobi_iteration_method.py::jacobi_iteration_method::13,"def jacobi_iteration_method(
    coefficient_matrix: NDArray[float64],
    constant_matrix: NDArray[float64],
    init_val: list[float],
    iterations: int,
) -> list[float]:
    """"""
    Jacobi Iteration Method:
    An iterative algorithm to determine the solutions of strictly diagonally dominant
    system of linear equations

    4x1 +  x2 +  x3 =  2
     x1 + 5x2 + 2x3 = -6
     x1 + 2x2 + 4x3 = -4

    x_init = [0.5, -0.5 , -0.5]

    Examples:

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    [0.909375, -1.14375, -0.7484375]


    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    Traceback (most recent call last):
        ...
    ValueError: Coefficient matrix dimensions must be nxn but received 2x3

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(
    ...     coefficient, constant, init_val, iterations
    ... )  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but
                received 3x3 and 2x1

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(
    ...     coefficient, constant, init_val, iterations
    ... )  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Number of initial values must be equal to number of rows in coefficient
                matrix but received 2 and 3

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 0
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    Traceback (most recent call last):
        ...
    ValueError: Iterations must be at least 1
    """"""

    rows1, cols1 = coefficient_matrix.shape
    rows2, cols2 = constant_matrix.shape

    if rows1 != cols1:
        msg = f""Coefficient matrix dimensions must be nxn but received {rows1}x{cols1}""
        raise ValueError(msg)

    if cols2 != 1:
        msg = f""Constant matrix must be nx1 but received {rows2}x{cols2}""
        raise ValueError(msg)

    if rows1 != rows2:
        msg = (
            ""Coefficient and constant matrices dimensions must be nxn and nx1 but ""
            f""received {rows1}x{cols1} and {rows2}x{cols2}""
        )
        raise ValueError(msg)

    if len(init_val) != rows1:
        msg = (
            ""Number of initial values must be equal to number of rows in coefficient ""
            f""matrix but received {len(init_val)} and {rows1}""
        )
        raise ValueError(msg)

    if iterations <= 0:
        raise ValueError(""Iterations must be at least 1"")

    table: NDArray[float64] = np.concatenate(
        (coefficient_matrix, constant_matrix), axis=1
    )

    rows, _cols = table.shape

    strictly_diagonally_dominant(table)

    """"""
    # Iterates the whole matrix for given number of times
    for _ in range(iterations):
        new_val = []
        for row in range(rows):
            temp = 0
            for col in range(cols):
                if col == row:
                    denom = table[row][col]
                elif col == cols - 1:
                    val = table[row][col]
                else:
                    temp += (-1) * table[row][col] * init_val[col]
            temp = (temp + val) / denom
            new_val.append(temp)
        init_val = new_val
    """"""

    # denominator - a list of values along the diagonal
    denominator = np.diag(coefficient_matrix)

    # val_last - values of the last column of the table array
    val_last = table[:, -1]

    # masks - boolean mask of all strings without diagonal
    # elements array coefficient_matrix
    masks = ~np.eye(coefficient_matrix.shape[0], dtype=bool)

    # no_diagonals - coefficient_matrix array values without diagonal elements
    no_diagonals = coefficient_matrix[masks].reshape(-1, rows - 1)

    # Here we get 'i_col' - these are the column numbers, for each row
    # without diagonal elements, except for the last column.
    _i_row, i_col = np.where(masks)
    ind = i_col.reshape(-1, rows - 1)

    #'i_col' is converted to a two-dimensional list 'ind', which will be
    # used to make selections from 'init_val' ('arr' array see below).

    # Iterates the whole matrix for given number of times
    for _ in range(iterations):
        arr = np.take(init_val, ind)
        sum_product_rows = np.sum((-1) * no_diagonals * arr, axis=1)
        new_val = (sum_product_rows + val_last) / denominator
        init_val = new_val

    return new_val.tolist()",data\repos\Python\linear_algebra\jacobi_iteration_method.py,jacobi_iteration_method,1458
1186,jacobi_iteration_method.py::strictly_diagonally_dominant::169,"def strictly_diagonally_dominant(table: NDArray[float64]) -> bool:
    """"""
    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 4, -4]])
    >>> strictly_diagonally_dominant(table)
    True

    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 3, -4]])
    >>> strictly_diagonally_dominant(table)
    Traceback (most recent call last):
        ...
    ValueError: Coefficient matrix is not strictly diagonally dominant
    """"""

    rows, cols = table.shape

    is_diagonally_dominant = True

    for i in range(rows):
        total = 0
        for j in range(cols - 1):
            if i == j:
                continue
            else:
                total += table[i][j]

        if table[i][i] <= total:
            raise ValueError(""Coefficient matrix is not strictly diagonally dominant"")

    return is_diagonally_dominant",data\repos\Python\linear_algebra\jacobi_iteration_method.py,strictly_diagonally_dominant,249
1187,lu_decomposition.py::lower_upper_decomposition::25,"def lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    """"""
    Perform LU decomposition on a given matrix and raises an error if the matrix
    isn't square or if no such decomposition exists

    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])
    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
    >>> lower_mat
    array([[1. , 0. , 0. ],
           [0. , 1. , 0. ],
           [2.5, 8. , 1. ]])
    >>> upper_mat
    array([[  2. ,  -2. ,   1. ],
           [  0. ,   1. ,   2. ],
           [  0. ,   0. , -17.5]])

    >>> matrix = np.array([[4, 3], [6, 3]])
    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
    >>> lower_mat
    array([[1. , 0. ],
           [1.5, 1. ]])
    >>> upper_mat
    array([[ 4. ,  3. ],
           [ 0. , -1.5]])

    >>> # Matrix is not square
    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])
    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
    Traceback (most recent call last):
        ...
    ValueError: 'table' has to be of square shaped array but got a 2x3 array:
    [[ 2 -2  1]
     [ 0  1  2]]

    >>> # Matrix is invertible, but its first leading principal minor is 0
    >>> matrix = np.array([[0, 1], [1, 0]])
    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
    Traceback (most recent call last):
    ...
    ArithmeticError: No LU decomposition exists

    >>> # Matrix is singular, but its first leading principal minor is 1
    >>> matrix = np.array([[1, 0], [1, 0]])
    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
    >>> lower_mat
    array([[1., 0.],
           [1., 1.]])
    >>> upper_mat
    array([[1., 0.],
           [0., 0.]])

    >>> # Matrix is singular, but its first leading principal minor is 0
    >>> matrix = np.array([[0, 1], [0, 1]])
    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
    Traceback (most recent call last):
    ...
    ArithmeticError: No LU decomposition exists
    """"""
    # Ensure that table is a square array
    rows, columns = np.shape(table)
    if rows != columns:
        msg = (
            ""'table' has to be of square shaped array but got a ""
            f""{rows}x{columns} array:\n{table}""
        )
        raise ValueError(msg)

    lower = np.zeros((rows, columns))
    upper = np.zeros((rows, columns))

    # in 'total', the necessary data is extracted through slices
    # and the sum of the products is obtained.

    for i in range(columns):
        for j in range(i):
            total = np.sum(lower[i, :i] * upper[:i, j])
            if upper[j][j] == 0:
                raise ArithmeticError(""No LU decomposition exists"")
            lower[i][j] = (table[i][j] - total) / upper[j][j]
        lower[i][i] = 1
        for j in range(i, columns):
            total = np.sum(lower[i, :i] * upper[:i, j])
            upper[i][j] = table[i][j] - total
    return lower, upper",data\repos\Python\linear_algebra\lu_decomposition.py,lower_upper_decomposition,861
1188,matrix_inversion.py::invert_matrix::4,"def invert_matrix(matrix: list[list[float]]) -> list[list[float]]:
    """"""
    Returns the inverse of a square matrix using NumPy.

    Parameters:
    matrix (list[list[float]]): A square matrix.

    Returns:
    list[list[float]]: Inverted matrix if invertible, else raises error.

    >>> invert_matrix([[4.0, 7.0], [2.0, 6.0]])
    [[0.6000000000000001, -0.7000000000000001], [-0.2, 0.4]]
    >>> invert_matrix([[1.0, 2.0], [0.0, 0.0]])
    Traceback (most recent call last):
        ...
    ValueError: Matrix is not invertible
    """"""
    np_matrix = np.array(matrix)

    try:
        inv_matrix = np.linalg.inv(np_matrix)
    except np.linalg.LinAlgError:
        raise ValueError(""Matrix is not invertible"")

    return inv_matrix.tolist()",data\repos\Python\linear_algebra\matrix_inversion.py,invert_matrix,210
1189,simplex.py::generate_col_titles::86,"    def generate_col_titles(self) -> list[str]:
        """"""Generate column titles for tableau of specific dimensions

        >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]),
        ... 2, 0).generate_col_titles()
        ['x1', 'x2', 's1', 's2', 'RHS']

        >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]),
        ... 2, 2).generate_col_titles()
        ['x1', 'x2', 'RHS']
        """"""
        args = (self.n_vars, self.n_slack)

        # decision | slack
        string_starts = [""x"", ""s""]
        titles = []
        for i in range(2):
            for j in range(args[i]):
                titles.append(string_starts[i] + str(j + 1))
        titles.append(""RHS"")
        return titles",data\repos\Python\linear_programming\simplex.py,generate_col_titles,235
1190,simplex.py::find_pivot::108,"    def find_pivot(self) -> tuple[Any, Any]:
        """"""Finds the pivot row and column.
        >>> tuple(int(x) for x in Tableau(np.array([[-2,1,0,0,0], [3,1,1,0,6],
        ... [1,2,0,1,7.]]), 2, 0).find_pivot())
        (1, 0)
        """"""
        objective = self.objectives[-1]

        # Find entries of highest magnitude in objective rows
        sign = (objective == ""min"") - (objective == ""max"")
        col_idx = np.argmax(sign * self.tableau[0, :-1])

        # Choice is only valid if below 0 for maximise, and above for minimise
        if sign * self.tableau[0, col_idx] <= 0:
            self.stop_iter = True
            return 0, 0

        # Pivot row is chosen as having the lowest quotient when elements of
        # the pivot column divide the right-hand side

        # Slice excluding the objective rows
        s = slice(self.n_stages, self.n_rows)

        # RHS
        dividend = self.tableau[s, -1]

        # Elements of pivot column within slice
        divisor = self.tableau[s, col_idx]

        # Array filled with nans
        nans = np.full(self.n_rows - self.n_stages, np.nan)

        # If element in pivot column is greater than zero, return
        # quotient or nan otherwise
        quotients = np.divide(dividend, divisor, out=nans, where=divisor > 0)

        # Arg of minimum quotient excluding the nan values. n_stages is added
        # to compensate for earlier exclusion of objective columns
        row_idx = np.nanargmin(quotients) + self.n_stages
        return row_idx, col_idx",data\repos\Python\linear_programming\simplex.py,find_pivot,402
1191,simplex.py::pivot::149,"    def pivot(self, row_idx: int, col_idx: int) -> np.ndarray:
        """"""Pivots on value on the intersection of pivot row and column.

        >>> Tableau(np.array([[-2,-3,0,0,0],[1,3,1,0,4],[3,1,0,1,4.]]),
        ... 2, 2).pivot(1, 0).tolist()
        ... # doctest: +NORMALIZE_WHITESPACE
        [[0.0, 3.0, 2.0, 0.0, 8.0],
        [1.0, 3.0, 1.0, 0.0, 4.0],
        [0.0, -8.0, -3.0, 1.0, -8.0]]
        """"""
        # Avoid changes to original tableau
        piv_row = self.tableau[row_idx].copy()

        piv_val = piv_row[col_idx]

        # Entry becomes 1
        piv_row *= 1 / piv_val

        # Variable in pivot column becomes basic, ie the only non-zero entry
        for idx, coeff in enumerate(self.tableau[:, col_idx]):
            self.tableau[idx] += -coeff * piv_row
        self.tableau[row_idx] = piv_row
        return self.tableau",data\repos\Python\linear_programming\simplex.py,pivot,290
1192,simplex.py::change_stage::173,"    def change_stage(self) -> np.ndarray:
        """"""Exits first phase of the two-stage method by deleting artificial
        rows and columns, or completes the algorithm if exiting the standard
        case.

        >>> Tableau(np.array([
        ... [3, 3, -1, -1, 0, 0, 4],
        ... [2, 1, 0, 0, 0, 0, 0.],
        ... [1, 2, -1, 0, 1, 0, 2],
        ... [2, 1, 0, -1, 0, 1, 2]
        ... ]), 2, 2).change_stage().tolist()
        ... # doctest: +NORMALIZE_WHITESPACE
        [[2.0, 1.0, 0.0, 0.0, 0.0],
        [1.0, 2.0, -1.0, 0.0, 2.0],
        [2.0, 1.0, 0.0, -1.0, 2.0]]
        """"""
        # Objective of original objective row remains
        self.objectives.pop()

        if not self.objectives:
            return self.tableau

        # Slice containing ids for artificial columns
        s = slice(-self.n_artificial_vars - 1, -1)

        # Delete the artificial variable columns
        self.tableau = np.delete(self.tableau, s, axis=1)

        # Delete the objective row of the first stage
        self.tableau = np.delete(self.tableau, 0, axis=0)

        self.n_stages = 1
        self.n_rows -= 1
        self.n_artificial_vars = 0
        self.stop_iter = False
        return self.tableau",data\repos\Python\linear_programming\simplex.py,change_stage,397
1193,simplex.py::run_simplex::210,"    def run_simplex(self) -> dict[Any, Any]:
        """"""Operate on tableau until objective function cannot be
        improved further.

        # Standard linear program:
        Max:  x1 +  x2
        ST:   x1 + 3x2 <= 4
             3x1 +  x2 <= 4
        >>> {key: float(value) for key, value in Tableau(np.array([[-1,-1,0,0,0],
        ... [1,3,1,0,4],[3,1,0,1,4.]]), 2, 0).run_simplex().items()}
        {'P': 2.0, 'x1': 1.0, 'x2': 1.0}

        # Standard linear program with 3 variables:
        Max: 3x1 +  x2 + 3x3
        ST:  2x1 +  x2 +  x3  2
              x1 + 2x2 + 3x3  5
             2x1 + 2x2 +  x3  6
        >>> {key: float(value) for key, value in Tableau(np.array([
        ... [-3,-1,-3,0,0,0,0],
        ... [2,1,1,1,0,0,2],
        ... [1,2,3,0,1,0,5],
        ... [2,2,1,0,0,1,6.]
        ... ]),3,0).run_simplex().items()} # doctest: +ELLIPSIS
        {'P': 5.4, 'x1': 0.199..., 'x3': 1.6}


        # Optimal tableau input:
        >>> {key: float(value) for key, value in Tableau(np.array([
        ... [0, 0, 0.25, 0.25, 2],
        ... [0, 1, 0.375, -0.125, 1],
        ... [1, 0, -0.125, 0.375, 1]
        ... ]), 2, 0).run_simplex().items()}
        {'P': 2.0, 'x1': 1.0, 'x2': 1.0}

        # Non-standard: >= constraints
        Max: 2x1 + 3x2 +  x3
        ST:   x1 +  x2 +  x3 <= 40
             2x1 +  x2 -  x3 >= 10
                 -  x2 +  x3 >= 10
        >>> {key: float(value) for key, value in Tableau(np.array([
        ... [2, 0, 0, 0, -1, -1, 0, 0, 20],
        ... [-2, -3, -1, 0, 0, 0, 0, 0, 0],
        ... [1, 1, 1, 1, 0, 0, 0, 0, 40],
        ... [2, 1, -1, 0, -1, 0, 1, 0, 10],
        ... [0, -1, 1, 0, 0, -1, 0, 1, 10.]
        ... ]), 3, 2).run_simplex().items()}
        {'P': 70.0, 'x1': 10.0, 'x2': 10.0, 'x3': 20.0}

        # Non standard: minimisation and equalities
        Min: x1 +  x2
        ST: 2x1 +  x2 = 12
            6x1 + 5x2 = 40
        >>> {key: float(value) for key, value in Tableau(np.array([
        ... [8, 6, 0, 0, 52],
        ... [1, 1, 0, 0, 0],
        ... [2, 1, 1, 0, 12],
        ... [6, 5, 0, 1, 40.],
        ... ]), 2, 2).run_simplex().items()}
        {'P': 7.0, 'x1': 5.0, 'x2': 2.0}


        # Pivot on slack variables
        Max: 8x1 + 6x2
        ST:   x1 + 3x2 <= 33
             4x1 + 2x2 <= 48
             2x1 + 4x2 <= 48
              x1 +  x2 >= 10
             x1        >= 2
        >>> {key: float(value) for key, value in Tableau(np.array([
        ... [2, 1, 0, 0, 0, -1, -1, 0, 0, 12.0],
        ... [-8, -6, 0, 0, 0, 0, 0, 0, 0, 0.0],
        ... [1, 3, 1, 0, 0, 0, 0, 0, 0, 33.0],
        ... [4, 2, 0, 1, 0, 0, 0, 0, 0, 60.0],
        ... [2, 4, 0, 0, 1, 0, 0, 0, 0, 48.0],
        ... [1, 1, 0, 0, 0, -1, 0, 1, 0, 10.0],
        ... [1, 0, 0, 0, 0, 0, -1, 0, 1, 2.0]
        ... ]), 2, 2).run_simplex().items()} # doctest: +ELLIPSIS
        {'P': 132.0, 'x1': 12.000... 'x2': 5.999...}
        """"""
        # Stop simplex algorithm from cycling.
        for _ in range(Tableau.maxiter):
            # Completion of each stage removes an objective. If both stages
            # are complete, then no objectives are left
            if not self.objectives:
                # Find the values of each variable at optimal solution
                return self.interpret_tableau()

            row_idx, col_idx = self.find_pivot()

            # If there are no more negative values in objective row
            if self.stop_iter:
                # Delete artificial variable columns and rows. Update attributes
                self.tableau = self.change_stage()
            else:
                self.tableau = self.pivot(row_idx, col_idx)
        return {}",data\repos\Python\linear_programming\simplex.py,run_simplex,1520
1194,simplex.py::interpret_tableau::307,"    def interpret_tableau(self) -> dict[str, float]:
        """"""Given the final tableau, add the corresponding values of the basic
        decision variables to the `output_dict`
        >>> {key: float(value) for key, value in Tableau(np.array([
        ... [0,0,0.875,0.375,5],
        ... [0,1,0.375,-0.125,1],
        ... [1,0,-0.125,0.375,1]
        ... ]),2, 0).interpret_tableau().items()}
        {'P': 5.0, 'x1': 1.0, 'x2': 1.0}
        """"""
        # P = RHS of final tableau
        output_dict = {""P"": abs(self.tableau[0, -1])}

        for i in range(self.n_vars):
            # Gives indices of nonzero entries in the ith column
            nonzero = np.nonzero(self.tableau[:, i])
            n_nonzero = len(nonzero[0])

            # First entry in the nonzero indices
            nonzero_rowidx = nonzero[0][0]
            nonzero_val = self.tableau[nonzero_rowidx, i]

            # If there is only one nonzero value in column, which is one
            if n_nonzero == 1 and nonzero_val == 1:
                rhs_val = self.tableau[nonzero_rowidx, -1]
                output_dict[self.col_titles[i]] = rhs_val
        return output_dict",data\repos\Python\linear_programming\simplex.py,interpret_tableau,319
1195,apriori_algorithm.py::load_data::18,"def load_data() -> list[list[str]]:
    """"""
    Returns a sample transaction dataset.

    >>> load_data()
    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]
    """"""
    return [[""milk""], [""milk"", ""butter""], [""milk"", ""bread""], [""milk"", ""bread"", ""chips""]]",data\repos\Python\machine_learning\apriori_algorithm.py,load_data,88
1196,apriori_algorithm.py::prune::28,"def prune(itemset: list, candidates: list, length: int) -> list:
    """"""
    Prune candidate itemsets that are not frequent.
    The goal of pruning is to filter out candidate itemsets that are not frequent.  This
    is done by checking if all the (k-1) subsets of a candidate itemset are present in
    the frequent itemsets of the previous iteration (valid subsequences of the frequent
    itemsets from the previous iteration).

    Prunes candidate itemsets that are not frequent.

    >>> itemset = ['X', 'Y', 'Z']
    >>> candidates = [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]
    >>> prune(itemset, candidates, 2)
    [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]

    >>> itemset = ['1', '2', '3', '4']
    >>> candidates = ['1', '2', '4']
    >>> prune(itemset, candidates, 3)
    []
    """"""
    itemset_counter = Counter(tuple(item) for item in itemset)
    pruned = []
    for candidate in candidates:
        is_subsequence = True
        for item in candidate:
            item_tuple = tuple(item)
            if (
                item_tuple not in itemset_counter
                or itemset_counter[item_tuple] < length - 1
            ):
                is_subsequence = False
                break
        if is_subsequence:
            pruned.append(candidate)
    return pruned",data\repos\Python\machine_learning\apriori_algorithm.py,prune,322
1197,apriori_algorithm.py::apriori::65,"def apriori(data: list[list[str]], min_support: int) -> list[tuple[list[str], int]]:
    """"""
    Returns a list of frequent itemsets and their support counts.

    >>> data = [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C']]
    >>> apriori(data, 2)
    [(['A', 'B'], 1), (['A', 'C'], 2), (['B', 'C'], 2)]

    >>> data = [['1', '2', '3'], ['1', '2'], ['1', '3'], ['1', '4'], ['2', '3']]
    >>> apriori(data, 3)
    []
    """"""
    itemset = [list(transaction) for transaction in data]
    frequent_itemsets = []
    length = 1

    while itemset:
        # Count itemset support
        counts = [0] * len(itemset)
        for transaction in data:
            for j, candidate in enumerate(itemset):
                if all(item in transaction for item in candidate):
                    counts[j] += 1

        # Prune infrequent itemsets
        itemset = [item for i, item in enumerate(itemset) if counts[i] >= min_support]

        # Append frequent itemsets (as a list to maintain order)
        for i, item in enumerate(itemset):
            frequent_itemsets.append((sorted(item), counts[i]))

        length += 1
        itemset = prune(itemset, list(combinations(itemset, length)), length)

    return frequent_itemsets",data\repos\Python\machine_learning\apriori_algorithm.py,apriori,348
1198,astar.py::astar::89,"def astar(world, start, goal):
    """"""
    Implementation of a start algorithm.
    world : Object of the world object.
    start : Object of the cell as  start position.
    stop  : Object of the cell as goal position.

    >>> p = Gridworld()
    >>> start = Cell()
    >>> start.position = (0,0)
    >>> goal = Cell()
    >>> goal.position = (4,4)
    >>> astar(p, start, goal)
    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
    """"""
    _open = []
    _closed = []
    _open.append(start)

    while _open:
        min_f = np.argmin([n.f for n in _open])
        current = _open[min_f]
        _closed.append(_open.pop(min_f))
        if current == goal:
            break
        for n in world.get_neighbours(current):
            for c in _closed:
                if c == n:
                    continue
            n.g = current.g + 1
            x1, y1 = n.position
            x2, y2 = goal.position
            n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2
            n.f = n.h + n.g

            for c in _open:
                if c == n and c.f < n.f:
                    continue
            _open.append(n)
    path = []
    while current.parent is not None:
        path.append(current.position)
        current = current.parent
    path.append(current.position)
    return path[::-1]",data\repos\Python\machine_learning\astar.py,astar,353
1199,astar.py::get_neighbours::61,"    def get_neighbours(self, cell):
        """"""
        Return the neighbours of cell
        """"""
        neughbour_cord = [
            (-1, -1),
            (-1, 0),
            (-1, 1),
            (0, -1),
            (0, 1),
            (1, -1),
            (1, 0),
            (1, 1),
        ]
        current_x = cell.position[0]
        current_y = cell.position[1]
        neighbours = []
        for n in neughbour_cord:
            x = current_x + n[0]
            y = current_y + n[1]
            if 0 <= x < self.world_x_limit and 0 <= y < self.world_y_limit:
                c = Cell()
                c.position = (x, y)
                c.parent = cell
                neighbours.append(c)
        return neighbours",data\repos\Python\machine_learning\astar.py,get_neighbours,188
1200,automatic_differentiation.py::append::221,"    def append(
        self,
        op_type: OpType,
        params: list[Variable],
        output: Variable,
        other_params: dict | None = None,
    ) -> None:
        """"""
        Adds Operation object to the related Variable objects for
        creating computational graph for calculating gradients.

        Args:
            op_type: Operation type
            params: Input parameters to the operation
            output: Output variable of the operation
        """"""
        operation = Operation(op_type, other_params=other_params)
        param_nodes = []
        for param in params:
            param.add_param_to(operation)
            param_nodes.append(param)
        output.add_result_of(operation)

        operation.add_params(param_nodes)
        operation.add_output(output)",data\repos\Python\machine_learning\automatic_differentiation.py,append,149
1201,automatic_differentiation.py::gradient::247,"    def gradient(self, target: Variable, source: Variable) -> np.ndarray | None:
        """"""
        Reverse accumulation of partial derivatives to calculate gradients
        of target variable with respect to source variable.

        Args:
            target: target variable for which gradients are calculated.
            source: source variable with respect to which the gradients are
            calculated.

        Returns:
            Gradient of the source variable with respect to the target variable
        """"""

        # partial derivatives with respect to target
        partial_deriv = defaultdict(lambda: 0)
        partial_deriv[target] = np.ones_like(target.to_ndarray())

        # iterating through each operations in the computation graph
        operation_queue = [target.result_of]
        while len(operation_queue) > 0:
            operation = operation_queue.pop()
            for param in operation.params:
                # as per the chain rule, multiplying partial derivatives
                # of variables with respect to the target
                dparam_doutput = self.derivative(param, operation)
                dparam_dtarget = dparam_doutput * partial_deriv[operation.output]
                partial_deriv[param] += dparam_dtarget

                if param.result_of and param.result_of != OpType.NOOP:
                    operation_queue.append(param.result_of)

        return partial_deriv.get(source)",data\repos\Python\machine_learning\automatic_differentiation.py,gradient,259
1202,automatic_differentiation.py::derivative::281,"    def derivative(self, param: Variable, operation: Operation) -> np.ndarray:
        """"""
        Compute the derivative of given operation/function

        Args:
            param: variable to be differentiated
            operation: function performed on the input variable

        Returns:
            Derivative of input variable with respect to the output of
            the operation
        """"""
        params = operation.params

        if operation == OpType.ADD:
            return np.ones_like(params[0].to_ndarray(), dtype=np.float64)
        if operation == OpType.SUB:
            if params[0] == param:
                return np.ones_like(params[0].to_ndarray(), dtype=np.float64)
            return -np.ones_like(params[1].to_ndarray(), dtype=np.float64)
        if operation == OpType.MUL:
            return (
                params[1].to_ndarray().T
                if params[0] == param
                else params[0].to_ndarray().T
            )
        if operation == OpType.DIV:
            if params[0] == param:
                return 1 / params[1].to_ndarray()
            return -params[0].to_ndarray() / (params[1].to_ndarray() ** 2)
        if operation == OpType.MATMUL:
            return (
                params[1].to_ndarray().T
                if params[0] == param
                else params[0].to_ndarray().T
            )
        if operation == OpType.POWER:
            power = operation.other_params[""power""]
            return power * (params[0].to_ndarray() ** (power - 1))

        err_msg = f""invalid operation type: {operation.op_type}""
        raise ValueError(err_msg)",data\repos\Python\machine_learning\automatic_differentiation.py,derivative,366
1203,data_transformations.py::normalization::32,"def normalization(data: list, ndigits: int = 3) -> list:
    """"""
    Return a normalized list of values.

    @params: data, a list of values to normalize
    @returns: a list of normalized values (rounded to ndigits decimal places)
    @examples:
    >>> normalization([2, 7, 10, 20, 30, 50])
    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]
    >>> normalization([5, 10, 15, 20, 25])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
    # variables for calculation
    x_min = min(data)
    x_max = max(data)
    # normalize data
    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]",data\repos\Python\machine_learning\data_transformations.py,normalization,210
1204,data_transformations.py::standardization::51,"def standardization(data: list, ndigits: int = 3) -> list:
    """"""
    Return a standardized list of values.

    @params: data, a list of values to standardize
    @returns: a list of standardized values (rounded to ndigits decimal places)
    @examples:
    >>> standardization([2, 7, 10, 20, 30, 50])
    [-0.999, -0.719, -0.551, 0.009, 0.57, 1.69]
    >>> standardization([5, 10, 15, 20, 25])
    [-1.265, -0.632, 0.0, 0.632, 1.265]
    """"""
    # variables for calculation
    mu = mean(data)
    sigma = stdev(data)
    # standardize data
    return [round((x - mu) / (sigma), ndigits) for x in data]",data\repos\Python\machine_learning\data_transformations.py,standardization,209
1205,decision_tree.py::main::176,"def main():
    """"""
    In this demonstration we're generating a sample data set from the sin function in
    numpy.  We then train a decision tree on the data set and use the decision tree to
    predict the label of 10 different test values. Then the mean squared error over
    this test is displayed.
    """"""
    x = np.arange(-1.0, 1.0, 0.005)
    y = np.sin(x)

    tree = DecisionTree(depth=10, min_leaf_size=10)
    tree.train(x, y)

    rng = np.random.default_rng()
    test_cases = (rng.random(10) * 2) - 1
    predictions = np.array([tree.predict(x) for x in test_cases])
    avg_error = np.mean((predictions - test_cases) ** 2)

    print(""Test values: "" + str(test_cases))
    print(""Predictions: "" + str(predictions))
    print(""Average error: "" + str(avg_error))",data\repos\Python\machine_learning\decision_tree.py,main,211
1206,decision_tree.py::mean_squared_error::19,"    def mean_squared_error(self, labels, prediction):
        """"""
        mean_squared_error:
        @param labels: a one-dimensional numpy array
        @param prediction: a floating point value
        return value: mean_squared_error calculates the error if prediction is used to
            estimate the labels
        >>> tester = DecisionTree()
        >>> test_labels = np.array([1,2,3,4,5,6,7,8,9,10])
        >>> test_prediction = float(6)
        >>> bool(tester.mean_squared_error(test_labels, test_prediction) == (
        ...     TestDecisionTree.helper_mean_squared_error_test(test_labels,
        ...         test_prediction)))
        True
        >>> test_labels = np.array([1,2,3])
        >>> test_prediction = float(2)
        >>> bool(tester.mean_squared_error(test_labels, test_prediction) == (
        ...     TestDecisionTree.helper_mean_squared_error_test(test_labels,
        ...         test_prediction)))
        True
        """"""
        if labels.ndim != 1:
            print(""Error: Input labels must be one dimensional"")

        return np.mean((labels - prediction) ** 2)",data\repos\Python\machine_learning\decision_tree.py,mean_squared_error,240
1207,decision_tree.py::train::45,"    def train(self, x, y):
        """"""
        train:
        @param x: a one-dimensional numpy array
        @param y: a one-dimensional numpy array.
        The contents of y are the labels for the corresponding X values

        train() does not have a return value

        Examples:
        1. Try to train when x & y are of same length & 1 dimensions (No errors)
        >>> dt = DecisionTree()
        >>> dt.train(np.array([10,20,30,40,50]),np.array([0,0,0,1,1]))

        2. Try to train when x is 2 dimensions
        >>> dt = DecisionTree()
        >>> dt.train(np.array([[1,2,3,4,5],[1,2,3,4,5]]),np.array([0,0,0,1,1]))
        Traceback (most recent call last):
            ...
        ValueError: Input data set must be one-dimensional

        3. Try to train when x and y are not of the same length
        >>> dt = DecisionTree()
        >>> dt.train(np.array([1,2,3,4,5]),np.array([[0,0,0,1,1],[0,0,0,1,1]]))
        Traceback (most recent call last):
            ...
        ValueError: x and y have different lengths

        4. Try to train when x & y are of the same length but different dimensions
        >>> dt = DecisionTree()
        >>> dt.train(np.array([1,2,3,4,5]),np.array([[1],[2],[3],[4],[5]]))
        Traceback (most recent call last):
            ...
        ValueError: Data set labels must be one-dimensional

        This section is to check that the inputs conform to our dimensionality
        constraints
        """"""
        if x.ndim != 1:
            raise ValueError(""Input data set must be one-dimensional"")
        if len(x) != len(y):
            raise ValueError(""x and y have different lengths"")
        if y.ndim != 1:
            raise ValueError(""Data set labels must be one-dimensional"")

        if len(x) < 2 * self.min_leaf_size:
            self.prediction = np.mean(y)
            return

        if self.depth == 1:
            self.prediction = np.mean(y)
            return

        best_split = 0
        min_error = self.mean_squared_error(x, np.mean(y)) * 2

        """"""
        loop over all possible splits for the decision tree. find the best split.
        if no split exists that is less than 2 * error for the entire array
        then the data set is not split and the average for the entire array is used as
        the predictor
        """"""
        for i in range(len(x)):
            if len(x[:i]) < self.min_leaf_size:  # noqa: SIM114
                continue
            elif len(x[i:]) < self.min_leaf_size:
                continue
            else:
                error_left = self.mean_squared_error(x[:i], np.mean(y[:i]))
                error_right = self.mean_squared_error(x[i:], np.mean(y[i:]))
                error = error_left + error_right
                if error < min_error:
                    best_split = i
                    min_error = error

        if best_split != 0:
            left_x = x[:best_split]
            left_y = y[:best_split]
            right_x = x[best_split:]
            right_y = y[best_split:]

            self.decision_boundary = x[best_split]
            self.left = DecisionTree(
                depth=self.depth - 1, min_leaf_size=self.min_leaf_size
            )
            self.right = DecisionTree(
                depth=self.depth - 1, min_leaf_size=self.min_leaf_size
            )
            self.left.train(left_x, left_y)
            self.right.train(right_x, right_y)
        else:
            self.prediction = np.mean(y)

        return",data\repos\Python\machine_learning\decision_tree.py,train,837
1208,decision_tree.py::predict::140,"    def predict(self, x):
        """"""
        predict:
        @param x: a floating point value to predict the label of
        the prediction function works by recursively calling the predict function
        of the appropriate subtrees based on the tree's decision boundary
        """"""
        if self.prediction is not None:
            return self.prediction
        elif self.left is not None and self.right is not None:
            if x >= self.decision_boundary:
                return self.right.predict(x)
            else:
                return self.left.predict(x)
        else:
            raise ValueError(""Decision tree not yet trained"")",data\repos\Python\machine_learning\decision_tree.py,predict,123
1209,decision_tree.py::helper_mean_squared_error_test::162,"    def helper_mean_squared_error_test(labels, prediction):
        """"""
        helper_mean_squared_error_test:
        @param labels: a one dimensional numpy array
        @param prediction: a floating point value
        return value: helper_mean_squared_error_test calculates the mean squared error
        """"""
        squared_error_sum = float(0)
        for label in labels:
            squared_error_sum += (label - prediction) ** 2

        return float(squared_error_sum / labels.size)",data\repos\Python\machine_learning\decision_tree.py,helper_mean_squared_error_test,98
1210,dimensionality_reduction.py::column_reshape::20,"def column_reshape(input_array: np.ndarray) -> np.ndarray:
    """"""Function to reshape a row Numpy array into a column Numpy array
    >>> input_array = np.array([1, 2, 3])
    >>> column_reshape(input_array)
    array([[1],
           [2],
           [3]])
    """"""

    return input_array.reshape((input_array.size, 1))",data\repos\Python\machine_learning\dimensionality_reduction.py,column_reshape,83
1211,dimensionality_reduction.py::covariance_within_classes::32,"def covariance_within_classes(
    features: np.ndarray, labels: np.ndarray, classes: int
) -> np.ndarray:
    """"""Function to compute the covariance matrix inside each class.
    >>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> labels = np.array([0, 1, 0])
    >>> covariance_within_classes(features, labels, 2)
    array([[0.66666667, 0.66666667, 0.66666667],
           [0.66666667, 0.66666667, 0.66666667],
           [0.66666667, 0.66666667, 0.66666667]])
    """"""

    covariance_sum = np.nan
    for i in range(classes):
        data = features[:, labels == i]
        data_mean = data.mean(1)
        # Centralize the data of class i
        centered_data = data - column_reshape(data_mean)
        if i > 0:
            # If covariance_sum is not None
            covariance_sum += np.dot(centered_data, centered_data.T)
        else:
            # If covariance_sum is np.nan (i.e. first loop)
            covariance_sum = np.dot(centered_data, centered_data.T)

    return covariance_sum / features.shape[1]",data\repos\Python\machine_learning\dimensionality_reduction.py,covariance_within_classes,292
1212,dimensionality_reduction.py::covariance_between_classes::60,"def covariance_between_classes(
    features: np.ndarray, labels: np.ndarray, classes: int
) -> np.ndarray:
    """"""Function to compute the covariance matrix between multiple classes
    >>> features = np.array([[9, 2, 3], [4, 3, 6], [1, 8, 9]])
    >>> labels = np.array([0, 1, 0])
    >>> covariance_between_classes(features, labels, 2)
    array([[ 3.55555556,  1.77777778, -2.66666667],
           [ 1.77777778,  0.88888889, -1.33333333],
           [-2.66666667, -1.33333333,  2.        ]])
    """"""

    general_data_mean = features.mean(1)
    covariance_sum = np.nan
    for i in range(classes):
        data = features[:, labels == i]
        device_data = data.shape[1]
        data_mean = data.mean(1)
        if i > 0:
            # If covariance_sum is not None
            covariance_sum += device_data * np.dot(
                column_reshape(data_mean) - column_reshape(general_data_mean),
                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,
            )
        else:
            # If covariance_sum is np.nan (i.e. first loop)
            covariance_sum = device_data * np.dot(
                column_reshape(data_mean) - column_reshape(general_data_mean),
                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,
            )

    return covariance_sum / features.shape[1]",data\repos\Python\machine_learning\dimensionality_reduction.py,covariance_between_classes,359
1213,dimensionality_reduction.py::principal_component_analysis::94,"def principal_component_analysis(features: np.ndarray, dimensions: int) -> np.ndarray:
    """"""
    Principal Component Analysis.

    For more details, see: https://en.wikipedia.org/wiki/Principal_component_analysis.
    Parameters:
        * features: the features extracted from the dataset
        * dimensions: to filter the projected data for the desired dimension

    >>> test_principal_component_analysis()
    """"""

    # Check if the features have been loaded
    if features.any():
        data_mean = features.mean(1)
        # Center the dataset
        centered_data = features - np.reshape(data_mean, (data_mean.size, 1))
        covariance_matrix = np.dot(centered_data, centered_data.T) / features.shape[1]
        _, eigenvectors = np.linalg.eigh(covariance_matrix)
        # Take all the columns in the reverse order (-1), and then takes only the first
        filtered_eigenvectors = eigenvectors[:, ::-1][:, 0:dimensions]
        # Project the database on the new space
        projected_data = np.dot(filtered_eigenvectors.T, features)
        logging.info(""Principal Component Analysis computed"")

        return projected_data
    else:
        logging.basicConfig(level=logging.ERROR, format=""%(message)s"", force=True)
        logging.error(""Dataset empty"")
        raise AssertionError",data\repos\Python\machine_learning\dimensionality_reduction.py,principal_component_analysis,272
1214,dimensionality_reduction.py::linear_discriminant_analysis::126,"def linear_discriminant_analysis(
    features: np.ndarray, labels: np.ndarray, classes: int, dimensions: int
) -> np.ndarray:
    """"""
    Linear Discriminant Analysis.

    For more details, see: https://en.wikipedia.org/wiki/Linear_discriminant_analysis.
    Parameters:
        * features: the features extracted from the dataset
        * labels: the class labels of the features
        * classes: the number of classes present in the dataset
        * dimensions: to filter the projected data for the desired dimension

    >>> test_linear_discriminant_analysis()
    """"""

    # Check if the dimension desired is less than the number of classes
    assert classes > dimensions

    # Check if features have been already loaded
    if features.any:
        _, eigenvectors = eigh(
            covariance_between_classes(features, labels, classes),
            covariance_within_classes(features, labels, classes),
        )
        filtered_eigenvectors = eigenvectors[:, ::-1][:, :dimensions]
        svd_matrix, _, _ = np.linalg.svd(filtered_eigenvectors)
        filtered_svd_matrix = svd_matrix[:, 0:dimensions]
        projected_data = np.dot(filtered_svd_matrix.T, features)
        logging.info(""Linear Discriminant Analysis computed"")

        return projected_data
    else:
        logging.basicConfig(level=logging.ERROR, format=""%(message)s"", force=True)
        logging.error(""Dataset empty"")
        raise AssertionError",data\repos\Python\machine_learning\dimensionality_reduction.py,linear_discriminant_analysis,299
1215,dimensionality_reduction.py::test_linear_discriminant_analysis::164,"def test_linear_discriminant_analysis() -> None:
    # Create dummy dataset with 2 classes and 3 features
    features = np.array([[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]])
    labels = np.array([0, 0, 0, 1, 1])
    classes = 2
    dimensions = 2

    # Assert that the function raises an AssertionError if dimensions > classes
    with pytest.raises(AssertionError) as error_info:  # noqa: PT012
        projected_data = linear_discriminant_analysis(
            features, labels, classes, dimensions
        )
        if isinstance(projected_data, np.ndarray):
            raise AssertionError(
                ""Did not raise AssertionError for dimensions > classes""
            )
        assert error_info.type is AssertionError",data\repos\Python\machine_learning\dimensionality_reduction.py,test_linear_discriminant_analysis,197
1216,dimensionality_reduction.py::test_principal_component_analysis::183,"def test_principal_component_analysis() -> None:
    features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    dimensions = 2
    expected_output = np.array([[6.92820323, 8.66025404, 10.39230485], [3.0, 3.0, 3.0]])

    with pytest.raises(AssertionError) as error_info:  # noqa: PT012
        output = principal_component_analysis(features, dimensions)
        if not np.allclose(expected_output, output):
            raise AssertionError
        assert error_info.type is AssertionError",data\repos\Python\machine_learning\dimensionality_reduction.py,test_principal_component_analysis,142
1217,frequent_pattern_growth.py::create_tree::55,"def create_tree(data_set: list, min_sup: int = 1) -> tuple[TreeNode, dict]:
    """"""
    Create Frequent Pattern tree

    Args:
        data_set: A list of transactions, where each transaction is a list of items.
        min_sup: The minimum support threshold.
        Items with support less than this will be pruned. Default is 1.

    Returns:
        The root of the FP-Tree.
        header_table: The header table dictionary with item information.

    Example:
    >>> data_set = [
    ...    ['A', 'B', 'C'],
    ...    ['A', 'C'],
    ...    ['A', 'B', 'E'],
    ...    ['A', 'B', 'C', 'E'],
    ...    ['B', 'E']
    ... ]
    >>> min_sup = 2
    >>> fp_tree, header_table = create_tree(data_set, min_sup)
    >>> fp_tree
    TreeNode('Null Set', 1, None)
    >>> len(header_table)
    4
    >>> header_table[""A""]
    [[4, None], TreeNode('A', 4, TreeNode('Null Set', 1, None))]
    >>> header_table[""E""][1]  # doctest: +NORMALIZE_WHITESPACE
    TreeNode('E', 1, TreeNode('B', 3, TreeNode('A', 4, TreeNode('Null Set', 1, None))))
    >>> sorted(header_table)
    ['A', 'B', 'C', 'E']
    >>> fp_tree.name
    'Null Set'
    >>> sorted(fp_tree.children)
    ['A', 'B']
    >>> fp_tree.children['A'].name
    'A'
    >>> sorted(fp_tree.children['A'].children)
    ['B', 'C']
    """"""
    header_table: dict = {}
    for trans in data_set:
        for item in trans:
            header_table[item] = header_table.get(item, [0, None])
            header_table[item][0] += 1

    for k in list(header_table):
        if header_table[k][0] < min_sup:
            del header_table[k]

    if not (freq_item_set := set(header_table)):
        return TreeNode(""Null Set"", 1, None), {}

    for key, value in header_table.items():
        header_table[key] = [value, None]

    fp_tree = TreeNode(""Null Set"", 1, None)  # Parent is None for the root node
    for tran_set in data_set:
        local_d = {
            item: header_table[item][0] for item in tran_set if item in freq_item_set
        }
        if local_d:
            sorted_items = sorted(
                local_d.items(), key=lambda item_info: item_info[1], reverse=True
            )
            ordered_items = [item[0] for item in sorted_items]
            update_tree(ordered_items, fp_tree, header_table, 1)

    return fp_tree, header_table",data\repos\Python\machine_learning\frequent_pattern_growth.py,create_tree,631
1218,frequent_pattern_growth.py::update_tree::128,"def update_tree(items: list, in_tree: TreeNode, header_table: dict, count: int) -> None:
    """"""
    Update the FP-Tree with a transaction.

    Args:
        items: List of items in the transaction.
        in_tree: The current node in the FP-Tree.
        header_table: The header table dictionary with item information.
        count: The count of the transaction.

    Example:
    >>> data_set = [
    ...    ['A', 'B', 'C'],
    ...    ['A', 'C'],
    ...    ['A', 'B', 'E'],
    ...    ['A', 'B', 'C', 'E'],
    ...    ['B', 'E']
    ... ]
    >>> min_sup = 2
    >>> fp_tree, header_table = create_tree(data_set, min_sup)
    >>> fp_tree
    TreeNode('Null Set', 1, None)
    >>> transaction = ['A', 'B', 'E']
    >>> update_tree(transaction, fp_tree, header_table, 1)
    >>> fp_tree
    TreeNode('Null Set', 1, None)
    >>> fp_tree.children['A'].children['B'].children['E'].children
    {}
    >>> fp_tree.children['A'].children['B'].children['E'].count
    2
    >>> header_table['E'][1].name
    'E'
    """"""
    if items[0] in in_tree.children:
        in_tree.children[items[0]].inc(count)
    else:
        in_tree.children[items[0]] = TreeNode(items[0], count, in_tree)
        if header_table[items[0]][1] is None:
            header_table[items[0]][1] = in_tree.children[items[0]]
        else:
            update_header(header_table[items[0]][1], in_tree.children[items[0]])
    if len(items) > 1:
        update_tree(items[1:], in_tree.children[items[0]], header_table, count)",data\repos\Python\machine_learning\frequent_pattern_growth.py,update_tree,426
1219,frequent_pattern_growth.py::update_header::173,"def update_header(node_to_test: TreeNode, target_node: TreeNode) -> TreeNode:
    """"""
    Update the header table with a node link.

    Args:
        node_to_test: The node to be updated in the header table.
        target_node: The node to link to.

    Example:
    >>> data_set = [
    ...    ['A', 'B', 'C'],
    ...    ['A', 'C'],
    ...    ['A', 'B', 'E'],
    ...    ['A', 'B', 'C', 'E'],
    ...    ['B', 'E']
    ... ]
    >>> min_sup = 2
    >>> fp_tree, header_table = create_tree(data_set, min_sup)
    >>> fp_tree
    TreeNode('Null Set', 1, None)
    >>> node1 = TreeNode(""A"", 3, None)
    >>> node2 = TreeNode(""B"", 4, None)
    >>> node1
    TreeNode('A', 3, None)
    >>> node1 = update_header(node1, node2)
    >>> node1
    TreeNode('A', 3, None)
    >>> node1.node_link
    TreeNode('B', 4, None)
    >>> node2.node_link is None
    True
    """"""
    while node_to_test.node_link is not None:
        node_to_test = node_to_test.node_link
    if node_to_test.node_link is None:
        node_to_test.node_link = target_node
    # Return the updated node
    return node_to_test",data\repos\Python\machine_learning\frequent_pattern_growth.py,update_header,322
1220,frequent_pattern_growth.py::ascend_tree::213,"def ascend_tree(leaf_node: TreeNode, prefix_path: list[str]) -> None:
    """"""
    Ascend the FP-Tree from a leaf node to its root, adding item names to the prefix
    path.

    Args:
        leaf_node: The leaf node to start ascending from.
        prefix_path: A list to store the item as they are ascended.

    Example:
    >>> data_set = [
    ...    ['A', 'B', 'C'],
    ...    ['A', 'C'],
    ...    ['A', 'B', 'E'],
    ...    ['A', 'B', 'C', 'E'],
    ...    ['B', 'E']
    ... ]
    >>> min_sup = 2
    >>> fp_tree, header_table = create_tree(data_set, min_sup)

    >>> path = []
    >>> ascend_tree(fp_tree.children['A'], path)
    >>> path # ascending from a leaf node 'A'
    ['A']
    """"""
    if leaf_node.parent is not None:
        prefix_path.append(leaf_node.name)
        ascend_tree(leaf_node.parent, prefix_path)",data\repos\Python\machine_learning\frequent_pattern_growth.py,ascend_tree,233
1221,frequent_pattern_growth.py::find_prefix_path::243,"def find_prefix_path(base_pat: frozenset, tree_node: TreeNode | None) -> dict:  # noqa: ARG001
    """"""
    Find the conditional pattern base for a given base pattern.

    Args:
        base_pat: The base pattern for which to find the conditional pattern base.
        tree_node: The node in the FP-Tree.

    Example:
    >>> data_set = [
    ...    ['A', 'B', 'C'],
    ...    ['A', 'C'],
    ...    ['A', 'B', 'E'],
    ...    ['A', 'B', 'C', 'E'],
    ...    ['B', 'E']
    ... ]
    >>> min_sup = 2
    >>> fp_tree, header_table = create_tree(data_set, min_sup)
    >>> fp_tree
    TreeNode('Null Set', 1, None)
    >>> len(header_table)
    4
    >>> base_pattern = frozenset(['A'])
    >>> sorted(find_prefix_path(base_pattern, fp_tree.children['A']))
    []
    """"""
    cond_pats: dict = {}
    while tree_node is not None:
        prefix_path: list = []
        ascend_tree(tree_node, prefix_path)
        if len(prefix_path) > 1:
            cond_pats[frozenset(prefix_path[1:])] = tree_node.count
        tree_node = tree_node.node_link
    return cond_pats",data\repos\Python\machine_learning\frequent_pattern_growth.py,find_prefix_path,297
1222,frequent_pattern_growth.py::mine_tree::279,"def mine_tree(
    in_tree: TreeNode,  # noqa: ARG001
    header_table: dict,
    min_sup: int,
    pre_fix: set,
    freq_item_list: list,
) -> None:
    """"""
    Mine the FP-Tree recursively to discover frequent itemsets.

    Args:
        in_tree: The FP-Tree to mine.
        header_table: The header table dictionary with item information.
        min_sup: The minimum support threshold.
        pre_fix: A set of items as a prefix for the itemsets being mined.
        freq_item_list: A list to store the frequent itemsets.

    Example:
    >>> data_set = [
    ...    ['A', 'B', 'C'],
    ...    ['A', 'C'],
    ...    ['A', 'B', 'E'],
    ...    ['A', 'B', 'C', 'E'],
    ...    ['B', 'E']
    ... ]
    >>> min_sup = 2
    >>> fp_tree, header_table = create_tree(data_set, min_sup)
    >>> fp_tree
    TreeNode('Null Set', 1, None)
    >>> frequent_itemsets = []
    >>> mine_tree(fp_tree, header_table, min_sup, set([]), frequent_itemsets)
    >>> expe_itm = [{'C'}, {'C', 'A'}, {'E'}, {'A', 'E'}, {'E', 'B'}, {'A'}, {'B'}]
    >>> all(expected in frequent_itemsets for expected in expe_itm)
    True
    """"""
    sorted_items = sorted(header_table.items(), key=lambda item_info: item_info[1][0])
    big_l = [item[0] for item in sorted_items]
    for base_pat in big_l:
        new_freq_set = pre_fix.copy()
        new_freq_set.add(base_pat)
        freq_item_list.append(new_freq_set)
        cond_patt_bases = find_prefix_path(base_pat, header_table[base_pat][1])
        my_cond_tree, my_head = create_tree(list(cond_patt_bases), min_sup)
        if my_head is not None:
            # Pass header_table[base_pat][1] as node_to_test to update_header
            header_table[base_pat][1] = update_header(
                header_table[base_pat][1], my_cond_tree
            )
            mine_tree(my_cond_tree, my_head, min_sup, new_freq_set, freq_item_list)",data\repos\Python\machine_learning\frequent_pattern_growth.py,mine_tree,508
1223,frequent_pattern_growth.py::disp::49,"    def disp(self, ind: int = 1) -> None:
        print(f""{'  ' * ind} {self.name}  {self.count}"")
        for child in self.children.values():
            child.disp(ind + 1)",data\repos\Python\machine_learning\frequent_pattern_growth.py,disp,51
1224,gradient_boosting_classifier.py::fit::26,"    def fit(self, features: np.ndarray, target: np.ndarray) -> None:
        """"""
        Fit the GradientBoostingClassifier to the training data.

        Parameters:
        - features (np.ndarray): The training features.
        - target (np.ndarray): The target values.

        Returns:
        None

        >>> import numpy as np
        >>> from sklearn.datasets import load_iris
        >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)
        >>> iris = load_iris()
        >>> X, y = iris.data, iris.target
        >>> clf.fit(X, y)
        >>> # Check if the model is trained
        >>> len(clf.models) == 100
        True
        """"""
        for _ in range(self.n_estimators):
            # Calculate the pseudo-residuals
            residuals = -self.gradient(target, self.predict(features))
            # Fit a weak learner (e.g., decision tree) to the residuals
            model = DecisionTreeRegressor(max_depth=1)
            model.fit(features, residuals)
            # Update the model by adding the weak learner with a learning rate
            self.models.append((model, self.learning_rate))",data\repos\Python\machine_learning\gradient_boosting_classifier.py,fit,245
1225,gradient_boosting_classifier.py::predict::56,"    def predict(self, features: np.ndarray) -> np.ndarray:
        """"""
        Make predictions on input data.

        Parameters:
        - features (np.ndarray): The input data for making predictions.

        Returns:
        - np.ndarray: An array of binary predictions (-1 or 1).

        >>> import numpy as np
        >>> from sklearn.datasets import load_iris
        >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)
        >>> iris = load_iris()
        >>> X, y = iris.data, iris.target
        >>> clf.fit(X, y)
        >>> y_pred = clf.predict(X)
        >>> # Check if the predictions have the correct shape
        >>> y_pred.shape == y.shape
        True
        """"""
        # Initialize predictions with zeros
        predictions = np.zeros(features.shape[0])
        for model, learning_rate in self.models:
            predictions += learning_rate * model.predict(features)
        return np.sign(predictions)  # Convert to binary predictions (-1 or 1)",data\repos\Python\machine_learning\gradient_boosting_classifier.py,predict,214
1226,gradient_boosting_classifier.py::gradient::83,"    def gradient(self, target: np.ndarray, y_pred: np.ndarray) -> np.ndarray:
        """"""
        Calculate the negative gradient (pseudo-residuals) for logistic loss.

        Parameters:
        - target (np.ndarray): The target values.
        - y_pred (np.ndarray): The predicted values.

        Returns:
        - np.ndarray: An array of pseudo-residuals.

        >>> import numpy as np
        >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)
        >>> target = np.array([0, 1, 0, 1])
        >>> y_pred = np.array([0.2, 0.8, 0.3, 0.7])
        >>> residuals = clf.gradient(target, y_pred)
        >>> # Check if residuals have the correct shape
        >>> residuals.shape == target.shape
        True
        """"""
        return -target / (1 + np.exp(target * y_pred))",data\repos\Python\machine_learning\gradient_boosting_classifier.py,gradient,201
1227,gradient_descent.py::output::49,"def output(example_no, data_set):
    """"""
    :param data_set: test data or train data
    :param example_no: example whose output is to be fetched
    :return: output for that example
    """"""
    if data_set == ""train"":
        return train_data[example_no][1]
    elif data_set == ""test"":
        return test_data[example_no][1]
    return None",data\repos\Python\machine_learning\gradient_descent.py,output,86
1228,gradient_descent.py::calculate_hypothesis_value::62,"def calculate_hypothesis_value(example_no, data_set):
    """"""
    Calculates hypothesis value for a given example
    :param data_set: test data or train_data
    :param example_no: example whose hypothesis value is to be calculated
    :return: hypothesis value for that example
    """"""
    if data_set == ""train"":
        return _hypothesis_value(train_data[example_no][0])
    elif data_set == ""test"":
        return _hypothesis_value(test_data[example_no][0])
    return None",data\repos\Python\machine_learning\gradient_descent.py,calculate_hypothesis_value,111
1229,gradient_descent.py::summation_of_cost_derivative::76,"def summation_of_cost_derivative(index, end=m):
    """"""
    Calculates the sum of cost function derivative
    :param index: index wrt derivative is being calculated
    :param end: value where summation ends, default is m, number of examples
    :return: Returns the summation of cost derivative
    Note: If index is -1, this means we are calculating summation wrt to biased
        parameter.
    """"""
    summation_value = 0
    for i in range(end):
        if index == -1:
            summation_value += _error(i)
        else:
            summation_value += _error(i) * train_data[i][0][index]
    return summation_value",data\repos\Python\machine_learning\gradient_descent.py,summation_of_cost_derivative,149
1230,gradient_descent.py::get_cost_derivative::94,"def get_cost_derivative(index):
    """"""
    :param index: index of the parameter vector wrt to derivative is to be calculated
    :return: derivative wrt to that index
    Note: If index is -1, this means we are calculating summation wrt to biased
        parameter.
    """"""
    cost_derivative_value = summation_of_cost_derivative(index, m) / m
    return cost_derivative_value",data\repos\Python\machine_learning\gradient_descent.py,get_cost_derivative,86
1231,gradient_descent.py::run_gradient_descent::105,"def run_gradient_descent():
    global parameter_vector
    # Tune these values to set a tolerance value for predicted output
    absolute_error_limit = 0.000002
    relative_error_limit = 0
    j = 0
    while True:
        j += 1
        temp_parameter_vector = [0, 0, 0, 0]
        for i in range(len(parameter_vector)):
            cost_derivative = get_cost_derivative(i - 1)
            temp_parameter_vector[i] = (
                parameter_vector[i] - LEARNING_RATE * cost_derivative
            )
        if np.allclose(
            parameter_vector,
            temp_parameter_vector,
            atol=absolute_error_limit,
            rtol=relative_error_limit,
        ):
            break
        parameter_vector = temp_parameter_vector
    print((""Number of iterations:"", j))",data\repos\Python\machine_learning\gradient_descent.py,run_gradient_descent,173
1232,gradient_descent.py::test_gradient_descent::130,"def test_gradient_descent():
    for i in range(len(test_data)):
        print((""Actual output value:"", output(i, ""test"")))
        print((""Hypothesis output:"", calculate_hypothesis_value(i, ""test"")))",data\repos\Python\machine_learning\gradient_descent.py,test_gradient_descent,46
1233,k_means_clust.py::get_initial_centroids::62,"def get_initial_centroids(data, k, seed=None):
    """"""Randomly choose k data points as initial centroids""""""
    # useful for obtaining consistent results
    rng = np.random.default_rng(seed)
    n = data.shape[0]  # number of data points

    # Pick K indices from range [0, N).
    rand_indices = rng.integers(0, n, k)

    # Keep centroids as dense format, as many entries will be nonzero due to averaging.
    # As long as at least one document in a cluster contains a word,
    # it will carry a nonzero weight in the TF-IDF vector of the centroid.
    centroids = data[rand_indices, :]

    return centroids",data\repos\Python\machine_learning\k_means_clust.py,get_initial_centroids,146
1234,k_means_clust.py::assign_clusters::83,"def assign_clusters(data, centroids):
    # Compute distances between each data point and the set of centroids:
    # Fill in the blank (RHS only)
    distances_from_centroids = centroid_pairwise_dist(data, centroids)

    # Compute cluster assignments for each data point:
    # Fill in the blank (RHS only)
    cluster_assignment = np.argmin(distances_from_centroids, axis=1)

    return cluster_assignment",data\repos\Python\machine_learning\k_means_clust.py,assign_clusters,88
1235,k_means_clust.py::revise_centroids::95,"def revise_centroids(data, k, cluster_assignment):
    new_centroids = []
    for i in range(k):
        # Select all data points that belong to cluster i. Fill in the blank (RHS only)
        member_data_points = data[cluster_assignment == i]
        # Compute the mean of the data points. Fill in the blank (RHS only)
        centroid = member_data_points.mean(axis=0)
        new_centroids.append(centroid)
    new_centroids = np.array(new_centroids)

    return new_centroids",data\repos\Python\machine_learning\k_means_clust.py,revise_centroids,111
1236,k_means_clust.py::compute_heterogeneity::108,"def compute_heterogeneity(data, k, centroids, cluster_assignment):
    heterogeneity = 0.0
    for i in range(k):
        # Select all data points that belong to cluster i. Fill in the blank (RHS only)
        member_data_points = data[cluster_assignment == i, :]

        if member_data_points.shape[0] > 0:  # check if i-th cluster is non-empty
            # Compute distances from centroid to data points (RHS only)
            distances = pairwise_distances(
                member_data_points, [centroids[i]], metric=""euclidean""
            )
            squared_distances = distances**2
            heterogeneity += np.sum(squared_distances)

    return heterogeneity",data\repos\Python\machine_learning\k_means_clust.py,compute_heterogeneity,148
1237,k_means_clust.py::plot_heterogeneity::125,"def plot_heterogeneity(heterogeneity, k):
    plt.figure(figsize=(7, 4))
    plt.plot(heterogeneity, linewidth=4)
    plt.xlabel(""# Iterations"")
    plt.ylabel(""Heterogeneity"")
    plt.title(f""Heterogeneity of clustering over time, K={k:d}"")
    plt.rcParams.update({""font.size"": 16})
    plt.show()",data\repos\Python\machine_learning\k_means_clust.py,plot_heterogeneity,79
1238,k_means_clust.py::plot_kmeans::135,"def plot_kmeans(data, centroids, cluster_assignment):
    ax = plt.axes(projection=""3d"")
    ax.scatter(data[:, 0], data[:, 1], data[:, 2], c=cluster_assignment, cmap=""viridis"")
    ax.scatter(
        centroids[:, 0], centroids[:, 1], centroids[:, 2], c=""red"", s=100, marker=""x""
    )
    ax.set_xlabel(""X"")
    ax.set_ylabel(""Y"")
    ax.set_zlabel(""Z"")
    ax.set_title(""3D K-Means Clustering Visualization"")
    plt.show()",data\repos\Python\machine_learning\k_means_clust.py,plot_kmeans,125
1239,k_means_clust.py::kmeans::148,"def kmeans(
    data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False
):
    """"""Runs k-means on given data and initial set of centroids.
    maxiter: maximum number of iterations to run.(default=500)
    record_heterogeneity: (optional) a list, to store the history of heterogeneity
                          as function of iterations
                          if None, do not store the history.
    verbose: if True, print how many data points changed their cluster labels in
                          each iteration""""""
    centroids = initial_centroids[:]
    prev_cluster_assignment = None

    for itr in range(maxiter):
        if verbose:
            print(itr, end="""")

        # 1. Make cluster assignments using nearest centroids
        cluster_assignment = assign_clusters(data, centroids)

        # 2. Compute a new centroid for each of the k clusters, averaging all data
        #    points assigned to that cluster.
        centroids = revise_centroids(data, k, cluster_assignment)

        # Check for convergence: if none of the assignments changed, stop
        if (
            prev_cluster_assignment is not None
            and (prev_cluster_assignment == cluster_assignment).all()
        ):
            break

        # Print number of new assignments
        if prev_cluster_assignment is not None:
            num_changed = np.sum(prev_cluster_assignment != cluster_assignment)
            if verbose:
                print(
                    f""    {num_changed:5d} elements changed their cluster assignment.""
                )

        # Record heterogeneity convergence metric
        if record_heterogeneity is not None:
            # YOUR CODE HERE
            score = compute_heterogeneity(data, k, centroids, cluster_assignment)
            record_heterogeneity.append(score)

        prev_cluster_assignment = cluster_assignment[:]

    return centroids, cluster_assignment",data\repos\Python\machine_learning\k_means_clust.py,kmeans,374
1240,k_means_clust.py::report_generator::218,"def report_generator(
    predicted: pd.DataFrame, clustering_variables: np.ndarray, fill_missing_report=None
) -> pd.DataFrame:
    """"""
    Generate a clustering report given these two arguments:
        predicted - dataframe with predicted cluster column
        fill_missing_report - dictionary of rules on how we are going to fill in missing
        values for final generated report (not included in modelling);
    >>> predicted = pd.DataFrame()
    >>> predicted['numbers'] = [1, 2, 3]
    >>> predicted['col1'] = [0.5, 2.5, 4.5]
    >>> predicted['col2'] = [100, 200, 300]
    >>> predicted['col3'] = [10, 20, 30]
    >>> predicted['Cluster'] = [1, 1, 2]
    >>> report_generator(predicted, ['col1', 'col2'], 0)
               Features               Type   Mark           1           2
    0    # of Customers        ClusterSize  False    2.000000    1.000000
    1    % of Customers  ClusterProportion  False    0.666667    0.333333
    2              col1    mean_with_zeros   True    1.500000    4.500000
    3              col2    mean_with_zeros   True  150.000000  300.000000
    4           numbers    mean_with_zeros  False    1.500000    3.000000
    ..              ...                ...    ...         ...         ...
    99            dummy                 5%  False    1.000000    1.000000
    100           dummy                95%  False    1.000000    1.000000
    101           dummy              stdev  False    0.000000         NaN
    102           dummy               mode  False    1.000000    1.000000
    103           dummy             median  False    1.000000    1.000000
    <BLANKLINE>
    [104 rows x 5 columns]
    """"""
    # Fill missing values with given rules
    if fill_missing_report:
        predicted = predicted.fillna(value=fill_missing_report)
    predicted[""dummy""] = 1
    numeric_cols = predicted.select_dtypes(np.number).columns
    report = (
        predicted.groupby([""Cluster""])[  # construct report dataframe
            numeric_cols
        ]  # group by cluster number
        .agg(
            [
                (""sum"", ""sum""),
                (""mean_with_zeros"", lambda x: np.mean(np.nan_to_num(x))),
                (""mean_without_zeros"", lambda x: x.replace(0, np.nan).mean()),
                (
                    ""mean_25-75"",
                    lambda x: np.mean(
                        np.nan_to_num(
                            sorted(x)[
                                round(len(x) * 25 / 100) : round(len(x) * 75 / 100)
                            ]
                        )
                    ),
                ),
                (""mean_with_na"", ""mean""),
                (""min"", lambda x: x.min()),
                (""5%"", lambda x: x.quantile(0.05)),
                (""25%"", lambda x: x.quantile(0.25)),
                (""50%"", lambda x: x.quantile(0.50)),
                (""75%"", lambda x: x.quantile(0.75)),
                (""95%"", lambda x: x.quantile(0.95)),
                (""max"", lambda x: x.max()),
                (""count"", lambda x: x.count()),
                (""stdev"", lambda x: x.std()),
                (""mode"", lambda x: x.mode()[0]),
                (""median"", lambda x: x.median()),
                (""# > 0"", lambda x: (x > 0).sum()),
            ]
        )
        .T.reset_index()
        .rename(index=str, columns={""level_0"": ""Features"", ""level_1"": ""Type""})
    )  # rename columns
    # calculate the size of cluster(count of clientID's)
    # avoid SettingWithCopyWarning
    clustersize = report[
        (report[""Features""] == ""dummy"") & (report[""Type""] == ""count"")
    ].copy()
    # rename created predicted cluster to match report column names
    clustersize.Type = ""ClusterSize""
    clustersize.Features = ""# of Customers""
    # calculating the proportion of cluster
    clusterproportion = pd.DataFrame(
        clustersize.iloc[:, 2:].to_numpy() / clustersize.iloc[:, 2:].to_numpy().sum()
    )
    # rename created predicted cluster to match report column names
    clusterproportion[""Type""] = ""% of Customers""
    clusterproportion[""Features""] = ""ClusterProportion""
    cols = clusterproportion.columns.tolist()
    cols = cols[-2:] + cols[:-2]
    clusterproportion = clusterproportion[cols]  # rearrange columns to match report
    clusterproportion.columns = report.columns
    # generating dataframe with count of nan values
    a = pd.DataFrame(
        abs(
            report[report[""Type""] == ""count""].iloc[:, 2:].to_numpy()
            - clustersize.iloc[:, 2:].to_numpy()
        )
    )
    a[""Features""] = 0
    a[""Type""] = ""# of nan""
    # filling values in order to match report
    a.Features = report[report[""Type""] == ""count""].Features.tolist()
    cols = a.columns.tolist()
    cols = cols[-2:] + cols[:-2]
    a = a[cols]  # rearrange columns to match report
    a.columns = report.columns  # rename columns to match report
    # drop count values except for cluster size
    report = report.drop(report[report.Type == ""count""].index)
    # concat report with cluster size and nan values
    report = pd.concat([report, a, clustersize, clusterproportion], axis=0)
    report[""Mark""] = report[""Features""].isin(clustering_variables)
    cols = report.columns.tolist()
    cols = cols[0:2] + cols[-1:] + cols[2:-1]
    report = report[cols]
    sorter1 = {
        ""ClusterSize"": 9,
        ""ClusterProportion"": 8,
        ""mean_with_zeros"": 7,
        ""mean_with_na"": 6,
        ""max"": 5,
        ""50%"": 4,
        ""min"": 3,
        ""25%"": 2,
        ""75%"": 1,
        ""# of nan"": 0,
        ""# > 0"": -1,
        ""sum_with_na"": -2,
    }
    report = (
        report.assign(
            Sorter1=lambda x: x.Type.map(sorter1),
            Sorter2=lambda x: list(reversed(range(len(x)))),
        )
        .sort_values([""Sorter1"", ""Mark"", ""Sorter2""], ascending=False)
        .drop([""Sorter1"", ""Sorter2""], axis=1)
    )
    report.columns.name = """"
    report = report.reset_index()
    report = report.drop(columns=[""index""])
    return report",data\repos\Python\machine_learning\k_means_clust.py,report_generator,1537
1241,k_nearest_neighbours.py::classify::47,"    def classify(self, pred_point: np.ndarray[float], k: int = 5) -> str:
        """"""
        Classify a given point using the kNN algorithm
        >>> train_X = np.array(
        ...     [[0, 0], [1, 0], [0, 1], [0.5, 0.5], [3, 3], [2, 3], [3, 2]]
        ... )
        >>> train_y = np.array([0, 0, 0, 0, 1, 1, 1])
        >>> classes = ['A', 'B']
        >>> knn = KNN(train_X, train_y, classes)
        >>> point = np.array([1.2, 1.2])
        >>> knn.classify(point)
        'A'
        """"""
        # Distances of all points from the point to be classified
        distances = (
            (self._euclidean_distance(data_point[0], pred_point), data_point[1])
            for data_point in self.data
        )

        # Choosing k points with the shortest distances
        votes = (i[1] for i in nsmallest(k, distances))

        # Most commonly occurring class is the one into which the point is classified
        result = Counter(votes).most_common(1)[0][0]
        return self.labels[result]",data\repos\Python\machine_learning\k_nearest_neighbours.py,classify,293
1242,linear_discriminant_analysis.py::gaussian_distribution::54,"def gaussian_distribution(mean: float, std_dev: float, instance_count: int) -> list:
    """"""
    Generate gaussian distribution instances based-on given mean and standard deviation
    :param mean: mean value of class
    :param std_dev: value of standard deviation entered by usr or default value of it
    :param instance_count: instance number of class
    :return: a list containing generated values based-on given mean, std_dev and
        instance_count

    >>> gaussian_distribution(5.0, 1.0, 20) # doctest: +NORMALIZE_WHITESPACE
    [6.288184753155463, 6.4494456086997705, 5.066335808938262, 4.235456349028368,
     3.9078267848958586, 5.031334516831717, 3.977896829989127, 3.56317055489747,
      5.199311976483754, 5.133374604658605, 5.546468300338232, 4.086029056264687,
       5.005005283626573, 4.935258239627312, 3.494170998739258, 5.537997178661033,
        5.320711100998849, 7.3891120432406865, 5.202969177309964, 4.855297691835079]
    """"""
    seed(1)
    return [gauss(mean, std_dev) for _ in range(instance_count)]",data\repos\Python\machine_learning\linear_discriminant_analysis.py,gaussian_distribution,337
1243,linear_discriminant_analysis.py::y_generator::75,"def y_generator(class_count: int, instance_count: list) -> list:
    """"""
    Generate y values for corresponding classes
    :param class_count: Number of classes(data groupings) in dataset
    :param instance_count: number of instances in class
    :return: corresponding values for data groupings in dataset

    >>> y_generator(1, [10])
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    >>> y_generator(2, [5, 10])
    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
    """"""

    return [k for k in range(class_count) for _ in range(instance_count[k])]",data\repos\Python\machine_learning\linear_discriminant_analysis.py,y_generator,370
1244,linear_discriminant_analysis.py::calculate_mean::95,"def calculate_mean(instance_count: int, items: list) -> float:
    """"""
    Calculate given class mean
    :param instance_count: Number of instances in class
    :param items: items that related to specific class(data grouping)
    :return: calculated actual mean of considered class

    >>> items = gaussian_distribution(5.0, 1.0, 20)
    >>> calculate_mean(len(items), items)
    5.011267842911003
    """"""
    # the sum of all items divided by number of instances
    return sum(items) / instance_count",data\repos\Python\machine_learning\linear_discriminant_analysis.py,calculate_mean,121
1245,linear_discriminant_analysis.py::calculate_probabilities::111,"def calculate_probabilities(instance_count: int, total_count: int) -> float:
    """"""
    Calculate the probability that a given instance will belong to which class
    :param instance_count: number of instances in class
    :param total_count: the number of all instances
    :return: value of probability for considered class

    >>> calculate_probabilities(20, 60)
    0.3333333333333333
    >>> calculate_probabilities(30, 100)
    0.3
    """"""
    # number of instances in specific class divided by number of all instances
    return instance_count / total_count",data\repos\Python\machine_learning\linear_discriminant_analysis.py,calculate_probabilities,131
1246,linear_discriminant_analysis.py::calculate_variance::128,"def calculate_variance(items: list, means: list, total_count: int) -> float:
    """"""
    Calculate the variance
    :param items: a list containing all items(gaussian distribution of all classes)
    :param means: a list containing real mean values of each class
    :param total_count: the number of all instances
    :return: calculated variance for considered dataset

    >>> items = gaussian_distribution(5.0, 1.0, 20)
    >>> means = [5.011267842911003]
    >>> total_count = 20
    >>> calculate_variance([items], means, total_count)
    0.9618530973487491
    """"""
    squared_diff = []  # An empty list to store all squared differences
    # iterate over number of elements in items
    for i in range(len(items)):
        # for loop iterates over number of elements in inner layer of items
        for j in range(len(items[i])):
            # appending squared differences to 'squared_diff' list
            squared_diff.append((items[i][j] - means[i]) ** 2)

    # one divided by (the number of all instances - number of classes) multiplied by
    # sum of all squared differences
    n_classes = len(means)  # Number of classes in dataset
    return 1 / (total_count - n_classes) * sum(squared_diff)",data\repos\Python\machine_learning\linear_discriminant_analysis.py,calculate_variance,296
1247,linear_discriminant_analysis.py::predict_y_values::157,"def predict_y_values(
    x_items: list, means: list, variance: float, probabilities: list
) -> list:
    """"""This function predicts new indexes(groups for our data)
    :param x_items: a list containing all items(gaussian distribution of all classes)
    :param means: a list containing real mean values of each class
    :param variance: calculated value of variance by calculate_variance function
    :param probabilities: a list containing all probabilities of classes
    :return: a list containing predicted Y values

    >>> x_items = [[6.288184753155463, 6.4494456086997705, 5.066335808938262,
    ...                4.235456349028368, 3.9078267848958586, 5.031334516831717,
    ...                3.977896829989127, 3.56317055489747, 5.199311976483754,
    ...                5.133374604658605, 5.546468300338232, 4.086029056264687,
    ...                5.005005283626573, 4.935258239627312, 3.494170998739258,
    ...                5.537997178661033, 5.320711100998849, 7.3891120432406865,
    ...                5.202969177309964, 4.855297691835079], [11.288184753155463,
    ...                11.44944560869977, 10.066335808938263, 9.235456349028368,
    ...                8.907826784895859, 10.031334516831716, 8.977896829989128,
    ...                8.56317055489747, 10.199311976483754, 10.133374604658606,
    ...                10.546468300338232, 9.086029056264687, 10.005005283626572,
    ...                9.935258239627313, 8.494170998739259, 10.537997178661033,
    ...                10.320711100998848, 12.389112043240686, 10.202969177309964,
    ...                9.85529769183508], [16.288184753155463, 16.449445608699772,
    ...                15.066335808938263, 14.235456349028368, 13.907826784895859,
    ...                15.031334516831716, 13.977896829989128, 13.56317055489747,
    ...                15.199311976483754, 15.133374604658606, 15.546468300338232,
    ...                14.086029056264687, 15.005005283626572, 14.935258239627313,
    ...                13.494170998739259, 15.537997178661033, 15.320711100998848,
    ...                17.389112043240686, 15.202969177309964, 14.85529769183508]]

    >>> means = [5.011267842911003, 10.011267842911003, 15.011267842911002]
    >>> variance = 0.9618530973487494
    >>> probabilities = [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]
    >>> predict_y_values(x_items, means, variance,
    ...                  probabilities)  # doctest: +NORMALIZE_WHITESPACE
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2]

    """"""
    # An empty list to store generated discriminant values of all items in dataset for
    # each class
    results = []
    # for loop iterates over number of elements in list
    for i in range(len(x_items)):
        # for loop iterates over number of inner items of each element
        for j in range(len(x_items[i])):
            temp = []  # to store all discriminant values of each item as a list
            # for loop iterates over number of classes we have in our dataset
            for k in range(len(x_items)):
                # appending values of discriminants for each class to 'temp' list
                temp.append(
                    x_items[i][j] * (means[k] / variance)
                    - (means[k] ** 2 / (2 * variance))
                    + log(probabilities[k])
                )
            # appending discriminant values of each item to 'results' list
            results.append(temp)

    return [result.index(max(result)) for result in results]",data\repos\Python\machine_learning\linear_discriminant_analysis.py,predict_y_values,1218
1248,linear_discriminant_analysis.py::accuracy::221,"def accuracy(actual_y: list, predicted_y: list) -> float:
    """"""
    Calculate the value of accuracy based-on predictions
    :param actual_y:a list containing initial Y values generated by 'y_generator'
        function
    :param predicted_y: a list containing predicted Y values generated by
        'predict_y_values' function
    :return: percentage of accuracy

    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
    ... 1, 1 ,1 ,1 ,1 ,1 ,1]
    >>> predicted_y = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,
    ... 0, 0, 1, 1, 1, 0, 1, 1, 1]
    >>> accuracy(actual_y, predicted_y)
    50.0

    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
    ... 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    >>> predicted_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    ... 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    >>> accuracy(actual_y, predicted_y)
    100.0
    """"""
    # iterate over one element of each list at a time (zip mode)
    # prediction is correct if actual Y value equals to predicted Y value
    correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)
    # percentage of accuracy equals to number of correct predictions divided by number
    # of all data and multiplied by 100
    return (correct / len(actual_y)) * 100",data\repos\Python\machine_learning\linear_discriminant_analysis.py,accuracy,546
1249,linear_discriminant_analysis.py::valid_input::255,"def valid_input(
    input_type: Callable[[object], num],  # Usually float or int
    input_msg: str,
    err_msg: str,
    condition: Callable[[num], bool] = lambda _: True,
    default: str | None = None,
) -> num:
    """"""
    Ask for user value and validate that it fulfill a condition.

    :input_type: user input expected type of value
    :input_msg: message to show user in the screen
    :err_msg: message to show in the screen in case of error
    :condition: function that represents the condition that user input is valid.
    :default: Default value in case the user does not type anything
    :return: user's input
    """"""
    while True:
        try:
            user_input = input_type(input(input_msg).strip() or default)
            if condition(user_input):
                return user_input
            else:
                print(f""{user_input}: {err_msg}"")
                continue
        except ValueError:
            print(
                f""{user_input}: Incorrect input type, expected {input_type.__name__!r}""
            )",data\repos\Python\machine_learning\linear_discriminant_analysis.py,valid_input,235
1250,linear_discriminant_analysis.py::main::287,"def main():
    """"""This function starts execution phase""""""
    while True:
        print("" Linear Discriminant Analysis "".center(50, ""*""))
        print(""*"" * 50, ""\n"")
        print(""First of all we should specify the number of classes that"")
        print(""we want to generate as training dataset"")
        # Trying to get number of classes
        n_classes = valid_input(
            input_type=int,
            condition=lambda x: x > 0,
            input_msg=""Enter the number of classes (Data Groupings): "",
            err_msg=""Number of classes should be positive!"",
        )

        print(""-"" * 100)

        # Trying to get the value of standard deviation
        std_dev = valid_input(
            input_type=float,
            condition=lambda x: x >= 0,
            input_msg=(
                ""Enter the value of standard deviation""
                ""(Default value is 1.0 for all classes): ""
            ),
            err_msg=""Standard deviation should not be negative!"",
            default=""1.0"",
        )

        print(""-"" * 100)

        # Trying to get number of instances in classes and theirs means to generate
        # dataset
        counts = []  # An empty list to store instance counts of classes in dataset
        for i in range(n_classes):
            user_count = valid_input(
                input_type=int,
                condition=lambda x: x > 0,
                input_msg=(f""Enter The number of instances for class_{i + 1}: ""),
                err_msg=""Number of instances should be positive!"",
            )
            counts.append(user_count)
        print(""-"" * 100)

        # An empty list to store values of user-entered means of classes
        user_means = []
        for a in range(n_classes):
            user_mean = valid_input(
                input_type=float,
                input_msg=(f""Enter the value of mean for class_{a + 1}: ""),
                err_msg=""This is an invalid value."",
            )
            user_means.append(user_mean)
        print(""-"" * 100)

        print(""Standard deviation: "", std_dev)
        # print out the number of instances in classes in separated line
        for i, count in enumerate(counts, 1):
            print(f""Number of instances in class_{i} is: {count}"")
        print(""-"" * 100)

        # print out mean values of classes separated line
        for i, user_mean in enumerate(user_means, 1):
            print(f""Mean of class_{i} is: {user_mean}"")
        print(""-"" * 100)

        # Generating training dataset drawn from gaussian distribution
        x = [
            gaussian_distribution(user_means[j], std_dev, counts[j])
            for j in range(n_classes)
        ]
        print(""Generated Normal Distribution: \n"", x)
        print(""-"" * 100)

        # Generating Ys to detecting corresponding classes
        y = y_generator(n_classes, counts)
        print(""Generated Corresponding Ys: \n"", y)
        print(""-"" * 100)

        # Calculating the value of actual mean for each class
        actual_means = [calculate_mean(counts[k], x[k]) for k in range(n_classes)]
        # for loop iterates over number of elements in 'actual_means' list and print
        # out them in separated line
        for i, actual_mean in enumerate(actual_means, 1):
            print(f""Actual(Real) mean of class_{i} is: {actual_mean}"")
        print(""-"" * 100)

        # Calculating the value of probabilities for each class
        probabilities = [
            calculate_probabilities(counts[i], sum(counts)) for i in range(n_classes)
        ]

        # for loop iterates over number of elements in 'probabilities' list and print
        # out them in separated line
        for i, probability in enumerate(probabilities, 1):
            print(f""Probability of class_{i} is: {probability}"")
        print(""-"" * 100)

        # Calculating the values of variance for each class
        variance = calculate_variance(x, actual_means, sum(counts))
        print(""Variance: "", variance)
        print(""-"" * 100)

        # Predicting Y values
        # storing predicted Y values in 'pre_indexes' variable
        pre_indexes = predict_y_values(x, actual_means, variance, probabilities)
        print(""-"" * 100)

        # Calculating Accuracy of the model
        print(f""Accuracy: {accuracy(y, pre_indexes)}"")
        print(""-"" * 100)
        print("" DONE "".center(100, ""+""))

        if input(""Press any key to restart or 'q' for quit: "").strip().lower() == ""q"":
            print(""\n"" + ""GoodBye!"".center(100, ""-"") + ""\n"")
            break
        system(""cls"" if name == ""nt"" else ""clear"")  # noqa: S605",data\repos\Python\machine_learning\linear_discriminant_analysis.py,main,1038
1251,linear_regression.py::collect_dataset::23,"def collect_dataset():
    """"""Collect dataset of CSGO
    The dataset contains ADR vs Rating of a Player
    :return : dataset obtained from the link, as matrix
    """"""
    response = httpx.get(
        ""https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/""
        ""master/Week1/ADRvsRating.csv"",
        timeout=10,
    )
    lines = response.text.splitlines()
    data = []
    for item in lines:
        item = item.split("","")
        data.append(item)
    data.pop(0)  # This is for removing the labels from the list
    dataset = np.matrix(data)
    return dataset",data\repos\Python\machine_learning\linear_regression.py,collect_dataset,142
1252,linear_regression.py::run_steep_gradient_descent::43,"def run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):
    """"""Run steep gradient descent and updates the Feature vector accordingly_
    :param data_x   : contains the dataset
    :param data_y   : contains the output associated with each data-entry
    :param len_data : length of the data_
    :param alpha    : Learning rate of the model
    :param theta    : Feature vector (weight's for our model)
    ;param return    : Updated Feature's, using
                       curr_features - alpha_ * gradient(w.r.t. feature)
    >>> import numpy as np
    >>> data_x = np.array([[1, 2], [3, 4]])
    >>> data_y = np.array([5, 6])
    >>> len_data = len(data_x)
    >>> alpha = 0.01
    >>> theta = np.array([0.1, 0.2])
    >>> run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)
    array([0.196, 0.343])
    """"""
    n = len_data

    prod = np.dot(theta, data_x.transpose())
    prod -= data_y.transpose()
    sum_grad = np.dot(prod, data_x)
    theta = theta - (alpha / n) * sum_grad
    return theta",data\repos\Python\machine_learning\linear_regression.py,run_steep_gradient_descent,284
1253,linear_regression.py::sum_of_square_error::70,"def sum_of_square_error(data_x, data_y, len_data, theta):
    """"""Return sum of square error for error calculation
    :param data_x    : contains our dataset
    :param data_y    : contains the output (result vector)
    :param len_data  : len of the dataset
    :param theta     : contains the feature vector
    :return          : sum of square error computed from given feature's

    Example:
    >>> vc_x = np.array([[1.1], [2.1], [3.1]])
    >>> vc_y = np.array([1.2, 2.2, 3.2])
    >>> round(sum_of_square_error(vc_x, vc_y, 3, np.array([1])),3)
    np.float64(0.005)
    """"""
    prod = np.dot(theta, data_x.transpose())
    prod -= data_y.transpose()
    sum_elem = np.sum(np.square(prod))
    error = sum_elem / (2 * len_data)
    return error",data\repos\Python\machine_learning\linear_regression.py,sum_of_square_error,214
1254,linear_regression.py::run_linear_regression::91,"def run_linear_regression(data_x, data_y):
    """"""Implement Linear regression over the dataset
    :param data_x  : contains our dataset
    :param data_y  : contains the output (result vector)
    :return        : feature for line of best fit (Feature vector)
    """"""
    iterations = 100000
    alpha = 0.0001550

    no_features = data_x.shape[1]
    len_data = data_x.shape[0] - 1

    theta = np.zeros((1, no_features))

    for i in range(iterations):
        theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)
        error = sum_of_square_error(data_x, data_y, len_data, theta)
        print(f""At Iteration {i + 1} - Error is {error:.5f}"")

    return theta",data\repos\Python\machine_learning\linear_regression.py,run_linear_regression,185
1255,linear_regression.py::mean_absolute_error::113,"def mean_absolute_error(predicted_y, original_y):
    """"""Return sum of square error for error calculation
    :param predicted_y   : contains the output of prediction (result vector)
    :param original_y    : contains values of expected outcome
    :return          : mean absolute error computed from given feature's

    >>> predicted_y = [3, -0.5, 2, 7]
    >>> original_y = [2.5, 0.0, 2, 8]
    >>> mean_absolute_error(predicted_y, original_y)
    0.5
    """"""
    total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))
    return total / len(original_y)",data\repos\Python\machine_learning\linear_regression.py,mean_absolute_error,153
1256,linear_regression.py::main::128,"def main():
    """"""Driver function""""""
    data = collect_dataset()

    len_data = data.shape[0]
    data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float)
    data_y = data[:, -1].astype(float)

    theta = run_linear_regression(data_x, data_y)
    len_result = theta.shape[1]
    print(""Resultant Feature vector : "")
    for i in range(len_result):
        print(f""{theta[0, i]:.5f}"")",data\repos\Python\machine_learning\linear_regression.py,main,107
1257,logistic_regression.py::sigmoid_function::31,"def sigmoid_function(z: float | np.ndarray) -> float | np.ndarray:
    """"""
    Also known as Logistic Function.

                1
    f(x) =   -------
              1 + e

    The sigmoid function approaches a value of 1 as its input 'x' becomes
    increasing positive. Opposite for negative values.

    Reference: https://en.wikipedia.org/wiki/Sigmoid_function

    @param z:  input to the function
    @returns: returns value in the range 0 to 1

    Examples:
    >>> float(sigmoid_function(4))
    0.9820137900379085
    >>> sigmoid_function(np.array([-3, 3]))
    array([0.04742587, 0.95257413])
    >>> sigmoid_function(np.array([-3, 3, 1]))
    array([0.04742587, 0.95257413, 0.73105858])
    >>> sigmoid_function(np.array([-0.01, -2, -1.9]))
    array([0.49750002, 0.11920292, 0.13010847])
    >>> sigmoid_function(np.array([-1.3, 5.3, 12]))
    array([0.21416502, 0.9950332 , 0.99999386])
    >>> sigmoid_function(np.array([0.01, 0.02, 4.1]))
    array([0.50249998, 0.50499983, 0.9836975 ])
    >>> sigmoid_function(np.array([0.8]))
    array([0.68997448])
    """"""
    return 1 / (1 + np.exp(-z))",data\repos\Python\machine_learning\logistic_regression.py,sigmoid_function,365
1258,logistic_regression.py::cost_function::66,"def cost_function(h: np.ndarray, y: np.ndarray) -> float:
    """"""
    Cost function quantifies the error between predicted and expected values.
    The cost function used in Logistic Regression is called Log Loss
    or Cross Entropy Function.

    J() = (1/m) *  [ -y * log(h(x)) - (1 - y) * log(1 - h(x)) ]

    Where:
       - J() is the cost that we want to minimize during training
       - m is the number of training examples
       -  represents the summation over all training examples
       - y is the actual binary label (0 or 1) for a given example
       - h(x) is the predicted probability that x belongs to the positive class

    @param h: the output of sigmoid function. It is the estimated probability
    that the input example 'x' belongs to the positive class

    @param y: the actual binary label associated with input example 'x'

    Examples:
    >>> estimations = sigmoid_function(np.array([0.3, -4.3, 8.1]))
    >>> cost_function(h=estimations,y=np.array([1, 0, 1]))
    0.18937868932131605
    >>> estimations = sigmoid_function(np.array([4, 3, 1]))
    >>> cost_function(h=estimations,y=np.array([1, 0, 0]))
    1.459999655669926
    >>> estimations = sigmoid_function(np.array([4, -3, -1]))
    >>> cost_function(h=estimations,y=np.array([1,0,0]))
    0.1266663223365915
    >>> estimations = sigmoid_function(0)
    >>> cost_function(h=estimations,y=np.array([1]))
    0.6931471805599453

    References:
       - https://en.wikipedia.org/wiki/Logistic_regression
    """"""
    return float((-y * np.log(h) - (1 - y) * np.log(1 - h)).mean())",data\repos\Python\machine_learning\logistic_regression.py,cost_function,448
1259,logistic_regression.py::log_likelihood::106,"def log_likelihood(x, y, weights):
    scores = np.dot(x, weights)
    return np.sum(y * scores - np.log(1 + np.exp(scores)))",data\repos\Python\machine_learning\logistic_regression.py,log_likelihood,35
1260,logistic_regression.py::logistic_reg::112,"def logistic_reg(alpha, x, y, max_iterations=70000):
    theta = np.zeros(x.shape[1])

    for iterations in range(max_iterations):
        z = np.dot(x, theta)
        h = sigmoid_function(z)
        gradient = np.dot(x.T, h - y) / y.size
        theta = theta - alpha * gradient  # updating the weights
        z = np.dot(x, theta)
        h = sigmoid_function(z)
        j = cost_function(h, y)
        if iterations % 100 == 0:
            print(f""loss: {j} \t"")  # printing the loss after every 100 iterations
    return theta",data\repos\Python\machine_learning\logistic_regression.py,logistic_reg,140
1261,logistic_regression.py::predict_prob::143,"    def predict_prob(x):
        return sigmoid_function(
            np.dot(x, theta)
        )  # predicting the value of probability from the logistic regression algorithm",data\repos\Python\machine_learning\logistic_regression.py,predict_prob,32
1262,loss_functions.py::binary_cross_entropy::4,"def binary_cross_entropy(
    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15
) -> float:
    """"""
    Calculate the mean binary cross-entropy (BCE) loss between true labels and predicted
    probabilities.

    BCE loss quantifies dissimilarity between true labels (0 or 1) and predicted
    probabilities. It's widely used in binary classification tasks.

    BCE = -(y_true * ln(y_pred) + (1 - y_true) * ln(1 - y_pred))

    Reference: https://en.wikipedia.org/wiki/Cross_entropy

    Parameters:
    - y_true: True binary labels (0 or 1)
    - y_pred: Predicted probabilities for class 1
    - epsilon: Small constant to avoid numerical instability

    >>> true_labels = np.array([0, 1, 1, 0, 1])
    >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])
    >>> float(binary_cross_entropy(true_labels, predicted_probs))
    0.2529995012327421
    >>> true_labels = np.array([0, 1, 1, 0, 1])
    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
    >>> binary_cross_entropy(true_labels, predicted_probs)
    Traceback (most recent call last):
        ...
    ValueError: Input arrays must have the same length.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Input arrays must have the same length."")

    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)  # Clip predictions to avoid log(0)
    bce_loss = -(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))
    return np.mean(bce_loss)",data\repos\Python\machine_learning\loss_functions.py,binary_cross_entropy,418
1263,loss_functions.py::binary_focal_cross_entropy::42,"def binary_focal_cross_entropy(
    y_true: np.ndarray,
    y_pred: np.ndarray,
    gamma: float = 2.0,
    alpha: float = 0.25,
    epsilon: float = 1e-15,
) -> float:
    """"""
    Calculate the mean binary focal cross-entropy (BFCE) loss between true labels
    and predicted probabilities.

    BFCE loss quantifies dissimilarity between true labels (0 or 1) and predicted
    probabilities. It's a variation of binary cross-entropy that addresses class
    imbalance by focusing on hard examples.

    BCFE = -(alpha * (1 - y_pred)**gamma * y_true * log(y_pred)
                + (1 - alpha) * y_pred**gamma * (1 - y_true) * log(1 - y_pred))

    Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)

    Parameters:
    - y_true: True binary labels (0 or 1).
    - y_pred: Predicted probabilities for class 1.
    - gamma: Focusing parameter for modulating the loss (default: 2.0).
    - alpha: Weighting factor for class 1 (default: 0.25).
    - epsilon: Small constant to avoid numerical instability.

    >>> true_labels = np.array([0, 1, 1, 0, 1])
    >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])
    >>> float(binary_focal_cross_entropy(true_labels, predicted_probs))
    0.008257977659239775
    >>> true_labels = np.array([0, 1, 1, 0, 1])
    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
    >>> binary_focal_cross_entropy(true_labels, predicted_probs)
    Traceback (most recent call last):
        ...
    ValueError: Input arrays must have the same length.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Input arrays must have the same length."")
    # Clip predicted probabilities to avoid log(0)
    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)

    bcfe_loss = -(
        alpha * (1 - y_pred) ** gamma * y_true * np.log(y_pred)
        + (1 - alpha) * y_pred**gamma * (1 - y_true) * np.log(1 - y_pred)
    )

    return np.mean(bcfe_loss)",data\repos\Python\machine_learning\loss_functions.py,binary_focal_cross_entropy,564
1264,loss_functions.py::categorical_cross_entropy::93,"def categorical_cross_entropy(
    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15
) -> float:
    """"""
    Calculate categorical cross-entropy (CCE) loss between true class labels and
    predicted class probabilities.

    CCE = -(y_true * ln(y_pred))

    Reference: https://en.wikipedia.org/wiki/Cross_entropy

    Parameters:
    - y_true: True class labels (one-hot encoded)
    - y_pred: Predicted class probabilities
    - epsilon: Small constant to avoid numerical instability

    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])
    >>> float(categorical_cross_entropy(true_labels, pred_probs))
    0.567395975254385
    >>> true_labels = np.array([[1, 0], [0, 1]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
    >>> categorical_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: Input arrays must have the same shape.
    >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
    >>> categorical_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: y_true must be one-hot encoded.
    >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
    >>> categorical_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: y_true must be one-hot encoded.
    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])
    >>> categorical_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: Predicted probabilities must sum to approximately 1.
    """"""
    if y_true.shape != y_pred.shape:
        raise ValueError(""Input arrays must have the same shape."")

    if np.any((y_true != 0) & (y_true != 1)) or np.any(y_true.sum(axis=1) != 1):
        raise ValueError(""y_true must be one-hot encoded."")

    if not np.all(np.isclose(np.sum(y_pred, axis=1), 1, rtol=epsilon, atol=epsilon)):
        raise ValueError(""Predicted probabilities must sum to approximately 1."")

    y_pred = np.clip(y_pred, epsilon, 1)  # Clip predictions to avoid log(0)
    return -np.sum(y_true * np.log(y_pred))",data\repos\Python\machine_learning\loss_functions.py,categorical_cross_entropy,754
1265,loss_functions.py::categorical_focal_cross_entropy::151,"def categorical_focal_cross_entropy(
    y_true: np.ndarray,
    y_pred: np.ndarray,
    alpha: np.ndarray = None,
    gamma: float = 2.0,
    epsilon: float = 1e-15,
) -> float:
    """"""
    Calculate the mean categorical focal cross-entropy (CFCE) loss between true
    labels and predicted probabilities for multi-class classification.

    CFCE loss is a generalization of binary focal cross-entropy for multi-class
    classification. It addresses class imbalance by focusing on hard examples.

    CFCE = - alpha * (1 - y_pred)**gamma * y_true * log(y_pred)

    Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)

    Parameters:
    - y_true: True labels in one-hot encoded form.
    - y_pred: Predicted probabilities for each class.
    - alpha: Array of weighting factors for each class.
    - gamma: Focusing parameter for modulating the loss (default: 2.0).
    - epsilon: Small constant to avoid numerical instability.

    Returns:
    - The mean categorical focal cross-entropy loss.

    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])
    >>> alpha = np.array([0.6, 0.2, 0.7])
    >>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha))
    0.0025966118981496423

    >>> true_labels = np.array([[0, 1, 0], [0, 0, 1]])
    >>> pred_probs = np.array([[0.05, 0.95, 0], [0.1, 0.8, 0.1]])
    >>> alpha = np.array([0.25, 0.25, 0.25])
    >>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha))
    0.23315276982014324

    >>> true_labels = np.array([[1, 0], [0, 1]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
    >>> categorical_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: Input arrays must have the same shape.

    >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
    >>> categorical_focal_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: y_true must be one-hot encoded.

    >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
    >>> categorical_focal_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: y_true must be one-hot encoded.

    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])
    >>> categorical_focal_cross_entropy(true_labels, pred_probs)
    Traceback (most recent call last):
        ...
    ValueError: Predicted probabilities must sum to approximately 1.

    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])
    >>> alpha = np.array([0.6, 0.2])
    >>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)
    Traceback (most recent call last):
        ...
    ValueError: Length of alpha must match the number of classes.
    """"""
    if y_true.shape != y_pred.shape:
        raise ValueError(""Shape of y_true and y_pred must be the same."")

    if alpha is None:
        alpha = np.ones(y_true.shape[1])

    if np.any((y_true != 0) & (y_true != 1)) or np.any(y_true.sum(axis=1) != 1):
        raise ValueError(""y_true must be one-hot encoded."")

    if len(alpha) != y_true.shape[1]:
        raise ValueError(""Length of alpha must match the number of classes."")

    if not np.all(np.isclose(np.sum(y_pred, axis=1), 1, rtol=epsilon, atol=epsilon)):
        raise ValueError(""Predicted probabilities must sum to approximately 1."")

    # Clip predicted probabilities to avoid log(0)
    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)

    # Calculate loss for each class and sum across classes
    cfce_loss = -np.sum(
        alpha * np.power(1 - y_pred, gamma) * y_true * np.log(y_pred), axis=1
    )

    return np.mean(cfce_loss)",data\repos\Python\machine_learning\loss_functions.py,categorical_focal_cross_entropy,1260
1266,loss_functions.py::hinge_loss::253,"def hinge_loss(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    """"""
    Calculate the mean hinge loss for between true labels and predicted probabilities
    for training support vector machines (SVMs).

    Hinge loss = max(0, 1 - true * pred)

    Reference: https://en.wikipedia.org/wiki/Hinge_loss

    Args:
    - y_true: actual values (ground truth) encoded as -1 or 1
    - y_pred: predicted values

    >>> true_labels = np.array([-1, 1, 1, -1, 1])
    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])
    >>> float(hinge_loss(true_labels, pred))
    1.52
    >>> true_labels = np.array([-1, 1, 1, -1, 1, 1])
    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])
    >>> hinge_loss(true_labels, pred)
    Traceback (most recent call last):
    ...
    ValueError: Length of predicted and actual array must be same.
    >>> true_labels = np.array([-1, 1, 10, -1, 1])
    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])
    >>> hinge_loss(true_labels, pred)
    Traceback (most recent call last):
    ...
    ValueError: y_true can have values -1 or 1 only.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Length of predicted and actual array must be same."")

    if np.any((y_true != -1) & (y_true != 1)):
        raise ValueError(""y_true can have values -1 or 1 only."")

    hinge_losses = np.maximum(0, 1.0 - (y_true * y_pred))
    return np.mean(hinge_losses)",data\repos\Python\machine_learning\loss_functions.py,hinge_loss,424
1267,loss_functions.py::huber_loss::293,"def huber_loss(y_true: np.ndarray, y_pred: np.ndarray, delta: float) -> float:
    """"""
    Calculate the mean Huber loss between the given ground truth and predicted values.

    The Huber loss describes the penalty incurred by an estimation procedure, and it
    serves as a measure of accuracy for regression models.

    Huber loss =
        0.5 * (y_true - y_pred)^2                   if |y_true - y_pred| <= delta
        delta * |y_true - y_pred| - 0.5 * delta^2   otherwise

    Reference: https://en.wikipedia.org/wiki/Huber_loss

    Parameters:
    - y_true: The true values (ground truth)
    - y_pred: The predicted values

    >>> true_values = np.array([0.9, 10.0, 2.0, 1.0, 5.2])
    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
    >>> bool(np.isclose(huber_loss(true_values, predicted_values, 1.0), 2.102))
    True
    >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0, 5.0])
    >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])
    >>> bool(np.isclose(huber_loss(true_labels, predicted_probs, 1.0), 1.80164))
    True
    >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0])
    >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])
    >>> huber_loss(true_labels, predicted_probs, 1.0)
    Traceback (most recent call last):
    ...
    ValueError: Input arrays must have the same length.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Input arrays must have the same length."")

    huber_mse = 0.5 * (y_true - y_pred) ** 2
    huber_mae = delta * (np.abs(y_true - y_pred) - 0.5 * delta)
    return np.where(np.abs(y_true - y_pred) <= delta, huber_mse, huber_mae).mean()",data\repos\Python\machine_learning\loss_functions.py,huber_loss,541
1268,loss_functions.py::mean_squared_error::333,"def mean_squared_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    """"""
    Calculate the mean squared error (MSE) between ground truth and predicted values.

    MSE measures the squared difference between true values and predicted values, and it
    serves as a measure of accuracy for regression models.

    MSE = (1/n) * (y_true - y_pred)^2

    Reference: https://en.wikipedia.org/wiki/Mean_squared_error

    Parameters:
    - y_true: The true values (ground truth)
    - y_pred: The predicted values

    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
    >>> bool(np.isclose(mean_squared_error(true_values, predicted_values), 0.028))
    True
    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
    >>> mean_squared_error(true_labels, predicted_probs)
    Traceback (most recent call last):
    ...
    ValueError: Input arrays must have the same length.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Input arrays must have the same length."")

    squared_errors = (y_true - y_pred) ** 2
    return np.mean(squared_errors)",data\repos\Python\machine_learning\loss_functions.py,mean_squared_error,348
1269,loss_functions.py::mean_absolute_error::366,"def mean_absolute_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    """"""
    Calculates the Mean Absolute Error (MAE) between ground truth (observed)
        and predicted values.

    MAE measures the absolute difference between true values and predicted values.

    Equation:
    MAE = (1/n) * (abs(y_true - y_pred))

    Reference: https://en.wikipedia.org/wiki/Mean_absolute_error

    Parameters:
    - y_true: The true values (ground truth)
    - y_pred: The predicted values

    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
    >>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 0.16))
    True
    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
    >>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 2.16))
    False
    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 5.2])
    >>> mean_absolute_error(true_labels, predicted_probs)
    Traceback (most recent call last):
    ...
    ValueError: Input arrays must have the same length.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Input arrays must have the same length."")

    return np.mean(abs(y_true - y_pred))",data\repos\Python\machine_learning\loss_functions.py,mean_absolute_error,418
1270,loss_functions.py::mean_squared_logarithmic_error::403,"def mean_squared_logarithmic_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    """"""
    Calculate the mean squared logarithmic error (MSLE) between ground truth and
    predicted values.

    MSLE measures the squared logarithmic difference between true values and predicted
    values for regression models. It's particularly useful for dealing with skewed or
    large-value data, and it's often used when the relative differences between
    predicted and true values are more important than absolute differences.

    MSLE = (1/n) * (log(1 + y_true) - log(1 + y_pred))^2

    Reference: https://insideaiml.com/blog/MeanSquared-Logarithmic-Error-Loss-1035

    Parameters:
    - y_true: The true values (ground truth)
    - y_pred: The predicted values

    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
    >>> float(mean_squared_logarithmic_error(true_values, predicted_values))
    0.0030860877925181344
    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
    >>> mean_squared_logarithmic_error(true_labels, predicted_probs)
    Traceback (most recent call last):
    ...
    ValueError: Input arrays must have the same length.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Input arrays must have the same length."")

    squared_logarithmic_errors = (np.log1p(y_true) - np.log1p(y_pred)) ** 2
    return np.mean(squared_logarithmic_errors)",data\repos\Python\machine_learning\loss_functions.py,mean_squared_logarithmic_error,430
1271,loss_functions.py::mean_absolute_percentage_error::439,"def mean_absolute_percentage_error(
    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15
) -> float:
    """"""
    Calculate the Mean Absolute Percentage Error between y_true and y_pred.

    Mean Absolute Percentage Error calculates the average of the absolute
    percentage differences between the predicted and true values.

    Formula = (|y_true[i]-Y_pred[i]/y_true[i]|)/n

    Source: https://stephenallwright.com/good-mape-score/

    Parameters:
    y_true (np.ndarray): Numpy array containing true/target values.
    y_pred (np.ndarray): Numpy array containing predicted values.

    Returns:
    float: The Mean Absolute Percentage error between y_true and y_pred.

    Examples:
    >>> y_true = np.array([10, 20, 30, 40])
    >>> y_pred = np.array([12, 18, 33, 45])
    >>> float(mean_absolute_percentage_error(y_true, y_pred))
    0.13125

    >>> y_true = np.array([1, 2, 3, 4])
    >>> y_pred = np.array([2, 3, 4, 5])
    >>> float(mean_absolute_percentage_error(y_true, y_pred))
    0.5208333333333333

    >>> y_true = np.array([34, 37, 44, 47, 48, 48, 46, 43, 32, 27, 26, 24])
    >>> y_pred = np.array([37, 40, 46, 44, 46, 50, 45, 44, 34, 30, 22, 23])
    >>> float(mean_absolute_percentage_error(y_true, y_pred))
    0.064671076436071
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""The length of the two arrays should be the same."")

    y_true = np.where(y_true == 0, epsilon, y_true)
    absolute_percentage_diff = np.abs((y_true - y_pred) / y_true)

    return np.mean(absolute_percentage_diff)",data\repos\Python\machine_learning\loss_functions.py,mean_absolute_percentage_error,463
1272,loss_functions.py::perplexity_loss::484,"def perplexity_loss(
    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-7
) -> float:
    """"""
    Calculate the perplexity for the y_true and y_pred.

    Compute the Perplexity which useful in predicting language model
    accuracy in Natural Language Processing (NLP.)
    Perplexity is measure of how certain the model in its predictions.

    Perplexity Loss = exp(-1/N ( ln(p(x)))

    Reference:
    https://en.wikipedia.org/wiki/Perplexity

    Args:
        y_true: Actual label encoded sentences of shape (batch_size, sentence_length)
        y_pred: Predicted sentences of shape (batch_size, sentence_length, vocab_size)
        epsilon: Small floating point number to avoid getting inf for log(0)

    Returns:
        Perplexity loss between y_true and y_pred.

    >>> y_true = np.array([[1, 4], [2, 3]])
    >>> y_pred = np.array(
    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],
    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],
    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]
    ... )
    >>> float(perplexity_loss(y_true, y_pred))
    5.0247347775367945
    >>> y_true = np.array([[1, 4], [2, 3]])
    >>> y_pred = np.array(
    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
    ...      [0.24, 0.19, 0.09, 0.18, 0.27],
    ...      [0.30, 0.10, 0.20, 0.15, 0.25]],
    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],
    ...       [0.28, 0.10, 0.33, 0.15, 0.12],
    ...       [0.30, 0.10, 0.20, 0.15, 0.25]],]
    ... )
    >>> perplexity_loss(y_true, y_pred)
    Traceback (most recent call last):
    ...
    ValueError: Sentence length of y_true and y_pred must be equal.
    >>> y_true = np.array([[1, 4], [2, 11]])
    >>> y_pred = np.array(
    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],
    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],
    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]
    ... )
    >>> perplexity_loss(y_true, y_pred)
    Traceback (most recent call last):
    ...
    ValueError: Label value must not be greater than vocabulary size.
    >>> y_true = np.array([[1, 4]])
    >>> y_pred = np.array(
    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],
    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],
    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]
    ... )
    >>> perplexity_loss(y_true, y_pred)
    Traceback (most recent call last):
    ...
    ValueError: Batch size of y_true and y_pred must be equal.
    """"""

    vocab_size = y_pred.shape[2]

    if y_true.shape[0] != y_pred.shape[0]:
        raise ValueError(""Batch size of y_true and y_pred must be equal."")
    if y_true.shape[1] != y_pred.shape[1]:
        raise ValueError(""Sentence length of y_true and y_pred must be equal."")
    if np.max(y_true) > vocab_size:
        raise ValueError(""Label value must not be greater than vocabulary size."")

    # Matrix to select prediction value only for true class
    filter_matrix = np.array(
        [[list(np.eye(vocab_size)[word]) for word in sentence] for sentence in y_true]
    )

    # Getting the matrix containing prediction for only true class
    true_class_pred = np.sum(y_pred * filter_matrix, axis=2).clip(epsilon, 1)

    # Calculating perplexity for each sentence
    perp_losses = np.exp(np.negative(np.mean(np.log(true_class_pred), axis=1)))

    return np.mean(perp_losses)",data\repos\Python\machine_learning\loss_functions.py,perplexity_loss,1160
1273,loss_functions.py::smooth_l1_loss::576,"def smooth_l1_loss(y_true: np.ndarray, y_pred: np.ndarray, beta: float = 1.0) -> float:
    """"""
    Calculate the Smooth L1 Loss between y_true and y_pred.

    The Smooth L1 Loss is less sensitive to outliers than the L2 Loss and is often used
    in regression problems, such as object detection.

    Smooth L1 Loss =
        0.5 * (x - y)^2 / beta, if |x - y| < beta
        |x - y| - 0.5 * beta, otherwise

    Reference:
    https://pytorch.org/docs/stable/generated/torch.nn.SmoothL1Loss.html

    Args:
        y_true: Array of true values.
        y_pred: Array of predicted values.
        beta: Specifies the threshold at which to change between L1 and L2 loss.

    Returns:
        The calculated Smooth L1 Loss between y_true and y_pred.

    Raises:
        ValueError: If the length of the two arrays is not the same.

    >>> y_true = np.array([3, 5, 2, 7])
    >>> y_pred = np.array([2.9, 4.8, 2.1, 7.2])
    >>> float(smooth_l1_loss(y_true, y_pred, 1.0))
    0.012500000000000022

    >>> y_true = np.array([2, 4, 6])
    >>> y_pred = np.array([1, 5, 7])
    >>> float(smooth_l1_loss(y_true, y_pred, 1.0))
    0.5

    >>> y_true = np.array([1, 3, 5, 7])
    >>> y_pred = np.array([1, 3, 5, 7])
    >>> float(smooth_l1_loss(y_true, y_pred, 1.0))
    0.0

    >>> y_true = np.array([1, 3, 5])
    >>> y_pred = np.array([1, 3, 5, 7])
    >>> smooth_l1_loss(y_true, y_pred, 1.0)
    Traceback (most recent call last):
    ...
    ValueError: The length of the two arrays should be the same.
    """"""

    if len(y_true) != len(y_pred):
        raise ValueError(""The length of the two arrays should be the same."")

    diff = np.abs(y_true - y_pred)
    loss = np.where(diff < beta, 0.5 * diff**2 / beta, diff - 0.5 * beta)
    return np.mean(loss)",data\repos\Python\machine_learning\loss_functions.py,smooth_l1_loss,566
1274,loss_functions.py::kullback_leibler_divergence::632,"def kullback_leibler_divergence(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    """"""
    Calculate the Kullback-Leibler divergence (KL divergence) loss between true labels
    and predicted probabilities.

    KL divergence loss quantifies dissimilarity between true labels and predicted
    probabilities. It's often used in training generative models.

    KL = (y_true * ln(y_true / y_pred))

    Reference: https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence

    Parameters:
    - y_true: True class probabilities
    - y_pred: Predicted class probabilities

    >>> true_labels = np.array([0.2, 0.3, 0.5])
    >>> predicted_probs = np.array([0.3, 0.3, 0.4])
    >>> float(kullback_leibler_divergence(true_labels, predicted_probs))
    0.030478754035472025
    >>> true_labels = np.array([0.2, 0.3, 0.5])
    >>> predicted_probs = np.array([0.3, 0.3, 0.4, 0.5])
    >>> kullback_leibler_divergence(true_labels, predicted_probs)
    Traceback (most recent call last):
        ...
    ValueError: Input arrays must have the same length.
    """"""
    if len(y_true) != len(y_pred):
        raise ValueError(""Input arrays must have the same length."")

    kl_loss = y_true * np.log(y_true / y_pred)
    return np.sum(kl_loss)",data\repos\Python\machine_learning\loss_functions.py,kullback_leibler_divergence,350
1275,mfcc.py::mfcc::69,"def mfcc(
    audio: np.ndarray,
    sample_rate: int,
    ftt_size: int = 1024,
    hop_length: int = 20,
    mel_filter_num: int = 10,
    dct_filter_num: int = 40,
) -> np.ndarray:
    """"""
    Calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio signal.

    Args:
        audio: The input audio signal.
        sample_rate: The sample rate of the audio signal (in Hz).
        ftt_size: The size of the FFT window (default is 1024).
        hop_length: The hop length for frame creation (default is 20ms).
        mel_filter_num: The number of Mel filters (default is 10).
        dct_filter_num: The number of DCT filters (default is 40).

    Returns:
        A matrix of MFCCs for the input audio.

    Raises:
        ValueError: If the input audio is empty.

    Example:
    >>> sample_rate = 44100  # Sample rate of 44.1 kHz
    >>> duration = 2.0  # Duration of 1 second
    >>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False)
    >>> audio = 0.5 * np.sin(2 * np.pi * 440.0 * t)  # Generate a 440 Hz sine wave
    >>> mfccs = mfcc(audio, sample_rate)
    >>> mfccs.shape
    (40, 101)
    """"""
    logging.info(f""Sample rate: {sample_rate}Hz"")
    logging.info(f""Audio duration: {len(audio) / sample_rate}s"")
    logging.info(f""Audio min: {np.min(audio)}"")
    logging.info(f""Audio max: {np.max(audio)}"")

    # normalize audio
    audio_normalized = normalize(audio)

    logging.info(f""Normalized audio min: {np.min(audio_normalized)}"")
    logging.info(f""Normalized audio max: {np.max(audio_normalized)}"")

    # frame audio into
    audio_framed = audio_frames(
        audio_normalized, sample_rate, ftt_size=ftt_size, hop_length=hop_length
    )

    logging.info(f""Framed audio shape: {audio_framed.shape}"")
    logging.info(f""First frame: {audio_framed[0]}"")

    # convert to frequency domain
    # For simplicity we will choose the Hanning window.
    window = get_window(""hann"", ftt_size, fftbins=True)
    audio_windowed = audio_framed * window

    logging.info(f""Windowed audio shape: {audio_windowed.shape}"")
    logging.info(f""First frame: {audio_windowed[0]}"")

    audio_fft = calculate_fft(audio_windowed, ftt_size)
    logging.info(f""fft audio shape: {audio_fft.shape}"")
    logging.info(f""First frame: {audio_fft[0]}"")

    audio_power = calculate_signal_power(audio_fft)
    logging.info(f""power audio shape: {audio_power.shape}"")
    logging.info(f""First frame: {audio_power[0]}"")

    filters = mel_spaced_filterbank(sample_rate, mel_filter_num, ftt_size)
    logging.info(f""filters shape: {filters.shape}"")

    audio_filtered = np.dot(filters, np.transpose(audio_power))
    audio_log = 10.0 * np.log10(audio_filtered)
    logging.info(f""audio_log shape: {audio_log.shape}"")

    dct_filters = discrete_cosine_transform(dct_filter_num, mel_filter_num)
    cepstral_coefficents = np.dot(dct_filters, audio_log)

    logging.info(f""cepstral_coefficents shape: {cepstral_coefficents.shape}"")
    return cepstral_coefficents",data\repos\Python\machine_learning\mfcc.py,mfcc,800
1276,mfcc.py::normalize::152,"def normalize(audio: np.ndarray) -> np.ndarray:
    """"""
    Normalize an audio signal by scaling it to have values between -1 and 1.

    Args:
        audio: The input audio signal.

    Returns:
        The normalized audio signal.

    Examples:
    >>> audio = np.array([1, 2, 3, 4, 5])
    >>> normalized_audio = normalize(audio)
    >>> float(np.max(normalized_audio))
    1.0
    >>> float(np.min(normalized_audio))
    0.2
    """"""
    # Divide the entire audio signal by the maximum absolute value
    return audio / np.max(np.abs(audio))",data\repos\Python\machine_learning\mfcc.py,normalize,138
1277,mfcc.py::audio_frames::174,"def audio_frames(
    audio: np.ndarray,
    sample_rate: int,
    hop_length: int = 20,
    ftt_size: int = 1024,
) -> np.ndarray:
    """"""
    Split an audio signal into overlapping frames.

    Args:
        audio: The input audio signal.
        sample_rate: The sample rate of the audio signal.
        hop_length: The length of the hopping (default is 20ms).
        ftt_size: The size of the FFT window (default is 1024).

    Returns:
        An array of overlapping frames.

    Examples:
    >>> audio = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000)
    >>> sample_rate = 8000
    >>> frames = audio_frames(audio, sample_rate, hop_length=10, ftt_size=512)
    >>> frames.shape
    (126, 512)
    """"""

    hop_size = np.round(sample_rate * hop_length / 1000).astype(int)

    # Pad the audio signal to handle edge cases
    audio = np.pad(audio, int(ftt_size / 2), mode=""reflect"")

    # Calculate the number of frames
    frame_count = int((len(audio) - ftt_size) / hop_size) + 1

    # Initialize an array to store the frames
    frames = np.zeros((frame_count, ftt_size))

    # Split the audio signal into frames
    for n in range(frame_count):
        frames[n] = audio[n * hop_size : n * hop_size + ftt_size]

    return frames",data\repos\Python\machine_learning\mfcc.py,audio_frames,348
1278,mfcc.py::calculate_fft::218,"def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:
    """"""
    Calculate the Fast Fourier Transform (FFT) of windowed audio data.

    Args:
        audio_windowed: The windowed audio signal.
        ftt_size: The size of the FFT (default is 1024).

    Returns:
        The FFT of the audio data.

    Examples:
    >>> audio_windowed = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> audio_fft = calculate_fft(audio_windowed, ftt_size=4)
    >>> bool(np.allclose(audio_fft[0], np.array([6.0+0.j, -1.5+0.8660254j,
    ...     -1.5-0.8660254j])))
    True
    """"""
    # Transpose the audio data to have time in rows and channels in columns
    audio_transposed = np.transpose(audio_windowed)

    # Initialize an array to store the FFT results
    audio_fft = np.empty(
        (int(1 + ftt_size // 2), audio_transposed.shape[1]),
        dtype=np.complex64,
        order=""F"",
    )

    # Compute FFT for each channel
    for n in range(audio_fft.shape[1]):
        audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]

    # Transpose the FFT results back to the original shape
    return np.transpose(audio_fft)",data\repos\Python\machine_learning\mfcc.py,calculate_fft,338
1279,mfcc.py::calculate_signal_power::254,"def calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:
    """"""
    Calculate the power of the audio signal from its FFT.

    Args:
        audio_fft: The FFT of the audio signal.

    Returns:
        The power of the audio signal.

    Examples:
    >>> audio_fft = np.array([1+2j, 2+3j, 3+4j, 4+5j])
    >>> power = calculate_signal_power(audio_fft)
    >>> np.allclose(power, np.array([5, 13, 25, 41]))
    True
    """"""
    # Calculate the power by squaring the absolute values of the FFT coefficients
    return np.square(np.abs(audio_fft))",data\repos\Python\machine_learning\mfcc.py,calculate_signal_power,148
1280,mfcc.py::freq_to_mel::274,"def freq_to_mel(freq: float) -> float:
    """"""
    Convert a frequency in Hertz to the mel scale.

    Args:
        freq: The frequency in Hertz.

    Returns:
        The frequency in mel scale.

    Examples:
    >>> float(round(freq_to_mel(1000), 2))
    999.99
    """"""
    # Use the formula to convert frequency to the mel scale
    return 2595.0 * np.log10(1.0 + freq / 700.0)",data\repos\Python\machine_learning\mfcc.py,freq_to_mel,110
1281,mfcc.py::mel_to_freq::292,"def mel_to_freq(mels: float) -> float:
    """"""
    Convert a frequency in the mel scale to Hertz.

    Args:
        mels: The frequency in mel scale.

    Returns:
        The frequency in Hertz.

    Examples:
    >>> round(mel_to_freq(999.99), 2)
    1000.01
    """"""
    # Use the formula to convert mel scale to frequency
    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)",data\repos\Python\machine_learning\mfcc.py,mel_to_freq,116
1282,mfcc.py::mel_spaced_filterbank::310,"def mel_spaced_filterbank(
    sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024
) -> np.ndarray:
    """"""
    Create a Mel-spaced filter bank for audio processing.

    Args:
        sample_rate: The sample rate of the audio.
        mel_filter_num: The number of mel filters (default is 10).
        ftt_size: The size of the FFT (default is 1024).

    Returns:
        Mel-spaced filter bank.

    Examples:
    >>> float(round(mel_spaced_filterbank(8000, 10, 1024)[0][1], 10))
    0.0004603981
    """"""
    freq_min = 0
    freq_high = sample_rate // 2

    logging.info(f""Minimum frequency: {freq_min}"")
    logging.info(f""Maximum frequency: {freq_high}"")

    # Calculate filter points and mel frequencies
    filter_points, mel_freqs = get_filter_points(
        sample_rate,
        freq_min,
        freq_high,
        mel_filter_num,
        ftt_size,
    )

    filters = get_filters(filter_points, ftt_size)

    # normalize filters
    # taken from the librosa library
    enorm = 2.0 / (mel_freqs[2 : mel_filter_num + 2] - mel_freqs[:mel_filter_num])
    return filters * enorm[:, np.newaxis]",data\repos\Python\machine_learning\mfcc.py,mel_spaced_filterbank,302
1283,mfcc.py::get_filters::351,"def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:
    """"""
    Generate filters for audio processing.

    Args:
        filter_points: A list of filter points.
        ftt_size: The size of the FFT.

    Returns:
        A matrix of filters.

    Examples:
    >>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape
    (4, 257)
    """"""
    num_filters = len(filter_points) - 2
    filters = np.zeros((num_filters, int(ftt_size / 2) + 1))

    for n in range(num_filters):
        start = filter_points[n]
        mid = filter_points[n + 1]
        end = filter_points[n + 2]

        # Linearly increase values from 0 to 1
        filters[n, start:mid] = np.linspace(0, 1, mid - start)

        # Linearly decrease values from 1 to 0
        filters[n, mid:end] = np.linspace(1, 0, end - mid)

    return filters",data\repos\Python\machine_learning\mfcc.py,get_filters,243
1284,mfcc.py::get_filter_points::383,"def get_filter_points(
    sample_rate: int,
    freq_min: int,
    freq_high: int,
    mel_filter_num: int = 10,
    ftt_size: int = 1024,
) -> tuple[np.ndarray, np.ndarray]:
    """"""
    Calculate the filter points and frequencies for mel frequency filters.

    Args:
        sample_rate: The sample rate of the audio.
        freq_min: The minimum frequency in Hertz.
        freq_high: The maximum frequency in Hertz.
        mel_filter_num: The number of mel filters (default is 10).
        ftt_size: The size of the FFT (default is 1024).

    Returns:
        Filter points and corresponding frequencies.

    Examples:
    >>> filter_points = get_filter_points(8000, 0, 4000, mel_filter_num=4, ftt_size=512)
    >>> filter_points[0]
    array([  0,  20,  51,  95, 161, 256])
    >>> filter_points[1]
    array([   0.        ,  324.46707094,  799.33254207, 1494.30973963,
           2511.42581671, 4000.        ])
    """"""
    # Convert minimum and maximum frequencies to mel scale
    fmin_mel = freq_to_mel(freq_min)
    fmax_mel = freq_to_mel(freq_high)

    logging.info(f""MEL min: {fmin_mel}"")
    logging.info(f""MEL max: {fmax_mel}"")

    # Generate equally spaced mel frequencies
    mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)

    # Convert mel frequencies back to Hertz
    freqs = mel_to_freq(mels)

    # Calculate filter points as integer values
    filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)

    return filter_points, freqs",data\repos\Python\machine_learning\mfcc.py,get_filter_points,427
1285,mfcc.py::discrete_cosine_transform::430,"def discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:
    """"""
    Compute the Discrete Cosine Transform (DCT) basis matrix.

    Args:
        dct_filter_num: The number of DCT filters to generate.
        filter_num: The number of the fbank filters.

    Returns:
        The DCT basis matrix.

    Examples:
    >>> float(round(discrete_cosine_transform(3, 5)[0][0], 5))
    0.44721
    """"""
    basis = np.empty((dct_filter_num, filter_num))
    basis[0, :] = 1.0 / np.sqrt(filter_num)

    samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)

    for i in range(1, dct_filter_num):
        basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)

    return basis",data\repos\Python\machine_learning\mfcc.py,discrete_cosine_transform,209
1286,mfcc.py::example::456,"def example(wav_file_path: str = ""./path-to-file/sample.wav"") -> np.ndarray:
    """"""
    Example function to calculate Mel Frequency Cepstral Coefficients
    (MFCCs) from an audio file.

    Args:
        wav_file_path: The path to the WAV audio file.

    Returns:
        np.ndarray: The computed MFCCs for the audio.
    """"""
    from scipy.io import wavfile

    # Load the audio from the WAV file
    sample_rate, audio = wavfile.read(wav_file_path)

    # Calculate MFCCs
    return mfcc(audio, sample_rate)",data\repos\Python\machine_learning\mfcc.py,example,129
1287,multilayer_perceptron_classifier.py::wrapper::18,"def wrapper(y):
    """"""
    >>> [int(x) for x in wrapper(Y)]
    [0, 0, 1]
    """"""
    return list(y)",data\repos\Python\machine_learning\multilayer_perceptron_classifier.py,wrapper,35
1288,polynomial_regression.py::main::183,"def main() -> None:
    """"""
    Fit a polynomial regression model to predict fuel efficiency using seaborn's mpg
    dataset

    >>> pass    # Placeholder, function is only for demo purposes
    """"""
    import seaborn as sns

    mpg_data = sns.load_dataset(""mpg"")

    poly_reg = PolynomialRegression(degree=2)
    poly_reg.fit(mpg_data.weight, mpg_data.mpg)

    weight_sorted = np.sort(mpg_data.weight)
    predictions = poly_reg.predict(weight_sorted)

    plt.scatter(mpg_data.weight, mpg_data.mpg, color=""gray"", alpha=0.5)
    plt.plot(weight_sorted, predictions, color=""red"", linewidth=3)
    plt.title(""Predicting Fuel Efficiency Using Polynomial Regression"")
    plt.xlabel(""Weight (lbs)"")
    plt.ylabel(""Fuel Efficiency (mpg)"")
    plt.show()",data\repos\Python\machine_learning\polynomial_regression.py,main,177
1289,polynomial_regression.py::fit::102,"    def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None:
        """"""
        Computes the polynomial regression model parameters using ordinary least squares
        (OLS) estimation:

         = (XX)Xy = Xy

        where X denotes the Moore-Penrose pseudoinverse of the design matrix X. This
        function computes X using singular value decomposition (SVD).

        References:
            - https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse
            - https://en.wikipedia.org/wiki/Singular_value_decomposition
            - https://en.wikipedia.org/wiki/Multicollinearity

        @param x_train: the predictor values x for model fitting
        @param y_train: the response values y for model fitting
        @raises ArithmeticError:    if X isn't full rank, then XX is singular and 
                                    doesn't exist

        >>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
        >>> y = x**3 - 2 * x**2 + 3 * x - 5
        >>> poly_reg = PolynomialRegression(degree=3)
        >>> poly_reg.fit(x, y)
        >>> poly_reg.params
        array([-5.,  3., -2.,  1.])
        >>> poly_reg = PolynomialRegression(degree=20)
        >>> poly_reg.fit(x, y)
        Traceback (most recent call last):
        ...
        ArithmeticError: Design matrix is not full rank, can't compute coefficients

        Make sure errors don't grow too large:
        >>> coefs = np.array([-250, 50, -2, 36, 20, -12, 10, 2, -1, -15, 1])
        >>> y = PolynomialRegression._design_matrix(x, len(coefs) - 1) @ coefs
        >>> poly_reg = PolynomialRegression(degree=len(coefs) - 1)
        >>> poly_reg.fit(x, y)
        >>> np.allclose(poly_reg.params, coefs, atol=10e-3)
        True
        """"""
        X = PolynomialRegression._design_matrix(x_train, self.degree)  # noqa: N806
        _, cols = X.shape
        if np.linalg.matrix_rank(X) < cols:
            raise ArithmeticError(
                ""Design matrix is not full rank, can't compute coefficients""
            )

        # np.linalg.pinv() computes the Moore-Penrose pseudoinverse using SVD
        self.params = np.linalg.pinv(X) @ y_train",data\repos\Python\machine_learning\polynomial_regression.py,fit,581
1290,polynomial_regression.py::predict::152,"    def predict(self, data: np.ndarray) -> np.ndarray:
        """"""
        Computes the predicted response values y for the given input data by
        constructing the design matrix X and evaluating y = X.

        @param data:    the predictor values x for prediction
        @returns:       the predicted response values y = X
        @raises ArithmeticError:    if this function is called before the model
                                    parameters are fit

        >>> x = np.array([0, 1, 2, 3, 4])
        >>> y = x**3 - 2 * x**2 + 3 * x - 5
        >>> poly_reg = PolynomialRegression(degree=3)
        >>> poly_reg.fit(x, y)
        >>> poly_reg.predict(np.array([-1]))
        array([-11.])
        >>> poly_reg.predict(np.array([-2]))
        array([-27.])
        >>> poly_reg.predict(np.array([6]))
        array([157.])
        >>> PolynomialRegression(degree=3).predict(x)
        Traceback (most recent call last):
        ...
        ArithmeticError: Predictor hasn't been fit yet
        """"""
        if self.params is None:
            raise ArithmeticError(""Predictor hasn't been fit yet"")

        return PolynomialRegression._design_matrix(data, self.degree) @ self.params",data\repos\Python\machine_learning\polynomial_regression.py,predict,275
1291,principle_component_analysis.py::collect_dataset::20,"def collect_dataset() -> tuple[np.ndarray, np.ndarray]:
    """"""
    Collects the dataset (Iris dataset) and returns feature matrix and target values.

    :return: Tuple containing feature matrix (X) and target labels (y)

    Example:
    >>> X, y = collect_dataset()
    >>> X.shape
    (150, 4)
    >>> y.shape
    (150,)
    """"""
    data = load_iris()
    return np.array(data.data), np.array(data.target)",data\repos\Python\machine_learning\principle_component_analysis.py,collect_dataset,103
1292,principle_component_analysis.py::apply_pca::37,"def apply_pca(data_x: np.ndarray, n_components: int) -> tuple[np.ndarray, np.ndarray]:
    """"""
    Applies Principal Component Analysis (PCA) to reduce dimensionality.

    :param data_x: Original dataset (features)
    :param n_components: Number of principal components to retain
    :return: Tuple containing transformed dataset and explained variance ratio

    Example:
    >>> X, _ = collect_dataset()
    >>> transformed_X, variance = apply_pca(X, 2)
    >>> transformed_X.shape
    (150, 2)
    >>> len(variance) == 2
    True
    """"""
    # Standardizing the dataset
    scaler = StandardScaler()
    data_x_scaled = scaler.fit_transform(data_x)

    # Applying PCA
    pca = PCA(n_components=n_components)
    principal_components = pca.fit_transform(data_x_scaled)

    return principal_components, pca.explained_variance_ratio_",data\repos\Python\machine_learning\principle_component_analysis.py,apply_pca,191
1293,principle_component_analysis.py::main::64,"def main() -> None:
    """"""
    Driver function to execute PCA and display results.
    """"""
    data_x, _data_y = collect_dataset()

    # Number of principal components to retain
    n_components = 2

    # Apply PCA
    transformed_data, variance_ratio = apply_pca(data_x, n_components)

    print(""Transformed Dataset (First 5 rows):"")
    print(transformed_data[:5])

    print(""\nExplained Variance Ratio:"")
    print(variance_ratio)",data\repos\Python\machine_learning\principle_component_analysis.py,main,105
1294,scoring_functions.py::mae::19,"def mae(predict, actual):
    """"""
    Examples(rounded for precision):
    >>> actual = [1,2,3];predict = [1,4,3]
    >>> float(np.around(mae(predict,actual),decimals = 2))
    0.67

    >>> actual = [1,1,1];predict = [1,1,1]
    >>> float(mae(predict,actual))
    0.0
    """"""
    predict = np.array(predict)
    actual = np.array(actual)

    difference = abs(predict - actual)
    score = difference.mean()

    return score",data\repos\Python\machine_learning\scoring_functions.py,mae,128
1295,scoring_functions.py::mse::40,"def mse(predict, actual):
    """"""
    Examples(rounded for precision):
    >>> actual = [1,2,3];predict = [1,4,3]
    >>> float(np.around(mse(predict,actual),decimals = 2))
    1.33

    >>> actual = [1,1,1];predict = [1,1,1]
    >>> float(mse(predict,actual))
    0.0
    """"""
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    square_diff = np.square(difference)

    score = square_diff.mean()
    return score",data\repos\Python\machine_learning\scoring_functions.py,mse,136
1296,scoring_functions.py::rmse::62,"def rmse(predict, actual):
    """"""
    Examples(rounded for precision):
    >>> actual = [1,2,3];predict = [1,4,3]
    >>> float(np.around(rmse(predict,actual),decimals = 2))
    1.15

    >>> actual = [1,1,1];predict = [1,1,1]
    >>> float(rmse(predict,actual))
    0.0
    """"""
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    square_diff = np.square(difference)
    mean_square_diff = square_diff.mean()
    score = np.sqrt(mean_square_diff)
    return score",data\repos\Python\machine_learning\scoring_functions.py,rmse,148
1297,scoring_functions.py::rmsle::84,"def rmsle(predict, actual):
    """"""
    Examples(rounded for precision):
    >>> float(np.around(rmsle(predict=[10, 2, 30], actual=[10, 10, 30]), decimals=2))
    0.75

    >>> float(rmsle(predict=[1, 1, 1], actual=[1, 1, 1]))
    0.0
    """"""
    predict = np.array(predict)
    actual = np.array(actual)

    log_predict = np.log(predict + 1)
    log_actual = np.log(actual + 1)

    difference = log_predict - log_actual
    square_diff = np.square(difference)
    mean_square_diff = square_diff.mean()

    score = np.sqrt(mean_square_diff)

    return score",data\repos\Python\machine_learning\scoring_functions.py,rmsle,164
1298,scoring_functions.py::mbd::109,"def mbd(predict, actual):
    """"""
    This value is Negative, if the model underpredicts,
    positive, if it overpredicts.

    Example(rounded for precision):

    Here the model overpredicts
    >>> actual = [1,2,3];predict = [2,3,4]
    >>> float(np.around(mbd(predict,actual),decimals = 2))
    50.0

    Here the model underpredicts
    >>> actual = [1,2,3];predict = [0,1,1]
    >>> float(np.around(mbd(predict,actual),decimals = 2))
    -66.67
    """"""
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    numerator = np.sum(difference) / len(predict)
    denumerator = np.sum(actual) / len(predict)
    # print(numerator, denumerator)
    score = float(numerator) / denumerator * 100

    return score",data\repos\Python\machine_learning\scoring_functions.py,mbd,215
1299,self_organizing_map.py::main::39,"def main() -> None:
    # Training Examples ( m, n )
    training_samples = [[1, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 1]]

    # weight initialization ( n, C )
    weights = [[0.2, 0.6, 0.5, 0.9], [0.8, 0.4, 0.7, 0.3]]

    # training
    self_organizing_map = SelfOrganizingMap()
    epochs = 3
    alpha = 0.5

    for _ in range(epochs):
        for j in range(len(training_samples)):
            # training sample
            sample = training_samples[j]

            # Compute the winning vector
            winner = self_organizing_map.get_winner(weights, sample)

            # Update the winning vector
            weights = self_organizing_map.update(weights, sample, winner, alpha)

    # classify test sample
    sample = [0, 0, 0, 1]
    winner = self_organizing_map.get_winner(weights, sample)

    # results
    print(f""Clusters that the test sample belongs to : {winner}"")
    print(f""Weights that have been trained : {weights}"")",data\repos\Python\machine_learning\self_organizing_map.py,main,290
1300,self_organizing_map.py::get_winner::9,"    def get_winner(self, weights: list[list[float]], sample: list[int]) -> int:
        """"""
        Compute the winning vector by Euclidean distance

        >>> SelfOrganizingMap().get_winner([[1, 2, 3], [4, 5, 6]], [1, 2, 3])
        1
        """"""
        d0 = 0.0
        d1 = 0.0
        for i in range(len(sample)):
            d0 += math.pow((sample[i] - weights[0][i]), 2)
            d1 += math.pow((sample[i] - weights[1][i]), 2)
            return 0 if d0 > d1 else 1
        return 0",data\repos\Python\machine_learning\self_organizing_map.py,get_winner,158
1301,self_organizing_map.py::update::24,"    def update(
        self, weights: list[list[int | float]], sample: list[int], j: int, alpha: float
    ) -> list[list[int | float]]:
        """"""
        Update the winning vector.

        >>> SelfOrganizingMap().update([[1, 2, 3], [4, 5, 6]], [1, 2, 3], 1, 0.1)
        [[1, 2, 3], [3.7, 4.7, 6]]
        """"""
        for i in range(len(weights)):
            weights[j][i] += alpha * (sample[i] - weights[j][i])
        return weights",data\repos\Python\machine_learning\self_organizing_map.py,update,143
1302,sequential_minimum_optimization.py::count_time::437,"def count_time(func):
    def call_func(*args, **kwargs):
        import time

        start_time = time.time()
        func(*args, **kwargs)
        end_time = time.time()
        print(f""SMO algorithm cost {end_time - start_time} seconds"")

    return call_func",data\repos\Python\machine_learning\sequential_minimum_optimization.py,count_time,62
1303,sequential_minimum_optimization.py::test_cancer_data::450,"def test_cancer_data():
    print(""Hello!\nStart test SVM using the SMO algorithm!"")
    # 0: download dataset and load into pandas' dataframe
    if not os.path.exists(r""cancer_data.csv""):
        request = urllib.request.Request(  # noqa: S310
            CANCER_DATASET_URL,
            headers={""User-Agent"": ""Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)""},
        )
        response = urllib.request.urlopen(request)  # noqa: S310
        content = response.read().decode(""utf-8"")
        with open(r""cancer_data.csv"", ""w"") as f:
            f.write(content)

    data = pd.read_csv(
        ""cancer_data.csv"",
        header=None,
        dtype={0: str},  # Assuming the first column contains string data
    )

    # 1: pre-processing data
    del data[data.columns.tolist()[0]]
    data = data.dropna(axis=0)
    data = data.replace({""M"": np.float64(1), ""B"": np.float64(-1)})
    samples = np.array(data)[:, :]

    # 2: dividing data into train_data data and test_data data
    train_data, test_data = samples[:328, :], samples[328:, :]
    test_tags, test_samples = test_data[:, 0], test_data[:, 1:]

    # 3: choose kernel function, and set initial alphas to zero (optional)
    my_kernel = Kernel(kernel=""rbf"", degree=5, coef0=1, gamma=0.5)
    al = np.zeros(train_data.shape[0])

    # 4: calculating best alphas using SMO algorithm and predict test_data samples
    mysvm = SmoSVM(
        train=train_data,
        kernel_func=my_kernel,
        alpha_list=al,
        cost=0.4,
        b=0.0,
        tolerance=0.001,
    )
    mysvm.fit()
    predict = mysvm.predict(test_samples)

    # 5: check accuracy
    score = 0
    test_num = test_tags.shape[0]
    for i in range(test_tags.shape[0]):
        if test_tags[i] == predict[i]:
            score += 1
    print(f""\nAll: {test_num}\nCorrect: {score}\nIncorrect: {test_num - score}"")
    print(f""Rough Accuracy: {score / test_tags.shape[0]}"")",data\repos\Python\machine_learning\sequential_minimum_optimization.py,test_cancer_data,524
1304,sequential_minimum_optimization.py::test_demonstration::505,"def test_demonstration():
    # change stdout
    print(""\nStarting plot, please wait!"")
    sys.stdout = open(os.devnull, ""w"")

    ax1 = plt.subplot2grid((2, 2), (0, 0))
    ax2 = plt.subplot2grid((2, 2), (0, 1))
    ax3 = plt.subplot2grid((2, 2), (1, 0))
    ax4 = plt.subplot2grid((2, 2), (1, 1))
    ax1.set_title(""Linear SVM, cost = 0.1"")
    test_linear_kernel(ax1, cost=0.1)
    ax2.set_title(""Linear SVM, cost = 500"")
    test_linear_kernel(ax2, cost=500)
    ax3.set_title(""RBF kernel SVM, cost = 0.1"")
    test_rbf_kernel(ax3, cost=0.1)
    ax4.set_title(""RBF kernel SVM, cost = 500"")
    test_rbf_kernel(ax4, cost=500)

    sys.stdout = sys.__stdout__
    print(""Plot done!"")",data\repos\Python\machine_learning\sequential_minimum_optimization.py,test_demonstration,241
1305,sequential_minimum_optimization.py::test_linear_kernel::527,"def test_linear_kernel(ax, cost):
    train_x, train_y = make_blobs(
        n_samples=500, centers=2, n_features=2, random_state=1
    )
    train_y[train_y == 0] = -1
    scaler = StandardScaler()
    train_x_scaled = scaler.fit_transform(train_x, train_y)
    train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))
    my_kernel = Kernel(kernel=""linear"", degree=5, coef0=1, gamma=0.5)
    mysvm = SmoSVM(
        train=train_data,
        kernel_func=my_kernel,
        cost=cost,
        tolerance=0.001,
        auto_norm=False,
    )
    mysvm.fit()
    plot_partition_boundary(mysvm, train_data, ax=ax)",data\repos\Python\machine_learning\sequential_minimum_optimization.py,test_linear_kernel,175
1306,sequential_minimum_optimization.py::test_rbf_kernel::547,"def test_rbf_kernel(ax, cost):
    train_x, train_y = make_circles(
        n_samples=500, noise=0.1, factor=0.1, random_state=1
    )
    train_y[train_y == 0] = -1
    scaler = StandardScaler()
    train_x_scaled = scaler.fit_transform(train_x, train_y)
    train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))
    my_kernel = Kernel(kernel=""rbf"", degree=5, coef0=1, gamma=0.5)
    mysvm = SmoSVM(
        train=train_data,
        kernel_func=my_kernel,
        cost=cost,
        tolerance=0.001,
        auto_norm=False,
    )
    mysvm.fit()
    plot_partition_boundary(mysvm, train_data, ax=ax)",data\repos\Python\machine_learning\sequential_minimum_optimization.py,test_rbf_kernel,180
1307,sequential_minimum_optimization.py::plot_partition_boundary::567,"def plot_partition_boundary(
    model, train_data, ax, resolution=100, colors=(""b"", ""k"", ""r"")
):
    """"""
    We cannot get the optimal w of our kernel SVM model, which is different from a
    linear SVM.  For this reason, we generate randomly distributed points with high
    density, and predicted values of these points are calculated using our trained
    model. Then we could use this predicted values to draw contour map, and this contour
    map represents the SVM's partition boundary.
    """"""
    train_data_x = train_data[:, 1]
    train_data_y = train_data[:, 2]
    train_data_tags = train_data[:, 0]
    xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)
    yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)
    test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(
        resolution * resolution, 2
    )

    test_tags = model.predict(test_samples, classify=False)
    grid = test_tags.reshape((len(xrange), len(yrange)))

    # Plot contour map which represents the partition boundary
    ax.contour(
        xrange,
        yrange,
        np.asmatrix(grid).T,
        levels=(-1, 0, 1),
        linestyles=(""--"", ""-"", ""--""),
        linewidths=(1, 1, 1),
        colors=colors,
    )
    # Plot all train samples
    ax.scatter(
        train_data_x,
        train_data_y,
        c=train_data_tags,
        cmap=plt.cm.Dark2,
        lw=0,
        alpha=0.5,
    )

    # Plot support vectors
    support = model.support
    ax.scatter(
        train_data_x[support],
        train_data_y[support],
        c=train_data_tags[support],
        cmap=plt.cm.Dark2,
    )",data\repos\Python\machine_learning\sequential_minimum_optimization.py,plot_partition_boundary,405
1308,sequential_minimum_optimization.py::fit::78,"    def fit(self):
        k = self._k
        state = None
        while True:
            # 1: Find alpha1, alpha2
            try:
                i1, i2 = self.choose_alpha.send(state)
                state = None
            except StopIteration:
                print(""Optimization done!\nEvery sample satisfy the KKT condition!"")
                break

            # 2: calculate new alpha2 and new alpha1
            y1, y2 = self.tags[i1], self.tags[i2]
            a1, a2 = self.alphas[i1].copy(), self.alphas[i2].copy()
            e1, e2 = self._e(i1), self._e(i2)
            args = (i1, i2, a1, a2, e1, e2, y1, y2)
            a1_new, a2_new = self._get_new_alpha(*args)
            if not a1_new and not a2_new:
                state = False
                continue
            self.alphas[i1], self.alphas[i2] = a1_new, a2_new

            # 3: update threshold(b)
            b1_new = np.float64(
                -e1
                - y1 * k(i1, i1) * (a1_new - a1)
                - y2 * k(i2, i1) * (a2_new - a2)
                + self._b
            )
            b2_new = np.float64(
                -e2
                - y2 * k(i2, i2) * (a2_new - a2)
                - y1 * k(i1, i2) * (a1_new - a1)
                + self._b
            )
            if 0.0 < a1_new < self._c:
                b = b1_new
            if 0.0 < a2_new < self._c:
                b = b2_new
            if not (np.float64(0) < a2_new < self._c) and not (
                np.float64(0) < a1_new < self._c
            ):
                b = (b1_new + b2_new) / 2.0
            b_old = self._b
            self._b = b

            # 4: update error, here we only calculate the error for non-bound samples
            self._unbound = [i for i in self._all_samples if self._is_unbound(i)]
            for s in self.unbound:
                if s in (i1, i2):
                    continue
                self._error[s] += (
                    y1 * (a1_new - a1) * k(i1, s)
                    + y2 * (a2_new - a2) * k(i2, s)
                    + (self._b - b_old)
                )

            # if i1 or i2 is non-bound, update their error value to zero
            if self._is_unbound(i1):
                self._error[i1] = 0
            if self._is_unbound(i2):
                self._error[i2] = 0",data\repos\Python\machine_learning\sequential_minimum_optimization.py,fit,675
1309,sequential_minimum_optimization.py::predict::143,"    def predict(self, test_samples, classify=True):
        if test_samples.shape[1] > self.samples.shape[1]:
            raise ValueError(
                ""Test samples' feature length does not equal to that of train samples""
            )

        if self._auto_norm:
            test_samples = self._norm(test_samples)

        results = []
        for test_sample in test_samples:
            result = self._predict(test_sample)
            if classify:
                results.append(1 if result > 0 else -1)
            else:
                results.append(result)
        return np.array(results)",data\repos\Python\machine_learning\sequential_minimum_optimization.py,predict,118
1310,sequential_minimum_optimization.py::call_func::438,"    def call_func(*args, **kwargs):
        import time

        start_time = time.time()
        func(*args, **kwargs)
        end_time = time.time()
        print(f""SMO algorithm cost {end_time - start_time} seconds"")",data\repos\Python\machine_learning\sequential_minimum_optimization.py,call_func,53
1311,similarity_search.py::euclidean::19,"def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:
    """"""
    Calculates euclidean distance between two data.
    :param input_a: ndarray of first vector.
    :param input_b: ndarray of second vector.
    :return: Euclidean distance of input_a and input_b. By using math.sqrt(),
             result will be float.

    >>> euclidean(np.array([0]), np.array([1]))
    1.0
    >>> euclidean(np.array([0, 1]), np.array([1, 1]))
    1.0
    >>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1]))
    1.0
    """"""
    return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))",data\repos\Python\machine_learning\similarity_search.py,euclidean,181
1312,similarity_search.py::similarity_search::37,"def similarity_search(
    dataset: np.ndarray, value_array: np.ndarray
) -> list[list[list[float] | float]]:
    """"""
    :param dataset: Set containing the vectors. Should be ndarray.
    :param value_array: vector/vectors we want to know the nearest vector from dataset.
    :return: Result will be a list containing
            1. the nearest vector
            2. distance from the vector

    >>> dataset = np.array([[0], [1], [2]])
    >>> value_array = np.array([[0]])
    >>> similarity_search(dataset, value_array)
    [[[0], 0.0]]

    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])
    >>> value_array = np.array([[0, 1]])
    >>> similarity_search(dataset, value_array)
    [[[0, 0], 1.0]]

    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])
    >>> value_array = np.array([[0, 0, 1]])
    >>> similarity_search(dataset, value_array)
    [[[0, 0, 0], 1.0]]

    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])
    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])
    >>> similarity_search(dataset, value_array)
    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]

    These are the errors that might occur:

    1. If dimensions are different.
    For example, dataset has 2d array and value_array has 1d array:
    >>> dataset = np.array([[1]])
    >>> value_array = np.array([1])
    >>> similarity_search(dataset, value_array)
    Traceback (most recent call last):
        ...
    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1

    2. If data's shapes are different.
    For example, dataset has shape of (3, 2) and value_array has (2, 3).
    We are expecting same shapes of two arrays, so it is wrong.
    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])
    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])
    >>> similarity_search(dataset, value_array)
    Traceback (most recent call last):
        ...
    ValueError: Wrong input data's shape... dataset : 2, value_array : 3

    3. If data types are different.
    When trying to compare, we are expecting same types so they should be same.
    If not, it'll come up with errors.
    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)
    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)
    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Input data have different datatype...
    dataset : float32, value_array : int32
    """"""

    if dataset.ndim != value_array.ndim:
        msg = (
            ""Wrong input data's dimensions... ""
            f""dataset : {dataset.ndim}, value_array : {value_array.ndim}""
        )
        raise ValueError(msg)

    try:
        if dataset.shape[1] != value_array.shape[1]:
            msg = (
                ""Wrong input data's shape... ""
                f""dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}""
            )
            raise ValueError(msg)
    except IndexError:
        if dataset.ndim != value_array.ndim:
            raise TypeError(""Wrong shape"")

    if dataset.dtype != value_array.dtype:
        msg = (
            ""Input data have different datatype... ""
            f""dataset : {dataset.dtype}, value_array : {value_array.dtype}""
        )
        raise TypeError(msg)

    answer = []

    for value in value_array:
        dist = euclidean(value, dataset[0])
        vector = dataset[0].tolist()

        for dataset_value in dataset[1:]:
            temp_dist = euclidean(value, dataset_value)

            if dist > temp_dist:
                dist = temp_dist
                vector = dataset_value.tolist()

        answer.append([vector, dist])

    return answer",data\repos\Python\machine_learning\similarity_search.py,similarity_search,992
1313,similarity_search.py::cosine_similarity::143,"def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:
    """"""
    Calculates cosine similarity between two data.
    :param input_a: ndarray of first vector.
    :param input_b: ndarray of second vector.
    :return: Cosine similarity of input_a and input_b. By using math.sqrt(),
             result will be float.

    >>> cosine_similarity(np.array([1]), np.array([1]))
    1.0
    >>> cosine_similarity(np.array([1, 2]), np.array([6, 32]))
    0.9615239476408232
    """"""
    return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))",data\repos\Python\machine_learning\similarity_search.py,cosine_similarity,150
1314,support_vector_machines.py::norm_squared::6,"def norm_squared(vector: ndarray) -> float:
    """"""
    Return the squared second norm of vector
    norm_squared(v) = sum(x * x for x in v)

    Args:
        vector (ndarray): input vector

    Returns:
        float: squared second norm of vector

    >>> int(norm_squared([1, 2]))
    5
    >>> int(norm_squared(np.asarray([1, 2])))
    5
    >>> int(norm_squared([0, 0]))
    0
    """"""
    return np.dot(vector, vector)",data\repos\Python\machine_learning\support_vector_machines.py,norm_squared,117
1315,support_vector_machines.py::fit::101,"    def fit(self, observations: list[ndarray], classes: ndarray) -> None:
        """"""
        Fits the SVC with a set of observations.

        Args:
            observations (list[ndarray]): list of observations
            classes (ndarray): classification of each observation (in {1, -1})
        """"""

        self.observations = observations
        self.classes = classes

        # using Wolfe's Dual to calculate w.
        # Primal problem: minimize 1/2*norm_squared(w)
        #   constraint: yn(w . xn + b) >= 1
        #
        # With l a vector
        # Dual problem: maximize sum_n(ln) -
        #       1/2 * sum_n(sum_m(ln*lm*yn*ym*xn . xm))
        #   constraint: self.C >= ln >= 0
        #           and sum_n(ln*yn) = 0
        # Then we get w using w = sum_n(ln*yn*xn)
        # At the end we can get b ~= mean(yn - w . xn)
        #
        # Since we use kernels, we only need l_star to calculate b
        # and to classify observations

        (n,) = np.shape(classes)

        def to_minimize(candidate: ndarray) -> float:
            """"""
            Opposite of the function to maximize

            Args:
                candidate (ndarray): candidate array to test

            Return:
                float: Wolfe's Dual result to minimize
            """"""
            s = 0
            (n,) = np.shape(candidate)
            for i in range(n):
                for j in range(n):
                    s += (
                        candidate[i]
                        * candidate[j]
                        * classes[i]
                        * classes[j]
                        * self.kernel(observations[i], observations[j])
                    )
            return 1 / 2 * s - sum(candidate)

        ly_contraint = LinearConstraint(classes, 0, 0)
        l_bounds = Bounds(0, self.regularization)

        l_star = minimize(
            to_minimize, np.ones(n), bounds=l_bounds, constraints=[ly_contraint]
        ).x
        self.optimum = l_star

        # calculating mean offset of separation plane to points
        s = 0
        for i in range(n):
            for j in range(n):
                s += classes[i] - classes[i] * self.optimum[i] * self.kernel(
                    observations[i], observations[j]
                )
        self.offset = s / n",data\repos\Python\machine_learning\support_vector_machines.py,fit,523
1316,support_vector_machines.py::predict::170,"    def predict(self, observation: ndarray) -> int:
        """"""
        Get the expected class of an observation

        Args:
            observation (Vector): observation

        Returns:
            int {1, -1}: expected class

        >>> xs = [
        ...     np.asarray([0, 1]), np.asarray([0, 2]),
        ...     np.asarray([1, 1]), np.asarray([1, 2])
        ... ]
        >>> y = np.asarray([1, 1, -1, -1])
        >>> s = SVC()
        >>> s.fit(xs, y)
        >>> s.predict(np.asarray([0, 1]))
        1
        >>> s.predict(np.asarray([1, 1]))
        -1
        >>> s.predict(np.asarray([2, 2]))
        -1
        """"""
        s = sum(
            self.optimum[n]
            * self.classes[n]
            * self.kernel(self.observations[n], observation)
            for n in range(len(self.classes))
        )
        return 1 if s + self.offset >= 0 else -1",data\repos\Python\machine_learning\support_vector_machines.py,predict,229
1317,support_vector_machines.py::to_minimize::130,"        def to_minimize(candidate: ndarray) -> float:
            """"""
            Opposite of the function to maximize

            Args:
                candidate (ndarray): candidate array to test

            Return:
                float: Wolfe's Dual result to minimize
            """"""
            s = 0
            (n,) = np.shape(candidate)
            for i in range(n):
                for j in range(n):
                    s += (
                        candidate[i]
                        * candidate[j]
                        * classes[i]
                        * classes[j]
                        * self.kernel(observations[i], observations[j])
                    )
            return 1 / 2 * s - sum(candidate)",data\repos\Python\machine_learning\support_vector_machines.py,to_minimize,130
1318,t_stochastic_neighbour_embedding.py::collect_dataset::15,"def collect_dataset() -> tuple[ndarray, ndarray]:
    """"""
    Load the Iris dataset and return features and labels.

    Returns:
        tuple[ndarray, ndarray]: Feature matrix and target labels.

    >>> features, targets = collect_dataset()
    >>> features.shape
    (150, 4)
    >>> targets.shape
    (150,)
    """"""
    iris_dataset = load_iris()
    return np.array(iris_dataset.data), np.array(iris_dataset.target)",data\repos\Python\machine_learning\t_stochastic_neighbour_embedding.py,collect_dataset,98
1319,t_stochastic_neighbour_embedding.py::compute_pairwise_affinities::32,"def compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:
    """"""
    Compute high-dimensional affinities (P matrix) using a Gaussian kernel.

    Args:
        data_matrix: Input data of shape (n_samples, n_features).
        sigma: Gaussian kernel bandwidth.

    Returns:
        ndarray: Symmetrized probability matrix.

    >>> x = np.array([[0.0, 0.0], [1.0, 0.0]])
    >>> probabilities = compute_pairwise_affinities(x)
    >>> float(round(probabilities[0, 1], 3))
    0.25
    """"""
    n_samples = data_matrix.shape[0]
    squared_sum = np.sum(np.square(data_matrix), axis=1)
    squared_distance = np.add(
        np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum
    )

    affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))
    np.fill_diagonal(affinity_matrix, 0)

    affinity_matrix /= np.sum(affinity_matrix)
    return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)",data\repos\Python\machine_learning\t_stochastic_neighbour_embedding.py,compute_pairwise_affinities,258
1320,t_stochastic_neighbour_embedding.py::compute_low_dim_affinities::61,"def compute_low_dim_affinities(embedding_matrix: ndarray) -> tuple[ndarray, ndarray]:
    """"""
    Compute low-dimensional affinities (Q matrix) using a Student-t distribution.

    Args:
        embedding_matrix: Low-dimensional embedding of shape (n_samples, n_components).

    Returns:
        tuple[ndarray, ndarray]: (Q probability matrix, numerator matrix).

    >>> y = np.array([[0.0, 0.0], [1.0, 0.0]])
    >>> q_matrix, numerators = compute_low_dim_affinities(y)
    >>> q_matrix.shape
    (2, 2)
    """"""
    squared_sum = np.sum(np.square(embedding_matrix), axis=1)
    numerator_matrix = 1 / (
        1
        + np.add(
            np.add(-2 * np.dot(embedding_matrix, embedding_matrix.T), squared_sum).T,
            squared_sum,
        )
    )
    np.fill_diagonal(numerator_matrix, 0)

    q_matrix = numerator_matrix / np.sum(numerator_matrix)
    return q_matrix, numerator_matrix",data\repos\Python\machine_learning\t_stochastic_neighbour_embedding.py,compute_low_dim_affinities,229
1321,t_stochastic_neighbour_embedding.py::apply_tsne::90,"def apply_tsne(
    data_matrix: ndarray,
    n_components: int = 2,
    learning_rate: float = 200.0,
    n_iter: int = 500,
) -> ndarray:
    """"""
    Apply t-SNE for dimensionality reduction.

    Args:
        data_matrix: Original dataset (features).
        n_components: Target dimension (2D or 3D).
        learning_rate: Step size for gradient descent.
        n_iter: Number of iterations.

    Returns:
        ndarray: Low-dimensional embedding of the data.

    >>> features, _ = collect_dataset()
    >>> embedding = apply_tsne(features, n_components=2, n_iter=50)
    >>> embedding.shape
    (150, 2)
    """"""
    if n_components < 1 or n_iter < 1:
        raise ValueError(""n_components and n_iter must be >= 1"")

    n_samples = data_matrix.shape[0]
    rng = np.random.default_rng()
    embedding = rng.standard_normal((n_samples, n_components)) * 1e-4

    high_dim_affinities = compute_pairwise_affinities(data_matrix)
    high_dim_affinities = np.maximum(high_dim_affinities, 1e-12)

    embedding_increment = np.zeros_like(embedding)
    momentum = 0.5

    for iteration in range(n_iter):
        low_dim_affinities, numerator_matrix = compute_low_dim_affinities(embedding)
        low_dim_affinities = np.maximum(low_dim_affinities, 1e-12)

        affinity_diff = high_dim_affinities - low_dim_affinities

        gradient = 4 * (
            np.dot((affinity_diff * numerator_matrix), embedding)
            - np.multiply(
                np.sum(affinity_diff * numerator_matrix, axis=1)[:, np.newaxis],
                embedding,
            )
        )

        embedding_increment = momentum * embedding_increment - learning_rate * gradient
        embedding += embedding_increment

        if iteration == int(n_iter / 4):
            momentum = 0.8

    return embedding",data\repos\Python\machine_learning\t_stochastic_neighbour_embedding.py,apply_tsne,434
1322,t_stochastic_neighbour_embedding.py::main::149,"def main() -> None:
    """"""
    Run t-SNE on the Iris dataset and display the first 5 embeddings.

    >>> main()  # doctest: +ELLIPSIS
    t-SNE embedding (first 5 points):
    [[...
    """"""
    features, _labels = collect_dataset()
    embedding = apply_tsne(features, n_components=2, n_iter=300)

    if not isinstance(embedding, np.ndarray):
        raise TypeError(""t-SNE embedding must be an ndarray"")

    print(""t-SNE embedding (first 5 points):"")
    print(embedding[:5])",data\repos\Python\machine_learning\t_stochastic_neighbour_embedding.py,main,126
1323,word_frequency_functions.py::term_frequency::43,"def term_frequency(term: str, document: str) -> int:
    """"""
    Return the number of times a term occurs within
    a given document.
    @params: term, the term to search a document for, and document,
            the document to search within
    @returns: an integer representing the number of times a term is
            found within the document

    @examples:
    >>> term_frequency(""to"", ""To be, or not to be"")
    2
    """"""
    # strip all punctuation and newlines and replace it with ''
    document_without_punctuation = document.translate(
        str.maketrans("""", """", string.punctuation)
    ).replace(""\n"", """")
    tokenize_document = document_without_punctuation.split("" "")  # word tokenization
    return len([word for word in tokenize_document if word.lower() == term.lower()])",data\repos\Python\machine_learning\word_frequency_functions.py,term_frequency,180
1324,word_frequency_functions.py::document_frequency::64,"def document_frequency(term: str, corpus: str) -> tuple[int, int]:
    """"""
    Calculate the number of documents in a corpus that contain a
    given term
    @params : term, the term to search each document for, and corpus, a collection of
             documents. Each document should be separated by a newline.
    @returns : the number of documents in the corpus that contain the term you are
               searching for and the number of documents in the corpus
    @examples :
    >>> document_frequency(""first"", ""This is the first document in the corpus.\\nThIs\
is the second document in the corpus.\\nTHIS is \
the third document in the corpus."")
    (1, 3)
    """"""
    corpus_without_punctuation = corpus.lower().translate(
        str.maketrans("""", """", string.punctuation)
    )  # strip all punctuation and replace it with ''
    docs = corpus_without_punctuation.split(""\n"")
    term = term.lower()
    return (len([doc for doc in docs if term in doc]), len(docs))",data\repos\Python\machine_learning\word_frequency_functions.py,document_frequency,224
1325,word_frequency_functions.py::inverse_document_frequency::86,"def inverse_document_frequency(df: int, n: int, smoothing=False) -> float:
    """"""
    Return an integer denoting the importance
    of a word. This measure of importance is
    calculated by log10(N/df), where N is the
    number of documents and df is
    the Document Frequency.
    @params : df, the Document Frequency, N,
    the number of documents in the corpus and
    smoothing, if True return the idf-smooth
    @returns : log10(N/df) or 1+log10(N/1+df)
    @examples :
    >>> inverse_document_frequency(3, 0)
    Traceback (most recent call last):
     ...
    ValueError: log10(0) is undefined.
    >>> inverse_document_frequency(1, 3)
    0.477
    >>> inverse_document_frequency(0, 3)
    Traceback (most recent call last):
     ...
    ZeroDivisionError: df must be > 0
    >>> inverse_document_frequency(0, 3,True)
    1.477
    """"""
    if smoothing:
        if n == 0:
            raise ValueError(""log10(0) is undefined."")
        return round(1 + log10(n / (1 + df)), 3)

    if df == 0:
        raise ZeroDivisionError(""df must be > 0"")
    elif n == 0:
        raise ValueError(""log10(0) is undefined."")
    return round(log10(n / df), 3)",data\repos\Python\machine_learning\word_frequency_functions.py,inverse_document_frequency,323
1326,word_frequency_functions.py::tf_idf::123,"def tf_idf(tf: int, idf: int) -> float:
    """"""
    Combine the term frequency
    and inverse document frequency functions to
    calculate the originality of a term. This
    'originality' is calculated by multiplying
    the term frequency and the inverse document
    frequency : tf-idf = TF * IDF
    @params : tf, the term frequency, and idf, the inverse document
    frequency
    @examples :
    >>> tf_idf(2, 0.477)
    0.954
    """"""
    return round(tf * idf, 3)",data\repos\Python\machine_learning\word_frequency_functions.py,tf_idf,130
1327,xgboost_classifier.py::data_handling::10,"def data_handling(data: dict) -> tuple:
    # Split dataset into features and target
    # data is features
    """"""
    >>> data_handling(({'data':'[5.1, 3.5, 1.4, 0.2]','target':([0])}))
    ('[5.1, 3.5, 1.4, 0.2]', [0])
    >>> data_handling(
    ...     {'data': '[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', 'target': ([0, 0])}
    ... )
    ('[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', [0, 0])
    """"""
    return (data[""data""], data[""target""])",data\repos\Python\machine_learning\xgboost_classifier.py,data_handling,212
1328,xgboost_classifier.py::xgboost::24,"def xgboost(features: np.ndarray, target: np.ndarray) -> XGBClassifier:
    """"""
    # THIS TEST IS BROKEN!! >>> xgboost(np.array([[5.1, 3.6, 1.4, 0.2]]), np.array([0]))
    XGBClassifier(base_score=0.5, booster='gbtree', callbacks=None,
                  colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1,
                  early_stopping_rounds=None, enable_categorical=False,
                  eval_metric=None, gamma=0, gpu_id=-1, grow_policy='depthwise',
                  importance_type=None, interaction_constraints='',
                  learning_rate=0.300000012, max_bin=256, max_cat_to_onehot=4,
                  max_delta_step=0, max_depth=6, max_leaves=0, min_child_weight=1,
                  missing=nan, monotone_constraints='()', n_estimators=100,
                  n_jobs=0, num_parallel_tree=1, predictor='auto', random_state=0,
                  reg_alpha=0, reg_lambda=1, ...)
    """"""
    classifier = XGBClassifier()
    classifier.fit(features, target)
    return classifier",data\repos\Python\machine_learning\xgboost_classifier.py,xgboost,258
1329,xgboost_classifier.py::main::43,"def main() -> None:
    """"""
    Url for the algorithm:
    https://xgboost.readthedocs.io/en/stable/
    Iris type dataset is used to demonstrate algorithm.
    """"""

    # Load Iris dataset
    iris = load_iris()
    features, targets = data_handling(iris)
    x_train, x_test, y_train, y_test = train_test_split(
        features, targets, test_size=0.25
    )

    names = iris[""target_names""]

    # Create an XGBoost Classifier from the training data
    xgboost_classifier = xgboost(x_train, y_train)

    # Display the confusion matrix of the classifier with both training and test sets
    ConfusionMatrixDisplay.from_estimator(
        xgboost_classifier,
        x_test,
        y_test,
        display_labels=names,
        cmap=""Blues"",
        normalize=""true"",
    )
    plt.title(""Normalized Confusion Matrix - IRIS Dataset"")
    plt.show()",data\repos\Python\machine_learning\xgboost_classifier.py,main,204
1330,xgboost_regressor.py::data_handling::9,"def data_handling(data: dict) -> tuple:
    # Split dataset into features and target.  Data is features.
    """"""
    >>> data_handling((
    ...  {'data':'[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]'
    ...  ,'target':([4.526])}))
    ('[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]', [4.526])
    """"""
    return (data[""data""], data[""target""])",data\repos\Python\machine_learning\xgboost_regressor.py,data_handling,153
1331,xgboost_regressor.py::xgboost::20,"def xgboost(
    features: np.ndarray, target: np.ndarray, test_features: np.ndarray
) -> np.ndarray:
    """"""
    >>> xgboost(np.array([[ 2.3571 ,   52. , 6.00813008, 1.06775068,
    ...    907. , 2.45799458,   40.58 , -124.26]]),np.array([1.114]),
    ... np.array([[1.97840000e+00,  3.70000000e+01,  4.98858447e+00,  1.03881279e+00,
    ...    1.14300000e+03,  2.60958904e+00,  3.67800000e+01, -1.19780000e+02]]))
    array([[1.1139996]], dtype=float32)
    """"""
    xgb = XGBRegressor(
        verbosity=0, random_state=42, tree_method=""exact"", base_score=0.5
    )
    xgb.fit(features, target)
    # Predict target for test data
    predictions = xgb.predict(test_features)
    predictions = predictions.reshape(len(predictions), 1)
    return predictions",data\repos\Python\machine_learning\xgboost_regressor.py,xgboost,274
1332,xgboost_regressor.py::main::40,"def main() -> None:
    """"""
    The URL for this algorithm
    https://xgboost.readthedocs.io/en/stable/
    California house price dataset is used to demonstrate the algorithm.

    Expected error values:
    Mean Absolute Error: 0.30957163379906033
    Mean Square Error: 0.22611560196662744
    """"""
    # Load California house price dataset
    california = fetch_california_housing()
    data, target = data_handling(california)
    x_train, x_test, y_train, y_test = train_test_split(
        data, target, test_size=0.25, random_state=1
    )
    predictions = xgboost(x_train, y_train, x_test)
    # Error printing
    print(f""Mean Absolute Error: {mean_absolute_error(y_test, predictions)}"")
    print(f""Mean Square Error: {mean_squared_error(y_test, predictions)}"")",data\repos\Python\machine_learning\xgboost_regressor.py,main,197
1333,abs.py::abs_val::4,"def abs_val(num: float) -> float:
    """"""
    Find the absolute value of a number.

    >>> abs_val(-5.1)
    5.1
    >>> abs_val(-5) == abs_val(5)
    True
    >>> abs_val(0)
    0
    """"""
    return -num if num < 0 else num",data\repos\Python\maths\abs.py,abs_val,76
1334,abs.py::abs_min::18,"def abs_min(x: list[int]) -> int:
    """"""
    >>> abs_min([0,5,1,11])
    0
    >>> abs_min([3,-10,-2])
    -2
    >>> abs_min([])
    Traceback (most recent call last):
        ...
    ValueError: abs_min() arg is an empty sequence
    """"""
    if len(x) == 0:
        raise ValueError(""abs_min() arg is an empty sequence"")
    j = x[0]
    for i in x:
        if abs_val(i) < abs_val(j):
            j = i
    return j",data\repos\Python\maths\abs.py,abs_min,129
1335,abs.py::abs_max::38,"def abs_max(x: list[int]) -> int:
    """"""
    >>> abs_max([0,5,1,11])
    11
    >>> abs_max([3,-10,-2])
    -10
    >>> abs_max([])
    Traceback (most recent call last):
        ...
    ValueError: abs_max() arg is an empty sequence
    """"""
    if len(x) == 0:
        raise ValueError(""abs_max() arg is an empty sequence"")
    j = x[0]
    for i in x:
        if abs(i) > abs(j):
            j = i
    return j",data\repos\Python\maths\abs.py,abs_max,127
1336,abs.py::abs_max_sort::58,"def abs_max_sort(x: list[int]) -> int:
    """"""
    >>> abs_max_sort([0,5,1,11])
    11
    >>> abs_max_sort([3,-10,-2])
    -10
    >>> abs_max_sort([])
    Traceback (most recent call last):
        ...
    ValueError: abs_max_sort() arg is an empty sequence
    """"""
    if len(x) == 0:
        raise ValueError(""abs_max_sort() arg is an empty sequence"")
    return sorted(x, key=abs)[-1]",data\repos\Python\maths\abs.py,abs_max_sort,114
1337,abs.py::test_abs_val::74,"def test_abs_val():
    """"""
    >>> test_abs_val()
    """"""
    assert abs_val(0) == 0
    assert abs_val(34) == 34
    assert abs_val(-100000000000) == 100000000000

    a = [-3, -1, 2, -11]
    assert abs_max(a) == -11
    assert abs_max_sort(a) == -11
    assert abs_min(a) == -1",data\repos\Python\maths\abs.py,test_abs_val,99
1338,addition_without_arithmetic.py::add::9,"def add(first: int, second: int) -> int:
    """"""
    Implementation of addition of integer

    Examples:
    >>> add(3, 5)
    8
    >>> add(13, 5)
    18
    >>> add(-7, 2)
    -5
    >>> add(0, -7)
    -7
    >>> add(-321, 0)
    -321
    """"""
    while second != 0:
        c = first & second
        first ^= second
        second = c << 1
    return first",data\repos\Python\maths\addition_without_arithmetic.py,add,122
1339,aliquot_sum.py::aliquot_sum::1,"def aliquot_sum(input_num: int) -> int:
    """"""
    Finds the aliquot sum of an input integer, where the
    aliquot sum of a number n is defined as the sum of all
    natural numbers less than n that divide n evenly. For
    example, the aliquot sum of 15 is 1 + 3 + 5 = 9. This is
    a simple O(n) implementation.
    @param input_num: a positive integer whose aliquot sum is to be found
    @return: the aliquot sum of input_num, if input_num is positive.
    Otherwise, raise a ValueError
    Wikipedia Explanation: https://en.wikipedia.org/wiki/Aliquot_sum

    >>> aliquot_sum(15)
    9
    >>> aliquot_sum(6)
    6
    >>> aliquot_sum(-1)
    Traceback (most recent call last):
      ...
    ValueError: Input must be positive
    >>> aliquot_sum(0)
    Traceback (most recent call last):
      ...
    ValueError: Input must be positive
    >>> aliquot_sum(1.6)
    Traceback (most recent call last):
      ...
    ValueError: Input must be an integer
    >>> aliquot_sum(12)
    16
    >>> aliquot_sum(1)
    0
    >>> aliquot_sum(19)
    1
    """"""
    if not isinstance(input_num, int):
        raise ValueError(""Input must be an integer"")
    if input_num <= 0:
        raise ValueError(""Input must be positive"")
    return sum(
        divisor for divisor in range(1, input_num // 2 + 1) if input_num % divisor == 0
    )",data\repos\Python\maths\aliquot_sum.py,aliquot_sum,364
1340,allocation_number.py::allocation_num::12,"def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:
    """"""
    Divide a number of bytes into x partitions.
    :param number_of_bytes: the total of bytes.
    :param partitions: the number of partition need to be allocated.
    :return: list of bytes to be assigned to each worker thread

    >>> allocation_num(16647, 4)
    ['1-4161', '4162-8322', '8323-12483', '12484-16647']
    >>> allocation_num(50000, 5)
    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']
    >>> allocation_num(888, 999)
    Traceback (most recent call last):
        ...
    ValueError: partitions can not > number_of_bytes!
    >>> allocation_num(888, -4)
    Traceback (most recent call last):
        ...
    ValueError: partitions must be a positive number!
    """"""
    if partitions <= 0:
        raise ValueError(""partitions must be a positive number!"")
    if partitions > number_of_bytes:
        raise ValueError(""partitions can not > number_of_bytes!"")
    bytes_per_partition = number_of_bytes // partitions
    allocation_list = []
    for i in range(partitions):
        start_bytes = i * bytes_per_partition + 1
        end_bytes = (
            number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition
        )
        allocation_list.append(f""{start_bytes}-{end_bytes}"")
    return allocation_list",data\repos\Python\maths\allocation_number.py,allocation_num,343
1341,arc_length.py::arc_length::4,"def arc_length(angle: int, radius: int) -> float:
    """"""
    >>> arc_length(45, 5)
    3.9269908169872414
    >>> arc_length(120, 15)
    31.415926535897928
    >>> arc_length(90, 10)
    15.707963267948966
    """"""
    return 2 * pi * radius * (angle / 360)",data\repos\Python\maths\arc_length.py,arc_length,94
1342,area.py::surface_area_cube::9,"def surface_area_cube(side_length: float) -> float:
    """"""
    Calculate the Surface Area of a Cube.

    >>> surface_area_cube(1)
    6
    >>> surface_area_cube(1.6)
    15.360000000000003
    >>> surface_area_cube(0)
    0
    >>> surface_area_cube(3)
    54
    >>> surface_area_cube(-1)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cube() only accepts non-negative values
    """"""
    if side_length < 0:
        raise ValueError(""surface_area_cube() only accepts non-negative values"")
    return 6 * side_length**2",data\repos\Python\maths\area.py,surface_area_cube,144
1343,area.py::surface_area_cuboid::31,"def surface_area_cuboid(length: float, breadth: float, height: float) -> float:
    """"""
    Calculate the Surface Area of a Cuboid.

    >>> surface_area_cuboid(1, 2, 3)
    22
    >>> surface_area_cuboid(0, 0, 0)
    0
    >>> surface_area_cuboid(1.6, 2.6, 3.6)
    38.56
    >>> surface_area_cuboid(-1, 2, 3)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cuboid() only accepts non-negative values
    >>> surface_area_cuboid(1, -2, 3)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cuboid() only accepts non-negative values
    >>> surface_area_cuboid(1, 2, -3)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cuboid() only accepts non-negative values
    """"""
    if length < 0 or breadth < 0 or height < 0:
        raise ValueError(""surface_area_cuboid() only accepts non-negative values"")
    return 2 * ((length * breadth) + (breadth * height) + (length * height))",data\repos\Python\maths\area.py,surface_area_cuboid,285
1344,area.py::surface_area_sphere::59,"def surface_area_sphere(radius: float) -> float:
    """"""
    Calculate the Surface Area of a Sphere.
    Wikipedia reference: https://en.wikipedia.org/wiki/Sphere
    Formula: 4 * pi * r^2

    >>> surface_area_sphere(5)
    314.1592653589793
    >>> surface_area_sphere(1)
    12.566370614359172
    >>> surface_area_sphere(1.6)
    32.169908772759484
    >>> surface_area_sphere(0)
    0.0
    >>> surface_area_sphere(-1)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_sphere() only accepts non-negative values
    """"""
    if radius < 0:
        raise ValueError(""surface_area_sphere() only accepts non-negative values"")
    return 4 * pi * radius**2",data\repos\Python\maths\area.py,surface_area_sphere,182
1345,area.py::surface_area_hemisphere::83,"def surface_area_hemisphere(radius: float) -> float:
    """"""
    Calculate the Surface Area of a Hemisphere.
    Formula: 3 * pi * r^2

    >>> surface_area_hemisphere(5)
    235.61944901923448
    >>> surface_area_hemisphere(1)
    9.42477796076938
    >>> surface_area_hemisphere(0)
    0.0
    >>> surface_area_hemisphere(1.1)
    11.40398133253095
    >>> surface_area_hemisphere(-1)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_hemisphere() only accepts non-negative values
    """"""
    if radius < 0:
        raise ValueError(""surface_area_hemisphere() only accepts non-negative values"")
    return 3 * pi * radius**2",data\repos\Python\maths\area.py,surface_area_hemisphere,185
1346,area.py::surface_area_cone::106,"def surface_area_cone(radius: float, height: float) -> float:
    """"""
    Calculate the Surface Area of a Cone.
    Wikipedia reference: https://en.wikipedia.org/wiki/Cone
    Formula: pi * r * (r + (h ** 2 + r ** 2) ** 0.5)

    >>> surface_area_cone(10, 24)
    1130.9733552923256
    >>> surface_area_cone(6, 8)
    301.59289474462014
    >>> surface_area_cone(1.6, 2.6)
    23.387862992395807
    >>> surface_area_cone(0, 0)
    0.0
    >>> surface_area_cone(-1, -2)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cone() only accepts non-negative values
    >>> surface_area_cone(1, -2)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cone() only accepts non-negative values
    >>> surface_area_cone(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cone() only accepts non-negative values
    """"""
    if radius < 0 or height < 0:
        raise ValueError(""surface_area_cone() only accepts non-negative values"")
    return pi * radius * (radius + (height**2 + radius**2) ** 0.5)",data\repos\Python\maths\area.py,surface_area_cone,320
1347,area.py::surface_area_conical_frustum::138,"def surface_area_conical_frustum(
    radius_1: float, radius_2: float, height: float
) -> float:
    """"""
    Calculate the Surface Area of a Conical Frustum.

    >>> surface_area_conical_frustum(1, 2, 3)
    45.511728065337266
    >>> surface_area_conical_frustum(4, 5, 6)
    300.7913575056268
    >>> surface_area_conical_frustum(0, 0, 0)
    0.0
    >>> surface_area_conical_frustum(1.6, 2.6, 3.6)
    78.57907060751548
    >>> surface_area_conical_frustum(-1, 2, 3)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_conical_frustum() only accepts non-negative values
    >>> surface_area_conical_frustum(1, -2, 3)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_conical_frustum() only accepts non-negative values
    >>> surface_area_conical_frustum(1, 2, -3)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_conical_frustum() only accepts non-negative values
    """"""
    if radius_1 < 0 or radius_2 < 0 or height < 0:
        raise ValueError(
            ""surface_area_conical_frustum() only accepts non-negative values""
        )
    slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5
    return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)",data\repos\Python\maths\area.py,surface_area_conical_frustum,401
1348,area.py::surface_area_cylinder::173,"def surface_area_cylinder(radius: float, height: float) -> float:
    """"""
    Calculate the Surface Area of a Cylinder.
    Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder
    Formula: 2 * pi * r * (h + r)

    >>> surface_area_cylinder(7, 10)
    747.6990515543707
    >>> surface_area_cylinder(1.6, 2.6)
    42.22300526424682
    >>> surface_area_cylinder(0, 0)
    0.0
    >>> surface_area_cylinder(6, 8)
    527.7875658030853
    >>> surface_area_cylinder(-1, -2)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cylinder() only accepts non-negative values
    >>> surface_area_cylinder(1, -2)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cylinder() only accepts non-negative values
    >>> surface_area_cylinder(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_cylinder() only accepts non-negative values
    """"""
    if radius < 0 or height < 0:
        raise ValueError(""surface_area_cylinder() only accepts non-negative values"")
    return 2 * pi * radius * (height + radius)",data\repos\Python\maths\area.py,surface_area_cylinder,297
1349,area.py::surface_area_torus::205,"def surface_area_torus(torus_radius: float, tube_radius: float) -> float:
    """"""Calculate the Area of a Torus.
    Wikipedia reference: https://en.wikipedia.org/wiki/Torus
    :return 4pi^2 * torus_radius * tube_radius
    >>> surface_area_torus(1, 1)
    39.47841760435743
    >>> surface_area_torus(4, 3)
    473.7410112522892
    >>> surface_area_torus(3, 4)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_torus() does not support spindle or self intersecting tori
    >>> surface_area_torus(1.6, 1.6)
    101.06474906715503
    >>> surface_area_torus(0, 0)
    0.0
    >>> surface_area_torus(-1, 1)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_torus() only accepts non-negative values
    >>> surface_area_torus(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: surface_area_torus() only accepts non-negative values
    """"""
    if torus_radius < 0 or tube_radius < 0:
        raise ValueError(""surface_area_torus() only accepts non-negative values"")
    if torus_radius < tube_radius:
        raise ValueError(
            ""surface_area_torus() does not support spindle or self intersecting tori""
        )
    return 4 * pow(pi, 2) * torus_radius * tube_radius",data\repos\Python\maths\area.py,surface_area_torus,345
1350,area.py::area_rectangle::239,"def area_rectangle(length: float, width: float) -> float:
    """"""
    Calculate the area of a rectangle.

    >>> area_rectangle(10, 20)
    200
    >>> area_rectangle(1.6, 2.6)
    4.16
    >>> area_rectangle(0, 0)
    0
    >>> area_rectangle(-1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_rectangle() only accepts non-negative values
    >>> area_rectangle(1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_rectangle() only accepts non-negative values
    >>> area_rectangle(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: area_rectangle() only accepts non-negative values
    """"""
    if length < 0 or width < 0:
        raise ValueError(""area_rectangle() only accepts non-negative values"")
    return length * width",data\repos\Python\maths\area.py,area_rectangle,203
1351,area.py::area_square::267,"def area_square(side_length: float) -> float:
    """"""
    Calculate the area of a square.

    >>> area_square(10)
    100
    >>> area_square(0)
    0
    >>> area_square(1.6)
    2.5600000000000005
    >>> area_square(-1)
    Traceback (most recent call last):
        ...
    ValueError: area_square() only accepts non-negative values
    """"""
    if side_length < 0:
        raise ValueError(""area_square() only accepts non-negative values"")
    return side_length**2",data\repos\Python\maths\area.py,area_square,122
1352,area.py::area_triangle::287,"def area_triangle(base: float, height: float) -> float:
    """"""
    Calculate the area of a triangle given the base and height.

    >>> area_triangle(10, 10)
    50.0
    >>> area_triangle(1.6, 2.6)
    2.08
    >>> area_triangle(0, 0)
    0.0
    >>> area_triangle(-1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_triangle() only accepts non-negative values
    >>> area_triangle(1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_triangle() only accepts non-negative values
    >>> area_triangle(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: area_triangle() only accepts non-negative values
    """"""
    if base < 0 or height < 0:
        raise ValueError(""area_triangle() only accepts non-negative values"")
    return (base * height) / 2",data\repos\Python\maths\area.py,area_triangle,217
1353,area.py::area_triangle_three_sides::315,"def area_triangle_three_sides(side1: float, side2: float, side3: float) -> float:
    """"""
    Calculate area of triangle when the length of 3 sides are known.
    This function uses Heron's formula: https://en.wikipedia.org/wiki/Heron%27s_formula

    >>> area_triangle_three_sides(5, 12, 13)
    30.0
    >>> area_triangle_three_sides(10, 11, 12)
    51.521233486786784
    >>> area_triangle_three_sides(0, 0, 0)
    0.0
    >>> area_triangle_three_sides(1.6, 2.6, 3.6)
    1.8703742940919619
    >>> area_triangle_three_sides(-1, -2, -1)
    Traceback (most recent call last):
        ...
    ValueError: area_triangle_three_sides() only accepts non-negative values
    >>> area_triangle_three_sides(1, -2, 1)
    Traceback (most recent call last):
        ...
    ValueError: area_triangle_three_sides() only accepts non-negative values
    >>> area_triangle_three_sides(2, 4, 7)
    Traceback (most recent call last):
        ...
    ValueError: Given three sides do not form a triangle
    >>> area_triangle_three_sides(2, 7, 4)
    Traceback (most recent call last):
        ...
    ValueError: Given three sides do not form a triangle
    >>> area_triangle_three_sides(7, 2, 4)
    Traceback (most recent call last):
        ...
    ValueError: Given three sides do not form a triangle
    """"""
    if side1 < 0 or side2 < 0 or side3 < 0:
        raise ValueError(""area_triangle_three_sides() only accepts non-negative values"")
    elif side1 + side2 < side3 or side1 + side3 < side2 or side2 + side3 < side1:
        raise ValueError(""Given three sides do not form a triangle"")
    semi_perimeter = (side1 + side2 + side3) / 2
    area = sqrt(
        semi_perimeter
        * (semi_perimeter - side1)
        * (semi_perimeter - side2)
        * (semi_perimeter - side3)
    )
    return area",data\repos\Python\maths\area.py,area_triangle_three_sides,511
1354,area.py::area_parallelogram::363,"def area_parallelogram(base: float, height: float) -> float:
    """"""
    Calculate the area of a parallelogram.

    >>> area_parallelogram(10, 20)
    200
    >>> area_parallelogram(1.6, 2.6)
    4.16
    >>> area_parallelogram(0, 0)
    0
    >>> area_parallelogram(-1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_parallelogram() only accepts non-negative values
    >>> area_parallelogram(1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_parallelogram() only accepts non-negative values
    >>> area_parallelogram(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: area_parallelogram() only accepts non-negative values
    """"""
    if base < 0 or height < 0:
        raise ValueError(""area_parallelogram() only accepts non-negative values"")
    return base * height",data\repos\Python\maths\area.py,area_parallelogram,238
1355,area.py::area_trapezium::391,"def area_trapezium(base1: float, base2: float, height: float) -> float:
    """"""
    Calculate the area of a trapezium.

    >>> area_trapezium(10, 20, 30)
    450.0
    >>> area_trapezium(1.6, 2.6, 3.6)
    7.5600000000000005
    >>> area_trapezium(0, 0, 0)
    0.0
    >>> area_trapezium(-1, -2, -3)
    Traceback (most recent call last):
        ...
    ValueError: area_trapezium() only accepts non-negative values
    >>> area_trapezium(-1, 2, 3)
    Traceback (most recent call last):
        ...
    ValueError: area_trapezium() only accepts non-negative values
    >>> area_trapezium(1, -2, 3)
    Traceback (most recent call last):
        ...
    ValueError: area_trapezium() only accepts non-negative values
    >>> area_trapezium(1, 2, -3)
    Traceback (most recent call last):
        ...
    ValueError: area_trapezium() only accepts non-negative values
    >>> area_trapezium(-1, -2, 3)
    Traceback (most recent call last):
        ...
    ValueError: area_trapezium() only accepts non-negative values
    >>> area_trapezium(1, -2, -3)
    Traceback (most recent call last):
        ...
    ValueError: area_trapezium() only accepts non-negative values
    >>> area_trapezium(-1, 2, -3)
    Traceback (most recent call last):
        ...
    ValueError: area_trapezium() only accepts non-negative values
    """"""
    if base1 < 0 or base2 < 0 or height < 0:
        raise ValueError(""area_trapezium() only accepts non-negative values"")
    return 1 / 2 * (base1 + base2) * height",data\repos\Python\maths\area.py,area_trapezium,461
1356,area.py::area_circle::435,"def area_circle(radius: float) -> float:
    """"""
    Calculate the area of a circle.

    >>> area_circle(20)
    1256.6370614359173
    >>> area_circle(1.6)
    8.042477193189871
    >>> area_circle(0)
    0.0
    >>> area_circle(-1)
    Traceback (most recent call last):
        ...
    ValueError: area_circle() only accepts non-negative values
    """"""
    if radius < 0:
        raise ValueError(""area_circle() only accepts non-negative values"")
    return pi * radius**2",data\repos\Python\maths\area.py,area_circle,129
1357,area.py::area_ellipse::455,"def area_ellipse(radius_x: float, radius_y: float) -> float:
    """"""
    Calculate the area of a ellipse.

    >>> area_ellipse(10, 10)
    314.1592653589793
    >>> area_ellipse(10, 20)
    628.3185307179587
    >>> area_ellipse(0, 0)
    0.0
    >>> area_ellipse(1.6, 2.6)
    13.06902543893354
    >>> area_ellipse(-10, 20)
    Traceback (most recent call last):
        ...
    ValueError: area_ellipse() only accepts non-negative values
    >>> area_ellipse(10, -20)
    Traceback (most recent call last):
        ...
    ValueError: area_ellipse() only accepts non-negative values
    >>> area_ellipse(-10, -20)
    Traceback (most recent call last):
        ...
    ValueError: area_ellipse() only accepts non-negative values
    """"""
    if radius_x < 0 or radius_y < 0:
        raise ValueError(""area_ellipse() only accepts non-negative values"")
    return pi * radius_x * radius_y",data\repos\Python\maths\area.py,area_ellipse,255
1358,area.py::area_rhombus::485,"def area_rhombus(diagonal_1: float, diagonal_2: float) -> float:
    """"""
    Calculate the area of a rhombus.

    >>> area_rhombus(10, 20)
    100.0
    >>> area_rhombus(1.6, 2.6)
    2.08
    >>> area_rhombus(0, 0)
    0.0
    >>> area_rhombus(-1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_rhombus() only accepts non-negative values
    >>> area_rhombus(1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_rhombus() only accepts non-negative values
    >>> area_rhombus(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: area_rhombus() only accepts non-negative values
    """"""
    if diagonal_1 < 0 or diagonal_2 < 0:
        raise ValueError(""area_rhombus() only accepts non-negative values"")
    return 1 / 2 * diagonal_1 * diagonal_2",data\repos\Python\maths\area.py,area_rhombus,261
1359,area.py::area_reg_polygon::513,"def area_reg_polygon(sides: int, length: float) -> float:
    """"""
    Calculate the area of a regular polygon.
    Wikipedia reference: https://en.wikipedia.org/wiki/Polygon#Regular_polygons
    Formula: (n*s^2*cot(pi/n))/4

    >>> area_reg_polygon(3, 10)
    43.301270189221945
    >>> area_reg_polygon(4, 10)
    100.00000000000001
    >>> area_reg_polygon(0, 0)
    Traceback (most recent call last):
        ...
    ValueError: area_reg_polygon() only accepts integers greater than or equal to \
three as number of sides
    >>> area_reg_polygon(-1, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_reg_polygon() only accepts integers greater than or equal to \
three as number of sides
    >>> area_reg_polygon(5, -2)
    Traceback (most recent call last):
        ...
    ValueError: area_reg_polygon() only accepts non-negative values as \
length of a side
    >>> area_reg_polygon(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: area_reg_polygon() only accepts integers greater than or equal to \
three as number of sides
    """"""
    if not isinstance(sides, int) or sides < 3:
        raise ValueError(
            ""area_reg_polygon() only accepts integers greater than or \
equal to three as number of sides""
        )
    elif length < 0:
        raise ValueError(
            ""area_reg_polygon() only accepts non-negative values as \
length of a side""
        )
    return (sides * length**2) / (4 * tan(pi / sides))
    return (sides * length**2) / (4 * tan(pi / sides))",data\repos\Python\maths\area.py,area_reg_polygon,387
1360,area_under_curve.py::trapezoidal_area::10,"def trapezoidal_area(
    fnc: Callable[[float], float],
    x_start: float,
    x_end: float,
    steps: int = 100,
) -> float:
    """"""
    Treats curve as a collection of linear lines and sums the area of the
    trapezium shape they form
    :param fnc: a function which defines a curve
    :param x_start: left end point to indicate the start of line segment
    :param x_end: right end point to indicate end of line segment
    :param steps: an accuracy gauge; more steps increases the accuracy
    :return: a float representing the length of the curve

    >>> def f(x):
    ...    return 5
    >>> f""{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}""
    '10.000'
    >>> def f(x):
    ...    return 9*x**2
    >>> f""{trapezoidal_area(f, -4.0, 0, 10000):.4f}""
    '192.0000'
    >>> f""{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}""
    '384.0000'
    """"""
    x1 = x_start
    fx1 = fnc(x_start)
    area = 0.0
    for _ in range(steps):
        # Approximates small segments of curve as linear and solve
        # for trapezoidal area
        x2 = (x_end - x_start) / steps + x1
        fx2 = fnc(x2)
        area += abs(fx2 + fx1) * (x2 - x1) / 2
        # Increment step
        x1 = x2
        fx1 = fx2
    return area",data\repos\Python\maths\area_under_curve.py,trapezoidal_area,403
1361,average_absolute_deviation.py::average_absolute_deviation::1,"def average_absolute_deviation(nums: list[int]) -> float:
    """"""
    Return the average absolute deviation of a list of numbers.
    Wiki: https://en.wikipedia.org/wiki/Average_absolute_deviation

    >>> average_absolute_deviation([0])
    0.0
    >>> average_absolute_deviation([4, 1, 3, 2])
    1.0
    >>> average_absolute_deviation([2, 70, 6, 50, 20, 8, 4, 0])
    20.0
    >>> average_absolute_deviation([-20, 0, 30, 15])
    16.25
    >>> average_absolute_deviation([])
    Traceback (most recent call last):
        ...
    ValueError: List is empty
    """"""
    if not nums:  # Makes sure that the list is not empty
        raise ValueError(""List is empty"")

    average = sum(nums) / len(nums)  # Calculate the average
    return sum(abs(x - average) for x in nums) / len(nums)",data\repos\Python\maths\average_absolute_deviation.py,average_absolute_deviation,225
1362,average_mean.py::mean::4,"def mean(nums: list) -> float:
    """"""
    Find mean of a list of numbers.
    Wiki: https://en.wikipedia.org/wiki/Mean

    >>> mean([3, 6, 9, 12, 15, 18, 21])
    12.0
    >>> mean([5, 10, 15, 20, 25, 30, 35])
    20.0
    >>> mean([1, 2, 3, 4, 5, 6, 7, 8])
    4.5
    >>> mean([])
    Traceback (most recent call last):
        ...
    ValueError: List is empty
    """"""
    if not nums:
        raise ValueError(""List is empty"")
    return sum(nums) / len(nums)",data\repos\Python\maths\average_mean.py,mean,171
1363,average_median.py::median::4,"def median(nums: list) -> int | float:
    """"""
    Find median of a list of numbers.
    Wiki: https://en.wikipedia.org/wiki/Median

    >>> median([0])
    0
    >>> median([4, 1, 3, 2])
    2.5
    >>> median([2, 70, 6, 50, 20, 8, 4])
    8

    Args:
        nums: List of nums

    Returns:
        Median.
    """"""
    # The sorted function returns list[SupportsRichComparisonT@sorted]
    # which does not support `+`
    sorted_list: list[int] = sorted(nums)
    length = len(sorted_list)
    mid_index = length >> 1
    return (
        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2
        if length % 2 == 0
        else sorted_list[mid_index]
    )",data\repos\Python\maths\average_median.py,median,205
1364,average_mode.py::mode::4,"def mode(input_list: list) -> list[Any]:
    """"""This function returns the mode(Mode as in the measures of
    central tendency) of the input data.

    The input list may contain any Datastructure or any Datatype.

    >>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])
    [2]
    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])
    [2]
    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])
    [2, 4]
    >>> mode([""x"", ""y"", ""y"", ""z""])
    ['y']
    >>> mode([""x"", ""x"" , ""y"", ""y"", ""z""])
    ['x', 'y']
    """"""
    if not input_list:
        return []
    result = [input_list.count(value) for value in input_list]
    y = max(result)  # Gets the maximum count in the input list.
    # Gets values of modes
    return sorted({input_list[i] for i, value in enumerate(result) if value == y})",data\repos\Python\maths\average_mode.py,mode,321
1365,bailey_borwein_plouffe.py::bailey_borwein_plouffe::1,"def bailey_borwein_plouffe(digit_position: int, precision: int = 1000) -> str:
    """"""
    Implement a popular pi-digit-extraction algorithm known as the
    Bailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi.
    Wikipedia page:
    https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula
    @param digit_position: a positive integer representing the position of the digit to
    extract.
    The digit immediately after the decimal point is located at position 1.
    @param precision: number of terms in the second summation to calculate.
    A higher number reduces the chance of an error but increases the runtime.
    @return: a hexadecimal digit representing the digit at the nth position
    in pi's decimal expansion.

    >>> """".join(bailey_borwein_plouffe(i) for i in range(1, 11))
    '243f6a8885'
    >>> bailey_borwein_plouffe(5, 10000)
    '6'
    >>> bailey_borwein_plouffe(-10)
    Traceback (most recent call last):
      ...
    ValueError: Digit position must be a positive integer
    >>> bailey_borwein_plouffe(0)
    Traceback (most recent call last):
      ...
    ValueError: Digit position must be a positive integer
    >>> bailey_borwein_plouffe(1.7)
    Traceback (most recent call last):
      ...
    ValueError: Digit position must be a positive integer
    >>> bailey_borwein_plouffe(2, -10)
    Traceback (most recent call last):
      ...
    ValueError: Precision must be a nonnegative integer
    >>> bailey_borwein_plouffe(2, 1.6)
    Traceback (most recent call last):
      ...
    ValueError: Precision must be a nonnegative integer
    """"""
    if (not isinstance(digit_position, int)) or (digit_position <= 0):
        raise ValueError(""Digit position must be a positive integer"")
    elif (not isinstance(precision, int)) or (precision < 0):
        raise ValueError(""Precision must be a nonnegative integer"")

    # compute an approximation of (16 ** (n - 1)) * pi whose fractional part is mostly
    # accurate
    sum_result = (
        4 * _subsum(digit_position, 1, precision)
        - 2 * _subsum(digit_position, 4, precision)
        - _subsum(digit_position, 5, precision)
        - _subsum(digit_position, 6, precision)
    )

    # return the first hex digit of the fractional part of the result
    return hex(int((sum_result % 1) * 16))[2:]",data\repos\Python\maths\bailey_borwein_plouffe.py,bailey_borwein_plouffe,625
1366,base_neg2_conversion.py::decimal_to_negative_base_2::1,"def decimal_to_negative_base_2(num: int) -> int:
    """"""
    This function returns the number negative base 2
        of the decimal number of the input data.

    Args:
        int: The decimal number to convert.

    Returns:
        int: The negative base 2 number.

    Examples:
        >>> decimal_to_negative_base_2(0)
        0
        >>> decimal_to_negative_base_2(-19)
        111101
        >>> decimal_to_negative_base_2(4)
        100
        >>> decimal_to_negative_base_2(7)
        11011
    """"""
    if num == 0:
        return 0
    ans = """"
    while num != 0:
        num, rem = divmod(num, -2)
        if rem < 0:
            rem += 2
            num += 1
        ans = str(rem) + ans
    return int(ans)",data\repos\Python\maths\base_neg2_conversion.py,decimal_to_negative_base_2,198
1367,basic_maths.py::prime_factors::6,"def prime_factors(n: int) -> list:
    """"""Find Prime Factors.
    >>> prime_factors(100)
    [2, 2, 5, 5]
    >>> prime_factors(0)
    Traceback (most recent call last):
        ...
    ValueError: Only positive integers have prime factors
    >>> prime_factors(-10)
    Traceback (most recent call last):
        ...
    ValueError: Only positive integers have prime factors
    """"""
    if n <= 0:
        raise ValueError(""Only positive integers have prime factors"")
    pf = []
    while n % 2 == 0:
        pf.append(2)
        n = int(n / 2)
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            pf.append(i)
            n = int(n / i)
    if n > 2:
        pf.append(n)
    return pf",data\repos\Python\maths\basic_maths.py,prime_factors,198
1368,basic_maths.py::number_of_divisors::34,"def number_of_divisors(n: int) -> int:
    """"""Calculate Number of Divisors of an Integer.
    >>> number_of_divisors(100)
    9
    >>> number_of_divisors(0)
    Traceback (most recent call last):
        ...
    ValueError: Only positive numbers are accepted
    >>> number_of_divisors(-10)
    Traceback (most recent call last):
        ...
    ValueError: Only positive numbers are accepted
    """"""
    if n <= 0:
        raise ValueError(""Only positive numbers are accepted"")
    div = 1
    temp = 1
    while n % 2 == 0:
        temp += 1
        n = int(n / 2)
    div *= temp
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        temp = 1
        while n % i == 0:
            temp += 1
            n = int(n / i)
        div *= temp
    if n > 1:
        div *= 2
    return div",data\repos\Python\maths\basic_maths.py,number_of_divisors,225
1369,basic_maths.py::sum_of_divisors::66,"def sum_of_divisors(n: int) -> int:
    """"""Calculate Sum of Divisors.
    >>> sum_of_divisors(100)
    217
    >>> sum_of_divisors(0)
    Traceback (most recent call last):
        ...
    ValueError: Only positive numbers are accepted
    >>> sum_of_divisors(-10)
    Traceback (most recent call last):
        ...
    ValueError: Only positive numbers are accepted
    """"""
    if n <= 0:
        raise ValueError(""Only positive numbers are accepted"")
    s = 1
    temp = 1
    while n % 2 == 0:
        temp += 1
        n = int(n / 2)
    if temp > 1:
        s *= (2**temp - 1) / (2 - 1)
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        temp = 1
        while n % i == 0:
            temp += 1
            n = int(n / i)
        if temp > 1:
            s *= (i**temp - 1) / (i - 1)
    return int(s)",data\repos\Python\maths\basic_maths.py,sum_of_divisors,251
1370,basic_maths.py::euler_phi::98,"def euler_phi(n: int) -> int:
    """"""Calculate Euler's Phi Function.
    >>> euler_phi(100)
    40
    >>> euler_phi(0)
    Traceback (most recent call last):
        ...
    ValueError: Only positive numbers are accepted
    >>> euler_phi(-10)
    Traceback (most recent call last):
        ...
    ValueError: Only positive numbers are accepted
    """"""
    if n <= 0:
        raise ValueError(""Only positive numbers are accepted"")
    s = n
    for x in set(prime_factors(n)):
        s *= (x - 1) / x
    return int(s)",data\repos\Python\maths\basic_maths.py,euler_phi,134
1371,binary_exponentiation.py::binary_exp_recursive::17,"def binary_exp_recursive(base: float, exponent: int) -> float:
    """"""
    Computes a^b recursively, where a is the base and b is the exponent

    >>> binary_exp_recursive(3, 5)
    243
    >>> binary_exp_recursive(11, 13)
    34522712143931
    >>> binary_exp_recursive(-1, 3)
    -1
    >>> binary_exp_recursive(0, 5)
    0
    >>> binary_exp_recursive(3, 1)
    3
    >>> binary_exp_recursive(3, 0)
    1
    >>> binary_exp_recursive(1.5, 4)
    5.0625
    >>> binary_exp_recursive(3, -1)
    Traceback (most recent call last):
        ...
    ValueError: Exponent must be a non-negative integer
    """"""
    if exponent < 0:
        raise ValueError(""Exponent must be a non-negative integer"")

    if exponent == 0:
        return 1

    if exponent % 2 == 1:
        return binary_exp_recursive(base, exponent - 1) * base

    b = binary_exp_recursive(base, exponent // 2)
    return b * b",data\repos\Python\maths\binary_exponentiation.py,binary_exp_recursive,260
1372,binary_exponentiation.py::binary_exp_iterative::53,"def binary_exp_iterative(base: float, exponent: int) -> float:
    """"""
    Computes a^b iteratively, where a is the base and b is the exponent

    >>> binary_exp_iterative(3, 5)
    243
    >>> binary_exp_iterative(11, 13)
    34522712143931
    >>> binary_exp_iterative(-1, 3)
    -1
    >>> binary_exp_iterative(0, 5)
    0
    >>> binary_exp_iterative(3, 1)
    3
    >>> binary_exp_iterative(3, 0)
    1
    >>> binary_exp_iterative(1.5, 4)
    5.0625
    >>> binary_exp_iterative(3, -1)
    Traceback (most recent call last):
        ...
    ValueError: Exponent must be a non-negative integer
    """"""
    if exponent < 0:
        raise ValueError(""Exponent must be a non-negative integer"")

    res: int | float = 1
    while exponent > 0:
        if exponent & 1:
            res *= base

        base *= base
        exponent >>= 1

    return res",data\repos\Python\maths\binary_exponentiation.py,binary_exp_iterative,258
1373,binary_exponentiation.py::binary_exp_mod_recursive::90,"def binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:
    """"""
    Computes a^b % c recursively, where a is the base, b is the exponent, and c is the
    modulus

    >>> binary_exp_mod_recursive(3, 4, 5)
    1
    >>> binary_exp_mod_recursive(11, 13, 7)
    4
    >>> binary_exp_mod_recursive(1.5, 4, 3)
    2.0625
    >>> binary_exp_mod_recursive(7, -1, 10)
    Traceback (most recent call last):
        ...
    ValueError: Exponent must be a non-negative integer
    >>> binary_exp_mod_recursive(7, 13, 0)
    Traceback (most recent call last):
        ...
    ValueError: Modulus must be a positive integer
    """"""
    if exponent < 0:
        raise ValueError(""Exponent must be a non-negative integer"")
    if modulus <= 0:
        raise ValueError(""Modulus must be a positive integer"")

    if exponent == 0:
        return 1

    if exponent % 2 == 1:
        return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus

    r = binary_exp_mod_recursive(base, exponent // 2, modulus)
    return (r * r) % modulus",data\repos\Python\maths\binary_exponentiation.py,binary_exp_mod_recursive,297
1374,binary_exponentiation.py::binary_exp_mod_iterative::125,"def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:
    """"""
    Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the
    modulus

    >>> binary_exp_mod_iterative(3, 4, 5)
    1
    >>> binary_exp_mod_iterative(11, 13, 7)
    4
    >>> binary_exp_mod_iterative(1.5, 4, 3)
    2.0625
    >>> binary_exp_mod_iterative(7, -1, 10)
    Traceback (most recent call last):
        ...
    ValueError: Exponent must be a non-negative integer
    >>> binary_exp_mod_iterative(7, 13, 0)
    Traceback (most recent call last):
        ...
    ValueError: Modulus must be a positive integer
    """"""
    if exponent < 0:
        raise ValueError(""Exponent must be a non-negative integer"")
    if modulus <= 0:
        raise ValueError(""Modulus must be a positive integer"")

    res: int | float = 1
    while exponent > 0:
        if exponent & 1:
            res = ((res % modulus) * (base % modulus)) % modulus

        base *= base
        exponent >>= 1

    return res",data\repos\Python\maths\binary_exponentiation.py,binary_exp_mod_iterative,290
1375,binary_multiplication.py::binary_multiply::23,"def binary_multiply(a: int, b: int) -> int:
    """"""
    Multiply 'a' and 'b' using bitwise multiplication.

    Parameters:
    a (int): The first number.
    b (int): The second number.

    Returns:
    int: a * b

    Examples:
    >>> binary_multiply(2, 3)
    6
    >>> binary_multiply(5, 0)
    0
    >>> binary_multiply(3, 4)
    12
    >>> binary_multiply(10, 5)
    50
    >>> binary_multiply(0, 5)
    0
    >>> binary_multiply(2, 1)
    2
    >>> binary_multiply(1, 10)
    10
    """"""
    res = 0
    while b > 0:
        if b & 1:
            res += a

        a += a
        b >>= 1

    return res",data\repos\Python\maths\binary_multiplication.py,binary_multiply,202
1376,binary_multiplication.py::binary_mod_multiply::61,"def binary_mod_multiply(a: int, b: int, modulus: int) -> int:
    """"""
    Calculate (a * b) % c using binary multiplication and modular arithmetic.

    Parameters:
    a (int): The first number.
    b (int): The second number.
    modulus (int): The modulus.

    Returns:
    int: (a * b) % modulus.

    Examples:
    >>> binary_mod_multiply(2, 3, 5)
    1
    >>> binary_mod_multiply(5, 0, 7)
    0
    >>> binary_mod_multiply(3, 4, 6)
    0
    >>> binary_mod_multiply(10, 5, 13)
    11
    >>> binary_mod_multiply(2, 1, 5)
    2
    >>> binary_mod_multiply(1, 10, 3)
    1
    """"""
    res = 0
    while b > 0:
        if b & 1:
            res = ((res % modulus) + (a % modulus)) % modulus

        a += a
        b >>= 1

    return res",data\repos\Python\maths\binary_multiplication.py,binary_mod_multiply,244
1377,binomial_coefficient.py::binomial_coefficient::1,"def binomial_coefficient(n: int, r: int) -> int:
    """"""
    Find binomial coefficient using Pascal's triangle.

    Calculate C(n, r) using Pascal's triangle.

    :param n: The total number of items.
    :param r: The number of items to choose.
    :return: The binomial coefficient C(n, r).

    >>> binomial_coefficient(10, 5)
    252
    >>> binomial_coefficient(10, 0)
    1
    >>> binomial_coefficient(0, 10)
    1
    >>> binomial_coefficient(10, 10)
    1
    >>> binomial_coefficient(5, 2)
    10
    >>> binomial_coefficient(5, 6)
    0
    >>> binomial_coefficient(3, 5)
    0
    >>> binomial_coefficient(-2, 3)
    Traceback (most recent call last):
        ...
    ValueError: n and r must be non-negative integers
    >>> binomial_coefficient(5, -1)
    Traceback (most recent call last):
        ...
    ValueError: n and r must be non-negative integers
    >>> binomial_coefficient(10.1, 5)
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> binomial_coefficient(10, 5.1)
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    """"""
    if n < 0 or r < 0:
        raise ValueError(""n and r must be non-negative integers"")
    if 0 in (n, r):
        return 1
    c = [0 for i in range(r + 1)]
    # nc0 = 1
    c[0] = 1
    for i in range(1, n + 1):
        # to compute current row from previous row.
        j = min(i, r)
        while j > 0:
            c[j] += c[j - 1]
            j -= 1
    return c[r]",data\repos\Python\maths\binomial_coefficient.py,binomial_coefficient,469
1378,binomial_distribution.py::binomial_distribution::7,"def binomial_distribution(successes: int, trials: int, prob: float) -> float:
    """"""
    Return probability of k successes out of n tries, with p probability for one
    success

    The function uses the factorial function in order to calculate the binomial
    coefficient

    >>> binomial_distribution(3, 5, 0.7)
    0.30870000000000003
    >>> binomial_distribution (2, 4, 0.5)
    0.375
    """"""
    if successes > trials:
        raise ValueError(""""""successes must be lower or equal to trials"""""")
    if trials < 0 or successes < 0:
        raise ValueError(""the function is defined for non-negative integers"")
    if not isinstance(successes, int) or not isinstance(trials, int):
        raise ValueError(""the function is defined for non-negative integers"")
    if not 0 < prob < 1:
        raise ValueError(""prob has to be in range of 1 - 0"")
    probability = (prob**successes) * ((1 - prob) ** (trials - successes))
    # Calculate the binomial coefficient: n! / k!(n-k)!
    coefficient = float(factorial(trials))
    coefficient /= factorial(successes) * factorial(trials - successes)
    return probability * coefficient",data\repos\Python\maths\binomial_distribution.py,binomial_distribution,280
1379,ceil.py::ceil::6,"def ceil(x: float) -> int:
    """"""
    Return the ceiling of x as an Integral.

    :param x: the number
    :return: the smallest integer >= x.

    >>> import math
    >>> all(ceil(n) == math.ceil(n) for n
    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))
    True
    """"""
    return int(x) if x - int(x) <= 0 else int(x) + 1",data\repos\Python\maths\ceil.py,ceil,130
1380,chebyshev_distance.py::chebyshev_distance::1,"def chebyshev_distance(point_a: list[float], point_b: list[float]) -> float:
    """"""
    This function calculates the Chebyshev distance (also known as the
    Chessboard distance) between two n-dimensional points represented as lists.

    https://en.wikipedia.org/wiki/Chebyshev_distance

    >>> chebyshev_distance([1.0, 1.0], [2.0, 2.0])
    1.0
    >>> chebyshev_distance([1.0, 1.0, 9.0], [2.0, 2.0, -5.2])
    14.2
    >>> chebyshev_distance([1.0], [2.0, 2.0])
    Traceback (most recent call last):
        ...
    ValueError: Both points must have the same dimension.
    """"""
    if len(point_a) != len(point_b):
        raise ValueError(""Both points must have the same dimension."")

    return max(abs(a - b) for a, b in zip(point_a, point_b))",data\repos\Python\maths\chebyshev_distance.py,chebyshev_distance,232
1381,check_polygon.py::check_polygon::4,"def check_polygon(nums: list[float]) -> bool:
    """"""
    Takes list of possible side lengths and determines whether a
    two-dimensional polygon with such side lengths can exist.

    Returns a boolean value for the < comparison
    of the largest side length with sum of the rest.
    Wiki: https://en.wikipedia.org/wiki/Triangle_inequality

    >>> check_polygon([6, 10, 5])
    True
    >>> check_polygon([3, 7, 13, 2])
    False
    >>> check_polygon([1, 4.3, 5.2, 12.2])
    False
    >>> nums = [3, 7, 13, 2]
    >>> _ = check_polygon(nums) #   Run function, do not show answer in output
    >>> nums #  Check numbers are not reordered
    [3, 7, 13, 2]
    >>> check_polygon([])
    Traceback (most recent call last):
        ...
    ValueError: Monogons and Digons are not polygons in the Euclidean space
    >>> check_polygon([-2, 5, 6])
    Traceback (most recent call last):
        ...
    ValueError: All values must be greater than 0
    """"""
    if len(nums) < 2:
        raise ValueError(""Monogons and Digons are not polygons in the Euclidean space"")
    if any(i <= 0 for i in nums):
        raise ValueError(""All values must be greater than 0"")
    copy_nums = nums.copy()
    copy_nums.sort()
    return copy_nums[-1] < sum(copy_nums[:-1])",data\repos\Python\maths\check_polygon.py,check_polygon,344
1382,chinese_remainder_theorem.py::extended_euclid::19,"def extended_euclid(a: int, b: int) -> tuple[int, int]:
    """"""
    >>> extended_euclid(10, 6)
    (-1, 2)

    >>> extended_euclid(7, 5)
    (-2, 3)

    """"""
    if b == 0:
        return (1, 0)
    (x, y) = extended_euclid(b, a % b)
    k = a // b
    return (y, x - k * y)",data\repos\Python\maths\chinese_remainder_theorem.py,extended_euclid,111
1383,chinese_remainder_theorem.py::chinese_remainder_theorem::36,"def chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:
    """"""
    >>> chinese_remainder_theorem(5,1,7,3)
    31

    Explanation : 31 is the smallest number such that
                (i)  When we divide it by 5, we get remainder 1
                (ii) When we divide it by 7, we get remainder 3

    >>> chinese_remainder_theorem(6,1,4,3)
    14

    """"""
    (x, y) = extended_euclid(n1, n2)
    m = n1 * n2
    n = r2 * x * n1 + r1 * y * n2
    return (n % m + m) % m",data\repos\Python\maths\chinese_remainder_theorem.py,chinese_remainder_theorem,178
1384,chinese_remainder_theorem.py::invert_modulo::59,"def invert_modulo(a: int, n: int) -> int:
    """"""
    >>> invert_modulo(2, 5)
    3

    >>> invert_modulo(8,7)
    1

    """"""
    (b, _x) = extended_euclid(a, n)
    if b < 0:
        b = (b % n + n) % n
    return b",data\repos\Python\maths\chinese_remainder_theorem.py,invert_modulo,87
1385,chinese_remainder_theorem.py::chinese_remainder_theorem2::75,"def chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:
    """"""
    >>> chinese_remainder_theorem2(5,1,7,3)
    31

    >>> chinese_remainder_theorem2(6,1,4,3)
    14

    """"""
    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)
    m = n1 * n2
    n = r2 * x * n1 + r1 * y * n2
    return (n % m + m) % m",data\repos\Python\maths\chinese_remainder_theorem.py,chinese_remainder_theorem2,138
1386,chudnovsky_algorithm.py::pi::5,"def pi(precision: int) -> str:
    """"""
    The Chudnovsky algorithm is a fast method for calculating the digits of PI,
    based on Ramanujan's PI formulae.

    https://en.wikipedia.org/wiki/Chudnovsky_algorithm

    PI = constant_term / ((multinomial_term * linear_term) / exponential_term)
        where constant_term = 426880 * sqrt(10005)

    The linear_term and the exponential_term can be defined iteratively as follows:
        L_k+1 = L_k + 545140134            where L_0 = 13591409
        X_k+1 = X_k * -262537412640768000  where X_0 = 1

    The multinomial_term is defined as follows:
        6k! / ((3k)! * (k!) ^ 3)
            where k is the k_th iteration.

    This algorithm correctly calculates around 14 digits of PI per iteration

    >>> pi(10)
    '3.14159265'
    >>> pi(100)
    '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706'
    >>> pi('hello')
    Traceback (most recent call last):
        ...
    TypeError: Undefined for non-integers
    >>> pi(-1)
    Traceback (most recent call last):
        ...
    ValueError: Undefined for non-natural numbers
    """"""

    if not isinstance(precision, int):
        raise TypeError(""Undefined for non-integers"")
    elif precision < 1:
        raise ValueError(""Undefined for non-natural numbers"")

    getcontext().prec = precision
    num_iterations = ceil(precision / 14)
    constant_term = 426880 * Decimal(10005).sqrt()
    exponential_term = 1
    linear_term = 13591409
    partial_sum = Decimal(linear_term)
    for k in range(1, num_iterations):
        multinomial_term = factorial(6 * k) // (factorial(3 * k) * factorial(k) ** 3)
        linear_term += 545140134
        exponential_term *= -262537412640768000
        partial_sum += Decimal(multinomial_term * linear_term) / exponential_term
    return str(constant_term / partial_sum)[:-1]",data\repos\Python\maths\chudnovsky_algorithm.py,pi,505
1387,collatz_sequence.py::collatz_sequence::20,"def collatz_sequence(n: int) -> Generator[int]:
    """"""
    Generate the Collatz sequence starting at n.
    >>> tuple(collatz_sequence(2.1))
    Traceback (most recent call last):
        ...
    Exception: Sequence only defined for positive integers
    >>> tuple(collatz_sequence(0))
    Traceback (most recent call last):
        ...
    Exception: Sequence only defined for positive integers
    >>> tuple(collatz_sequence(4))
    (4, 2, 1)
    >>> tuple(collatz_sequence(11))
    (11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1)
    >>> tuple(collatz_sequence(31))     # doctest: +NORMALIZE_WHITESPACE
    (31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137,
    412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593,
    1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425,
    1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644,
    1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732,
    866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53,
    160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1)
    >>> tuple(collatz_sequence(43))     # doctest: +NORMALIZE_WHITESPACE
    (43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26,
    13, 40, 20, 10, 5, 16, 8, 4, 2, 1)
    """"""
    if not isinstance(n, int) or n < 1:
        raise Exception(""Sequence only defined for positive integers"")

    yield n
    while n != 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
        yield n",data\repos\Python\maths\collatz_sequence.py,collatz_sequence,720
1388,collatz_sequence.py::main::59,"def main():
    n = int(input(""Your number: ""))
    sequence = tuple(collatz_sequence(n))
    print(sequence)
    print(f""Collatz sequence from {n} took {len(sequence)} steps."")",data\repos\Python\maths\collatz_sequence.py,main,44
1389,combinations.py::combinations::6,"def combinations(n: int, k: int) -> int:
    """"""
    Returns the number of different combinations of k length which can
    be made from n values, where n >= k.

    Examples:
    >>> combinations(10,5)
    252

    >>> combinations(6,3)
    20

    >>> combinations(20,5)
    15504

    >>> combinations(52, 5)
    2598960

    >>> combinations(0, 0)
    1

    >>> combinations(-4, -5)
    ...
    Traceback (most recent call last):
    ValueError: Please enter positive integers for n and k where n >= k
    """"""

    # If either of the conditions are true, the function is being asked
    # to calculate a factorial of a negative number, which is not possible
    if n < k or k < 0:
        raise ValueError(""Please enter positive integers for n and k where n >= k"")
    res = 1
    for i in range(k):
        res *= n - i
        res //= i + 1
    return res",data\repos\Python\maths\combinations.py,combinations,237
1390,continued_fraction.py::continued_fraction::11,"def continued_fraction(num: Fraction) -> list[int]:
    """"""
    :param num:
    Fraction of the number whose continued fractions to be found.
    Use Fraction(str(number)) for more accurate results due to
    float inaccuracies.

    :return:
    The continued fraction of rational number.
    It is the all commas in the (n + 1)-tuple notation.

    >>> continued_fraction(Fraction(2))
    [2]
    >>> continued_fraction(Fraction(""3.245""))
    [3, 4, 12, 4]
    >>> continued_fraction(Fraction(""2.25""))
    [2, 4]
    >>> continued_fraction(1/Fraction(""2.25""))
    [0, 2, 4]
    >>> continued_fraction(Fraction(""415/93""))
    [4, 2, 6, 7]
    >>> continued_fraction(Fraction(0))
    [0]
    >>> continued_fraction(Fraction(0.75))
    [0, 1, 3]
    >>> continued_fraction(Fraction(""-2.25""))    # -2.25 = -3 + 0.75
    [-3, 1, 3]
    """"""
    numerator, denominator = num.as_integer_ratio()
    continued_fraction_list: list[int] = []
    while True:
        integer_part = floor(numerator / denominator)
        continued_fraction_list.append(integer_part)
        numerator -= integer_part * denominator
        if numerator == 0:
            break
        numerator, denominator = denominator, numerator

    return continued_fraction_list",data\repos\Python\maths\continued_fraction.py,continued_fraction,325
1391,decimal_isolate.py::decimal_isolate::7,"def decimal_isolate(number: float, digit_amount: int) -> float:
    """"""
    Isolates the decimal part of a number.
    If digitAmount > 0 round to that decimal place, else print the entire decimal.
    >>> decimal_isolate(1.53, 0)
    0.53
    >>> decimal_isolate(35.345, 1)
    0.3
    >>> decimal_isolate(35.345, 2)
    0.34
    >>> decimal_isolate(35.345, 3)
    0.345
    >>> decimal_isolate(-14.789, 3)
    -0.789
    >>> decimal_isolate(0, 2)
    0
    >>> decimal_isolate(-14.123, 1)
    -0.1
    >>> decimal_isolate(-14.123, 2)
    -0.12
    >>> decimal_isolate(-14.123, 3)
    -0.123
    """"""
    if digit_amount > 0:
        return round(number - int(number), digit_amount)
    return number - int(number)",data\repos\Python\maths\decimal_isolate.py,decimal_isolate,243
1392,decimal_to_fraction.py::decimal_to_fraction::1,"def decimal_to_fraction(decimal: float | str) -> tuple[int, int]:
    """"""
    Return a decimal number in its simplest fraction form
    >>> decimal_to_fraction(2)
    (2, 1)
    >>> decimal_to_fraction(89.)
    (89, 1)
    >>> decimal_to_fraction(""67"")
    (67, 1)
    >>> decimal_to_fraction(""45.0"")
    (45, 1)
    >>> decimal_to_fraction(1.5)
    (3, 2)
    >>> decimal_to_fraction(""6.25"")
    (25, 4)
    >>> decimal_to_fraction(""78td"")
    Traceback (most recent call last):
    ValueError: Please enter a valid number
    >>> decimal_to_fraction(0)
    (0, 1)
    >>> decimal_to_fraction(-2.5)
    (-5, 2)
    >>> decimal_to_fraction(0.125)
    (1, 8)
    >>> decimal_to_fraction(1000000.25)
    (4000001, 4)
    >>> decimal_to_fraction(1.3333)
    (13333, 10000)
    >>> decimal_to_fraction(""1.23e2"")
    (123, 1)
    >>> decimal_to_fraction(""0.500"")
    (1, 2)
    """"""
    try:
        decimal = float(decimal)
    except ValueError:
        raise ValueError(""Please enter a valid number"")
    fractional_part = decimal - int(decimal)
    if fractional_part == 0:
        return int(decimal), 1
    else:
        number_of_frac_digits = len(str(decimal).split(""."")[1])
        numerator = int(decimal * (10**number_of_frac_digits))
        denominator = 10**number_of_frac_digits
        divisor, dividend = denominator, numerator
        while True:
            remainder = dividend % divisor
            if remainder == 0:
                break
            dividend, divisor = divisor, remainder
        numerator, denominator = numerator // divisor, denominator // divisor
        return numerator, denominator",data\repos\Python\maths\decimal_to_fraction.py,decimal_to_fraction,428
1393,dodecahedron.py::dodecahedron_surface_area::9,"def dodecahedron_surface_area(edge: float) -> float:
    """"""
    Calculates the surface area of a regular dodecahedron
    a = 3 * ((25 + 10 * (5** (1 / 2))) ** (1 / 2 )) * (e**2)
    where:
    a --> is the area of the dodecahedron
    e --> is the length of the edge
    reference-->""Dodecahedron"" Study.com
    <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>

    :param edge: length of the edge of the dodecahedron
    :type edge: float
    :return: the surface area of the dodecahedron as a float


    Tests:
    >>> dodecahedron_surface_area(5)
    516.1432201766901
    >>> dodecahedron_surface_area(10)
    2064.5728807067603
    >>> dodecahedron_surface_area(-1)
    Traceback (most recent call last):
      ...
    ValueError: Length must be a positive.
    """"""

    if edge <= 0 or not isinstance(edge, int):
        raise ValueError(""Length must be a positive."")
    return 3 * ((25 + 10 * (5 ** (1 / 2))) ** (1 / 2)) * (edge**2)",data\repos\Python\maths\dodecahedron.py,dodecahedron_surface_area,309
1394,dodecahedron.py::dodecahedron_volume::40,"def dodecahedron_volume(edge: float) -> float:
    """"""
    Calculates the volume of a regular dodecahedron
    v = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3)
    where:
    v --> is the volume of the dodecahedron
    e --> is the length of the edge
    reference-->""Dodecahedron"" Study.com
    <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>

    :param edge: length of the edge of the dodecahedron
    :type edge: float
    :return: the volume of the dodecahedron as a float

    Tests:
    >>> dodecahedron_volume(5)
    957.8898700780791
    >>> dodecahedron_volume(10)
    7663.118960624633
    >>> dodecahedron_volume(-1)
    Traceback (most recent call last):
      ...
    ValueError: Length must be a positive.
    """"""

    if edge <= 0 or not isinstance(edge, int):
        raise ValueError(""Length must be a positive."")
    return ((15 + (7 * (5 ** (1 / 2)))) / 4) * (edge**3)",data\repos\Python\maths\dodecahedron.py,dodecahedron_volume,290
1395,double_factorial.py::double_factorial_recursive::1,"def double_factorial_recursive(n: int) -> int:
    """"""
    Compute double factorial using recursive method.
    Recursion can be costly for large numbers.

    To learn about the theory behind this algorithm:
    https://en.wikipedia.org/wiki/Double_factorial

    >>> from math import prod
    >>> all(double_factorial_recursive(i) == prod(range(i, 0, -2)) for i in range(20))
    True
    >>> double_factorial_recursive(0.1)
    Traceback (most recent call last):
        ...
    ValueError: double_factorial_recursive() only accepts integral values
    >>> double_factorial_recursive(-1)
    Traceback (most recent call last):
        ...
    ValueError: double_factorial_recursive() not defined for negative values
    """"""
    if not isinstance(n, int):
        raise ValueError(""double_factorial_recursive() only accepts integral values"")
    if n < 0:
        raise ValueError(""double_factorial_recursive() not defined for negative values"")
    return 1 if n <= 1 else n * double_factorial_recursive(n - 2)",data\repos\Python\maths\double_factorial.py,double_factorial_recursive,227
1396,double_factorial.py::double_factorial_iterative::28,"def double_factorial_iterative(num: int) -> int:
    """"""
    Compute double factorial using iterative method.

    To learn about the theory behind this algorithm:
    https://en.wikipedia.org/wiki/Double_factorial

    >>> from math import prod
    >>> all(double_factorial_iterative(i) == prod(range(i, 0, -2)) for i in range(20))
    True
    >>> double_factorial_iterative(0.1)
    Traceback (most recent call last):
        ...
    ValueError: double_factorial_iterative() only accepts integral values
    >>> double_factorial_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: double_factorial_iterative() not defined for negative values
    """"""
    if not isinstance(num, int):
        raise ValueError(""double_factorial_iterative() only accepts integral values"")
    if num < 0:
        raise ValueError(""double_factorial_iterative() not defined for negative values"")
    value = 1
    for i in range(num, 0, -2):
        value *= i
    return value",data\repos\Python\maths\double_factorial.py,double_factorial_iterative,231
1397,dual_number_automatic_differentiation.py::differentiate::95,"def differentiate(func, position, order):
    """"""
    >>> differentiate(lambda x: x**2, 2, 2)
    2
    >>> differentiate(lambda x: x**2 * x**4, 9, 2)
    196830
    >>> differentiate(lambda y: 0.5 * (y + 3) ** 6, 3.5, 4)
    7605.0
    >>> differentiate(lambda y: y ** 2, 4, 3)
    0
    >>> differentiate(8, 8, 8)
    Traceback (most recent call last):
        ...
    ValueError: differentiate() requires a function as input for func
    >>> differentiate(lambda x: x **2, """", 1)
    Traceback (most recent call last):
        ...
    ValueError: differentiate() requires a float as input for position
    >>> differentiate(lambda x: x**2, 3, """")
    Traceback (most recent call last):
        ...
    ValueError: differentiate() requires an int as input for order
    """"""
    if not callable(func):
        raise ValueError(""differentiate() requires a function as input for func"")
    if not isinstance(position, (float, int)):
        raise ValueError(""differentiate() requires a float as input for position"")
    if not isinstance(order, int):
        raise ValueError(""differentiate() requires an int as input for order"")
    d = Dual(position, 1)
    result = func(d)
    if order == 0:
        return result.real
    return result.duals[order - 1] * factorial(order)",data\repos\Python\maths\dual_number_automatic_differentiation.py,differentiate,339
1398,dual_number_automatic_differentiation.py::reduce::23,"    def reduce(self):
        cur = self.duals.copy()
        while cur[-1] == 0:
            cur.pop(-1)
        return Dual(self.real, cur)",data\repos\Python\maths\dual_number_automatic_differentiation.py,reduce,38
1399,entropy.py::calculate_prob::15,"def calculate_prob(text: str) -> None:
    """"""
    This method takes path and two dict as argument
    and than calculates entropy of them.
    :param dict:
    :param dict:
    :return: Prints
    1) Entropy of information based on 1 alphabet
    2) Entropy of information based on couples of 2 alphabet
    3) print Entropy of H(X n|Xn-1)

    Text from random books. Also, random quotes.
    >>> text = (""Behind Winston's back the voice ""
    ...         ""from the telescreen was still ""
    ...         ""babbling and the overfulfilment"")
    >>> calculate_prob(text)
    4.0
    6.0
    2.0

    >>> text = (""The Ministry of TruthMinitrue, in Newspeak [Newspeak was the official""
    ...         ""face in elegant lettering, the three"")
    >>> calculate_prob(text)
    4.0
    5.0
    1.0
    >>> text = (""Had repulsive dashwoods suspicion sincerity but advantage now him. ""
    ...         ""Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. ""
    ...         ""You greatest jointure saw horrible. He private he on be imagine ""
    ...         ""suppose. Fertile beloved evident through no service elderly is. Blind ""
    ...         ""there if every no so at. Own neglected you preferred way sincerity ""
    ...         ""delivered his attempted. To of message cottage windows do besides ""
    ...         ""against uncivil.  Delightful unreserved impossible few estimating ""
    ...         ""men favourable see entreaties. She propriety immediate was improving. ""
    ...         ""He or entrance humoured likewise moderate. Much nor game son say ""
    ...         ""feel. Fat make met can must form into gate. Me we offending prevailed ""
    ...         ""discovery."")
    >>> calculate_prob(text)
    4.0
    7.0
    3.0
    """"""
    single_char_strings, two_char_strings = analyze_text(text)
    my_alphas = list("" "" + ascii_lowercase)
    # what is our total sum of probabilities.
    all_sum = sum(single_char_strings.values())

    # one length string
    my_fir_sum = 0
    # for each alpha we go in our dict and if it is in it we calculate entropy
    for ch in my_alphas:
        if ch in single_char_strings:
            my_str = single_char_strings[ch]
            prob = my_str / all_sum
            my_fir_sum += prob * math.log2(prob)  # entropy formula.

    # print entropy
    print(f""{round(-1 * my_fir_sum):.1f}"")

    # two len string
    all_sum = sum(two_char_strings.values())
    my_sec_sum = 0
    # for each alpha (two in size) calculate entropy.
    for ch0 in my_alphas:
        for ch1 in my_alphas:
            sequence = ch0 + ch1
            if sequence in two_char_strings:
                my_str = two_char_strings[sequence]
                prob = int(my_str) / all_sum
                my_sec_sum += prob * math.log2(prob)

    # print second entropy
    print(f""{round(-1 * my_sec_sum):.1f}"")

    # print the difference between them
    print(f""{round((-1 * my_sec_sum) - (-1 * my_fir_sum)):.1f}"")",data\repos\Python\maths\entropy.py,calculate_prob,765
1400,entropy.py::analyze_text::93,"def analyze_text(text: str) -> tuple[dict, dict]:
    """"""
    Convert text input into two dicts of counts.
    The first dictionary stores the frequency of single character strings.
    The second dictionary stores the frequency of two character strings.
    """"""
    single_char_strings = Counter()  # type: ignore[var-annotated]
    two_char_strings = Counter()  # type: ignore[var-annotated]
    single_char_strings[text[-1]] += 1

    # first case when we have space at start.
    two_char_strings["" "" + text[0]] += 1
    for i in range(len(text) - 1):
        single_char_strings[text[i]] += 1
        two_char_strings[text[i : i + 2]] += 1
    return single_char_strings, two_char_strings",data\repos\Python\maths\entropy.py,analyze_text,172
1401,euclidean_distance.py::euclidean_distance::12,"def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:
    """"""
    Calculate the distance between the two endpoints of two vectors.
    A vector is defined as a list, tuple, or numpy 1D array.
    >>> float(euclidean_distance((0, 0), (2, 2)))
    2.8284271247461903
    >>> float(euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2])))
    3.4641016151377544
    >>> float(euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])))
    8.0
    >>> float(euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8]))
    8.0
    """"""
    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))",data\repos\Python\maths\euclidean_distance.py,euclidean_distance,226
1402,euclidean_distance.py::euclidean_distance_no_np::28,"def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:
    """"""
    Calculate the distance between the two endpoints of two vectors without numpy.
    A vector is defined as a list, tuple, or numpy 1D array.
    >>> euclidean_distance_no_np((0, 0), (2, 2))
    2.8284271247461903
    >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])
    8.0
    """"""
    return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)",data\repos\Python\maths\euclidean_distance.py,euclidean_distance_no_np,161
1403,euclidean_distance.py::benchmark::42,"    def benchmark() -> None:
        """"""
        Benchmarks
        """"""
        from timeit import timeit

        print(""Without Numpy"")
        print(
            timeit(
                ""euclidean_distance_no_np([1, 2, 3], [4, 5, 6])"",
                number=10000,
                globals=globals(),
            )
        )
        print(""With Numpy"")
        print(
            timeit(
                ""euclidean_distance([1, 2, 3], [4, 5, 6])"",
                number=10000,
                globals=globals(),
            )
        )",data\repos\Python\maths\euclidean_distance.py,benchmark,131
1404,eulers_totient.py::totient::2,"def totient(n: int) -> list:
    """"""
    >>> n = 10
    >>> totient_calculation = totient(n)
    >>> for i in range(1, n):
    ...     print(f""{i} has {totient_calculation[i]} relative primes."")
    1 has 0 relative primes.
    2 has 1 relative primes.
    3 has 2 relative primes.
    4 has 2 relative primes.
    5 has 4 relative primes.
    6 has 2 relative primes.
    7 has 6 relative primes.
    8 has 4 relative primes.
    9 has 6 relative primes.
    """"""
    is_prime = [True for i in range(n + 1)]
    totients = [i - 1 for i in range(n + 1)]
    primes = []
    for i in range(2, n + 1):
        if is_prime[i]:
            primes.append(i)
        for j in range(len(primes)):
            if i * primes[j] >= n:
                break
            is_prime[i * primes[j]] = False

            if i % primes[j] == 0:
                totients[i * primes[j]] = totients[i] * primes[j]
                break

            totients[i * primes[j]] = totients[i] * (primes[j] - 1)

    return totients",data\repos\Python\maths\eulers_totient.py,totient,295
1405,euler_method.py::explicit_euler::6,"def explicit_euler(
    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float
) -> np.ndarray:
    """"""Calculate numeric solution at each step to an ODE using Euler's Method

    For reference to Euler's method refer to https://en.wikipedia.org/wiki/Euler_method.

    Args:
        ode_func (Callable):  The ordinary differential equation
            as a function of x and y.
        y0 (float): The initial value for y.
        x0 (float): The initial value for x.
        step_size (float): The increment value for x.
        x_end (float): The final value of x to be calculated.

    Returns:
        np.ndarray: Solution of y for every step in x.

    >>> # the exact solution is math.exp(x)
    >>> def f(x, y):
    ...     return y
    >>> y0 = 1
    >>> y = explicit_euler(f, y0, 0.0, 0.01, 5)
    >>> float(y[-1])
    144.77277243257308
    """"""
    n = int(np.ceil((x_end - x0) / step_size))
    y = np.zeros((n + 1,))
    y[0] = y0
    x = x0

    for k in range(n):
        y[k + 1] = y[k] + step_size * ode_func(x, y[k])
        x += step_size

    return y",data\repos\Python\maths\euler_method.py,explicit_euler,321
1406,euler_modified.py::euler_modified::6,"def euler_modified(
    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float
) -> np.ndarray:
    """"""
    Calculate solution at each step to an ODE using Euler's Modified Method
    The Euler Method is straightforward to implement, but can't give accurate solutions.
    So, some changes were proposed to improve accuracy.

    https://en.wikipedia.org/wiki/Euler_method

    Arguments:
    ode_func -- The ode as a function of x and y
    y0 -- the initial value for y
    x0 -- the initial value for x
    stepsize -- the increment value for x
    x_end -- the end value for x

    >>> # the exact solution is math.exp(x)
    >>> def f1(x, y):
    ...     return -2*x*(y**2)
    >>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)
    >>> float(y[-1])
    0.503338255442106
    >>> import math
    >>> def f2(x, y):
    ...     return -2*y + (x**3)*math.exp(-2*x)
    >>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)
    >>> float(y[-1])
    0.5525976431951775
    """"""
    n = int(np.ceil((x_end - x0) / step_size))
    y = np.zeros((n + 1,))
    y[0] = y0
    x = x0

    for k in range(n):
        y_get = y[k] + step_size * ode_func(x, y[k])
        y[k + 1] = y[k] + (
            (step_size / 2) * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))
        )
        x += step_size

    return y",data\repos\Python\maths\euler_modified.py,euler_modified,428
1407,extended_euclidean_algorithm.py::extended_euclidean_algorithm::20,"def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:
    """"""
    Extended Euclidean Algorithm.

    Finds 2 numbers a and b such that it satisfies
    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)

    >>> extended_euclidean_algorithm(1, 24)
    (1, 0)

    >>> extended_euclidean_algorithm(8, 14)
    (2, -1)

    >>> extended_euclidean_algorithm(240, 46)
    (-9, 47)

    >>> extended_euclidean_algorithm(1, -4)
    (1, 0)

    >>> extended_euclidean_algorithm(-2, -4)
    (-1, 0)

    >>> extended_euclidean_algorithm(0, -4)
    (0, -1)

    >>> extended_euclidean_algorithm(2, 0)
    (1, 0)

    """"""
    # base cases
    if abs(a) == 1:
        return a, 0
    elif abs(b) == 1:
        return 0, b

    old_remainder, remainder = a, b
    old_coeff_a, coeff_a = 1, 0
    old_coeff_b, coeff_b = 0, 1

    while remainder != 0:
        quotient = old_remainder // remainder
        old_remainder, remainder = remainder, old_remainder - quotient * remainder
        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a
        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b

    # sign correction for negative numbers
    if a < 0:
        old_coeff_a = -old_coeff_a
    if b < 0:
        old_coeff_b = -old_coeff_b

    return old_coeff_a, old_coeff_b",data\repos\Python\maths\extended_euclidean_algorithm.py,extended_euclidean_algorithm,404
1408,extended_euclidean_algorithm.py::main::74,"def main():
    """"""Call Extended Euclidean Algorithm.""""""
    if len(sys.argv) < 3:
        print(""2 integer arguments required"")
        return 1
    a = int(sys.argv[1])
    b = int(sys.argv[2])
    print(extended_euclidean_algorithm(a, b))
    return 0",data\repos\Python\maths\extended_euclidean_algorithm.py,main,68
1409,factorial.py::factorial::6,"def factorial(number: int) -> int:
    """"""
    Calculate the factorial of specified number (n!).

    >>> import math
    >>> all(factorial(i) == math.factorial(i) for i in range(20))
    True
    >>> factorial(0.1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() only accepts integral values
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() not defined for negative values
    >>> factorial(1)
    1
    >>> factorial(6)
    720
    >>> factorial(0)
    1
    """"""
    if number != int(number):
        raise ValueError(""factorial() only accepts integral values"")
    if number < 0:
        raise ValueError(""factorial() not defined for negative values"")
    value = 1
    for i in range(1, number + 1):
        value *= i
    return value",data\repos\Python\maths\factorial.py,factorial,204
1410,factorial.py::factorial_recursive::38,"def factorial_recursive(n: int) -> int:
    """"""
    Calculate the factorial of a positive integer
    https://en.wikipedia.org/wiki/Factorial

    >>> import math
    >>> all(factorial(i) == math.factorial(i) for i in range(20))
    True
    >>> factorial(0.1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() only accepts integral values
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() not defined for negative values
    """"""
    if not isinstance(n, int):
        raise ValueError(""factorial() only accepts integral values"")
    if n < 0:
        raise ValueError(""factorial() not defined for negative values"")
    return 1 if n in {0, 1} else n * factorial_recursive(n - 1)",data\repos\Python\maths\factorial.py,factorial_recursive,182
1411,factors.py::factors_of_a_number::5,"def factors_of_a_number(num: int) -> list:
    """"""
    >>> factors_of_a_number(1)
    [1]
    >>> factors_of_a_number(5)
    [1, 5]
    >>> factors_of_a_number(24)
    [1, 2, 3, 4, 6, 8, 12, 24]
    >>> factors_of_a_number(-24)
    []
    """"""
    facs: list[int] = []
    if num < 1:
        return facs
    facs.append(1)
    if num == 1:
        return facs
    facs.append(num)
    for i in range(2, int(sqrt(num)) + 1):
        if num % i == 0:  # If i is a factor of num
            facs.append(i)
            d = num // i  # num//i is the other factor of num
            if d != i:  # If d and i are distinct
                facs.append(d)  # we have found another factor
    facs.sort()
    return facs",data\repos\Python\maths\factors.py,factors_of_a_number,233
1412,fast_inverse_sqrt.py::fast_inverse_sqrt::10,"def fast_inverse_sqrt(number: float) -> float:
    """"""
    Compute the fast inverse square root of a floating-point number using the famous
    Quake III algorithm.

    :param float number: Input number for which to calculate the inverse square root.
    :return float: The fast inverse square root of the input number.

    Example:
    >>> fast_inverse_sqrt(10)
    0.3156857923527257
    >>> fast_inverse_sqrt(4)
    0.49915357479239103
    >>> fast_inverse_sqrt(4.1)
    0.4932849504615651
    >>> fast_inverse_sqrt(0)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a positive number.
    >>> fast_inverse_sqrt(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a positive number.
    >>> from math import isclose, sqrt
    >>> all(isclose(fast_inverse_sqrt(i), 1 / sqrt(i), rel_tol=0.00132)
    ...     for i in range(50, 60))
    True
    """"""
    if number <= 0:
        raise ValueError(""Input must be a positive number."")
    i = struct.unpack("">i"", struct.pack("">f"", number))[0]
    i = 0x5F3759DF - (i >> 1)
    y = struct.unpack("">f"", struct.pack("">i"", i))[0]
    return y * (1.5 - 0.5 * number * y * y)",data\repos\Python\maths\fast_inverse_sqrt.py,fast_inverse_sqrt,331
1413,fermat_little_theorem.py::binary_exponentiation::8,"def binary_exponentiation(a: int, n: float, mod: int) -> int:
    if n == 0:
        return 1

    elif n % 2 == 1:
        return (binary_exponentiation(a, n - 1, mod) * a) % mod

    else:
        b = binary_exponentiation(a, n / 2, mod)
        return (b * b) % mod",data\repos\Python\maths\fermat_little_theorem.py,binary_exponentiation,92
1414,fibonacci.py::time_func::26,"def time_func(func, *args, **kwargs):
    """"""
    Times the execution of a function with parameters
    """"""
    start = time()
    output = func(*args, **kwargs)
    end = time()
    if int(end - start) > 0:
        print(f""{func.__name__} runtime: {(end - start):0.4f} s"")
    else:
        print(f""{func.__name__} runtime: {(end - start) * 1000:0.4f} ms"")
    return output",data\repos\Python\maths\fibonacci.py,time_func,113
1415,fibonacci.py::fib_iterative_yield::40,"def fib_iterative_yield(n: int) -> Iterator[int]:
    """"""
    Calculates the first n (1-indexed) Fibonacci numbers using iteration with yield
    >>> list(fib_iterative_yield(0))
    [0]
    >>> tuple(fib_iterative_yield(1))
    (0, 1)
    >>> tuple(fib_iterative_yield(5))
    (0, 1, 1, 2, 3, 5)
    >>> tuple(fib_iterative_yield(10))
    (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
    >>> tuple(fib_iterative_yield(-1))
    Traceback (most recent call last):
        ...
    ValueError: n is negative
    """"""
    if n < 0:
        raise ValueError(""n is negative"")
    a, b = 0, 1
    yield a
    for _ in range(n):
        yield b
        a, b = b, a + b",data\repos\Python\maths\fibonacci.py,fib_iterative_yield,222
1416,fibonacci.py::fib_iterative::65,"def fib_iterative(n: int) -> list[int]:
    """"""
    Calculates the first n (0-indexed) Fibonacci numbers using iteration
    >>> fib_iterative(0)
    [0]
    >>> fib_iterative(1)
    [0, 1]
    >>> fib_iterative(5)
    [0, 1, 1, 2, 3, 5]
    >>> fib_iterative(10)
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    >>> fib_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: n is negative
    """"""
    if n < 0:
        raise ValueError(""n is negative"")
    if n == 0:
        return [0]
    fib = [0, 1]
    for _ in range(n - 1):
        fib.append(fib[-1] + fib[-2])
    return fib",data\repos\Python\maths\fibonacci.py,fib_iterative,215
1417,fibonacci.py::fib_recursive::91,"def fib_recursive(n: int) -> list[int]:
    """"""
    Calculates the first n (0-indexed) Fibonacci numbers using recursion
    >>> fib_iterative(0)
    [0]
    >>> fib_iterative(1)
    [0, 1]
    >>> fib_iterative(5)
    [0, 1, 1, 2, 3, 5]
    >>> fib_iterative(10)
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    >>> fib_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: n is negative
    """"""

    def fib_recursive_term(i: int) -> int:
        """"""
        Calculates the i-th (0-indexed) Fibonacci number using recursion
        >>> fib_recursive_term(0)
        0
        >>> fib_recursive_term(1)
        1
        >>> fib_recursive_term(5)
        5
        >>> fib_recursive_term(10)
        55
        >>> fib_recursive_term(-1)
        Traceback (most recent call last):
            ...
        Exception: n is negative
        """"""
        if i < 0:
            raise ValueError(""n is negative"")
        if i < 2:
            return i
        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)

    if n < 0:
        raise ValueError(""n is negative"")
    return [fib_recursive_term(i) for i in range(n + 1)]",data\repos\Python\maths\fibonacci.py,fib_recursive,334
1418,fibonacci.py::fib_recursive_cached::135,"def fib_recursive_cached(n: int) -> list[int]:
    """"""
    Calculates the first n (0-indexed) Fibonacci numbers using recursion
    >>> fib_iterative(0)
    [0]
    >>> fib_iterative(1)
    [0, 1]
    >>> fib_iterative(5)
    [0, 1, 1, 2, 3, 5]
    >>> fib_iterative(10)
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    >>> fib_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: n is negative
    """"""

    @functools.cache
    def fib_recursive_term(i: int) -> int:
        """"""
        Calculates the i-th (0-indexed) Fibonacci number using recursion
        """"""
        if i < 0:
            raise ValueError(""n is negative"")
        if i < 2:
            return i
        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)

    if n < 0:
        raise ValueError(""n is negative"")
    return [fib_recursive_term(i) for i in range(n + 1)]",data\repos\Python\maths\fibonacci.py,fib_recursive_cached,268
1419,fibonacci.py::fib_memoization::168,"def fib_memoization(n: int) -> list[int]:
    """"""
    Calculates the first n (0-indexed) Fibonacci numbers using memoization
    >>> fib_memoization(0)
    [0]
    >>> fib_memoization(1)
    [0, 1]
    >>> fib_memoization(5)
    [0, 1, 1, 2, 3, 5]
    >>> fib_memoization(10)
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    >>> fib_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: n is negative
    """"""
    if n < 0:
        raise ValueError(""n is negative"")
    # Cache must be outside recursive function
    # other it will reset every time it calls itself.
    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache

    def rec_fn_memoized(num: int) -> int:
        if num in cache:
            return cache[num]

        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)
        cache[num] = value
        return value

    return [rec_fn_memoized(i) for i in range(n + 1)]",data\repos\Python\maths\fibonacci.py,fib_memoization,307
1420,fibonacci.py::fib_binet::201,"def fib_binet(n: int) -> list[int]:
    """"""
    Calculates the first n (0-indexed) Fibonacci numbers using a simplified form
    of Binet's formula:
    https://en.m.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding

    NOTE 1: this function diverges from fib_iterative at around n = 71, likely
    due to compounding floating-point arithmetic errors

    NOTE 2: this function doesn't accept n >= 1475 because it overflows
    thereafter due to the size limitations of Python floats
    >>> fib_binet(0)
    [0]
    >>> fib_binet(1)
    [0, 1]
    >>> fib_binet(5)
    [0, 1, 1, 2, 3, 5]
    >>> fib_binet(10)
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    >>> fib_binet(-1)
    Traceback (most recent call last):
        ...
    ValueError: n is negative
    >>> fib_binet(1475)
    Traceback (most recent call last):
        ...
    ValueError: n is too large
    """"""
    if n < 0:
        raise ValueError(""n is negative"")
    if n >= 1475:
        raise ValueError(""n is too large"")
    sqrt_5 = sqrt(5)
    phi = (1 + sqrt_5) / 2
    return [round(phi**i / sqrt_5) for i in range(n + 1)]",data\repos\Python\maths\fibonacci.py,fib_binet,348
1421,fibonacci.py::matrix_pow_np::238,"def matrix_pow_np(m: ndarray, power: int) -> ndarray:
    """"""
    Raises a matrix to the power of 'power' using binary exponentiation.

    Args:
        m: Matrix as a numpy array.
        power: The power to which the matrix is to be raised.

    Returns:
        The matrix raised to the power.

    Raises:
        ValueError: If power is negative.

    >>> m = np.array([[1, 1], [1, 0]], dtype=int)
    >>> matrix_pow_np(m, 0)  # Identity matrix when raised to the power of 0
    array([[1, 0],
           [0, 1]])

    >>> matrix_pow_np(m, 1)  # Same matrix when raised to the power of 1
    array([[1, 1],
           [1, 0]])

    >>> matrix_pow_np(m, 5)
    array([[8, 5],
           [5, 3]])

    >>> matrix_pow_np(m, -1)
    Traceback (most recent call last):
        ...
    ValueError: power is negative
    """"""
    result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix
    base = m
    if power < 0:  # Negative power is not allowed
        raise ValueError(""power is negative"")
    while power:
        if power % 2 == 1:
            result = np.dot(result, base)
        base = np.dot(base, base)
        power //= 2
    return result",data\repos\Python\maths\fibonacci.py,matrix_pow_np,327
1422,fibonacci.py::fib_matrix_np::282,"def fib_matrix_np(n: int) -> int:
    """"""
    Calculates the n-th Fibonacci number using matrix exponentiation.
    https://www.nayuki.io/page/fast-fibonacci-algorithms#:~:text=
    Summary:%20The%20two%20fast%20Fibonacci%20algorithms%20are%20matrix

    Args:
        n: Fibonacci sequence index

    Returns:
        The n-th Fibonacci number.

    Raises:
        ValueError: If n is negative.

    >>> fib_matrix_np(0)
    0
    >>> fib_matrix_np(1)
    1
    >>> fib_matrix_np(5)
    5
    >>> fib_matrix_np(10)
    55
    >>> fib_matrix_np(-1)
    Traceback (most recent call last):
        ...
    ValueError: n is negative
    """"""
    if n < 0:
        raise ValueError(""n is negative"")
    if n == 0:
        return 0

    m = np.array([[1, 1], [1, 0]], dtype=int)
    result = matrix_pow_np(m, n - 1)
    return int(result[0, 0])",data\repos\Python\maths\fibonacci.py,fib_matrix_np,249
1423,fibonacci.py::fib_recursive_term::108,"    def fib_recursive_term(i: int) -> int:
        """"""
        Calculates the i-th (0-indexed) Fibonacci number using recursion
        >>> fib_recursive_term(0)
        0
        >>> fib_recursive_term(1)
        1
        >>> fib_recursive_term(5)
        5
        >>> fib_recursive_term(10)
        55
        >>> fib_recursive_term(-1)
        Traceback (most recent call last):
            ...
        Exception: n is negative
        """"""
        if i < 0:
            raise ValueError(""n is negative"")
        if i < 2:
            return i
        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)",data\repos\Python\maths\fibonacci.py,fib_recursive_term,150
1424,fibonacci.py::fib_recursive_term::153,"    def fib_recursive_term(i: int) -> int:
        """"""
        Calculates the i-th (0-indexed) Fibonacci number using recursion
        """"""
        if i < 0:
            raise ValueError(""n is negative"")
        if i < 2:
            return i
        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)",data\repos\Python\maths\fibonacci.py,fib_recursive_term,76
1425,fibonacci.py::rec_fn_memoized::190,"    def rec_fn_memoized(num: int) -> int:
        if num in cache:
            return cache[num]

        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)
        cache[num] = value
        return value",data\repos\Python\maths\fibonacci.py,rec_fn_memoized,59
1426,find_max.py::find_max_iterative::4,"def find_max_iterative(nums: list[int | float]) -> int | float:
    """"""
    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
    ...     find_max_iterative(nums) == max(nums)
    True
    True
    True
    True
    >>> find_max_iterative([2, 4, 9, 7, 19, 94, 5])
    94
    >>> find_max_iterative([])
    Traceback (most recent call last):
        ...
    ValueError: find_max_iterative() arg is an empty sequence
    """"""
    if len(nums) == 0:
        raise ValueError(""find_max_iterative() arg is an empty sequence"")
    max_num = nums[0]
    for x in nums:
        if x > max_num:  # noqa: PLR1730
            max_num = x
    return max_num",data\repos\Python\maths\find_max.py,find_max_iterative,220
1427,find_max.py::find_max_recursive::29,"def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:
    """"""
    find max value in list
    :param nums: contains elements
    :param left: index of first element
    :param right: index of last element
    :return: max in nums

    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
    ...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums)
    True
    True
    True
    True
    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
    >>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums)
    True
    >>> find_max_recursive([], 0, 0)
    Traceback (most recent call last):
        ...
    ValueError: find_max_recursive() arg is an empty sequence
    >>> find_max_recursive(nums, 0, len(nums)) == max(nums)
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    >>> find_max_recursive(nums, -len(nums), -1) == max(nums)
    True
    >>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums)
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    """"""
    if len(nums) == 0:
        raise ValueError(""find_max_recursive() arg is an empty sequence"")
    if (
        left >= len(nums)
        or left < -len(nums)
        or right >= len(nums)
        or right < -len(nums)
    ):
        raise IndexError(""list index out of range"")
    if left == right:
        return nums[left]
    mid = (left + right) >> 1  # the middle
    left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]
    right_max = find_max_recursive(
        nums, mid + 1, right
    )  # find max in range[mid + 1, right]

    return left_max if left_max >= right_max else right_max",data\repos\Python\maths\find_max.py,find_max_recursive,509
1428,find_min.py::find_min_iterative::4,"def find_min_iterative(nums: list[int | float]) -> int | float:
    """"""
    Find Minimum Number in a List
    :param nums: contains elements
    :return: min number in list

    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
    ...     find_min_iterative(nums) == min(nums)
    True
    True
    True
    True
    >>> find_min_iterative([0, 1, 2, 3, 4, 5, -3, 24, -56])
    -56
    >>> find_min_iterative([])
    Traceback (most recent call last):
        ...
    ValueError: find_min_iterative() arg is an empty sequence
    """"""
    if len(nums) == 0:
        raise ValueError(""find_min_iterative() arg is an empty sequence"")
    min_num = nums[0]
    for num in nums:
        min_num = min(min_num, num)
    return min_num",data\repos\Python\maths\find_min.py,find_min_iterative,239
1429,find_min.py::find_min_recursive::32,"def find_min_recursive(nums: list[int | float], left: int, right: int) -> int | float:
    """"""
    find min value in list
    :param nums: contains elements
    :param left: index of first element
    :param right: index of last element
    :return: min in nums

    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
    ...     find_min_recursive(nums, 0, len(nums) - 1) == min(nums)
    True
    True
    True
    True
    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
    >>> find_min_recursive(nums, 0, len(nums) - 1) == min(nums)
    True
    >>> find_min_recursive([], 0, 0)
    Traceback (most recent call last):
        ...
    ValueError: find_min_recursive() arg is an empty sequence
    >>> find_min_recursive(nums, 0, len(nums)) == min(nums)
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    >>> find_min_recursive(nums, -len(nums), -1) == min(nums)
    True
    >>> find_min_recursive(nums, -len(nums) - 1, -1) == min(nums)
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    """"""
    if len(nums) == 0:
        raise ValueError(""find_min_recursive() arg is an empty sequence"")
    if (
        left >= len(nums)
        or left < -len(nums)
        or right >= len(nums)
        or right < -len(nums)
    ):
        raise IndexError(""list index out of range"")
    if left == right:
        return nums[left]
    mid = (left + right) >> 1  # the middle
    left_min = find_min_recursive(nums, left, mid)  # find min in range[left, mid]
    right_min = find_min_recursive(
        nums, mid + 1, right
    )  # find min in range[mid + 1, right]

    return left_min if left_min <= right_min else right_min",data\repos\Python\maths\find_min.py,find_min_recursive,509
1430,floor.py::floor::6,"def floor(x: float) -> int:
    """"""
    Return the floor of x as an Integral.
    :param x: the number
    :return: the largest integer <= x.
    >>> import math
    >>> all(floor(n) == math.floor(n) for n
    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))
    True
    """"""
    return int(x) if x - int(x) >= 0 else int(x) - 1",data\repos\Python\maths\floor.py,floor,129
1431,gamma.py::gamma_iterative::18,"def gamma_iterative(num: float) -> float:
    """"""
    Calculates the value of Gamma function of num
    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).

    >>> gamma_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: math domain error
    >>> gamma_iterative(0)
    Traceback (most recent call last):
        ...
    ValueError: math domain error
    >>> gamma_iterative(9)
    40320.0
    >>> from math import gamma as math_gamma
    >>> all(.99999999 < gamma_iterative(i) / math_gamma(i) <= 1.000000001
    ...     for i in range(1, 50))
    True
    >>> gamma_iterative(-1)/math_gamma(-1) <= 1.000000001
    Traceback (most recent call last):
        ...
    ValueError: math domain error
    >>> gamma_iterative(3.3) - math_gamma(3.3) <= 0.00000001
    True
    """"""
    if num <= 0:
        raise ValueError(""math domain error"")

    return quad(integrand, 0, inf, args=(num))[0]",data\repos\Python\maths\gamma.py,gamma_iterative,283
1432,gamma.py::integrand::50,"def integrand(x: float, z: float) -> float:
    return math.pow(x, z - 1) * math.exp(-x)",data\repos\Python\maths\gamma.py,integrand,31
1433,gamma.py::gamma_recursive::54,"def gamma_recursive(num: float) -> float:
    """"""
    Calculates the value of Gamma function of num
    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).
    Implemented using recursion
    Examples:
    >>> from math import isclose, gamma as math_gamma
    >>> gamma_recursive(0.5)
    1.7724538509055159
    >>> gamma_recursive(1)
    1.0
    >>> gamma_recursive(2)
    1.0
    >>> gamma_recursive(3.5)
    3.3233509704478426
    >>> gamma_recursive(171.5)
    9.483367566824795e+307
    >>> all(isclose(gamma_recursive(num), math_gamma(num))
    ...     for num in (0.5, 2, 3.5, 171.5))
    True
    >>> gamma_recursive(0)
    Traceback (most recent call last):
        ...
    ValueError: math domain error
    >>> gamma_recursive(-1.1)
    Traceback (most recent call last):
        ...
    ValueError: math domain error
    >>> gamma_recursive(-4)
    Traceback (most recent call last):
        ...
    ValueError: math domain error
    >>> gamma_recursive(172)
    Traceback (most recent call last):
        ...
    OverflowError: math range error
    >>> gamma_recursive(1.1)
    Traceback (most recent call last):
        ...
    NotImplementedError: num must be an integer or a half-integer
    """"""
    if num <= 0:
        raise ValueError(""math domain error"")
    if num > 171.5:
        raise OverflowError(""math range error"")
    elif num - int(num) not in (0, 0.5):
        raise NotImplementedError(""num must be an integer or a half-integer"")
    elif num == 0.5:
        return math.sqrt(math.pi)
    else:
        return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)",data\repos\Python\maths\gamma.py,gamma_recursive,460
1434,gaussian.py::gaussian::8,"def gaussian(x, mu: float = 0.0, sigma: float = 1.0) -> float:
    """"""
    >>> float(gaussian(1))
    0.24197072451914337

    >>> float(gaussian(24))
    3.342714441794458e-126

    >>> float(gaussian(1, 4, 2))
    0.06475879783294587

    >>> float(gaussian(1, 5, 3))
    0.05467002489199788

    Supports NumPy Arrays
    Use numpy.meshgrid with this to generate gaussian blur on images.
    >>> import numpy as np
    >>> x = np.arange(15)
    >>> gaussian(x)
    array([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,
           1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,
           5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,
           2.14638374e-32, 7.99882776e-38, 1.09660656e-43])

    >>> float(gaussian(15))
    5.530709549844416e-50

    >>> gaussian([1,2, 'string'])
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for -: 'list' and 'float'

    >>> gaussian('hello world')
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for -: 'str' and 'float'

    >>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
        ...
    OverflowError: (34, 'Result too large')

    >>> float(gaussian(10**-326))
    0.3989422804014327

    >>> float(gaussian(2523, mu=234234, sigma=3425))
    0.0
    """"""
    return 1 / sqrt(2 * pi * sigma**2) * exp(-((x - mu) ** 2) / (2 * sigma**2))",data\repos\Python\maths\gaussian.py,gaussian,532
1435,gcd_of_n_numbers.py::get_factors::9,"def get_factors(
    number: int, factors: Counter | None = None, factor: int = 2
) -> Counter:
    """"""
    this is a recursive function for get all factors of number
    >>> get_factors(45)
    Counter({3: 2, 5: 1})
    >>> get_factors(2520)
    Counter({2: 3, 3: 2, 5: 1, 7: 1})
    >>> get_factors(23)
    Counter({23: 1})
    >>> get_factors(0)
    Traceback (most recent call last):
        ...
    TypeError: number must be integer and greater than zero
    >>> get_factors(-1)
    Traceback (most recent call last):
        ...
    TypeError: number must be integer and greater than zero
    >>> get_factors(1.5)
    Traceback (most recent call last):
        ...
    TypeError: number must be integer and greater than zero

    factor can be all numbers from 2 to number that we check if number % factor == 0
    if it is equal to zero, we check again with number // factor
    else we increase factor by one
    """"""

    match number:
        case int(number) if number == 1:
            return Counter({1: 1})
        case int(num) if number > 0:
            number = num
        case _:
            raise TypeError(""number must be integer and greater than zero"")

    factors = factors or Counter()

    if number == factor:  # break condition
        # all numbers are factors of itself
        factors[factor] += 1
        return factors

    if number % factor > 0:
        # if it is greater than zero
        # so it is not a factor of number and we check next number
        return get_factors(number, factors, factor + 1)

    factors[factor] += 1
    # else we update factors (that is Counter(dict-like) type) and check again
    return get_factors(number // factor, factors, factor)",data\repos\Python\maths\gcd_of_n_numbers.py,get_factors,437
1436,gcd_of_n_numbers.py::get_greatest_common_divisor::63,"def get_greatest_common_divisor(*numbers: int) -> int:
    """"""
    get gcd of n numbers:
    >>> get_greatest_common_divisor(18, 45)
    9
    >>> get_greatest_common_divisor(23, 37)
    1
    >>> get_greatest_common_divisor(2520, 8350)
    10
    >>> get_greatest_common_divisor(-10, 20)
    Traceback (most recent call last):
        ...
    Exception: numbers must be integer and greater than zero
    >>> get_greatest_common_divisor(1.5, 2)
    Traceback (most recent call last):
        ...
    Exception: numbers must be integer and greater than zero
    >>> get_greatest_common_divisor(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    1
    >>> get_greatest_common_divisor(""1"", 2, 3, 4, 5, 6, 7, 8, 9, 10)
    Traceback (most recent call last):
        ...
    Exception: numbers must be integer and greater than zero
    """"""

    # we just need factors, not numbers itself
    try:
        same_factors, *factors = map(get_factors, numbers)
    except TypeError as e:
        raise Exception(""numbers must be integer and greater than zero"") from e

    for factor in factors:
        same_factors &= factor
        # get common factor between all
        # `&` return common elements with smaller value (for Counter type)

    # now, same_factors is something like {2: 2, 3: 4} that means 2 * 2 * 3 * 3 * 3 * 3
    mult = 1
    # power each factor and multiply
    # for {2: 2, 3: 4}, it is [4, 81] and then 324
    for m in [factor**power for factor, power in same_factors.items()]:
        mult *= m
    return mult",data\repos\Python\maths\gcd_of_n_numbers.py,get_greatest_common_divisor,456
1437,geometric_mean.py::compute_geometric_mean::8,"def compute_geometric_mean(*args: int) -> float:
    """"""
    Return the geometric mean of the argument numbers.
    >>> compute_geometric_mean(2,8)
    4.0
    >>> compute_geometric_mean('a', 4)
    Traceback (most recent call last):
        ...
    TypeError: Not a Number
    >>> compute_geometric_mean(5, 125)
    25.0
    >>> compute_geometric_mean(1, 0)
    0.0
    >>> compute_geometric_mean(1, 5, 25, 5)
    5.0
    >>> compute_geometric_mean(2, -2)
    Traceback (most recent call last):
        ...
    ArithmeticError: Cannot Compute Geometric Mean for these numbers.
    >>> compute_geometric_mean(-5, 25, 1)
    -5.0
    """"""
    product = 1
    for number in args:
        if not isinstance(number, int) and not isinstance(number, float):
            raise TypeError(""Not a Number"")
        product *= number
    # Cannot calculate the even root for negative product.
    # Frequently they are restricted to being positive.
    if product < 0 and len(args) % 2 == 0:
        raise ArithmeticError(""Cannot Compute Geometric Mean for these numbers."")
    mean = abs(product) ** (1 / len(args))
    # Since python calculates complex roots for negative products with odd roots.
    if product < 0:
        mean = -mean
    # Since it does floating point arithmetic, it gives 64**(1/3) as 3.99999996
    possible_mean = float(round(mean))
    # To check if the rounded number is actually the mean.
    if possible_mean ** len(args) == product:
        mean = possible_mean
    return mean",data\repos\Python\maths\geometric_mean.py,compute_geometric_mean,390
1438,germain_primes.py::is_germain_prime::14,"def is_germain_prime(number: int) -> bool:
    """"""Checks if input number and 2*number + 1 are prime.

    >>> is_germain_prime(3)
    True
    >>> is_germain_prime(11)
    True
    >>> is_germain_prime(4)
    False
    >>> is_germain_prime(23)
    True
    >>> is_germain_prime(13)
    False
    >>> is_germain_prime(20)
    False
    >>> is_germain_prime('abc')
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a positive integer. Input value: abc
    """"""
    if not isinstance(number, int) or number < 1:
        msg = f""Input value must be a positive integer. Input value: {number}""
        raise TypeError(msg)

    return is_prime(number) and is_prime(2 * number + 1)",data\repos\Python\maths\germain_primes.py,is_germain_prime,202
1439,germain_primes.py::is_safe_prime::41,"def is_safe_prime(number: int) -> bool:
    """"""Checks if input number and (number - 1)/2 are prime.
    The smallest safe prime is 5, with the Germain prime is 2.

    >>> is_safe_prime(5)
    True
    >>> is_safe_prime(11)
    True
    >>> is_safe_prime(1)
    False
    >>> is_safe_prime(2)
    False
    >>> is_safe_prime(3)
    False
    >>> is_safe_prime(47)
    True
    >>> is_safe_prime('abc')
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a positive integer. Input value: abc
    """"""
    if not isinstance(number, int) or number < 1:
        msg = f""Input value must be a positive integer. Input value: {number}""
        raise TypeError(msg)

    return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)",data\repos\Python\maths\germain_primes.py,is_safe_prime,219
1440,greatest_common_divisor.py::greatest_common_divisor::10,"def greatest_common_divisor(a: int, b: int) -> int:
    """"""
    Calculate Greatest Common Divisor (GCD).
    >>> greatest_common_divisor(24, 40)
    8
    >>> greatest_common_divisor(1, 1)
    1
    >>> greatest_common_divisor(1, 800)
    1
    >>> greatest_common_divisor(11, 37)
    1
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(16, 4)
    4
    >>> greatest_common_divisor(-3, 9)
    3
    >>> greatest_common_divisor(9, -3)
    3
    >>> greatest_common_divisor(3, -9)
    3
    >>> greatest_common_divisor(-3, -9)
    3
    """"""
    return abs(b) if a == 0 else greatest_common_divisor(b % a, a)",data\repos\Python\maths\greatest_common_divisor.py,greatest_common_divisor,211
1441,greatest_common_divisor.py::gcd_by_iterative::37,"def gcd_by_iterative(x: int, y: int) -> int:
    """"""
    Below method is more memory efficient because it does not create additional
    stack frames for recursive functions calls (as done in the above method).
    >>> gcd_by_iterative(24, 40)
    8
    >>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)
    True
    >>> gcd_by_iterative(-3, -9)
    3
    >>> gcd_by_iterative(3, -9)
    3
    >>> gcd_by_iterative(1, -800)
    1
    >>> gcd_by_iterative(11, 37)
    1
    """"""
    while y:  # --> when y=0 then loop will terminate and return x as final GCD.
        x, y = y, x % y
    return abs(x)",data\repos\Python\maths\greatest_common_divisor.py,gcd_by_iterative,194
1442,greatest_common_divisor.py::main::59,"def main():
    """"""
    Call Greatest Common Divisor function.
    """"""
    try:
        nums = input(""Enter two integers separated by comma (,): "").split("","")
        num_1 = int(nums[0])
        num_2 = int(nums[1])
        print(
            f""greatest_common_divisor({num_1}, {num_2}) = ""
            f""{greatest_common_divisor(num_1, num_2)}""
        )
        print(f""By iterative gcd({num_1}, {num_2}) = {gcd_by_iterative(num_1, num_2)}"")
    except (IndexError, UnboundLocalError, ValueError):
        print(""Wrong input"")",data\repos\Python\maths\greatest_common_divisor.py,main,146
1443,hardy_ramanujanalgo.py::exact_prime_factor_count::7,"def exact_prime_factor_count(n: int) -> int:
    """"""
    >>> exact_prime_factor_count(51242183)
    3
    """"""
    count = 0
    if n % 2 == 0:
        count += 1
        while n % 2 == 0:
            n = int(n / 2)
    # the n input value must be odd so that
    # we can skip one element (ie i += 2)

    i = 3

    while i <= int(math.sqrt(n)):
        if n % i == 0:
            count += 1
            while n % i == 0:
                n = int(n / i)
        i = i + 2

    # this condition checks the prime
    # number n is greater than 2

    if n > 2:
        count += 1
    return count",data\repos\Python\maths\hardy_ramanujanalgo.py,exact_prime_factor_count,187
1444,integer_square_root.py::integer_square_root::16,"def integer_square_root(num: int) -> int:
    """"""
    Returns the integer square root of a non-negative integer num.
    Args:
        num: A non-negative integer.
    Returns:
        The integer square root of num.
    Raises:
        ValueError: If num is not an integer or is negative.
    >>> [integer_square_root(i) for i in range(18)]
    [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4]
    >>> integer_square_root(625)
    25
    >>> integer_square_root(2_147_483_647)
    46340
    >>> from math import isqrt
    >>> all(integer_square_root(i) == isqrt(i) for i in range(20))
    True
    >>> integer_square_root(-1)
    Traceback (most recent call last):
        ...
    ValueError: num must be non-negative integer
    >>> integer_square_root(1.5)
    Traceback (most recent call last):
        ...
    ValueError: num must be non-negative integer
    >>> integer_square_root(""0"")
    Traceback (most recent call last):
        ...
    ValueError: num must be non-negative integer
    """"""
    if not isinstance(num, int) or num < 0:
        raise ValueError(""num must be non-negative integer"")

    if num < 2:
        return num

    left_bound = 0
    right_bound = num // 2

    while left_bound <= right_bound:
        mid = left_bound + (right_bound - left_bound) // 2
        mid_squared = mid * mid
        if mid_squared == num:
            return mid

        if mid_squared < num:
            left_bound = mid + 1
        else:
            right_bound = mid - 1

    return right_bound",data\repos\Python\maths\integer_square_root.py,integer_square_root,415
1445,interquartile_range.py::find_median::14,"def find_median(nums: list[int | float]) -> float:
    """"""
    This is the implementation of the median.
    :param nums: The list of numeric nums
    :return: Median of the list
    >>> find_median(nums=([1, 2, 2, 3, 4]))
    2
    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))
    2.5
    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))
    1.5
    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))
    2.65
    """"""
    div, mod = divmod(len(nums), 2)
    if mod:
        return nums[div]
    return (nums[div] + nums[(div) - 1]) / 2",data\repos\Python\maths\interquartile_range.py,find_median,211
1446,interquartile_range.py::interquartile_range::34,"def interquartile_range(nums: list[int | float]) -> float:
    """"""
    Return the interquartile range for a list of numeric values.
    :param nums: The list of numeric values.
    :return: interquartile range

    >>> interquartile_range(nums=[4, 1, 2, 3, 2])
    2.0
    >>> interquartile_range(nums = [-2, -7, -10, 9, 8, 4, -67, 45])
    17.0
    >>> interquartile_range(nums = [-2.1, -7.1, -10.1, 9.1, 8.1, 4.1, -67.1, 45.1])
    17.2
    >>> interquartile_range(nums = [0, 0, 0, 0, 0])
    0.0
    >>> interquartile_range(nums=[])
    Traceback (most recent call last):
    ...
    ValueError: The list is empty. Provide a non-empty list.
    """"""
    if not nums:
        raise ValueError(""The list is empty. Provide a non-empty list."")
    nums.sort()
    length = len(nums)
    div, mod = divmod(length, 2)
    q1 = find_median(nums[:div])
    half_length = sum((div, mod))
    q3 = find_median(nums[half_length:length])
    return q3 - q1",data\repos\Python\maths\interquartile_range.py,interquartile_range,325
1447,is_int_palindrome.py::is_int_palindrome::1,"def is_int_palindrome(num: int) -> bool:
    """"""
    Returns whether `num` is a palindrome or not
    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).

    >>> is_int_palindrome(-121)
    False
    >>> is_int_palindrome(0)
    True
    >>> is_int_palindrome(10)
    False
    >>> is_int_palindrome(11)
    True
    >>> is_int_palindrome(101)
    True
    >>> is_int_palindrome(120)
    False
    """"""
    if num < 0:
        return False

    num_copy: int = num
    rev_num: int = 0
    while num > 0:
        rev_num = rev_num * 10 + (num % 10)
        num //= 10

    return num_copy == rev_num",data\repos\Python\maths\is_int_palindrome.py,is_int_palindrome,182
1448,is_ip_v4_address_valid.py::is_ip_v4_address_valid::12,"def is_ip_v4_address_valid(ip: str) -> bool:
    """"""
    print ""Valid IP address"" If IP is valid.
    or
    print ""Invalid IP address"" If IP is invalid.

    >>> is_ip_v4_address_valid(""192.168.0.23"")
    True

    >>> is_ip_v4_address_valid(""192.256.15.8"")
    False

    >>> is_ip_v4_address_valid(""172.100.0.8"")
    True

    >>> is_ip_v4_address_valid(""255.256.0.256"")
    False

    >>> is_ip_v4_address_valid(""1.2.33333333.4"")
    False

    >>> is_ip_v4_address_valid(""1.2.-3.4"")
    False

    >>> is_ip_v4_address_valid(""1.2.3"")
    False

    >>> is_ip_v4_address_valid(""1.2.3.4.5"")
    False

    >>> is_ip_v4_address_valid(""1.2.A.4"")
    False

    >>> is_ip_v4_address_valid(""0.0.0.0"")
    True

    >>> is_ip_v4_address_valid(""1.2.3."")
    False

    >>> is_ip_v4_address_valid(""1.2.3.05"")
    False
    """"""
    octets = ip.split(""."")
    if len(octets) != 4:
        return False

    for octet in octets:
        if not octet.isdigit():
            return False

        number = int(octet)
        if len(str(number)) != len(octet):
            return False

        if not 0 <= number <= 255:
            return False

    return True",data\repos\Python\maths\is_ip_v4_address_valid.py,is_ip_v4_address_valid,368
1449,is_square_free.py::is_square_free::10,"def is_square_free(factors: list[int]) -> bool:
    """"""
    # doctest: +NORMALIZE_WHITESPACE
    This functions takes a list of prime factors as input.
    returns True if the factors are square free.
    >>> is_square_free([1, 1, 2, 3, 4])
    False

    These are wrong but should return some value
    it simply checks for repetition in the numbers.
    >>> is_square_free([1, 3, 4, 'sd', 0.0])
    True

    >>> is_square_free([1, 0.5, 2, 0.0])
    True
    >>> is_square_free([1, 2, 2, 5])
    False
    >>> is_square_free('asd')
    True
    >>> is_square_free(24)
    Traceback (most recent call last):
        ...
    TypeError: 'int' object is not iterable
    """"""
    return len(set(factors)) == len(factors)",data\repos\Python\maths\is_square_free.py,is_square_free,216
1450,jaccard_similarity.py::jaccard_similarity::17,"def jaccard_similarity(
    set_a: set[str] | list[str] | tuple[str],
    set_b: set[str] | list[str] | tuple[str],
    alternative_union=False,
):
    """"""
    Finds the jaccard similarity between two sets.
    Essentially, its intersection over union.

    The alternative way to calculate this is to take union as sum of the
    number of items in the two sets. This will lead to jaccard similarity
    of a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]

    Parameters:
        :set_a (set,list,tuple): A non-empty set/list
        :set_b (set,list,tuple): A non-empty set/list
        :alternativeUnion (boolean): If True, use sum of number of
        items as union

    Output:
        (float) The jaccard similarity between the two sets.

    Examples:
    >>> set_a = {'a', 'b', 'c', 'd', 'e'}
    >>> set_b = {'c', 'd', 'e', 'f', 'h', 'i'}
    >>> jaccard_similarity(set_a, set_b)
    0.375
    >>> jaccard_similarity(set_a, set_a)
    1.0
    >>> jaccard_similarity(set_a, set_a, True)
    0.5
    >>> set_a = ['a', 'b', 'c', 'd', 'e']
    >>> set_b = ('c', 'd', 'e', 'f', 'h', 'i')
    >>> jaccard_similarity(set_a, set_b)
    0.375
    >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')
    >>> set_b = ['a', 'b', 'c', 'd', 'e']
    >>> jaccard_similarity(set_a, set_b)
    0.375
    >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')
    >>> set_b = ['a', 'b', 'c', 'd']
    >>> jaccard_similarity(set_a, set_b, True)
    0.2
    >>> set_a = {'a', 'b'}
    >>> set_b = ['c', 'd']
    >>> jaccard_similarity(set_a, set_b)
    Traceback (most recent call last):
        ...
    ValueError: Set a and b must either both be sets or be either a list or a tuple.
    """"""

    if isinstance(set_a, set) and isinstance(set_b, set):
        intersection_length = len(set_a.intersection(set_b))

        if alternative_union:
            union_length = len(set_a) + len(set_b)
        else:
            union_length = len(set_a.union(set_b))

        return intersection_length / union_length

    elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):
        intersection = [element for element in set_a if element in set_b]

        if alternative_union:
            return len(intersection) / (len(set_a) + len(set_b))
        else:
            # Cast set_a to list because tuples cannot be mutated
            union = list(set_a) + [element for element in set_b if element not in set_a]
            return len(intersection) / len(union)
    raise ValueError(
        ""Set a and b must either both be sets or be either a list or a tuple.""
    )",data\repos\Python\maths\jaccard_similarity.py,jaccard_similarity,750
1451,joint_probability_distribution.py::joint_probability_distribution::7,"def joint_probability_distribution(
    x_values: list[int],
    y_values: list[int],
    x_probabilities: list[float],
    y_probabilities: list[float],
) -> dict:
    """"""
    >>> joint_distribution =  joint_probability_distribution(
    ...     [1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2]
    ... )
    >>> from math import isclose
    >>> isclose(joint_distribution.pop((1, 8)), 0.14)
    True
    >>> joint_distribution
    {(1, -2): 0.21, (1, 5): 0.35, (2, -2): 0.09, (2, 5): 0.15, (2, 8): 0.06}
    """"""
    return {
        (x, y): x_prob * y_prob
        for x, x_prob in zip(x_values, x_probabilities)
        for y, y_prob in zip(y_values, y_probabilities)
    }",data\repos\Python\maths\joint_probability_distribution.py,joint_probability_distribution,237
1452,joint_probability_distribution.py::expectation::31,"def expectation(values: list, probabilities: list) -> float:
    """"""
    >>> from math import isclose
    >>> isclose(expectation([1, 2], [0.7, 0.3]), 1.3)
    True
    """"""
    return sum(x * p for x, p in zip(values, probabilities))",data\repos\Python\maths\joint_probability_distribution.py,expectation,71
1453,joint_probability_distribution.py::variance::41,"def variance(values: list[int], probabilities: list[float]) -> float:
    """"""
    >>> from math import isclose
    >>> isclose(variance([1,2],[0.7,0.3]), 0.21)
    True
    """"""
    mean = expectation(values, probabilities)
    return sum((x - mean) ** 2 * p for x, p in zip(values, probabilities))",data\repos\Python\maths\joint_probability_distribution.py,variance,85
1454,joint_probability_distribution.py::covariance::52,"def covariance(
    x_values: list[int],
    y_values: list[int],
    x_probabilities: list[float],
    y_probabilities: list[float],
) -> float:
    """"""
    >>> covariance([1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2])
    -2.7755575615628914e-17
    """"""
    mean_x = expectation(x_values, x_probabilities)
    mean_y = expectation(y_values, y_probabilities)
    return sum(
        (x - mean_x) * (y - mean_y) * px * py
        for x, px in zip(x_values, x_probabilities)
        for y, py in zip(y_values, y_probabilities)
    )",data\repos\Python\maths\joint_probability_distribution.py,covariance,175
1455,joint_probability_distribution.py::standard_deviation::72,"def standard_deviation(variance: float) -> float:
    """"""
    >>> standard_deviation(0.21)
    0.458257569495584
    """"""
    return variance**0.5",data\repos\Python\maths\joint_probability_distribution.py,standard_deviation,43
1456,josephus_problem.py::josephus_recursive::18,"def josephus_recursive(num_people: int, step_size: int) -> int:
    """"""
    Solve the Josephus problem for num_people and a step_size recursively.

    Args:
        num_people: A positive integer representing the number of people.
        step_size: A positive integer representing the step size for elimination.

    Returns:
        The position of the last person remaining.

    Raises:
        ValueError: If num_people or step_size is not a positive integer.

    Examples:
        >>> josephus_recursive(7, 3)
        3
        >>> josephus_recursive(10, 2)
        4
        >>> josephus_recursive(0, 2)
        Traceback (most recent call last):
            ...
        ValueError: num_people or step_size is not a positive integer.
        >>> josephus_recursive(1.9, 2)
        Traceback (most recent call last):
            ...
        ValueError: num_people or step_size is not a positive integer.
        >>> josephus_recursive(-2, 2)
        Traceback (most recent call last):
            ...
        ValueError: num_people or step_size is not a positive integer.
        >>> josephus_recursive(7, 0)
        Traceback (most recent call last):
            ...
        ValueError: num_people or step_size is not a positive integer.
        >>> josephus_recursive(7, -2)
        Traceback (most recent call last):
            ...
        ValueError: num_people or step_size is not a positive integer.
        >>> josephus_recursive(1_000, 0.01)
        Traceback (most recent call last):
            ...
        ValueError: num_people or step_size is not a positive integer.
        >>> josephus_recursive(""cat"", ""dog"")
        Traceback (most recent call last):
            ...
        ValueError: num_people or step_size is not a positive integer.
    """"""
    if (
        not isinstance(num_people, int)
        or not isinstance(step_size, int)
        or num_people <= 0
        or step_size <= 0
    ):
        raise ValueError(""num_people or step_size is not a positive integer."")

    if num_people == 1:
        return 0

    return (josephus_recursive(num_people - 1, step_size) + step_size) % num_people",data\repos\Python\maths\josephus_problem.py,josephus_recursive,487
1457,josephus_problem.py::find_winner::80,"def find_winner(num_people: int, step_size: int) -> int:
    """"""
    Find the winner of the Josephus problem for num_people and a step_size.

    Args:
        num_people (int): Number of people.
        step_size (int): Step size for elimination.

    Returns:
        int: The position of the last person remaining (1-based index).

    Examples:
        >>> find_winner(7, 3)
        4
        >>> find_winner(10, 2)
        5
    """"""
    return josephus_recursive(num_people, step_size) + 1",data\repos\Python\maths\josephus_problem.py,find_winner,125
1458,josephus_problem.py::josephus_iterative::100,"def josephus_iterative(num_people: int, step_size: int) -> int:
    """"""
    Solve the Josephus problem for num_people and a step_size iteratively.

    Args:
        num_people (int): The number of people in the circle.
        step_size (int): The number of steps to take before eliminating someone.

    Returns:
        int: The position of the last person standing.

    Examples:
        >>> josephus_iterative(5, 2)
        3
        >>> josephus_iterative(7, 3)
        4
    """"""
    circle = list(range(1, num_people + 1))
    current = 0

    while len(circle) > 1:
        current = (current + step_size - 1) % len(circle)
        circle.pop(current)

    return circle[0]",data\repos\Python\maths\josephus_problem.py,josephus_iterative,179
1459,juggler_sequence.py::juggler_sequence::15,"def juggler_sequence(number: int) -> list[int]:
    """"""
    >>> juggler_sequence(0)
    Traceback (most recent call last):
        ...
    ValueError: Input value of [number=0] must be a positive integer
    >>> juggler_sequence(1)
    [1]
    >>> juggler_sequence(2)
    [2, 1]
    >>> juggler_sequence(3)
    [3, 5, 11, 36, 6, 2, 1]
    >>> juggler_sequence(5)
    [5, 11, 36, 6, 2, 1]
    >>> juggler_sequence(10)
    [10, 3, 5, 11, 36, 6, 2, 1]
    >>> juggler_sequence(25)
    [25, 125, 1397, 52214, 228, 15, 58, 7, 18, 4, 2, 1]
    >>> juggler_sequence(6.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=6.0] must be an integer
    >>> juggler_sequence(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input value of [number=-1] must be a positive integer
    """"""
    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)
    if number < 1:
        msg = f""Input value of [number={number}] must be a positive integer""
        raise ValueError(msg)
    sequence = [number]
    while number != 1:
        if number % 2 == 0:
            number = math.floor(math.sqrt(number))
        else:
            number = math.floor(
                math.sqrt(number) * math.sqrt(number) * math.sqrt(number)
            )
        sequence.append(number)
    return sequence",data\repos\Python\maths\juggler_sequence.py,juggler_sequence,419
1460,karatsuba.py::karatsuba::4,"def karatsuba(a: int, b: int) -> int:
    """"""
    >>> karatsuba(15463, 23489) == 15463 * 23489
    True
    >>> karatsuba(3, 9) == 3 * 9
    True
    """"""
    if len(str(a)) == 1 or len(str(b)) == 1:
        return a * b

    m1 = max(len(str(a)), len(str(b)))
    m2 = m1 // 2

    a1, a2 = divmod(a, 10**m2)
    b1, b2 = divmod(b, 10**m2)

    x = karatsuba(a2, b2)
    y = karatsuba((a1 + a2), (b1 + b2))
    z = karatsuba(a1, b1)

    return (z * 10 ** (2 * m2)) + ((y - z - x) * 10 ** (m2)) + (x)",data\repos\Python\maths\karatsuba.py,karatsuba,224
1461,kth_lexicographic_permutation.py::kth_permutation::1,"def kth_permutation(k, n):
    """"""
    Finds k'th lexicographic permutation (in increasing order) of
    0,1,2,...n-1 in O(n^2) time.

    Examples:
    First permutation is always 0,1,2,...n
    >>> kth_permutation(0,5)
    [0, 1, 2, 3, 4]

    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],
    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],
    [1,2,3,0], [1,3,0,2]
    >>> kth_permutation(10,4)
    [1, 3, 0, 2]
    """"""
    # Factorails from 1! to (n-1)!
    factorials = [1]
    for i in range(2, n):
        factorials.append(factorials[-1] * i)
    assert 0 <= k < factorials[-1] * n, ""k out of bounds""

    permutation = []
    elements = list(range(n))

    # Find permutation
    while factorials:
        factorial = factorials.pop()
        number, k = divmod(k, factorial)
        permutation.append(elements[number])
        elements.remove(elements[number])
    permutation.append(elements[0])

    return permutation",data\repos\Python\maths\kth_lexicographic_permutation.py,kth_permutation,357
1462,largest_of_very_large_numbers.py::res::6,"def res(x, y):
    """"""
    Reduces large number to a more manageable number
    >>> res(5, 7)
    4.892790030352132
    >>> res(0, 5)
    0
    >>> res(3, 0)
    1
    >>> res(-1, 5)
    Traceback (most recent call last):
    ...
    ValueError: expected a positive input
    """"""
    if 0 not in (x, y):
        # We use the relation x^y = y*log10(x), where 10 is the base.
        return y * math.log10(x)
    elif x == 0:  # 0 raised to any number is 0
        return 0
    elif y == 0:
        return 1  # any number raised to 0 is 1
    raise AssertionError(""This should never happen"")",data\repos\Python\maths\largest_of_very_large_numbers.py,res,192
1463,least_common_multiple.py::least_common_multiple_slow::7,"def least_common_multiple_slow(first_num: int, second_num: int) -> int:
    """"""
    Find the least common multiple of two numbers.

    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple

    >>> least_common_multiple_slow(5, 2)
    10
    >>> least_common_multiple_slow(12, 76)
    228
    """"""
    max_num = first_num if first_num >= second_num else second_num
    common_mult = max_num
    while (common_mult % first_num > 0) or (common_mult % second_num > 0):
        common_mult += max_num
    return common_mult",data\repos\Python\maths\least_common_multiple.py,least_common_multiple_slow,136
1464,least_common_multiple.py::least_common_multiple_fast::25,"def least_common_multiple_fast(first_num: int, second_num: int) -> int:
    """"""
    Find the least common multiple of two numbers.
    https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor
    >>> least_common_multiple_fast(5,2)
    10
    >>> least_common_multiple_fast(12,76)
    228
    """"""
    return first_num // greatest_common_divisor(first_num, second_num) * second_num",data\repos\Python\maths\least_common_multiple.py,least_common_multiple_fast,100
1465,least_common_multiple.py::benchmark::37,"def benchmark():
    setup = (
        ""from __main__ import least_common_multiple_slow, least_common_multiple_fast""
    )
    print(
        ""least_common_multiple_slow():"",
        timeit(""least_common_multiple_slow(1000, 999)"", setup=setup),
    )
    print(
        ""least_common_multiple_fast():"",
        timeit(""least_common_multiple_fast(1000, 999)"", setup=setup),
    )",data\repos\Python\maths\least_common_multiple.py,benchmark,90
1466,least_common_multiple.py::test_lcm_function::65,"    def test_lcm_function(self):
        for i, (first_num, second_num) in enumerate(self.test_inputs):
            slow_result = least_common_multiple_slow(first_num, second_num)
            fast_result = least_common_multiple_fast(first_num, second_num)
            with self.subTest(i=i):
                assert slow_result == self.expected_results[i]
                assert fast_result == self.expected_results[i]",data\repos\Python\maths\least_common_multiple.py,test_lcm_function,81
1467,line_length.py::line_length::7,"def line_length(
    fnc: Callable[[float], float],
    x_start: float,
    x_end: float,
    steps: int = 100,
) -> float:
    """"""
    Approximates the arc length of a line segment by treating the curve as a
    sequence of linear lines and summing their lengths
    :param fnc: a function which defines a curve
    :param x_start: left end point to indicate the start of line segment
    :param x_end: right end point to indicate end of line segment
    :param steps: an accuracy gauge; more steps increases accuracy
    :return: a float representing the length of the curve

    >>> def f(x):
    ...    return x
    >>> f""{line_length(f, 0, 1, 10):.6f}""
    '1.414214'

    >>> def f(x):
    ...    return 1
    >>> f""{line_length(f, -5.5, 4.5):.6f}""
    '10.000000'

    >>> def f(x):
    ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10
    >>> f""{line_length(f, 0.0, 10.0, 10000):.6f}""
    '69.534930'
    """"""

    x1 = x_start
    fx1 = fnc(x_start)
    length = 0.0

    for _ in range(steps):
        # Approximates curve as a sequence of linear lines and sums their length
        x2 = (x_end - x_start) / steps + x1
        fx2 = fnc(x2)
        length += math.hypot(x2 - x1, fx2 - fx1)

        # Increment step
        x1 = x2
        fx1 = fx2

    return length",data\repos\Python\maths\line_length.py,line_length,404
1468,liouville_lambda.py::liouville_lambda::14,"def liouville_lambda(number: int) -> int:
    """"""
    This functions takes an integer number as input.
    returns 1 if n has even number of prime factors and -1 otherwise.
    >>> liouville_lambda(10)
    1
    >>> liouville_lambda(11)
    -1
    >>> liouville_lambda(0)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a positive integer
    >>> liouville_lambda(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a positive integer
    >>> liouville_lambda(11.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=11.0] must be an integer
    """"""
    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)
    if number < 1:
        raise ValueError(""Input must be a positive integer"")
    return -1 if len(prime_factors(number)) % 2 else 1",data\repos\Python\maths\liouville_lambda.py,liouville_lambda,235
1469,lucas_lehmer_primality_test.py::lucas_lehmer_test::16,"def lucas_lehmer_test(p: int) -> bool:
    """"""
    >>> lucas_lehmer_test(p=7)
    True

    >>> lucas_lehmer_test(p=11)
    False

    # M_11 = 2^11 - 1 = 2047 = 23 * 89
    """"""

    if p < 2:
        raise ValueError(""p should not be less than 2!"")
    elif p == 2:
        return True

    s = 4
    m = (1 << p) - 1
    for _ in range(p - 2):
        s = ((s * s) - 2) % m
    return s == 0",data\repos\Python\maths\lucas_lehmer_primality_test.py,lucas_lehmer_test,152
1470,lucas_series.py::recursive_lucas_number::6,"def recursive_lucas_number(n_th_number: int) -> int:
    """"""
    Returns the nth lucas number
    >>> recursive_lucas_number(1)
    1
    >>> recursive_lucas_number(20)
    15127
    >>> recursive_lucas_number(0)
    2
    >>> recursive_lucas_number(25)
    167761
    >>> recursive_lucas_number(-1.5)
    Traceback (most recent call last):
        ...
    TypeError: recursive_lucas_number accepts only integer arguments.
    """"""
    if not isinstance(n_th_number, int):
        raise TypeError(""recursive_lucas_number accepts only integer arguments."")
    if n_th_number == 0:
        return 2
    if n_th_number == 1:
        return 1

    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(
        n_th_number - 2
    )",data\repos\Python\maths\lucas_series.py,recursive_lucas_number,194
1471,lucas_series.py::dynamic_lucas_number::34,"def dynamic_lucas_number(n_th_number: int) -> int:
    """"""
    Returns the nth lucas number
    >>> dynamic_lucas_number(1)
    1
    >>> dynamic_lucas_number(20)
    15127
    >>> dynamic_lucas_number(0)
    2
    >>> dynamic_lucas_number(25)
    167761
    >>> dynamic_lucas_number(-1.5)
    Traceback (most recent call last):
        ...
    TypeError: dynamic_lucas_number accepts only integer arguments.
    """"""
    if not isinstance(n_th_number, int):
        raise TypeError(""dynamic_lucas_number accepts only integer arguments."")
    a, b = 2, 1
    for _ in range(n_th_number):
        a, b = b, a + b
    return a",data\repos\Python\maths\lucas_series.py,dynamic_lucas_number,171
1472,maclaurin_series.py::maclaurin_sin::8,"def maclaurin_sin(theta: float, accuracy: int = 30) -> float:
    """"""
    Finds the maclaurin approximation of sin

    :param theta: the angle to which sin is found
    :param accuracy: the degree of accuracy wanted minimum
    :return: the value of sine in radians


    >>> from math import isclose, sin
    >>> all(isclose(maclaurin_sin(x, 50), sin(x)) for x in range(-25, 25))
    True
    >>> maclaurin_sin(10)
    -0.5440211108893691
    >>> maclaurin_sin(-10)
    0.5440211108893704
    >>> maclaurin_sin(10, 15)
    -0.544021110889369
    >>> maclaurin_sin(-10, 15)
    0.5440211108893704
    >>> maclaurin_sin(""10"")
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_sin() requires either an int or float for theta
    >>> maclaurin_sin(10, -30)
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_sin() requires a positive int for accuracy
    >>> maclaurin_sin(10, 30.5)
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_sin() requires a positive int for accuracy
    >>> maclaurin_sin(10, ""30"")
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_sin() requires a positive int for accuracy
    """"""

    if not isinstance(theta, (int, float)):
        raise ValueError(""maclaurin_sin() requires either an int or float for theta"")

    if not isinstance(accuracy, int) or accuracy <= 0:
        raise ValueError(""maclaurin_sin() requires a positive int for accuracy"")

    theta = float(theta)
    div = theta // (2 * pi)
    theta -= 2 * div * pi
    return sum(
        (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)
    )",data\repos\Python\maths\maclaurin_series.py,maclaurin_sin,491
1473,maclaurin_series.py::maclaurin_cos::60,"def maclaurin_cos(theta: float, accuracy: int = 30) -> float:
    """"""
    Finds the maclaurin approximation of cos

    :param theta: the angle to which cos is found
    :param accuracy: the degree of accuracy wanted
    :return: the value of cosine in radians


    >>> from math import isclose, cos
    >>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25))
    True
    >>> maclaurin_cos(5)
    0.2836621854632268
    >>> maclaurin_cos(-5)
    0.2836621854632265
    >>> maclaurin_cos(10, 15)
    -0.8390715290764524
    >>> maclaurin_cos(-10, 15)
    -0.8390715290764521
    >>> maclaurin_cos(""10"")
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_cos() requires either an int or float for theta
    >>> maclaurin_cos(10, -30)
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_cos() requires a positive int for accuracy
    >>> maclaurin_cos(10, 30.5)
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_cos() requires a positive int for accuracy
    >>> maclaurin_cos(10, ""30"")
    Traceback (most recent call last):
        ...
    ValueError: maclaurin_cos() requires a positive int for accuracy
    """"""

    if not isinstance(theta, (int, float)):
        raise ValueError(""maclaurin_cos() requires either an int or float for theta"")

    if not isinstance(accuracy, int) or accuracy <= 0:
        raise ValueError(""maclaurin_cos() requires a positive int for accuracy"")

    theta = float(theta)
    div = theta // (2 * pi)
    theta -= 2 * div * pi
    return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))",data\repos\Python\maths\maclaurin_series.py,maclaurin_cos,481
1474,manhattan_distance.py::manhattan_distance::1,"def manhattan_distance(point_a: list, point_b: list) -> float:
    """"""
    Expectts two list of numbers representing two points in the same
    n-dimensional space

    https://en.wikipedia.org/wiki/Taxicab_geometry

    >>> manhattan_distance([1,1], [2,2])
    2.0
    >>> manhattan_distance([1.5,1.5], [2,2])
    1.0
    >>> manhattan_distance([1.5,1.5], [2.5,2])
    1.5
    >>> manhattan_distance([-3, -3, -3], [0, 0, 0])
    9.0
    >>> manhattan_distance([1,1], None)
    Traceback (most recent call last):
        ...
    ValueError: Missing an input
    >>> manhattan_distance([1,1], [2, 2, 2])
    Traceback (most recent call last):
        ...
    ValueError: Both points must be in the same n-dimensional space
    >>> manhattan_distance([1,""one""], [2, 2, 2])
    Traceback (most recent call last):
        ...
    TypeError: Expected a list of numbers as input, found str
    >>> manhattan_distance(1, [2, 2, 2])
    Traceback (most recent call last):
         ...
    TypeError: Expected a list of numbers as input, found int
    >>> manhattan_distance([1,1], ""not_a_list"")
    Traceback (most recent call last):
         ...
    TypeError: Expected a list of numbers as input, found str
    """"""

    _validate_point(point_a)
    _validate_point(point_b)
    if len(point_a) != len(point_b):
        raise ValueError(""Both points must be in the same n-dimensional space"")

    return float(sum(abs(a - b) for a, b in zip(point_a, point_b)))",data\repos\Python\maths\manhattan_distance.py,manhattan_distance,416
1475,manhattan_distance.py::manhattan_distance_one_liner::81,"def manhattan_distance_one_liner(point_a: list, point_b: list) -> float:
    """"""
    Version with one liner

    >>> manhattan_distance_one_liner([1,1], [2,2])
    2.0
    >>> manhattan_distance_one_liner([1.5,1.5], [2,2])
    1.0
    >>> manhattan_distance_one_liner([1.5,1.5], [2.5,2])
    1.5
    >>> manhattan_distance_one_liner([-3, -3, -3], [0, 0, 0])
    9.0
    >>> manhattan_distance_one_liner([1,1], None)
    Traceback (most recent call last):
         ...
    ValueError: Missing an input
    >>> manhattan_distance_one_liner([1,1], [2, 2, 2])
    Traceback (most recent call last):
         ...
    ValueError: Both points must be in the same n-dimensional space
    >>> manhattan_distance_one_liner([1,""one""], [2, 2, 2])
    Traceback (most recent call last):
         ...
    TypeError: Expected a list of numbers as input, found str
    >>> manhattan_distance_one_liner(1, [2, 2, 2])
    Traceback (most recent call last):
         ...
    TypeError: Expected a list of numbers as input, found int
    >>> manhattan_distance_one_liner([1,1], ""not_a_list"")
    Traceback (most recent call last):
         ...
    TypeError: Expected a list of numbers as input, found str
    """"""

    _validate_point(point_a)
    _validate_point(point_b)
    if len(point_a) != len(point_b):
        raise ValueError(""Both points must be in the same n-dimensional space"")

    return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))",data\repos\Python\maths\manhattan_distance.py,manhattan_distance_one_liner,420
1476,matrix_exponentiation.py::modular_exponentiation::31,"def modular_exponentiation(a, b):
    matrix = Matrix([[1, 0], [0, 1]])
    while b > 0:
        if b & 1:
            matrix *= a
        a *= a
        b >>= 1
    return matrix",data\repos\Python\maths\matrix_exponentiation.py,modular_exponentiation,58
1477,matrix_exponentiation.py::fibonacci_with_matrix_exponentiation::41,"def fibonacci_with_matrix_exponentiation(n, f1, f2):
    """"""
    Returns the nth number of the Fibonacci sequence that
    starts with f1 and f2
    Uses the matrix exponentiation
    >>> fibonacci_with_matrix_exponentiation(1, 5, 6)
    5
    >>> fibonacci_with_matrix_exponentiation(2, 10, 11)
    11
    >>> fibonacci_with_matrix_exponentiation(13, 0, 1)
    144
    >>> fibonacci_with_matrix_exponentiation(10, 5, 9)
    411
    >>> fibonacci_with_matrix_exponentiation(9, 2, 3)
    89
    """"""
    # Trivial Cases
    if n == 1:
        return f1
    elif n == 2:
        return f2
    matrix = Matrix([[1, 1], [1, 0]])
    matrix = modular_exponentiation(matrix, n - 2)
    return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]",data\repos\Python\maths\matrix_exponentiation.py,fibonacci_with_matrix_exponentiation,234
1478,matrix_exponentiation.py::simple_fibonacci::67,"def simple_fibonacci(n, f1, f2):
    """"""
    Returns the nth number of the Fibonacci sequence that
    starts with f1 and f2
    Uses the definition
    >>> simple_fibonacci(1, 5, 6)
    5
    >>> simple_fibonacci(2, 10, 11)
    11
    >>> simple_fibonacci(13, 0, 1)
    144
    >>> simple_fibonacci(10, 5, 9)
    411
    >>> simple_fibonacci(9, 2, 3)
    89
    """"""
    # Trivial Cases
    if n == 1:
        return f1
    elif n == 2:
        return f2

    n -= 2

    while n > 0:
        f2, f1 = f1 + f2, f2
        n -= 1

    return f2",data\repos\Python\maths\matrix_exponentiation.py,simple_fibonacci,206
1479,matrix_exponentiation.py::matrix_exponentiation_time::98,"def matrix_exponentiation_time():
    setup = """"""
from random import randint
from __main__ import fibonacci_with_matrix_exponentiation
""""""
    code = ""fibonacci_with_matrix_exponentiation(randint(1,70000), 1, 1)""
    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)
    print(""With matrix exponentiation the average execution time is "", exec_time / 100)
    return exec_time",data\repos\Python\maths\matrix_exponentiation.py,matrix_exponentiation_time,98
1480,matrix_exponentiation.py::simple_fibonacci_time::109,"def simple_fibonacci_time():
    setup = """"""
from random import randint
from __main__ import simple_fibonacci
""""""
    code = ""simple_fibonacci(randint(1,70000), 1, 1)""
    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)
    print(
        ""Without matrix exponentiation the average execution time is "", exec_time / 100
    )
    return exec_time",data\repos\Python\maths\matrix_exponentiation.py,simple_fibonacci_time,97
1481,max_sum_sliding_window.py::max_sum_in_array::13,"def max_sum_in_array(array: list[int], k: int) -> int:
    """"""
    Returns the maximum sum of k consecutive elements
    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]
    >>> k = 4
    >>> max_sum_in_array(arr, k)
    24
    >>> k = 10
    >>> max_sum_in_array(arr,k)
    Traceback (most recent call last):
        ...
    ValueError: Invalid Input
    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]
    >>> k = 4
    >>> max_sum_in_array(arr, k)
    27
    """"""
    if len(array) < k or k < 0:
        raise ValueError(""Invalid Input"")
    max_sum = current_sum = sum(array[:k])
    for i in range(len(array) - k):
        current_sum = current_sum - array[i] + array[i + k]
        max_sum = max(max_sum, current_sum)
    return max_sum",data\repos\Python\maths\max_sum_sliding_window.py,max_sum_in_array,242
1482,minkowski_distance.py::minkowski_distance::1,"def minkowski_distance(
    point_a: list[float],
    point_b: list[float],
    order: int,
) -> float:
    """"""
    This function calculates the Minkowski distance for a given order between
    two n-dimensional points represented as lists. For the case of order = 1,
    the Minkowski distance degenerates to the Manhattan distance. For
    order = 2, the usual Euclidean distance is obtained.

    https://en.wikipedia.org/wiki/Minkowski_distance

    Note: due to floating point calculation errors the output of this
    function may be inaccurate.

    >>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)
    2.0
    >>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)
    8.0
    >>> import numpy as np
    >>> bool(np.isclose(5.0, minkowski_distance([5.0], [0.0], 3)))
    True
    >>> minkowski_distance([1.0], [2.0], -1)
    Traceback (most recent call last):
        ...
    ValueError: The order must be greater than or equal to 1.
    >>> minkowski_distance([1.0], [1.0, 2.0], 1)
    Traceback (most recent call last):
        ...
    ValueError: Both points must have the same dimension.
    """"""
    if order < 1:
        raise ValueError(""The order must be greater than or equal to 1."")

    if len(point_a) != len(point_b):
        raise ValueError(""Both points must have the same dimension."")

    return sum(abs(a - b) ** order for a, b in zip(point_a, point_b)) ** (1 / order)",data\repos\Python\maths\minkowski_distance.py,minkowski_distance,421
1483,mobius_function.py::mobius::12,"def mobius(n: int) -> int:
    """"""
    Mobius function
    >>> mobius(24)
    0
    >>> mobius(-1)
    1
    >>> mobius('asd')
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> mobius(10**400)
    0
    >>> mobius(10**-400)
    1
    >>> mobius(-1424)
    1
    >>> mobius([1, '2', 2.0])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'
    """"""
    factors = prime_factors(n)
    if is_square_free(factors):
        return -1 if len(factors) % 2 else 1
    return 0",data\repos\Python\maths\mobius_function.py,mobius,193
1484,modular_division.py::modular_division::4,"def modular_division(a: int, b: int, n: int) -> int:
    """"""
    Modular Division :
    An efficient algorithm for dividing b by a modulo n.

    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )

    Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should
    return an integer x such that 0xn-1, and  b/a=x(modn) (that is, b=ax(modn)).

    Theorem:
    a has a multiplicative inverse modulo n iff gcd(a,n) = 1


    This find x = b*a^(-1) mod n
    Uses ExtendedEuclid to find the inverse of a

    >>> modular_division(4,8,5)
    2

    >>> modular_division(3,8,5)
    1

    >>> modular_division(4, 11, 5)
    4

    """"""
    assert n > 1
    assert a > 0
    assert greatest_common_divisor(a, n) == 1
    (_d, _t, s) = extended_gcd(n, a)  # Implemented below
    x = (b * s) % n
    return x",data\repos\Python\maths\modular_division.py,modular_division,281
1485,modular_division.py::invert_modulo::39,"def invert_modulo(a: int, n: int) -> int:
    """"""
    This function find the inverses of a i.e., a^(-1)

    >>> invert_modulo(2, 5)
    3

    >>> invert_modulo(8,7)
    1

    """"""
    (b, _x) = extended_euclid(a, n)  # Implemented below
    if b < 0:
        b = (b % n + n) % n
    return b",data\repos\Python\maths\modular_division.py,invert_modulo,109
1486,modular_division.py::modular_division2::59,"def modular_division2(a: int, b: int, n: int) -> int:
    """"""
    This function used the above inversion of a to find x = (b*a^(-1))mod n

    >>> modular_division2(4,8,5)
    2

    >>> modular_division2(3,8,5)
    1

    >>> modular_division2(4, 11, 5)
    4

    """"""
    s = invert_modulo(a, n)
    x = (b * s) % n
    return x",data\repos\Python\maths\modular_division.py,modular_division2,124
1487,modular_division.py::extended_gcd::78,"def extended_gcd(a: int, b: int) -> tuple[int, int, int]:
    """"""
    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x
    and y, then d = gcd(a,b)
    >>> extended_gcd(10, 6)
    (2, -1, 2)

    >>> extended_gcd(7, 5)
    (1, -2, 3)

    ** extended_gcd function is used when d = gcd(a,b) is required in output

    """"""
    assert a >= 0
    assert b >= 0

    if b == 0:
        d, x, y = a, 1, 0
    else:
        (d, p, q) = extended_gcd(b, a % b)
        x = q
        y = p - q * (a // b)

    assert a % d == 0
    assert b % d == 0
    assert d == a * x + b * y

    return (d, x, y)",data\repos\Python\maths\modular_division.py,extended_gcd,235
1488,modular_division.py::extended_euclid::108,"def extended_euclid(a: int, b: int) -> tuple[int, int]:
    """"""
    Extended Euclid
    >>> extended_euclid(10, 6)
    (-1, 2)

    >>> extended_euclid(7, 5)
    (-2, 3)

    """"""
    if b == 0:
        return (1, 0)
    (x, y) = extended_euclid(b, a % b)
    k = a // b
    return (y, x - k * y)",data\repos\Python\maths\modular_division.py,extended_euclid,116
1489,modular_division.py::greatest_common_divisor::125,"def greatest_common_divisor(a: int, b: int) -> int:
    """"""
    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b
    Euclid's Algorithm

    >>> greatest_common_divisor(7,5)
    1

    Note : In number theory, two integers a and b are said to be relatively prime,
        mutually prime, or co-prime if the only positive integer (factor) that divides
        both of them is 1  i.e., gcd(a,b) = 1.

    >>> greatest_common_divisor(121, 11)
    11

    """"""
    if a < b:
        a, b = b, a

    while a % b != 0:
        a, b = b, a % b

    return b",data\repos\Python\maths\modular_division.py,greatest_common_divisor,176
1490,modular_exponential.py::modular_exponential::11,"def modular_exponential(base: int, power: int, mod: int):
    """"""
    >>> modular_exponential(5, 0, 10)
    1
    >>> modular_exponential(2, 8, 7)
    4
    >>> modular_exponential(3, -2, 9)
    -1
    """"""

    if power < 0:
        return -1
    base %= mod
    result = 1

    while power > 0:
        if power & 1:
            result = (result * base) % mod
        power = power >> 1
        base = (base * base) % mod

    return result",data\repos\Python\maths\modular_exponential.py,modular_exponential,144
1491,monte_carlo.py::pi_estimator::11,"def pi_estimator(iterations: int) -> None:
    """"""
    An implementation of the Monte Carlo method used to find pi.
    1. Draw a 2x2 square centred at (0,0).
    2. Inscribe a circle within the square.
    3. For each iteration, place a dot anywhere in the square.
       a. Record the number of dots within the circle.
    4. After all the dots are placed, divide the dots in the circle by the total.
    5. Multiply this value by 4 to get your estimate of pi.
    6. Print the estimated and numpy value of pi
    """"""

    # A local function to see if a dot lands in the circle.
    def is_in_circle(x: float, y: float) -> bool:
        distance_from_centre = sqrt((x**2) + (y**2))
        # Our circle has a radius of 1, so a distance
        # greater than 1 would land outside the circle.
        return distance_from_centre <= 1

    # The proportion of guesses that landed in the circle
    proportion = mean(
        int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))
        for _ in range(iterations)
    )
    # The ratio of the area for circle to square is pi/4.
    pi_estimate = proportion * 4
    print(f""The estimated value of pi is {pi_estimate}"")
    print(f""The numpy value of pi is {pi}"")
    print(f""The total error is {abs(pi - pi_estimate)}"")",data\repos\Python\maths\monte_carlo.py,pi_estimator,344
1492,monte_carlo.py::area_under_curve_estimator::42,"def area_under_curve_estimator(
    iterations: int,
    function_to_integrate: Callable[[float], float],
    min_value: float = 0.0,
    max_value: float = 1.0,
) -> float:
    """"""
    An implementation of the Monte Carlo method to find area under
       a single variable non-negative real-valued continuous function,
       say f(x), where x lies within a continuous bounded interval,
       say [min_value, max_value], where min_value and max_value are
       finite numbers
    1. Let x be a uniformly distributed random variable between min_value to
       max_value
    2. Expected value of f(x) =
       (integrate f(x) from min_value to max_value)/(max_value - min_value)
    3. Finding expected value of f(x):
        a. Repeatedly draw x from uniform distribution
        b. Evaluate f(x) at each of the drawn x values
        c. Expected value = average of the function evaluations
    4. Estimated value of integral = Expected value * (max_value - min_value)
    5. Returns estimated value
    """"""

    return mean(
        function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)
    ) * (max_value - min_value)",data\repos\Python\maths\monte_carlo.py,area_under_curve_estimator,276
1493,monte_carlo.py::area_under_line_estimator_check::71,"def area_under_line_estimator_check(
    iterations: int, min_value: float = 0.0, max_value: float = 1.0
) -> None:
    """"""
    Checks estimation error for area_under_curve_estimator function
    for f(x) = x where x lies within min_value to max_value
    1. Calls ""area_under_curve_estimator"" function
    2. Compares with the expected value
    3. Prints estimated, expected and error value
    """"""

    def identity_function(x: float) -> float:
        """"""
        Represents identity function
        >>> [function_to_integrate(x) for x in [-2.0, -1.0, 0.0, 1.0, 2.0]]
        [-2.0, -1.0, 0.0, 1.0, 2.0]
        """"""
        return x

    estimated_value = area_under_curve_estimator(
        iterations, identity_function, min_value, max_value
    )
    expected_value = (max_value * max_value - min_value * min_value) / 2

    print(""******************"")
    print(f""Estimating area under y=x where x varies from {min_value} to {max_value}"")
    print(f""Estimated value is {estimated_value}"")
    print(f""Expected value is {expected_value}"")
    print(f""Total error is {abs(estimated_value - expected_value)}"")
    print(""******************"")",data\repos\Python\maths\monte_carlo.py,area_under_line_estimator_check,309
1494,monte_carlo.py::pi_estimator_using_area_under_curve::103,"def pi_estimator_using_area_under_curve(iterations: int) -> None:
    """"""
    Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi
    """"""

    def function_to_integrate(x: float) -> float:
        """"""
        Represents semi-circle with radius 2
        >>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]]
        [0.0, 2.0, 0.0]
        """"""
        return sqrt(4.0 - x * x)

    estimated_value = area_under_curve_estimator(
        iterations, function_to_integrate, 0.0, 2.0
    )

    print(""******************"")
    print(""Estimating pi using area_under_curve_estimator"")
    print(f""Estimated value is {estimated_value}"")
    print(f""Expected value is {pi}"")
    print(f""Total error is {abs(estimated_value - pi)}"")
    print(""******************"")",data\repos\Python\maths\monte_carlo.py,pi_estimator_using_area_under_curve,218
1495,monte_carlo.py::is_in_circle::24,"    def is_in_circle(x: float, y: float) -> bool:
        distance_from_centre = sqrt((x**2) + (y**2))
        # Our circle has a radius of 1, so a distance
        # greater than 1 would land outside the circle.
        return distance_from_centre <= 1",data\repos\Python\maths\monte_carlo.py,is_in_circle,70
1496,monte_carlo.py::identity_function::82,"    def identity_function(x: float) -> float:
        """"""
        Represents identity function
        >>> [function_to_integrate(x) for x in [-2.0, -1.0, 0.0, 1.0, 2.0]]
        [-2.0, -1.0, 0.0, 1.0, 2.0]
        """"""
        return x",data\repos\Python\maths\monte_carlo.py,identity_function,86
1497,monte_carlo.py::function_to_integrate::108,"    def function_to_integrate(x: float) -> float:
        """"""
        Represents semi-circle with radius 2
        >>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]]
        [0.0, 2.0, 0.0]
        """"""
        return sqrt(4.0 - x * x)",data\repos\Python\maths\monte_carlo.py,function_to_integrate,81
1498,monte_carlo_dice.py::throw_dice::17,"def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:
    """"""
    Return probability list of all possible sums when throwing dice.

    >>> random.seed(0)
    >>> throw_dice(10, 1)
    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]
    >>> throw_dice(100, 1)
    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]
    >>> throw_dice(1000, 1)
    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]
    >>> throw_dice(10000, 1)
    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]
    >>> throw_dice(10000, 2)
    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]
    """"""
    dices = [Dice() for i in range(num_dice)]
    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)
    for _ in range(num_throws):
        count_of_sum[sum(dice.roll() for dice in dices)] += 1
    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]
    return probability[num_dice:]  # remove probability of sums that never appear",data\repos\Python\maths\monte_carlo_dice.py,throw_dice,384
1499,number_of_digits.py::num_digits::5,"def num_digits(n: int) -> int:
    """"""
    Find the number of digits in a number.

    >>> num_digits(12345)
    5
    >>> num_digits(123)
    3
    >>> num_digits(0)
    1
    >>> num_digits(-1)
    1
    >>> num_digits(-123456)
    6
    >>> num_digits('123')  # Raises a TypeError for non-integer input
    Traceback (most recent call last):
        ...
    TypeError: Input must be an integer
    """"""

    if not isinstance(n, int):
        raise TypeError(""Input must be an integer"")

    digits = 0
    n = abs(n)
    while True:
        n = n // 10
        digits += 1
        if n == 0:
            break
    return digits",data\repos\Python\maths\number_of_digits.py,num_digits,180
1500,number_of_digits.py::num_digits_fast::38,"def num_digits_fast(n: int) -> int:
    """"""
    Find the number of digits in a number.
    abs() is used as logarithm for negative numbers is not defined.

    >>> num_digits_fast(12345)
    5
    >>> num_digits_fast(123)
    3
    >>> num_digits_fast(0)
    1
    >>> num_digits_fast(-1)
    1
    >>> num_digits_fast(-123456)
    6
    >>> num_digits('123')  # Raises a TypeError for non-integer input
    Traceback (most recent call last):
        ...
    TypeError: Input must be an integer
    """"""

    if not isinstance(n, int):
        raise TypeError(""Input must be an integer"")

    return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)",data\repos\Python\maths\number_of_digits.py,num_digits_fast,182
1501,number_of_digits.py::num_digits_faster::65,"def num_digits_faster(n: int) -> int:
    """"""
    Find the number of digits in a number.
    abs() is used for negative numbers

    >>> num_digits_faster(12345)
    5
    >>> num_digits_faster(123)
    3
    >>> num_digits_faster(0)
    1
    >>> num_digits_faster(-1)
    1
    >>> num_digits_faster(-123456)
    6
    >>> num_digits('123')  # Raises a TypeError for non-integer input
    Traceback (most recent call last):
        ...
    TypeError: Input must be an integer
    """"""

    if not isinstance(n, int):
        raise TypeError(""Input must be an integer"")

    return len(str(abs(n)))",data\repos\Python\maths\number_of_digits.py,num_digits_faster,165
1502,number_of_digits.py::benchmark::92,"def benchmark() -> None:
    """"""
    Benchmark multiple functions, with three different length int values.
    """"""
    from collections.abc import Callable

    def benchmark_a_function(func: Callable, value: int) -> None:
        call = f""{func.__name__}({value})""
        timing = timeit(f""__main__.{call}"", setup=""import __main__"")
        print(f""{call}: {func(value)} -- {timing} seconds"")

    for value in (262144, 1125899906842624, 1267650600228229401496703205376):
        for func in (num_digits, num_digits_fast, num_digits_faster):
            benchmark_a_function(func, value)
        print()",data\repos\Python\maths\number_of_digits.py,benchmark,152
1503,number_of_digits.py::benchmark_a_function::98,"    def benchmark_a_function(func: Callable, value: int) -> None:
        call = f""{func.__name__}({value})""
        timing = timeit(f""__main__.{call}"", setup=""import __main__"")
        print(f""{call}: {func(value)} -- {timing} seconds"")",data\repos\Python\maths\number_of_digits.py,benchmark_a_function,65
1504,odd_sieve.py::odd_sieve::5,"def odd_sieve(num: int) -> list[int]:
    """"""
    Returns the prime numbers < `num`. The prime numbers are calculated using an
    odd sieve implementation of the Sieve of Eratosthenes algorithm
    (see for reference https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).

    >>> odd_sieve(2)
    []
    >>> odd_sieve(3)
    [2]
    >>> odd_sieve(10)
    [2, 3, 5, 7]
    >>> odd_sieve(20)
    [2, 3, 5, 7, 11, 13, 17, 19]
    """"""

    if num <= 2:
        return []
    if num == 3:
        return [2]

    # Odd sieve for numbers in range [3, num - 1]
    sieve = bytearray(b""\x01"") * ((num >> 1) - 1)

    for i in range(3, int(sqrt(num)) + 1, 2):
        if sieve[(i >> 1) - 1]:
            i_squared = i**2
            sieve[(i_squared >> 1) - 1 :: i] = repeat(
                0, ceil((num - i_squared) / (i << 1))
            )

    return [2, *list(compress(range(3, num, 2), sieve))]",data\repos\Python\maths\odd_sieve.py,odd_sieve,301
1505,perfect_cube.py::perfect_cube::1,"def perfect_cube(n: int) -> bool:
    """"""
    Check if a number is a perfect cube or not.

    >>> perfect_cube(27)
    True
    >>> perfect_cube(4)
    False
    """"""
    val = n ** (1 / 3)
    return (val * val * val) == n",data\repos\Python\maths\perfect_cube.py,perfect_cube,68
1506,perfect_cube.py::perfect_cube_binary_search::14,"def perfect_cube_binary_search(n: int) -> bool:
    """"""
    Check if a number is a perfect cube or not using binary search.
    Time complexity : O(Log(n))
    Space complexity: O(1)

    >>> perfect_cube_binary_search(27)
    True
    >>> perfect_cube_binary_search(64)
    True
    >>> perfect_cube_binary_search(4)
    False
    >>> perfect_cube_binary_search(""a"")
    Traceback (most recent call last):
        ...
    TypeError: perfect_cube_binary_search() only accepts integers
    >>> perfect_cube_binary_search(0.1)
    Traceback (most recent call last):
        ...
    TypeError: perfect_cube_binary_search() only accepts integers
    """"""
    if not isinstance(n, int):
        raise TypeError(""perfect_cube_binary_search() only accepts integers"")
    if n < 0:
        n = -n
    left = 0
    right = n
    while left <= right:
        mid = left + (right - left) // 2
        if mid * mid * mid == n:
            return True
        elif mid * mid * mid < n:
            left = mid + 1
        else:
            right = mid - 1
    return False",data\repos\Python\maths\perfect_cube.py,perfect_cube_binary_search,260
1507,perfect_number.py::perfect::15,"def perfect(number: int) -> bool:
    """"""
    Check if a number is a perfect number.

    A perfect number is a positive integer that is equal to the sum of its proper
    divisors (excluding itself).

    Args:
        number: The number to be checked.

    Returns:
        True if the number is a perfect number otherwise, False.
    Start from 1 because dividing by 0 will raise ZeroDivisionError.
    A number at most can be divisible by the half of the number except the number
    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.
    Examples:
    >>> perfect(27)
    False
    >>> perfect(28)
    True
    >>> perfect(29)
    False
    >>> perfect(6)
    True
    >>> perfect(12)
    False
    >>> perfect(496)
    True
    >>> perfect(8128)
    True
    >>> perfect(0)
    False
    >>> perfect(-1)
    False
    >>> perfect(33550336)  # Large perfect number
    True
    >>> perfect(33550337)  # Just above a large perfect number
    False
    >>> perfect(1)  # Edge case: 1 is not a perfect number
    False
    >>> perfect(""123"")  # String representation of a number
    Traceback (most recent call last):
    ...
    ValueError: number must be an integer
    >>> perfect(12.34)
    Traceback (most recent call last):
      ...
    ValueError: number must be an integer
    >>> perfect(""Hello"")
    Traceback (most recent call last):
      ...
    ValueError: number must be an integer
    """"""
    if not isinstance(number, int):
        raise ValueError(""number must be an integer"")
    if number <= 0:
        return False
    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number",data\repos\Python\maths\perfect_number.py,perfect,423
1508,perfect_square.py::perfect_square::4,"def perfect_square(num: int) -> bool:
    """"""
    Check if a number is perfect square number or not
    :param num: the number to be checked
    :return: True if number is square number, otherwise False

    >>> perfect_square(9)
    True
    >>> perfect_square(16)
    True
    >>> perfect_square(1)
    True
    >>> perfect_square(0)
    True
    >>> perfect_square(10)
    False
    """"""
    return math.sqrt(num) * math.sqrt(num) == num",data\repos\Python\maths\perfect_square.py,perfect_square,114
1509,perfect_square.py::perfect_square_binary_search::24,"def perfect_square_binary_search(n: int) -> bool:
    """"""
    Check if a number is perfect square using binary search.
    Time complexity : O(Log(n))
    Space complexity: O(1)

    >>> perfect_square_binary_search(9)
    True
    >>> perfect_square_binary_search(16)
    True
    >>> perfect_square_binary_search(1)
    True
    >>> perfect_square_binary_search(0)
    True
    >>> perfect_square_binary_search(10)
    False
    >>> perfect_square_binary_search(-1)
    False
    >>> perfect_square_binary_search(1.1)
    False
    >>> perfect_square_binary_search(""a"")
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> perfect_square_binary_search(None)
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'NoneType'
    >>> perfect_square_binary_search([])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'
    """"""
    left = 0
    right = n
    while left <= right:
        mid = (left + right) // 2
        if mid**2 == n:
            return True
        elif mid**2 > n:
            right = mid - 1
        else:
            left = mid + 1
    return False",data\repos\Python\maths\perfect_square.py,perfect_square_binary_search,310
1510,persistence.py::multiplicative_persistence::1,"def multiplicative_persistence(num: int) -> int:
    """"""
    Return the persistence of a given number.

    https://en.wikipedia.org/wiki/Persistence_of_a_number

    >>> multiplicative_persistence(217)
    2
    >>> multiplicative_persistence(-1)
    Traceback (most recent call last):
        ...
    ValueError: multiplicative_persistence() does not accept negative values
    >>> multiplicative_persistence(""long number"")
    Traceback (most recent call last):
        ...
    ValueError: multiplicative_persistence() only accepts integral values
    """"""

    if not isinstance(num, int):
        raise ValueError(""multiplicative_persistence() only accepts integral values"")
    if num < 0:
        raise ValueError(""multiplicative_persistence() does not accept negative values"")

    steps = 0
    num_string = str(num)

    while len(num_string) != 1:
        numbers = [int(i) for i in num_string]

        total = 1
        for i in range(len(numbers)):
            total *= numbers[i]

        num_string = str(total)

        steps += 1
    return steps",data\repos\Python\maths\persistence.py,multiplicative_persistence,235
1511,persistence.py::additive_persistence::40,"def additive_persistence(num: int) -> int:
    """"""
    Return the persistence of a given number.

    https://en.wikipedia.org/wiki/Persistence_of_a_number

    >>> additive_persistence(199)
    3
    >>> additive_persistence(-1)
    Traceback (most recent call last):
        ...
    ValueError: additive_persistence() does not accept negative values
    >>> additive_persistence(""long number"")
    Traceback (most recent call last):
        ...
    ValueError: additive_persistence() only accepts integral values
    """"""

    if not isinstance(num, int):
        raise ValueError(""additive_persistence() only accepts integral values"")
    if num < 0:
        raise ValueError(""additive_persistence() does not accept negative values"")

    steps = 0
    num_string = str(num)

    while len(num_string) != 1:
        numbers = [int(i) for i in num_string]

        total = 0
        for i in range(len(numbers)):
            total += numbers[i]

        num_string = str(total)

        steps += 1
    return steps",data\repos\Python\maths\persistence.py,additive_persistence,229
1512,pi_generator.py::calculate_pi::1,"def calculate_pi(limit: int) -> str:
    """"""
    https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
    Leibniz Formula for Pi

    The Leibniz formula is the special case arctan(1) = pi / 4.
    Leibniz's formula converges extremely slowly: it exhibits sublinear convergence.

    Convergence (https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Convergence)

    We cannot try to prove against an interrupted, uncompleted generation.
    https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Unusual_behaviour
    The errors can in fact be predicted, but those calculations also approach infinity
    for accuracy.

    Our output will be a string so that we can definitely store all digits.

    >>> import math
    >>> float(calculate_pi(15)) == math.pi
    True

    Since we cannot predict errors or interrupt any infinite alternating series
    generation since they approach infinity, or interrupt any alternating series, we'll
    need math.isclose()

    >>> math.isclose(float(calculate_pi(50)), math.pi)
    True
    >>> math.isclose(float(calculate_pi(100)), math.pi)
    True

    Since math.pi contains only 16 digits, here are some tests with known values:

    >>> calculate_pi(50)
    '3.14159265358979323846264338327950288419716939937510'
    >>> calculate_pi(80)
    '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'
    """"""
    # Variables used for the iteration process
    q = 1
    r = 0
    t = 1
    k = 1
    n = 3
    m = 3

    decimal = limit
    counter = 0

    result = """"

    # We can't compare against anything if we make a generator,
    # so we'll stick with plain return logic
    while counter != decimal + 1:
        if 4 * q + r - t < n * t:
            result += str(n)
            if counter == 0:
                result += "".""

            if decimal == counter:
                break

            counter += 1
            nr = 10 * (r - n * t)
            n = ((10 * (3 * q + r)) // t) - 10 * n
            q *= 10
            r = nr
        else:
            nr = (2 * q + r) * m
            nn = (q * (7 * k) + 2 + (r * m)) // (t * m)
            q *= k
            t *= m
            m += 2
            k += 1
            n = nn
            r = nr
    return result",data\repos\Python\maths\pi_generator.py,calculate_pi,625
1513,pi_monte_carlo_estimation.py::estimate_pi::24,"def estimate_pi(number_of_simulations: int) -> float:
    """"""
    Generates an estimate of the mathematical constant PI.
    See https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview

    The estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from
    the unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:

        P[U in unit circle] = 1/4 PI

    and therefore

        PI = 4 * P[U in unit circle]

    We can get an estimate of the probability P[U in unit circle].
    See https://en.wikipedia.org/wiki/Empirical_probability by:

        1. Draw a point uniformly from the unit square.
        2. Repeat the first step n times and count the number of points in the unit
            circle, which is called m.
        3. An estimate of P[U in unit circle] is m/n
    """"""
    if number_of_simulations < 1:
        raise ValueError(""At least one simulation is necessary to estimate PI."")

    number_in_unit_circle = 0
    for _ in range(number_of_simulations):
        random_point = Point.random_unit_square()

        if random_point.is_in_unit_circle():
            number_in_unit_circle += 1

    return 4 * number_in_unit_circle / number_of_simulations",data\repos\Python\maths\pi_monte_carlo_estimation.py,estimate_pi,289
1514,pi_monte_carlo_estimation.py::is_in_unit_circle::9,"    def is_in_unit_circle(self) -> bool:
        """"""
        True, if the point lies in the unit circle
        False, otherwise
        """"""
        return (self.x**2 + self.y**2) <= 1",data\repos\Python\maths\pi_monte_carlo_estimation.py,is_in_unit_circle,48
1515,pi_monte_carlo_estimation.py::random_unit_square::17,"    def random_unit_square(cls):
        """"""
        Generates a point randomly drawn from the unit square [0, 1) x [0, 1).
        """"""
        return cls(x=random.random(), y=random.random())",data\repos\Python\maths\pi_monte_carlo_estimation.py,random_unit_square,45
1516,points_are_collinear_3d.py::create_vector::35,"def create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:
    """"""
    Pass two points to get the vector from them in the form (x, y, z).

    >>> create_vector((0, 0, 0), (1, 1, 1))
    (1, 1, 1)
    >>> create_vector((45, 70, 24), (47, 32, 1))
    (2, -38, -23)
    >>> create_vector((-14, -1, -8), (-7, 6, 4))
    (7, 7, 12)
    """"""
    x = end_point2[0] - end_point1[0]
    y = end_point2[1] - end_point1[1]
    z = end_point2[2] - end_point1[2]
    return (x, y, z)",data\repos\Python\maths\points_are_collinear_3d.py,create_vector,201
1517,points_are_collinear_3d.py::get_3d_vectors_cross::52,"def get_3d_vectors_cross(ab: Vector3d, ac: Vector3d) -> Vector3d:
    """"""
    Get the cross of the two vectors AB and AC.

    I used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.

    Read More:
        https://en.wikipedia.org/wiki/Cross_product
        https://en.wikipedia.org/wiki/Determinant

    >>> get_3d_vectors_cross((3, 4, 7), (4, 9, 2))
    (-55, 22, 11)
    >>> get_3d_vectors_cross((1, 1, 1), (1, 1, 1))
    (0, 0, 0)
    >>> get_3d_vectors_cross((-4, 3, 0), (3, -9, -12))
    (-36, -48, 27)
    >>> get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33))
    (-123.2594, 277.15110000000004, 129.11260000000001)
    """"""
    x = ab[1] * ac[2] - ab[2] * ac[1]  # *i
    y = (ab[0] * ac[2] - ab[2] * ac[0]) * -1  # *j
    z = ab[0] * ac[1] - ab[1] * ac[0]  # *k
    return (x, y, z)",data\repos\Python\maths\points_are_collinear_3d.py,get_3d_vectors_cross,355
1518,points_are_collinear_3d.py::is_zero_vector::77,"def is_zero_vector(vector: Vector3d, accuracy: int) -> bool:
    """"""
    Check if vector is equal to (0, 0, 0) or not.

    Since the algorithm is very accurate, we will never get a zero vector,
    so we need to round the vector axis,
    because we want a result that is either True or False.
    In other applications, we can return a float that represents the collinearity ratio.

    >>> is_zero_vector((0, 0, 0), accuracy=10)
    True
    >>> is_zero_vector((15, 74, 32), accuracy=10)
    False
    >>> is_zero_vector((-15, -74, -32), accuracy=10)
    False
    """"""
    return tuple(round(x, accuracy) for x in vector) == (0, 0, 0)",data\repos\Python\maths\points_are_collinear_3d.py,is_zero_vector,183
1519,points_are_collinear_3d.py::are_collinear::96,"def are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:
    """"""
    Check if three points are collinear or not.

    1- Create two vectors AB and AC.
    2- Get the cross vector of the two vectors.
    3- Calculate the length of the cross vector.
    4- If the length is zero then the points are collinear, else they are not.

    The use of the accuracy parameter is explained in is_zero_vector docstring.

    >>> are_collinear((4.802293498137402, 3.536233125455244, 0),
    ...               (-2.186788107953106, -9.24561398001649, 7.141509524846482),
    ...               (1.530169574640268, -2.447927606600034, 3.343487096469054))
    True
    >>> are_collinear((-6, -2, 6),
    ...               (6.200213806439997, -4.930157614926678, -4.482371908289856),
    ...               (-4.085171149525941, -2.459889509029438, 4.354787180795383))
    True
    >>> are_collinear((2.399001826862445, -2.452009976680793, 4.464656666157666),
    ...               (-3.682816335934376, 5.753788986533145, 9.490993909044244),
    ...               (1.962903518985307, 3.741415730125627, 7))
    False
    >>> are_collinear((1.875375340689544, -7.268426006071538, 7.358196269835993),
    ...               (-3.546599383667157, -4.630005261513976, 3.208784032924246),
    ...               (-2.564606140206386, 3.937845170672183, 7))
    False
    """"""
    ab = create_vector(a, b)
    ac = create_vector(a, c)
    return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)",data\repos\Python\maths\points_are_collinear_3d.py,are_collinear,499
1520,pollard_rho.py::pollard_rho::6,"def pollard_rho(
    num: int,
    seed: int = 2,
    step: int = 1,
    attempts: int = 3,
) -> int | None:
    """"""
    Use Pollard's Rho algorithm to return a nontrivial factor of ``num``.
    The returned factor may be composite and require further factorization.
    If the algorithm will return None if it fails to find a factor within
    the specified number of attempts or within the specified number of steps.
    If ``num`` is prime, this algorithm is guaranteed to return None.
    https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm

    >>> pollard_rho(18446744073709551617)
    274177
    >>> pollard_rho(97546105601219326301)
    9876543191
    >>> pollard_rho(100)
    2
    >>> pollard_rho(17)
    >>> pollard_rho(17**3)
    17
    >>> pollard_rho(17**3, attempts=1)
    >>> pollard_rho(3*5*7)
    21
    >>> pollard_rho(1)
    Traceback (most recent call last):
        ...
    ValueError: The input value cannot be less than 2
    """"""
    # A value less than 2 can cause an infinite loop in the algorithm.
    if num < 2:
        raise ValueError(""The input value cannot be less than 2"")

    # Because of the relationship between ``f(f(x))`` and ``f(x)``, this
    # algorithm struggles to find factors that are divisible by two.
    # As a workaround, we specifically check for two and even inputs.
    #   See: https://math.stackexchange.com/a/2856214/165820
    if num > 2 and num % 2 == 0:
        return 2

    # Pollard's Rho algorithm requires a function that returns pseudorandom
    # values between 0 <= X < ``num``.  It doesn't need to be random in the
    # sense that the output value is cryptographically secure or difficult
    # to calculate, it only needs to be random in the sense that all output
    # values should be equally likely to appear.
    # For this reason, Pollard suggested using ``f(x) = (x**2 - 1) % num``
    # However, the success of Pollard's algorithm isn't guaranteed and is
    # determined in part by the initial seed and the chosen random function.
    # To make retries easier, we will instead use ``f(x) = (x**2 + C) % num``
    # where ``C`` is a value that we can modify between each attempt.
    def rand_fn(value: int, step: int, modulus: int) -> int:
        """"""
        Returns a pseudorandom value modulo ``modulus`` based on the
        input ``value`` and attempt-specific ``step`` size.

        >>> rand_fn(0, 0, 0)
        Traceback (most recent call last):
            ...
        ZeroDivisionError: integer division or modulo by zero
        >>> rand_fn(1, 2, 3)
        0
        >>> rand_fn(0, 10, 7)
        3
        >>> rand_fn(1234, 1, 17)
        16
        """"""
        return (pow(value, 2) + step) % modulus

    for _ in range(attempts):
        # These track the position within the cycle detection logic.
        tortoise = seed
        hare = seed

        while True:
            # At each iteration, the tortoise moves one step and the hare moves two.
            tortoise = rand_fn(tortoise, step, num)
            hare = rand_fn(hare, step, num)
            hare = rand_fn(hare, step, num)

            # At some point both the tortoise and the hare will enter a cycle whose
            # length ``p`` is a divisor of ``num``.  Once in that cycle, at some point
            # the tortoise and hare will end up on the same value modulo ``p``.
            # We can detect when this happens because the position difference between
            # the tortoise and the hare will share a common divisor with ``num``.
            divisor = gcd(hare - tortoise, num)

            if divisor == 1:
                # No common divisor yet, just keep searching.
                continue
            # We found a common divisor!
            elif divisor == num:
                # Unfortunately, the divisor is ``num`` itself and is useless.
                break
            else:
                # The divisor is a nontrivial factor of ``num``!
                return divisor

        # If we made it here, then this attempt failed.
        # We need to pick a new starting seed for the tortoise and hare
        # in addition to a new step value for the random function.
        # To keep this example implementation deterministic, the
        # new values will be generated based on currently available
        # values instead of using something like ``random.randint``.

        # We can use the hare's position as the new seed.
        # This is actually what Richard Brent's the ""optimized"" variant does.
        seed = hare

        # The new step value for the random function can just be incremented.
        # At first the results will be similar to what the old function would
        # have produced, but the value will quickly diverge after a bit.
        step += 1

    # We haven't found a divisor within the requested number of attempts.
    # We were unlucky or ``num`` itself is actually prime.
    return None",data\repos\Python\maths\pollard_rho.py,pollard_rho,1212
1521,pollard_rho.py::rand_fn::58,"    def rand_fn(value: int, step: int, modulus: int) -> int:
        """"""
        Returns a pseudorandom value modulo ``modulus`` based on the
        input ``value`` and attempt-specific ``step`` size.

        >>> rand_fn(0, 0, 0)
        Traceback (most recent call last):
            ...
        ZeroDivisionError: integer division or modulo by zero
        >>> rand_fn(1, 2, 3)
        0
        >>> rand_fn(0, 10, 7)
        3
        >>> rand_fn(1234, 1, 17)
        16
        """"""
        return (pow(value, 2) + step) % modulus",data\repos\Python\maths\pollard_rho.py,rand_fn,154
1522,polynomial_evaluation.py::evaluate_poly::4,"def evaluate_poly(poly: Sequence[float], x: float) -> float:
    """"""Evaluate a polynomial f(x) at specified point x and return the value.

    Arguments:
    poly -- the coefficients of a polynomial as an iterable in order of
            ascending degree
    x -- the point at which to evaluate the polynomial

    >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)
    79800.0
    """"""
    return sum(c * (x**i) for i, c in enumerate(poly))",data\repos\Python\maths\polynomial_evaluation.py,evaluate_poly,127
1523,polynomial_evaluation.py::horner::18,"def horner(poly: Sequence[float], x: float) -> float:
    """"""Evaluate a polynomial at specified point using Horner's method.

    In terms of computational complexity, Horner's method is an efficient method
    of evaluating a polynomial. It avoids the use of expensive exponentiation,
    and instead uses only multiplication and addition to evaluate the polynomial
    in O(n), where n is the degree of the polynomial.

    https://en.wikipedia.org/wiki/Horner's_method

    Arguments:
    poly -- the coefficients of a polynomial as an iterable in order of
            ascending degree
    x -- the point at which to evaluate the polynomial

    >>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)
    79800.0
    """"""
    result = 0.0
    for coeff in reversed(poly):
        result = result * x + coeff
    return result",data\repos\Python\maths\polynomial_evaluation.py,horner,204
1524,power_using_recursion.py::power::16,"def power(base: int, exponent: int) -> float:
    """"""
    Calculate the power of a base raised to an exponent.

    >>> power(3, 4)
    81
    >>> power(2, 0)
    1
    >>> all(power(base, exponent) == pow(base, exponent)
    ...     for base in range(-10, 10) for exponent in range(10))
    True
    >>> power('a', 1)
    'a'
    >>> power('a', 2)
    Traceback (most recent call last):
        ...
    TypeError: can't multiply sequence by non-int of type 'str'
    >>> power('a', 'b')
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
    >>> power(2, -1)
    Traceback (most recent call last):
        ...
    RecursionError: maximum recursion depth exceeded
    >>> power(0, 0)
    1
    >>> power(0, 1)
    0
    >>> power(5,6)
    15625
    >>> power(23, 12)
    21914624432020321
    """"""
    return base * power(base, (exponent - 1)) if exponent else 1",data\repos\Python\maths\power_using_recursion.py,power,283
1525,primelib.py::is_prime::45,"def is_prime(number: int) -> bool:
    """"""
    input: positive integer 'number'
    returns true if 'number' is prime otherwise false.

    >>> is_prime(3)
    True
    >>> is_prime(10)
    False
    >>> is_prime(97)
    True
    >>> is_prime(9991)
    False
    >>> is_prime(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and positive
    >>> is_prime(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and positive
    """"""

    # precondition
    assert isinstance(number, int) and (number >= 0), (
        ""'number' must been an int and positive""
    )

    status = True

    # 0 and 1 are none primes.
    if number <= 1:
        status = False

    for divisor in range(2, round(sqrt(number)) + 1):
        # if 'number' divisible by 'divisor' then sets 'status'
        # of false and break up the loop.
        if number % divisor == 0:
            status = False
            break

    # precondition
    assert isinstance(status, bool), ""'status' must been from type bool""

    return status",data\repos\Python\maths\primelib.py,is_prime,280
1526,primelib.py::sieve_er::95,"def sieve_er(n):
    """"""
    input: positive integer 'N' > 2
    returns a list of prime numbers from 2 up to N.

    This function implements the algorithm called
    sieve of erathostenes.

    >>> sieve_er(8)
    [2, 3, 5, 7]
    >>> sieve_er(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'N' must been an int and > 2
    >>> sieve_er(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'N' must been an int and > 2
    """"""

    # precondition
    assert isinstance(n, int) and (n > 2), ""'N' must been an int and > 2""

    # beginList: contains all natural numbers from 2 up to N
    begin_list = list(range(2, n + 1))

    ans = []  # this list will be returns.

    # actual sieve of erathostenes
    for i in range(len(begin_list)):
        for j in range(i + 1, len(begin_list)):
            if (begin_list[i] != 0) and (begin_list[j] % begin_list[i] == 0):
                begin_list[j] = 0

    # filters actual prime numbers.
    ans = [x for x in begin_list if x != 0]

    # precondition
    assert isinstance(ans, list), ""'ans' must been from type list""

    return ans",data\repos\Python\maths\primelib.py,sieve_er,323
1527,primelib.py::get_prime_numbers::141,"def get_prime_numbers(n):
    """"""
    input: positive integer 'N' > 2
    returns a list of prime numbers from 2 up to N (inclusive)
    This function is more efficient as function 'sieveEr(...)'

    >>> get_prime_numbers(8)
    [2, 3, 5, 7]
    >>> get_prime_numbers(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'N' must been an int and > 2
    >>> get_prime_numbers(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'N' must been an int and > 2
    """"""

    # precondition
    assert isinstance(n, int) and (n > 2), ""'N' must been an int and > 2""

    ans = []

    # iterates over all numbers between 2 up to N+1
    # if a number is prime then appends to list 'ans'
    for number in range(2, n + 1):
        if is_prime(number):
            ans.append(number)

    # precondition
    assert isinstance(ans, list), ""'ans' must been from type list""

    return ans",data\repos\Python\maths\primelib.py,get_prime_numbers,253
1528,primelib.py::prime_factorization::179,"def prime_factorization(number):
    """"""
    input: positive integer 'number'
    returns a list of the prime number factors of 'number'

    >>> prime_factorization(0)
    [0]
    >>> prime_factorization(8)
    [2, 2, 2]
    >>> prime_factorization(287)
    [7, 41]
    >>> prime_factorization(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 0
    >>> prime_factorization(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 0
    """"""

    # precondition
    assert isinstance(number, int) and number >= 0, ""'number' must been an int and >= 0""

    ans = []  # this list will be returns of the function.

    # potential prime number factors.

    factor = 2

    quotient = number

    if number in {0, 1}:
        ans.append(number)

    # if 'number' not prime then builds the prime factorization of 'number'
    elif not is_prime(number):
        while quotient != 1:
            if is_prime(factor) and (quotient % factor == 0):
                ans.append(factor)
                quotient /= factor
            else:
                factor += 1

    else:
        ans.append(number)

    # precondition
    assert isinstance(ans, list), ""'ans' must been from type list""

    return ans",data\repos\Python\maths\primelib.py,prime_factorization,320
1529,primelib.py::greatest_prime_factor::235,"def greatest_prime_factor(number):
    """"""
    input: positive integer 'number' >= 0
    returns the greatest prime number factor of 'number'

    >>> greatest_prime_factor(0)
    0
    >>> greatest_prime_factor(8)
    2
    >>> greatest_prime_factor(287)
    41
    >>> greatest_prime_factor(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 0
    >>> greatest_prime_factor(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 0
    """"""

    # precondition
    assert isinstance(number, int) and (number >= 0), (
        ""'number' must been an int and >= 0""
    )

    ans = 0

    # prime factorization of 'number'
    prime_factors = prime_factorization(number)

    ans = max(prime_factors)

    # precondition
    assert isinstance(ans, int), ""'ans' must been from type int""

    return ans",data\repos\Python\maths\primelib.py,greatest_prime_factor,226
1530,primelib.py::smallest_prime_factor::277,"def smallest_prime_factor(number):
    """"""
    input: integer 'number' >= 0
    returns the smallest prime number factor of 'number'

    >>> smallest_prime_factor(0)
    0
    >>> smallest_prime_factor(8)
    2
    >>> smallest_prime_factor(287)
    7
    >>> smallest_prime_factor(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 0
    >>> smallest_prime_factor(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 0
    """"""

    # precondition
    assert isinstance(number, int) and (number >= 0), (
        ""'number' must been an int and >= 0""
    )

    ans = 0

    # prime factorization of 'number'
    prime_factors = prime_factorization(number)

    ans = min(prime_factors)

    # precondition
    assert isinstance(ans, int), ""'ans' must been from type int""

    return ans",data\repos\Python\maths\primelib.py,smallest_prime_factor,225
1531,primelib.py::is_even::319,"def is_even(number):
    """"""
    input: integer 'number'
    returns true if 'number' is even, otherwise false.

    >>> is_even(0)
    True
    >>> is_even(8)
    True
    >>> is_even(287)
    False
    >>> is_even(-1)
    False
    >>> is_even(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int
    """"""

    # precondition
    assert isinstance(number, int), ""'number' must been an int""
    assert isinstance(number % 2 == 0, bool), ""compare must been from type bool""

    return number % 2 == 0",data\repos\Python\maths\primelib.py,is_even,147
1532,primelib.py::is_odd::348,"def is_odd(number):
    """"""
    input: integer 'number'
    returns true if 'number' is odd, otherwise false.

    >>> is_odd(0)
    False
    >>> is_odd(8)
    False
    >>> is_odd(287)
    True
    >>> is_odd(-1)
    True
    >>> is_odd(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int
    """"""

    # precondition
    assert isinstance(number, int), ""'number' must been an int""
    assert isinstance(number % 2 != 0, bool), ""compare must been from type bool""

    return number % 2 != 0",data\repos\Python\maths\primelib.py,is_odd,147
1533,primelib.py::goldbach::377,"def goldbach(number):
    """"""
    Goldbach's assumption
    input: a even positive integer 'number' > 2
    returns a list of two prime numbers whose sum is equal to 'number'

    >>> goldbach(8)
    [3, 5]
    >>> goldbach(824)
    [3, 821]
    >>> goldbach(0)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int, even and > 2
    >>> goldbach(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int, even and > 2
    >>> goldbach(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int, even and > 2
    """"""

    # precondition
    assert isinstance(number, int) and (number > 2) and is_even(number), (
        ""'number' must been an int, even and > 2""
    )

    ans = []  # this list will returned

    # creates a list of prime numbers between 2 up to 'number'
    prime_numbers = get_prime_numbers(number)
    len_pn = len(prime_numbers)

    # run variable for while-loops.
    i = 0
    j = None

    # exit variable. for break up the loops
    loop = True

    while i < len_pn and loop:
        j = i + 1

        while j < len_pn and loop:
            if prime_numbers[i] + prime_numbers[j] == number:
                loop = False
                ans.append(prime_numbers[i])
                ans.append(prime_numbers[j])

            j += 1

        i += 1

    # precondition
    assert (
        isinstance(ans, list)
        and (len(ans) == 2)
        and (ans[0] + ans[1] == number)
        and is_prime(ans[0])
        and is_prime(ans[1])
    ), ""'ans' must contains two primes. And sum of elements must been eq 'number'""

    return ans",data\repos\Python\maths\primelib.py,goldbach,454
1534,primelib.py::kg_v::447,"def kg_v(number1, number2):
    """"""
    Least common multiple
    input: two positive integer 'number1' and 'number2'
    returns the least common multiple of 'number1' and 'number2'

    >>> kg_v(8,10)
    40
    >>> kg_v(824,67)
    55208
    >>> kg_v(1, 10)
    10
    >>> kg_v(0)
    Traceback (most recent call last):
        ...
    TypeError: kg_v() missing 1 required positional argument: 'number2'
    >>> kg_v(10,-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number1' and 'number2' must been positive integer.
    >>> kg_v(""test"",""test2"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number1' and 'number2' must been positive integer.
    """"""

    # precondition
    assert (
        isinstance(number1, int)
        and isinstance(number2, int)
        and (number1 >= 1)
        and (number2 >= 1)
    ), ""'number1' and 'number2' must been positive integer.""

    ans = 1  # actual answer that will be return.

    # for kgV (x,1)
    if number1 > 1 and number2 > 1:
        # builds the prime factorization of 'number1' and 'number2'
        prime_fac_1 = prime_factorization(number1)
        prime_fac_2 = prime_factorization(number2)

    elif number1 == 1 or number2 == 1:
        prime_fac_1 = []
        prime_fac_2 = []
        ans = max(number1, number2)

    count1 = 0
    count2 = 0

    done = []  # captured numbers int both 'primeFac1' and 'primeFac2'

    # iterates through primeFac1
    for n in prime_fac_1:
        if n not in done:
            if n in prime_fac_2:
                count1 = prime_fac_1.count(n)
                count2 = prime_fac_2.count(n)

                for _ in range(max(count1, count2)):
                    ans *= n

            else:
                count1 = prime_fac_1.count(n)

                for _ in range(count1):
                    ans *= n

            done.append(n)

    # iterates through primeFac2
    for n in prime_fac_2:
        if n not in done:
            count2 = prime_fac_2.count(n)

            for _ in range(count2):
                ans *= n

            done.append(n)

    # precondition
    assert isinstance(ans, int) and (ans >= 0), (
        ""'ans' must been from type int and positive""
    )

    return ans",data\repos\Python\maths\primelib.py,kg_v,603
1535,primelib.py::get_prime::538,"def get_prime(n):
    """"""
    Gets the n-th prime number.
    input: positive integer 'n' >= 0
    returns the n-th prime number, beginning at index 0

    >>> get_prime(0)
    2
    >>> get_prime(8)
    23
    >>> get_prime(824)
    6337
    >>> get_prime(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been a positive int
    >>> get_prime(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been a positive int
    """"""

    # precondition
    assert isinstance(n, int) and (n >= 0), ""'number' must been a positive int""

    index = 0
    ans = 2  # this variable holds the answer

    while index < n:
        index += 1

        ans += 1  # counts to the next number

        # if ans not prime then
        # runs to the next prime number.
        while not is_prime(ans):
            ans += 1

    # precondition
    assert isinstance(ans, int) and is_prime(ans), (
        ""'ans' must been a prime number and from type int""
    )

    return ans",data\repos\Python\maths\primelib.py,get_prime,274
1536,primelib.py::get_primes_between::587,"def get_primes_between(p_number_1, p_number_2):
    """"""
    input: prime numbers 'pNumber1' and 'pNumber2'
            pNumber1 < pNumber2
    returns a list of all prime numbers between 'pNumber1' (exclusive)
            and 'pNumber2' (exclusive)

    >>> get_primes_between(3, 67)
    [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
    >>> get_primes_between(0)
    Traceback (most recent call last):
        ...
    TypeError: get_primes_between() missing 1 required positional argument: 'p_number_2'
    >>> get_primes_between(0, 1)
    Traceback (most recent call last):
        ...
    AssertionError: The arguments must been prime numbers and 'pNumber1' < 'pNumber2'
    >>> get_primes_between(-1, 3)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and positive
    >>> get_primes_between(""test"",""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and positive
    """"""

    # precondition
    assert (
        is_prime(p_number_1) and is_prime(p_number_2) and (p_number_1 < p_number_2)
    ), ""The arguments must been prime numbers and 'pNumber1' < 'pNumber2'""

    number = p_number_1 + 1  # jump to the next number

    ans = []  # this list will be returns.

    # if number is not prime then
    # fetch the next prime number.
    while not is_prime(number):
        number += 1

    while number < p_number_2:
        ans.append(number)

        number += 1

        # fetch the next prime number.
        while not is_prime(number):
            number += 1

    # precondition
    assert (
        isinstance(ans, list)
        and ans[0] != p_number_1
        and ans[len(ans) - 1] != p_number_2
    ), ""'ans' must been a list without the arguments""

    # 'ans' contains not 'pNumber1' and 'pNumber2' !
    return ans",data\repos\Python\maths\primelib.py,get_primes_between,522
1537,primelib.py::get_divisors::651,"def get_divisors(n):
    """"""
    input: positive integer 'n' >= 1
    returns all divisors of n (inclusive 1 and 'n')

    >>> get_divisors(8)
    [1, 2, 4, 8]
    >>> get_divisors(824)
    [1, 2, 4, 8, 103, 206, 412, 824]
    >>> get_divisors(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'n' must been int and >= 1
    >>> get_divisors(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'n' must been int and >= 1
    """"""

    # precondition
    assert isinstance(n, int) and (n >= 1), ""'n' must been int and >= 1""

    ans = []  # will be returned.

    for divisor in range(1, n + 1):
        if n % divisor == 0:
            ans.append(divisor)

    # precondition
    assert ans[0] == 1 and ans[len(ans) - 1] == n, ""Error in function getDivisiors(...)""

    return ans",data\repos\Python\maths\primelib.py,get_divisors,262
1538,primelib.py::is_perfect_number::688,"def is_perfect_number(number):
    """"""
    input: positive integer 'number' > 1
    returns true if 'number' is a perfect number otherwise false.

    >>> is_perfect_number(28)
    True
    >>> is_perfect_number(824)
    False
    >>> is_perfect_number(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 1
    >>> is_perfect_number(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'number' must been an int and >= 1
    """"""

    # precondition
    assert isinstance(number, int) and (number > 1), (
        ""'number' must been an int and >= 1""
    )

    divisors = get_divisors(number)

    # precondition
    assert (
        isinstance(divisors, list)
        and (divisors[0] == 1)
        and (divisors[len(divisors) - 1] == number)
    ), ""Error in help-function getDivisiors(...)""

    # summed all divisors up to 'number' (exclusive), hence [:-1]
    return sum(divisors[:-1]) == number",data\repos\Python\maths\primelib.py,is_perfect_number,258
1539,primelib.py::simplify_fraction::728,"def simplify_fraction(numerator, denominator):
    """"""
    input: two integer 'numerator' and 'denominator'
    assumes: 'denominator' != 0
    returns: a tuple with simplify numerator and denominator.

    >>> simplify_fraction(10, 20)
    (1, 2)
    >>> simplify_fraction(10, -1)
    (10, -1)
    >>> simplify_fraction(""test"",""test"")
    Traceback (most recent call last):
        ...
    AssertionError: The arguments must been from type int and 'denominator' != 0
    """"""

    # precondition
    assert (
        isinstance(numerator, int)
        and isinstance(denominator, int)
        and (denominator != 0)
    ), ""The arguments must been from type int and 'denominator' != 0""

    # build the greatest common divisor of numerator and denominator.
    gcd_of_fraction = gcd_by_iterative(abs(numerator), abs(denominator))

    # precondition
    assert (
        isinstance(gcd_of_fraction, int)
        and (numerator % gcd_of_fraction == 0)
        and (denominator % gcd_of_fraction == 0)
    ), ""Error in function gcd_by_iterative(...,...)""

    return (numerator // gcd_of_fraction, denominator // gcd_of_fraction)",data\repos\Python\maths\primelib.py,simplify_fraction,273
1540,primelib.py::factorial::767,"def factorial(n):
    """"""
    input: positive integer 'n'
    returns the factorial of 'n' (n!)

    >>> factorial(0)
    1
    >>> factorial(20)
    2432902008176640000
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    AssertionError: 'n' must been a int and >= 0
    >>> factorial(""test"")
    Traceback (most recent call last):
        ...
    AssertionError: 'n' must been a int and >= 0
    """"""

    # precondition
    assert isinstance(n, int) and (n >= 0), ""'n' must been a int and >= 0""

    ans = 1  # this will be return.

    for factor in range(1, n + 1):
        ans *= factor

    return ans",data\repos\Python\maths\primelib.py,factorial,180
1541,primelib.py::fib::800,"def fib(n: int) -> int:
    """"""
    input: positive integer 'n'
    returns the n-th fibonacci term , indexing by 0

    >>> fib(0)
    1
    >>> fib(5)
    8
    >>> fib(20)
    10946
    >>> fib(99)
    354224848179261915075
    >>> fib(-1)
    Traceback (most recent call last):
    ...
    AssertionError: 'n' must been an int and >= 0
    >>> fib(""test"")
    Traceback (most recent call last):
    ...
    AssertionError: 'n' must been an int and >= 0
    """"""

    # precondition
    assert isinstance(n, int) and (n >= 0), ""'n' must been an int and >= 0""

    tmp = 0
    fib1 = 1
    ans = 1  # this will be return

    for _ in range(n - 1):
        tmp = ans
        ans += fib1
        fib1 = tmp

    return ans",data\repos\Python\maths\primelib.py,fib,230
1542,prime_check.py::is_prime::9,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).

    A number is prime if it has exactly two factors: 1 and itself.

    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(87)
    False
    >>> is_prime(563)
    True
    >>> is_prime(2999)
    True
    >>> is_prime(67483)
    False
    >>> is_prime(16.1)
    Traceback (most recent call last):
        ...
    ValueError: is_prime() only accepts positive integers
    >>> is_prime(-4)
    Traceback (most recent call last):
        ...
    ValueError: is_prime() only accepts positive integers
    """"""

    # precondition
    if not isinstance(number, int) or not number >= 0:
        raise ValueError(""is_prime() only accepts positive integers"")

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\maths\prime_check.py,is_prime,368
1543,prime_check.py::test_primes::61,"    def test_primes(self):
        assert is_prime(2)
        assert is_prime(3)
        assert is_prime(5)
        assert is_prime(7)
        assert is_prime(11)
        assert is_prime(13)
        assert is_prime(17)
        assert is_prime(19)
        assert is_prime(23)
        assert is_prime(29)",data\repos\Python\maths\prime_check.py,test_primes,77
1544,prime_check.py::test_not_primes::73,"    def test_not_primes(self):
        with pytest.raises(ValueError):
            is_prime(-19)
        assert not is_prime(0), (
            ""Zero doesn't have any positive factors, primes must have exactly two.""
        )
        assert not is_prime(1), (
            ""One only has 1 positive factor, primes must have exactly two.""
        )
        assert not is_prime(2 * 2)
        assert not is_prime(2 * 3)
        assert not is_prime(3 * 3)
        assert not is_prime(3 * 5)
        assert not is_prime(3 * 5 * 7)",data\repos\Python\maths\prime_check.py,test_not_primes,132
1545,prime_factors.py::prime_factors::8,"def prime_factors(n: int) -> list[int]:
    """"""
    Returns prime factors of n as a list.

    >>> prime_factors(0)
    []
    >>> prime_factors(100)
    [2, 2, 5, 5]
    >>> prime_factors(2560)
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]
    >>> prime_factors(10**-2)
    []
    >>> prime_factors(0.02)
    []
    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE
    >>> x == [2]*241 + [5]*241
    True
    >>> prime_factors(10**-354)
    []
    >>> prime_factors('hello')
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> prime_factors([1,2,'hello'])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'

    """"""
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",data\repos\Python\maths\prime_factors.py,prime_factors,299
1546,prime_factors.py::unique_prime_factors::50,"def unique_prime_factors(n: int) -> list[int]:
    """"""
    Returns unique prime factors of n as a list.

    >>> unique_prime_factors(0)
    []
    >>> unique_prime_factors(100)
    [2, 5]
    >>> unique_prime_factors(2560)
    [2, 5]
    >>> unique_prime_factors(10**-2)
    []
    >>> unique_prime_factors(0.02)
    []
    >>> unique_prime_factors(10**241)
    [2, 5]
    >>> unique_prime_factors(10**-354)
    []
    >>> unique_prime_factors('hello')
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> unique_prime_factors([1,2,'hello'])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'
    """"""
    i = 2
    factors = []
    while i * i <= n:
        if not n % i:
            while not n % i:
                n //= i
            factors.append(i)
        i += 1
    if n > 1:
        factors.append(n)
    return factors",data\repos\Python\maths\prime_factors.py,unique_prime_factors,262
1547,prime_numbers.py::slow_primes::5,"def slow_primes(max_n: int) -> Generator[int]:
    """"""
    Return a list of all primes numbers up to max.
    >>> list(slow_primes(0))
    []
    >>> list(slow_primes(-1))
    []
    >>> list(slow_primes(-10))
    []
    >>> list(slow_primes(25))
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
    >>> list(slow_primes(11))
    [2, 3, 5, 7, 11]
    >>> list(slow_primes(33))
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
    >>> list(slow_primes(1000))[-1]
    997
    """"""
    numbers: Generator = (i for i in range(1, (max_n + 1)))
    for i in (n for n in numbers if n > 1):
        for j in range(2, i):
            if (i % j) == 0:
                break
        else:
            yield i",data\repos\Python\maths\prime_numbers.py,slow_primes,258
1548,prime_numbers.py::primes::32,"def primes(max_n: int) -> Generator[int]:
    """"""
    Return a list of all primes numbers up to max.
    >>> list(primes(0))
    []
    >>> list(primes(-1))
    []
    >>> list(primes(-10))
    []
    >>> list(primes(25))
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
    >>> list(primes(11))
    [2, 3, 5, 7, 11]
    >>> list(primes(33))
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
    >>> list(primes(1000))[-1]
    997
    """"""
    numbers: Generator = (i for i in range(1, (max_n + 1)))
    for i in (n for n in numbers if n > 1):
        # only need to check for factors up to sqrt(i)
        bound = int(math.sqrt(i)) + 1
        for j in range(2, bound):
            if (i % j) == 0:
                break
        else:
            yield i",data\repos\Python\maths\prime_numbers.py,primes,267
1549,prime_numbers.py::fast_primes::61,"def fast_primes(max_n: int) -> Generator[int]:
    """"""
    Return a list of all primes numbers up to max.
    >>> list(fast_primes(0))
    []
    >>> list(fast_primes(-1))
    []
    >>> list(fast_primes(-10))
    []
    >>> list(fast_primes(25))
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
    >>> list(fast_primes(11))
    [2, 3, 5, 7, 11]
    >>> list(fast_primes(33))
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
    >>> list(fast_primes(1000))[-1]
    997
    """"""
    numbers: Generator = (i for i in range(1, (max_n + 1), 2))
    # It's useless to test even numbers as they will not be prime
    if max_n > 2:
        yield 2  # Because 2 will not be tested, it's necessary to yield it now
    for i in (n for n in numbers if n > 1):
        bound = int(math.sqrt(i)) + 1
        for j in range(3, bound, 2):
            # As we removed the even numbers, we don't need them now
            if (i % j) == 0:
                break
        else:
            yield i",data\repos\Python\maths\prime_numbers.py,fast_primes,338
1550,prime_numbers.py::benchmark::93,"def benchmark():
    """"""
    Let's benchmark our functions side-by-side...
    """"""
    from timeit import timeit

    setup = ""from __main__ import slow_primes, primes, fast_primes""
    print(timeit(""slow_primes(1_000_000_000_000)"", setup=setup, number=1_000_000))
    print(timeit(""primes(1_000_000_000_000)"", setup=setup, number=1_000_000))
    print(timeit(""fast_primes(1_000_000_000_000)"", setup=setup, number=1_000_000))",data\repos\Python\maths\prime_numbers.py,benchmark,136
1551,prime_sieve_eratosthenes.py::prime_sieve_eratosthenes::15,"def prime_sieve_eratosthenes(num: int) -> list[int]:
    """"""
    Print the prime numbers up to n

    >>> prime_sieve_eratosthenes(10)
    [2, 3, 5, 7]
    >>> prime_sieve_eratosthenes(20)
    [2, 3, 5, 7, 11, 13, 17, 19]
    >>> prime_sieve_eratosthenes(2)
    [2]
    >>> prime_sieve_eratosthenes(1)
    []
    >>> prime_sieve_eratosthenes(-1)
    Traceback (most recent call last):
    ...
    ValueError: Input must be a positive integer
    """"""

    if num <= 0:
        raise ValueError(""Input must be a positive integer"")

    primes = [True] * (num + 1)

    p = 2
    while p * p <= num:
        if primes[p]:
            for i in range(p * p, num + 1, p):
                primes[i] = False
        p += 1

    return [prime for prime in range(2, num + 1) if primes[prime]]",data\repos\Python\maths\prime_sieve_eratosthenes.py,prime_sieve_eratosthenes,260
1552,print_multiplication_table.py::multiplication_table::1,"def multiplication_table(number: int, number_of_terms: int) -> str:
    """"""
    Prints the multiplication table of a given number till the given number of terms

    >>> print(multiplication_table(3, 5))
    3 * 1 = 3
    3 * 2 = 6
    3 * 3 = 9
    3 * 4 = 12
    3 * 5 = 15

    >>> print(multiplication_table(-4, 6))
    -4 * 1 = -4
    -4 * 2 = -8
    -4 * 3 = -12
    -4 * 4 = -16
    -4 * 5 = -20
    -4 * 6 = -24
    """"""
    return ""\n"".join(
        f""{number} * {i} = {number * i}"" for i in range(1, number_of_terms + 1)
    )",data\repos\Python\maths\print_multiplication_table.py,multiplication_table,210
1553,pythagoras.py::distance::16,"def distance(a: Point, b: Point) -> float:
    """"""
    >>> point1 = Point(2, -1, 7)
    >>> point2 = Point(1, -3, 5)
    >>> print(f""Distance from {point1} to {point2} is {distance(point1, point2)}"")
    Distance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0
    """"""
    return math.sqrt(abs((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2))",data\repos\Python\maths\pythagoras.py,distance,141
1554,qr_decomposition.py::qr_householder::4,"def qr_householder(a: np.ndarray):
    """"""Return a QR-decomposition of the matrix A using Householder reflection.

    The QR-decomposition decomposes the matrix A of shape (m, n) into an
    orthogonal matrix Q of shape (m, m) and an upper triangular matrix R of
    shape (m, n).  Note that the matrix A does not have to be square.  This
    method of decomposing A uses the Householder reflection, which is
    numerically stable and of complexity O(n^3).

    https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections

    Arguments:
    A -- a numpy.ndarray of shape (m, n)

    Note: several optimizations can be made for numeric efficiency, but this is
    intended to demonstrate how it would be represented in a mathematics
    textbook.  In cases where efficiency is particularly important, an optimized
    version from BLAS should be used.

    >>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float)
    >>> Q, R = qr_householder(A)

    >>> # check that the decomposition is correct
    >>> np.allclose(Q@R, A)
    True

    >>> # check that Q is orthogonal
    >>> np.allclose(Q@Q.T, np.eye(A.shape[0]))
    True
    >>> np.allclose(Q.T@Q, np.eye(A.shape[0]))
    True

    >>> # check that R is upper triangular
    >>> np.allclose(np.triu(R), R)
    True
    """"""
    m, n = a.shape
    t = min(m, n)
    q = np.eye(m)
    r = a.copy()

    for k in range(t - 1):
        # select a column of modified matrix A':
        x = r[k:, [k]]
        # construct first basis vector
        e1 = np.zeros_like(x)
        e1[0] = 1.0
        # determine scaling factor
        alpha = np.linalg.norm(x)
        # construct vector v for Householder reflection
        v = x + np.sign(x[0]) * alpha * e1
        v /= np.linalg.norm(v)

        # construct the Householder matrix
        q_k = np.eye(m - k) - 2.0 * v @ v.T
        # pad with ones and zeros as necessary
        q_k = np.block([[np.eye(k), np.zeros((k, m - k))], [np.zeros((m - k, k)), q_k]])

        q = q @ q_k.T
        r = q_k @ r

    return q, r",data\repos\Python\maths\qr_decomposition.py,qr_householder,579
1555,quadratic_equations_complex_numbers.py::quadratic_roots::6,"def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:
    """"""
    Given the numerical coefficients a, b and c,
    calculates the roots for any quadratic equation of the form ax^2 + bx + c

    >>> quadratic_roots(a=1, b=3, c=-4)
    (1.0, -4.0)
    >>> quadratic_roots(5, 6, 1)
    (-0.2, -1.0)
    >>> quadratic_roots(1, -6, 25)
    ((3+4j), (3-4j))
    """"""

    if a == 0:
        raise ValueError(""Coefficient 'a' must not be zero."")
    delta = b * b - 4 * a * c

    root_1 = (-b + sqrt(delta)) / (2 * a)
    root_2 = (-b - sqrt(delta)) / (2 * a)

    return (
        root_1.real if not root_1.imag else root_1,
        root_2.real if not root_2.imag else root_2,
    )",data\repos\Python\maths\quadratic_equations_complex_numbers.py,quadratic_roots,242
1556,quadratic_equations_complex_numbers.py::main::32,"def main():
    solution1, solution2 = quadratic_roots(a=5, b=6, c=1)
    print(f""The solutions are: {solution1} and {solution2}"")",data\repos\Python\maths\quadratic_equations_complex_numbers.py,main,41
1557,radians.py::radians::4,"def radians(degree: float) -> float:
    """"""
    Converts the given angle from degrees to radians
    https://en.wikipedia.org/wiki/Radian

    >>> radians(180)
    3.141592653589793
    >>> radians(92)
    1.6057029118347832
    >>> radians(274)
    4.782202150464463
    >>> radians(109.82)
    1.9167205845401725

    >>> from math import radians as math_radians
    >>> all(abs(radians(i) - math_radians(i)) <= 1e-8 for i in range(-2, 361))
    True
    """"""

    return degree / (180 / pi)",data\repos\Python\maths\radians.py,radians,155
1558,remove_digit.py::remove_digit::1,"def remove_digit(num: int) -> int:
    """"""

    returns the biggest possible result
    that can be achieved by removing
    one digit from the given number

    >>> remove_digit(152)
    52
    >>> remove_digit(6385)
    685
    >>> remove_digit(-11)
    1
    >>> remove_digit(2222222)
    222222
    >>> remove_digit(""2222222"")
    Traceback (most recent call last):
    TypeError: only integers accepted as input
    >>> remove_digit(""string input"")
    Traceback (most recent call last):
    TypeError: only integers accepted as input
    """"""

    if not isinstance(num, int):
        raise TypeError(""only integers accepted as input"")
    else:
        num_str = str(abs(num))
        num_transpositions = [list(num_str) for char in range(len(num_str))]
        for index in range(len(num_str)):
            num_transpositions[index].pop(index)
        return max(
            int("""".join(list(transposition))) for transposition in num_transpositions
        )",data\repos\Python\maths\remove_digit.py,remove_digit,226
1559,segmented_sieve.py::sieve::6,"def sieve(n: int) -> list[int]:
    """"""
    Segmented Sieve.

    Examples:
    >>> sieve(8)
    [2, 3, 5, 7]

    >>> sieve(27)
    [2, 3, 5, 7, 11, 13, 17, 19, 23]

    >>> sieve(0)
    Traceback (most recent call last):
        ...
    ValueError: Number 0 must instead be a positive integer

    >>> sieve(-1)
    Traceback (most recent call last):
        ...
    ValueError: Number -1 must instead be a positive integer

    >>> sieve(22.2)
    Traceback (most recent call last):
        ...
    ValueError: Number 22.2 must instead be a positive integer
    """"""

    if n <= 0 or isinstance(n, float):
        msg = f""Number {n} must instead be a positive integer""
        raise ValueError(msg)

    in_prime = []
    start = 2
    end = int(math.sqrt(n))  # Size of every segment
    temp = [True] * (end + 1)
    prime = []

    while start <= end:
        if temp[start] is True:
            in_prime.append(start)
            for i in range(start * start, end + 1, start):
                temp[i] = False
        start += 1
    prime += in_prime

    low = end + 1
    high = min(2 * end, n)

    while low <= n:
        temp = [True] * (high - low + 1)
        for each in in_prime:
            t = math.floor(low / each) * each
            if t < low:
                t += each

            for j in range(t, high + 1, each):
                temp[j - low] = False

        for j in range(len(temp)):
            if temp[j] is True:
                prime.append(j + low)

        low = high + 1
        high = min(high + end, n)

    return prime",data\repos\Python\maths\segmented_sieve.py,sieve,438
1560,sieve_of_eratosthenes.py::prime_sieve::19,"def prime_sieve(num: int) -> list[int]:
    """"""
    Returns a list with all prime numbers up to n.

    >>> prime_sieve(50)
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    >>> prime_sieve(25)
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
    >>> prime_sieve(10)
    [2, 3, 5, 7]
    >>> prime_sieve(9)
    [2, 3, 5, 7]
    >>> prime_sieve(2)
    [2]
    >>> prime_sieve(1)
    []
    """"""

    if num <= 0:
        msg = f""{num}: Invalid input, please enter a positive integer.""
        raise ValueError(msg)

    sieve = [True] * (num + 1)
    prime = []
    start = 2
    end = int(math.sqrt(num))

    while start <= end:
        # If start is a prime
        if sieve[start] is True:
            prime.append(start)

            # Set multiples of start be False
            for i in range(start * start, num + 1, start):
                if sieve[i] is True:
                    sieve[i] = False

        start += 1

    for j in range(end + 1, num + 1):
        if sieve[j] is True:
            prime.append(j)

    return prime",data\repos\Python\maths\sieve_of_eratosthenes.py,prime_sieve,345
1561,sigmoid.py::sigmoid::14,"def sigmoid(vector: np.ndarray) -> np.ndarray:
    """"""
    Implements the sigmoid function

    Parameters:
        vector (np.array): A  numpy array of shape (1,n)
        consisting of real values

    Returns:
        sigmoid_vec (np.array): The input numpy array, after applying
        sigmoid.

    Examples:
    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))
    array([0.26894142, 0.73105858, 0.88079708])

    >>> sigmoid(np.array([0.0]))
    array([0.5])
    """"""
    return 1 / (1 + np.exp(-vector))",data\repos\Python\maths\sigmoid.py,sigmoid,143
1562,signum.py::signum::6,"def signum(num: float) -> int:
    """"""
    Applies signum function on the number

    Custom test cases:
    >>> signum(-10)
    -1
    >>> signum(10)
    1
    >>> signum(0)
    0
    >>> signum(-20.5)
    -1
    >>> signum(20.5)
    1
    >>> signum(-1e-6)
    -1
    >>> signum(1e-6)
    1
    >>> signum(""Hello"")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    >>> signum([])
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'list' and 'int'
    """"""
    if num < 0:
        return -1
    return 1 if num else 0",data\repos\Python\maths\signum.py,signum,204
1563,signum.py::test_signum::39,"def test_signum() -> None:
    """"""
    Tests the signum function
    >>> test_signum()
    """"""
    assert signum(5) == 1
    assert signum(-5) == -1
    assert signum(0) == 0
    assert signum(10.5) == 1
    assert signum(-10.5) == -1
    assert signum(1e-6) == 1
    assert signum(-1e-6) == -1
    assert signum(123456789) == 1
    assert signum(-123456789) == -1",data\repos\Python\maths\signum.py,test_signum,137
1564,simultaneous_linear_equation_solver.py::simplify::12,"def simplify(current_set: list[list]) -> list[list]:
    """"""
    >>> simplify([[1, 2, 3], [4, 5, 6]])
    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]
    >>> simplify([[5, 2, 5], [5, 1, 10]])
    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]
    """"""
    # Divide each row by magnitude of first term --> creates 'unit' matrix
    duplicate_set = current_set.copy()
    for row_index, row in enumerate(duplicate_set):
        magnitude = row[0]
        for column_index, column in enumerate(row):
            if magnitude == 0:
                current_set[row_index][column_index] = column
                continue
            current_set[row_index][column_index] = column / magnitude
    # Subtract to cancel term
    first_row = current_set[0]
    final_set = [first_row]
    current_set = current_set[1::]
    for row in current_set:
        temp_row = []
        # If first term is 0, it is already in form we want, so we preserve it
        if row[0] == 0:
            final_set.append(row)
            continue
        for column_index in range(len(row)):
            temp_row.append(first_row[column_index] - row[column_index])
        final_set.append(temp_row)
    # Create next recursion iteration set
    if len(final_set[0]) != 3:
        current_first_row = final_set[0]
        current_first_column = []
        next_iteration = []
        for row in final_set[1::]:
            current_first_column.append(row[0])
            next_iteration.append(row[1::])
        resultant = simplify(next_iteration)
        for i in range(len(resultant)):
            resultant[i].insert(0, current_first_column[i])
        resultant.insert(0, current_first_row)
        final_set = resultant
    return final_set",data\repos\Python\maths\simultaneous_linear_equation_solver.py,simplify,445
1565,simultaneous_linear_equation_solver.py::solve_simultaneous::57,"def solve_simultaneous(equations: list[list]) -> list:
    """"""
    >>> solve_simultaneous([[1, 2, 3],[4, 5, 6]])
    [-1.0, 2.0]
    >>> solve_simultaneous([[0, -3, 1, 7],[3, 2, -1, 11],[5, 1, -2, 12]])
    [6.4, 1.2, 10.6]
    >>> solve_simultaneous([])
    Traceback (most recent call last):
        ...
    IndexError: solve_simultaneous() requires n lists of length n+1
    >>> solve_simultaneous([[1, 2, 3],[1, 2]])
    Traceback (most recent call last):
        ...
    IndexError: solve_simultaneous() requires n lists of length n+1
    >>> solve_simultaneous([[1, 2, 3],[""a"", 7, 8]])
    Traceback (most recent call last):
        ...
    ValueError: solve_simultaneous() requires lists of integers
    >>> solve_simultaneous([[0, 2, 3],[4, 0, 6]])
    Traceback (most recent call last):
        ...
    ValueError: solve_simultaneous() requires at least 1 full equation
    """"""
    if len(equations) == 0:
        raise IndexError(""solve_simultaneous() requires n lists of length n+1"")
    _length = len(equations) + 1
    if any(len(item) != _length for item in equations):
        raise IndexError(""solve_simultaneous() requires n lists of length n+1"")
    for row in equations:
        if any(not isinstance(column, (int, float)) for column in row):
            raise ValueError(""solve_simultaneous() requires lists of integers"")
    if len(equations) == 1:
        return [equations[0][-1] / equations[0][0]]
    data_set = equations.copy()
    if any(0 in row for row in data_set):
        temp_data = data_set.copy()
        full_row = []
        for row_index, row in enumerate(temp_data):
            if 0 not in row:
                full_row = data_set.pop(row_index)
                break
        if not full_row:
            raise ValueError(""solve_simultaneous() requires at least 1 full equation"")
        data_set.insert(0, full_row)
    useable_form = data_set.copy()
    simplified = simplify(useable_form)
    simplified = simplified[::-1]
    solutions: list = []
    for row in simplified:
        current_solution = row[-1]
        if not solutions:
            if row[-2] == 0:
                solutions.append(0)
                continue
            solutions.append(current_solution / row[-2])
            continue
        temp_row = row.copy()[: len(row) - 1 :]
        while temp_row[0] == 0:
            temp_row.pop(0)
        if len(temp_row) == 0:
            solutions.append(0)
            continue
        temp_row = temp_row[1::]
        temp_row = temp_row[::-1]
        for column_index, column in enumerate(temp_row):
            current_solution -= column * solutions[column_index]
        solutions.append(current_solution)
    final = []
    for item in solutions:
        final.append(float(round(item, 5)))
    return final[::-1]",data\repos\Python\maths\simultaneous_linear_equation_solver.py,solve_simultaneous,732
1566,sin.py::sin::17,"def sin(
    angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10
) -> float:
    """"""
    Implement sin function.

    >>> sin(0.0)
    0.0
    >>> sin(90.0)
    1.0
    >>> sin(180.0)
    0.0
    >>> sin(270.0)
    -1.0
    >>> sin(0.68)
    0.0118679603
    >>> sin(1.97)
    0.0343762121
    >>> sin(64.0)
    0.8987940463
    >>> sin(9999.0)
    -0.9876883406
    >>> sin(-689.0)
    0.5150380749
    >>> sin(89.7)
    0.9999862922
    """"""
    # Simplify the angle to be between 360 and -360 degrees.
    angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)

    # Converting from degrees to radians
    angle_in_radians = radians(angle_in_degrees)

    result = angle_in_radians
    a = 3
    b = -1

    for _ in range(accuracy):
        result += (b * (angle_in_radians**a)) / factorial(a)

        b = -b  # One positive term and the next will be negative and so on...
        a += 2  # Increased by 2 for every term.

    return round(result, rounded_values_count)",data\repos\Python\maths\sin.py,sin,354
1567,sock_merchant.py::sock_merchant::4,"def sock_merchant(colors: list[int]) -> int:
    """"""
    >>> sock_merchant([10, 20, 20, 10, 10, 30, 50, 10, 20])
    3
    >>> sock_merchant([1, 1, 3, 3])
    2
    """"""
    return sum(socks_by_color // 2 for socks_by_color in Counter(colors).values())",data\repos\Python\maths\sock_merchant.py,sock_merchant,93
1568,softmax.py::softmax::16,"def softmax(vector):
    """"""
    Implements the softmax function

    Parameters:
        vector (np.array,list,tuple): A  numpy array of shape (1,n)
        consisting of real values or a similar list,tuple


    Returns:
        softmax_vec (np.array): The input numpy array  after applying
        softmax.

    The softmax vector adds up to one. We need to ceil to mitigate for
    precision
    >>> float(np.ceil(np.sum(softmax([1,2,3,4]))))
    1.0

    >>> vec = np.array([5,5])
    >>> softmax(vec)
    array([0.5, 0.5])

    >>> softmax([0])
    array([1.])
    """"""

    # Calculate e^x for each x in your vector where e is Euler's
    # number (approximately 2.718)
    exponent_vector = np.exp(vector)

    # Add up the all the exponentials
    sum_of_exponents = np.sum(exponent_vector)

    # Divide every exponent by the sum of all exponents
    softmax_vector = exponent_vector / sum_of_exponents

    return softmax_vector",data\repos\Python\maths\softmax.py,softmax,241
1569,solovay_strassen_primality_test.py::jacobi_symbol::15,"def jacobi_symbol(random_a: int, number: int) -> int:
    """"""
    Calculate the Jacobi symbol. The Jacobi symbol is a generalization
    of the Legendre symbol, which can be used to simplify computations involving
    quadratic residues. The Jacobi symbol is used in primality tests, like the
    Solovay-Strassen test, because it helps determine if an integer is a
    quadratic residue modulo a given modulus, providing valuable information
    about the number's potential primality or compositeness.

    Parameters:
        random_a: A randomly chosen integer from 2 to n-2 (inclusive)
        number: The number that is tested for primality

    Returns:
        jacobi_symbol: The Jacobi symbol is a mathematical function
        used to determine whether an integer is a quadratic residue modulo
        another integer (usually prime) or not.

    >>> jacobi_symbol(2, 13)
    -1
    >>> jacobi_symbol(5, 19)
    1
    >>> jacobi_symbol(7, 14)
    0
    """"""

    if random_a in (0, 1):
        return random_a

    random_a %= number
    t = 1

    while random_a != 0:
        while random_a % 2 == 0:
            random_a //= 2
            r = number % 8
            if r in (3, 5):
                t = -t

        random_a, number = number, random_a

        if random_a % 4 == number % 4 == 3:
            t = -t

        random_a %= number

    return t if number == 1 else 0",data\repos\Python\maths\solovay_strassen_primality_test.py,jacobi_symbol,360
1570,solovay_strassen_primality_test.py::solovay_strassen::64,"def solovay_strassen(number: int, iterations: int) -> bool:
    """"""
    Check whether the input number is prime or not using
    the Solovay-Strassen Primality test

    Parameters:
        number: The number that is tested for primality
        iterations: The number of times that the test is run
        which effects the accuracy

    Returns:
        result: True if number is probably prime and false
        if not

    >>> random.seed(10)
    >>> solovay_strassen(13, 5)
    True
    >>> solovay_strassen(9, 10)
    False
    >>> solovay_strassen(17, 15)
    True
    """"""

    if number <= 1:
        return False
    if number <= 3:
        return True

    for _ in range(iterations):
        a = random.randint(2, number - 2)
        x = jacobi_symbol(a, number)
        y = pow(a, (number - 1) // 2, number)

        if x == 0 or y != x % number:
            return False

    return True",data\repos\Python\maths\solovay_strassen_primality_test.py,solovay_strassen,244
1571,spearman_rank_correlation_coefficient.py::assign_ranks::4,"def assign_ranks(data: Sequence[float]) -> list[int]:
    """"""
    Assigns ranks to elements in the array.

    :param data: List of floats.
    :return: List of ints representing the ranks.

    Example:
    >>> assign_ranks([3.2, 1.5, 4.0, 2.7, 5.1])
    [3, 1, 4, 2, 5]

    >>> assign_ranks([10.5, 8.1, 12.4, 9.3, 11.0])
    [3, 1, 5, 2, 4]
    """"""
    ranked_data = sorted((value, index) for index, value in enumerate(data))
    ranks = [0] * len(data)

    for position, (_, index) in enumerate(ranked_data):
        ranks[index] = position + 1

    return ranks",data\repos\Python\maths\spearman_rank_correlation_coefficient.py,assign_ranks,196
1572,spearman_rank_correlation_coefficient.py::calculate_spearman_rank_correlation::27,"def calculate_spearman_rank_correlation(
    variable_1: Sequence[float], variable_2: Sequence[float]
) -> float:
    """"""
    Calculates Spearman's rank correlation coefficient.

    :param variable_1: List of floats representing the first variable.
    :param variable_2: List of floats representing the second variable.
    :return: Spearman's rank correlation coefficient.

    Example Usage:

    >>> x = [1, 2, 3, 4, 5]
    >>> y = [5, 4, 3, 2, 1]
    >>> calculate_spearman_rank_correlation(x, y)
    -1.0

    >>> x = [1, 2, 3, 4, 5]
    >>> y = [2, 4, 6, 8, 10]
    >>> calculate_spearman_rank_correlation(x, y)
    1.0

    >>> x = [1, 2, 3, 4, 5]
    >>> y = [5, 1, 2, 9, 5]
    >>> calculate_spearman_rank_correlation(x, y)
    0.6
    """"""
    n = len(variable_1)
    rank_var1 = assign_ranks(variable_1)
    rank_var2 = assign_ranks(variable_2)

    # Calculate differences of ranks
    d = [rx - ry for rx, ry in zip(rank_var1, rank_var2)]

    # Calculate the sum of squared differences
    d_squared = sum(di**2 for di in d)

    # Calculate the Spearman's rank correlation coefficient
    rho = 1 - (6 * d_squared) / (n * (n**2 - 1))

    return rho",data\repos\Python\maths\spearman_rank_correlation_coefficient.py,calculate_spearman_rank_correlation,377
1573,sumset.py::sumset::11,"def sumset(set_a: set, set_b: set) -> set:
    """"""
    :param first set: a set of numbers
    :param second set: a set of numbers
    :return: the nth number in Sylvester's sequence

    >>> sumset({1, 2, 3}, {4, 5, 6})
    {5, 6, 7, 8, 9}

    >>> sumset({1, 2, 3}, {4, 5, 6, 7})
    {5, 6, 7, 8, 9, 10}

    >>> sumset({1, 2, 3, 4}, 3)
    Traceback (most recent call last):
    ...
    AssertionError: The input value of [set_b=3] is not a set
    """"""
    assert isinstance(set_a, set), f""The input value of [set_a={set_a}] is not a set""
    assert isinstance(set_b, set), f""The input value of [set_b={set_b}] is not a set""

    return {a + b for a in set_a for b in set_b}",data\repos\Python\maths\sumset.py,sumset,252
1574,sum_of_arithmetic_series.py::sum_of_series::2,"def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:
    """"""
    Find the sum of n terms in an arithmetic progression.

    >>> sum_of_series(1, 1, 10)
    55.0
    >>> sum_of_series(1, 10, 100)
    49600.0
    """"""
    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)
    # formula for sum of series
    return total",data\repos\Python\maths\sum_of_arithmetic_series.py,sum_of_series,121
1575,sum_of_digits.py::sum_of_digits::1,"def sum_of_digits(n: int) -> int:
    """"""
    Find the sum of digits of a number.
    >>> sum_of_digits(12345)
    15
    >>> sum_of_digits(123)
    6
    >>> sum_of_digits(-123)
    6
    >>> sum_of_digits(0)
    0
    """"""
    n = abs(n)
    res = 0
    while n > 0:
        res += n % 10
        n //= 10
    return res",data\repos\Python\maths\sum_of_digits.py,sum_of_digits,110
1576,sum_of_digits.py::sum_of_digits_recursion::21,"def sum_of_digits_recursion(n: int) -> int:
    """"""
    Find the sum of digits of a number using recursion
    >>> sum_of_digits_recursion(12345)
    15
    >>> sum_of_digits_recursion(123)
    6
    >>> sum_of_digits_recursion(-123)
    6
    >>> sum_of_digits_recursion(0)
    0
    """"""
    n = abs(n)
    return n if n < 10 else n % 10 + sum_of_digits(n // 10)",data\repos\Python\maths\sum_of_digits.py,sum_of_digits_recursion,114
1577,sum_of_digits.py::sum_of_digits_compact::37,"def sum_of_digits_compact(n: int) -> int:
    """"""
    Find the sum of digits of a number
    >>> sum_of_digits_compact(12345)
    15
    >>> sum_of_digits_compact(123)
    6
    >>> sum_of_digits_compact(-123)
    6
    >>> sum_of_digits_compact(0)
    0
    """"""
    return sum(int(c) for c in str(abs(n)))",data\repos\Python\maths\sum_of_digits.py,sum_of_digits_compact,97
1578,sum_of_digits.py::benchmark::52,"def benchmark() -> None:
    """"""
    Benchmark multiple functions, with three different length int values.
    """"""
    from collections.abc import Callable
    from timeit import timeit

    def benchmark_a_function(func: Callable, value: int) -> None:
        call = f""{func.__name__}({value})""
        timing = timeit(f""__main__.{call}"", setup=""import __main__"")
        print(f""{call:56} = {func(value)} -- {timing:.4f} seconds"")

    for value in (262144, 1125899906842624, 1267650600228229401496703205376):
        for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):
            benchmark_a_function(func, value)
        print()",data\repos\Python\maths\sum_of_digits.py,benchmark,170
1579,sum_of_digits.py::benchmark_a_function::59,"    def benchmark_a_function(func: Callable, value: int) -> None:
        call = f""{func.__name__}({value})""
        timing = timeit(f""__main__.{call}"", setup=""import __main__"")
        print(f""{call:56} = {func(value)} -- {timing:.4f} seconds"")",data\repos\Python\maths\sum_of_digits.py,benchmark_a_function,71
1580,sum_of_geometric_progression.py::sum_of_geometric_progression::1,"def sum_of_geometric_progression(
    first_term: int, common_ratio: int, num_of_terms: int
) -> float:
    """""" ""
    Return the sum of n terms in a geometric progression.
    >>> sum_of_geometric_progression(1, 2, 10)
    1023.0
    >>> sum_of_geometric_progression(1, 10, 5)
    11111.0
    >>> sum_of_geometric_progression(0, 2, 10)
    0.0
    >>> sum_of_geometric_progression(1, 0, 10)
    1.0
    >>> sum_of_geometric_progression(1, 2, 0)
    -0.0
    >>> sum_of_geometric_progression(-1, 2, 10)
    -1023.0
    >>> sum_of_geometric_progression(1, -2, 10)
    -341.0
    >>> sum_of_geometric_progression(1, 2, -10)
    -0.9990234375
    """"""
    if common_ratio == 1:
        # Formula for sum if common ratio is 1
        return num_of_terms * first_term

    # Formula for finding sum of n terms of a GeometricProgression
    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)",data\repos\Python\maths\sum_of_geometric_progression.py,sum_of_geometric_progression,304
1581,sum_of_harmonic_series.py::sum_of_harmonic_progression::1,"def sum_of_harmonic_progression(
    first_term: float, common_difference: float, number_of_terms: int
) -> float:
    """"""
    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)

    Find the sum of n terms in an harmonic progression.  The calculation starts with the
    first_term and loops adding the common difference of Arithmetic Progression by which
    the given Harmonic Progression is linked.

    >>> sum_of_harmonic_progression(1 / 2, 2, 2)
    0.75
    >>> sum_of_harmonic_progression(1 / 5, 5, 5)
    0.45666666666666667
    """"""
    arithmetic_progression = [1 / first_term]
    first_term = 1 / first_term
    for _ in range(number_of_terms - 1):
        first_term += common_difference
        arithmetic_progression.append(first_term)
    harmonic_series = [1 / step for step in arithmetic_progression]
    return sum(harmonic_series)",data\repos\Python\maths\sum_of_harmonic_series.py,sum_of_harmonic_progression,225
1582,sylvester_sequence.py::sylvester::11,"def sylvester(number: int) -> int:
    """"""
    :param number: nth number to calculate in the sequence
    :return: the nth number in Sylvester's sequence

    >>> sylvester(8)
    113423713055421844361000443

    >>> sylvester(-1)
    Traceback (most recent call last):
        ...
    ValueError: The input value of [n=-1] has to be > 0

    >>> sylvester(8.0)
    Traceback (most recent call last):
        ...
    AssertionError: The input value of [n=8.0] is not an integer
    """"""
    assert isinstance(number, int), f""The input value of [n={number}] is not an integer""

    if number == 1:
        return 2
    elif number < 1:
        msg = f""The input value of [n={number}] has to be > 0""
        raise ValueError(msg)
    else:
        num = sylvester(number - 1)
        lower = num - 1
        upper = num
        return lower * upper + 1",data\repos\Python\maths\sylvester_sequence.py,sylvester,240
1583,tanh.py::tangent_hyperbolic::16,"def tangent_hyperbolic(vector: np.ndarray) -> np.ndarray:
    """"""
        Implements the tanh function

        Parameters:
            vector: np.ndarray

        Returns:
            tanh (np.array): The input numpy array after applying tanh.

        mathematically (e^x - e^(-x))/(e^x + e^(-x)) can be written as (2/(1+e^(-2x))-1

    Examples:
        >>> tangent_hyperbolic(np.array([1,5,6,-0.67]))
        array([ 0.76159416,  0.9999092 ,  0.99998771, -0.58497988])

        >>> tangent_hyperbolic(np.array([8,10,2,-0.98,13]))
        array([ 0.99999977,  1.        ,  0.96402758, -0.7530659 ,  1.        ])

    """"""

    return (2 / (1 + np.exp(-2 * vector))) - 1",data\repos\Python\maths\tanh.py,tangent_hyperbolic,224
1584,test_factorial.py::test_positive_integers::19,"def test_positive_integers(function):
    assert function(1) == 1
    assert function(5) == 120
    assert function(7) == 5040",data\repos\Python\maths\test_factorial.py,test_positive_integers,37
1585,three_sum.py::three_sum::6,"def three_sum(nums: list[int]) -> list[list[int]]:
    """"""
    Find all unique triplets in a sorted array of integers that sum up to zero.

    Args:
        nums: A sorted list of integers.

    Returns:
        A list of lists containing unique triplets that sum up to zero.

    >>> three_sum([-1, 0, 1, 2, -1, -4])
    [[-1, -1, 2], [-1, 0, 1]]
    >>> three_sum([1, 2, 3, 4])
    []
    """"""
    nums.sort()
    ans = []
    for i in range(len(nums) - 2):
        if i == 0 or (nums[i] != nums[i - 1]):
            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]
            while low < high:
                if nums[low] + nums[high] == c:
                    ans.append([nums[i], nums[low], nums[high]])

                    while low < high and nums[low] == nums[low + 1]:
                        low += 1
                    while low < high and nums[high] == nums[high - 1]:
                        high -= 1

                    low += 1
                    high -= 1
                elif nums[low] + nums[high] < c:
                    low += 1
                else:
                    high -= 1
    return ans",data\repos\Python\maths\three_sum.py,three_sum,315
1586,trapezoidal_rule.py::trapezoidal_rule::6,"def trapezoidal_rule(boundary, steps):
    """"""
    Implements the extended trapezoidal rule for numerical integration.
    The function f(x) is provided below.

    :param boundary: List containing the lower and upper bounds of integration [a, b]
    :param steps: The number of steps (intervals) used in the approximation
    :return: The numerical approximation of the integral

    >>> abs(trapezoidal_rule([0, 1], 10) - 0.33333) < 0.01
    True
    >>> abs(trapezoidal_rule([0, 1], 100) - 0.33333) < 0.01
    True
    >>> abs(trapezoidal_rule([0, 2], 1000) - 2.66667) < 0.01
    True
    >>> abs(trapezoidal_rule([1, 2], 1000) - 2.33333) < 0.01
    True
    """"""
    h = (boundary[1] - boundary[0]) / steps
    a = boundary[0]
    b = boundary[1]
    x_i = make_points(a, b, h)
    y = 0.0
    y += (h / 2.0) * f(a)
    for i in x_i:
        y += h * f(i)
    y += (h / 2.0) * f(b)
    return y",data\repos\Python\maths\trapezoidal_rule.py,trapezoidal_rule,318
1587,trapezoidal_rule.py::make_points::36,"def make_points(a, b, h):
    """"""
    Generates points between a and b with step size h for trapezoidal integration.

    :param a: The lower bound of integration
    :param b: The upper bound of integration
    :param h: The step size
    :yield: The next x-value in the range (a, b)

    >>> list(make_points(0, 1, 0.1))    # doctest: +NORMALIZE_WHITESPACE
    [0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999, \
    0.8999999999999999]
    >>> list(make_points(0, 10, 2.5))
    [2.5, 5.0, 7.5]
    >>> list(make_points(0, 10, 2))
    [2, 4, 6, 8]
    >>> list(make_points(1, 21, 5))
    [6, 11, 16]
    >>> list(make_points(1, 5, 2))
    [3]
    >>> list(make_points(1, 4, 3))
    []
    """"""
    x = a + h
    while x <= (b - h):
        yield x
        x += h",data\repos\Python\maths\trapezoidal_rule.py,make_points,310
1588,trapezoidal_rule.py::f::65,"def f(x):
    """"""
    This is the function to integrate, f(x) = (x - 0)^2 = x^2.

    :param x: The input value
    :return: The value of f(x)

    >>> f(0)
    0
    >>> f(1)
    1
    >>> f(0.5)
    0.25
    """"""
    return x**2",data\repos\Python\maths\trapezoidal_rule.py,f,90
1589,trapezoidal_rule.py::main::82,"def main():
    """"""
    Main function to test the trapezoidal rule.
    :a: Lower bound of integration
    :b: Upper bound of integration
    :steps: define number of steps or resolution
    :boundary: define boundary of integration

    >>> main()
    y = 0.3349999999999999
    """"""
    a = 0.0
    b = 1.0
    steps = 10.0
    boundary = [a, b]
    y = trapezoidal_rule(boundary, steps)
    print(f""y = {y}"")",data\repos\Python\maths\trapezoidal_rule.py,main,128
1590,triplet_sum.py::make_dataset::14,"def make_dataset() -> tuple[list[int], int]:
    arr = [randint(-1000, 1000) for i in range(10)]
    r = randint(-5000, 5000)
    return (arr, r)",data\repos\Python\maths\triplet_sum.py,make_dataset,51
1591,triplet_sum.py::triplet_sum1::23,"def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:
    """"""
    Returns a triplet in the array with sum equal to target,
    else (0, 0, 0).
    >>> triplet_sum1([13, 29, 7, 23, 5], 35)
    (5, 7, 23)
    >>> triplet_sum1([37, 9, 19, 50, 44], 65)
    (9, 19, 37)
    >>> arr = [6, 47, 27, 1, 15]
    >>> target = 11
    >>> triplet_sum1(arr, target)
    (0, 0, 0)
    """"""
    for triplet in permutations(arr, 3):
        if sum(triplet) == target:
            return tuple(sorted(triplet))
    return (0, 0, 0)",data\repos\Python\maths\triplet_sum.py,triplet_sum1,197
1592,triplet_sum.py::triplet_sum2::42,"def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:
    """"""
    Returns a triplet in the array with sum equal to target,
    else (0, 0, 0).
    >>> triplet_sum2([13, 29, 7, 23, 5], 35)
    (5, 7, 23)
    >>> triplet_sum2([37, 9, 19, 50, 44], 65)
    (9, 19, 37)
    >>> arr = [6, 47, 27, 1, 15]
    >>> target = 11
    >>> triplet_sum2(arr, target)
    (0, 0, 0)
    """"""
    arr.sort()
    n = len(arr)
    for i in range(n - 1):
        left, right = i + 1, n - 1
        while left < right:
            if arr[i] + arr[left] + arr[right] == target:
                return (arr[i], arr[left], arr[right])
            elif arr[i] + arr[left] + arr[right] < target:
                left += 1
            elif arr[i] + arr[left] + arr[right] > target:
                right -= 1
    return (0, 0, 0)",data\repos\Python\maths\triplet_sum.py,triplet_sum2,284
1593,triplet_sum.py::solution_times::69,"def solution_times() -> tuple[float, float]:
    setup_code = """"""
from __main__ import dataset, triplet_sum1, triplet_sum2
""""""
    test_code1 = """"""
triplet_sum1(*dataset)
""""""
    test_code2 = """"""
triplet_sum2(*dataset)
""""""
    times1 = repeat(setup=setup_code, stmt=test_code1, repeat=5, number=10000)
    times2 = repeat(setup=setup_code, stmt=test_code2, repeat=5, number=10000)
    return (min(times1), min(times2))",data\repos\Python\maths\triplet_sum.py,solution_times,120
1594,twin_prime.py::twin_prime::14,"def twin_prime(number: int) -> int:
    """"""
    # doctest: +NORMALIZE_WHITESPACE
    This functions takes an integer number as input.
    returns n+2 if n and n+2 are prime numbers and -1 otherwise.
    >>> twin_prime(3)
    5
    >>> twin_prime(4)
    -1
    >>> twin_prime(5)
    7
    >>> twin_prime(17)
    19
    >>> twin_prime(0)
    -1
    >>> twin_prime(6.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=6.0] must be an integer
    """"""
    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)
    if is_prime(number) and is_prime(number + 2):
        return number + 2
    else:
        return -1",data\repos\Python\maths\twin_prime.py,twin_prime,207
1595,two_pointer.py::two_pointer::24,"def two_pointer(nums: list[int], target: int) -> list[int]:
    """"""
    >>> two_pointer([2, 7, 11, 15], 9)
    [0, 1]
    >>> two_pointer([2, 7, 11, 15], 17)
    [0, 3]
    >>> two_pointer([2, 7, 11, 15], 18)
    [1, 2]
    >>> two_pointer([2, 7, 11, 15], 26)
    [2, 3]
    >>> two_pointer([1, 3, 3], 6)
    [1, 2]
    >>> two_pointer([2, 7, 11, 15], 8)
    []
    >>> two_pointer([3 * i for i in range(10)], 19)
    []
    >>> two_pointer([1, 2, 3], 6)
    []
    """"""
    i = 0
    j = len(nums) - 1

    while i < j:
        if nums[i] + nums[j] == target:
            return [i, j]
        elif nums[i] + nums[j] < target:
            i = i + 1
        else:
            j = j - 1

    return []",data\repos\Python\maths\two_pointer.py,two_pointer,281
1596,two_sum.py::two_sum::18,"def two_sum(nums: list[int], target: int) -> list[int]:
    """"""
    >>> two_sum([2, 7, 11, 15], 9)
    [0, 1]
    >>> two_sum([15, 2, 11, 7], 13)
    [1, 2]
    >>> two_sum([2, 7, 11, 15], 17)
    [0, 3]
    >>> two_sum([7, 15, 11, 2], 18)
    [0, 2]
    >>> two_sum([2, 7, 11, 15], 26)
    [2, 3]
    >>> two_sum([2, 7, 11, 15], 8)
    []
    >>> two_sum([3 * i for i in range(10)], 19)
    []
    """"""
    chk_map: dict[int, int] = {}
    for index, val in enumerate(nums):
        compl = target - val
        if compl in chk_map:
            return [chk_map[compl], index]
        chk_map[val] = index
    return []",data\repos\Python\maths\two_sum.py,two_sum,247
1597,volume.py::vol_cube::13,"def vol_cube(side_length: float) -> float:
    """"""
    Calculate the Volume of a Cube.

    >>> vol_cube(1)
    1.0
    >>> vol_cube(3)
    27.0
    >>> vol_cube(0)
    0.0
    >>> vol_cube(1.6)
    4.096000000000001
    >>> vol_cube(-1)
    Traceback (most recent call last):
        ...
    ValueError: vol_cube() only accepts non-negative values
    """"""
    if side_length < 0:
        raise ValueError(""vol_cube() only accepts non-negative values"")
    return pow(side_length, 3)",data\repos\Python\maths\volume.py,vol_cube,141
1598,volume.py::vol_spherical_cap::35,"def vol_spherical_cap(height: float, radius: float) -> float:
    """"""
    Calculate the volume of the spherical cap.

    >>> vol_spherical_cap(1, 2)
    5.235987755982988
    >>> vol_spherical_cap(1.6, 2.6)
    16.621119532592402
    >>> vol_spherical_cap(0, 0)
    0.0
    >>> vol_spherical_cap(-1, 2)
    Traceback (most recent call last):
        ...
    ValueError: vol_spherical_cap() only accepts non-negative values
    >>> vol_spherical_cap(1, -2)
    Traceback (most recent call last):
        ...
    ValueError: vol_spherical_cap() only accepts non-negative values
    """"""
    if height < 0 or radius < 0:
        raise ValueError(""vol_spherical_cap() only accepts non-negative values"")
    # Volume is 1/3 pi * height squared * (3 * radius - height)
    return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)",data\repos\Python\maths\volume.py,vol_spherical_cap,240
1599,volume.py::vol_spheres_intersect::60,"def vol_spheres_intersect(
    radius_1: float, radius_2: float, centers_distance: float
) -> float:
    r""""""
    Calculate the volume of the intersection of two spheres.

    The intersection is composed by two spherical caps and therefore its volume is the
    sum of the volumes of the spherical caps.
    First, it calculates the heights :math:`(h_1, h_2)` of the spherical caps,
    then the two volumes and it returns the sum.
    The height formulas are

    .. math::
        h_1 = \frac{(radius_1 - radius_2 + centers\_distance)
                    \cdot (radius_1 + radius_2 - centers\_distance)}
                   {2 \cdot centers\_distance}

        h_2 = \frac{(radius_2 - radius_1 + centers\_distance)
                    \cdot (radius_2 + radius_1 - centers\_distance)}
                   {2 \cdot centers\_distance}

    if `centers_distance` is 0 then it returns the volume of the smallers sphere

    :return: ``vol_spherical_cap`` (:math:`h_1`, :math:`radius_2`)
             + ``vol_spherical_cap`` (:math:`h_2`, :math:`radius_1`)

    >>> vol_spheres_intersect(2, 2, 1)
    21.205750411731103
    >>> vol_spheres_intersect(2.6, 2.6, 1.6)
    40.71504079052372
    >>> vol_spheres_intersect(0, 0, 0)
    0.0
    >>> vol_spheres_intersect(-2, 2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_intersect() only accepts non-negative values
    >>> vol_spheres_intersect(2, -2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_intersect() only accepts non-negative values
    >>> vol_spheres_intersect(2, 2, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_intersect() only accepts non-negative values
    """"""
    if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:
        raise ValueError(""vol_spheres_intersect() only accepts non-negative values"")
    if centers_distance == 0:
        return vol_sphere(min(radius_1, radius_2))

    h1 = (
        (radius_1 - radius_2 + centers_distance)
        * (radius_1 + radius_2 - centers_distance)
        / (2 * centers_distance)
    )
    h2 = (
        (radius_2 - radius_1 + centers_distance)
        * (radius_2 + radius_1 - centers_distance)
        / (2 * centers_distance)
    )

    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)",data\repos\Python\maths\volume.py,vol_spheres_intersect,636
1600,volume.py::vol_spheres_union::124,"def vol_spheres_union(
    radius_1: float, radius_2: float, centers_distance: float
) -> float:
    r""""""
    Calculate the volume of the union of two spheres that possibly intersect.

    It is the sum of sphere :math:`A` and sphere :math:`B` minus their intersection.
    First, it calculates the volumes :math:`(v_1, v_2)` of the spheres,
    then the volume of the intersection :math:`i` and
    it returns the sum :math:`v_1 + v_2 - i`.
    If `centers_distance` is 0 then it returns the volume of the larger sphere

    :return: ``vol_sphere`` (:math:`radius_1`) + ``vol_sphere`` (:math:`radius_2`)
             - ``vol_spheres_intersect``
             (:math:`radius_1`, :math:`radius_2`, :math:`centers\_distance`)

    >>> vol_spheres_union(2, 2, 1)
    45.814892864851146
    >>> vol_spheres_union(1.56, 2.2, 1.4)
    48.77802773671288
    >>> vol_spheres_union(0, 2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius
    >>> vol_spheres_union('1.56', '2.2', '1.4')
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'str' and 'int'
    >>> vol_spheres_union(1, None, 1)
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'NoneType' and 'int'
    """"""

    if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:
        raise ValueError(
            ""vol_spheres_union() only accepts non-negative values, non-zero radius""
        )

    if centers_distance == 0:
        return vol_sphere(max(radius_1, radius_2))

    return (
        vol_sphere(radius_1)
        + vol_sphere(radius_2)
        - vol_spheres_intersect(radius_1, radius_2, centers_distance)
    )",data\repos\Python\maths\volume.py,vol_spheres_union,497
1601,volume.py::vol_cuboid::173,"def vol_cuboid(width: float, height: float, length: float) -> float:
    """"""
    Calculate the Volume of a Cuboid.

    :return: multiple of `width`, `length` and `height`

    >>> vol_cuboid(1, 1, 1)
    1.0
    >>> vol_cuboid(1, 2, 3)
    6.0
    >>> vol_cuboid(1.6, 2.6, 3.6)
    14.976
    >>> vol_cuboid(0, 0, 0)
    0.0
    >>> vol_cuboid(-1, 2, 3)
    Traceback (most recent call last):
        ...
    ValueError: vol_cuboid() only accepts non-negative values
    >>> vol_cuboid(1, -2, 3)
    Traceback (most recent call last):
        ...
    ValueError: vol_cuboid() only accepts non-negative values
    >>> vol_cuboid(1, 2, -3)
    Traceback (most recent call last):
        ...
    ValueError: vol_cuboid() only accepts non-negative values
    """"""
    if width < 0 or height < 0 or length < 0:
        raise ValueError(""vol_cuboid() only accepts non-negative values"")
    return float(width * height * length)",data\repos\Python\maths\volume.py,vol_cuboid,300
1602,volume.py::vol_cone::205,"def vol_cone(area_of_base: float, height: float) -> float:
    r""""""
    | Calculate the Volume of a Cone.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Cone

    :return: :math:`\frac{1}{3} \cdot area\_of\_base \cdot height`

    >>> vol_cone(10, 3)
    10.0
    >>> vol_cone(1, 1)
    0.3333333333333333
    >>> vol_cone(1.6, 1.6)
    0.8533333333333335
    >>> vol_cone(0, 0)
    0.0
    >>> vol_cone(-1, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_cone() only accepts non-negative values
    >>> vol_cone(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_cone() only accepts non-negative values
    """"""
    if height < 0 or area_of_base < 0:
        raise ValueError(""vol_cone() only accepts non-negative values"")
    return area_of_base * height / 3.0",data\repos\Python\maths\volume.py,vol_cone,262
1603,volume.py::vol_right_circ_cone::234,"def vol_right_circ_cone(radius: float, height: float) -> float:
    r""""""
    | Calculate the Volume of a Right Circular Cone.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Cone

    :return: :math:`\frac{1}{3} \cdot \pi \cdot radius^2 \cdot height`

    >>> vol_right_circ_cone(2, 3)
    12.566370614359172
    >>> vol_right_circ_cone(0, 0)
    0.0
    >>> vol_right_circ_cone(1.6, 1.6)
    4.289321169701265
    >>> vol_right_circ_cone(-1, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_right_circ_cone() only accepts non-negative values
    >>> vol_right_circ_cone(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_right_circ_cone() only accepts non-negative values
    """"""
    if height < 0 or radius < 0:
        raise ValueError(""vol_right_circ_cone() only accepts non-negative values"")
    return pi * pow(radius, 2) * height / 3.0",data\repos\Python\maths\volume.py,vol_right_circ_cone,275
1604,volume.py::vol_prism::261,"def vol_prism(area_of_base: float, height: float) -> float:
    r""""""
    | Calculate the Volume of a Prism.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Prism_(geometry)

    :return: :math:`V = B \cdot h`

    >>> vol_prism(10, 2)
    20.0
    >>> vol_prism(11, 1)
    11.0
    >>> vol_prism(1.6, 1.6)
    2.5600000000000005
    >>> vol_prism(0, 0)
    0.0
    >>> vol_prism(-1, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_prism() only accepts non-negative values
    >>> vol_prism(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_prism() only accepts non-negative values
    """"""
    if height < 0 or area_of_base < 0:
        raise ValueError(""vol_prism() only accepts non-negative values"")
    return float(area_of_base * height)",data\repos\Python\maths\volume.py,vol_prism,246
1605,volume.py::vol_pyramid::290,"def vol_pyramid(area_of_base: float, height: float) -> float:
    r""""""
    | Calculate the Volume of a Pyramid.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Pyramid_(geometry)

    :return: :math:`\frac{1}{3} \cdot B \cdot h`

    >>> vol_pyramid(10, 3)
    10.0
    >>> vol_pyramid(1.5, 3)
    1.5
    >>> vol_pyramid(1.6, 1.6)
    0.8533333333333335
    >>> vol_pyramid(0, 0)
    0.0
    >>> vol_pyramid(-1, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_pyramid() only accepts non-negative values
    >>> vol_pyramid(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_pyramid() only accepts non-negative values
    """"""
    if height < 0 or area_of_base < 0:
        raise ValueError(""vol_pyramid() only accepts non-negative values"")
    return area_of_base * height / 3.0",data\repos\Python\maths\volume.py,vol_pyramid,258
1606,volume.py::vol_sphere::319,"def vol_sphere(radius: float) -> float:
    r""""""
    | Calculate the Volume of a Sphere.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Sphere

    :return: :math:`\frac{4}{3} \cdot \pi \cdot r^3`

    >>> vol_sphere(5)
    523.5987755982989
    >>> vol_sphere(1)
    4.1887902047863905
    >>> vol_sphere(1.6)
    17.15728467880506
    >>> vol_sphere(0)
    0.0
    >>> vol_sphere(-1)
    Traceback (most recent call last):
        ...
    ValueError: vol_sphere() only accepts non-negative values
    """"""
    if radius < 0:
        raise ValueError(""vol_sphere() only accepts non-negative values"")
    # Volume is 4/3 * pi * radius cubed
    return 4 / 3 * pi * pow(radius, 3)",data\repos\Python\maths\volume.py,vol_sphere,210
1607,volume.py::vol_hemisphere::345,"def vol_hemisphere(radius: float) -> float:
    r""""""
    | Calculate the volume of a hemisphere
    | Wikipedia reference: https://en.wikipedia.org/wiki/Hemisphere
    | Other references: https://www.cuemath.com/geometry/hemisphere

    :return: :math:`\frac{2}{3} \cdot \pi \cdot radius^3`

    >>> vol_hemisphere(1)
    2.0943951023931953
    >>> vol_hemisphere(7)
    718.377520120866
    >>> vol_hemisphere(1.6)
    8.57864233940253
    >>> vol_hemisphere(0)
    0.0
    >>> vol_hemisphere(-1)
    Traceback (most recent call last):
        ...
    ValueError: vol_hemisphere() only accepts non-negative values
    """"""
    if radius < 0:
        raise ValueError(""vol_hemisphere() only accepts non-negative values"")
    # Volume is radius cubed * pi * 2/3
    return pow(radius, 3) * pi * 2 / 3",data\repos\Python\maths\volume.py,vol_hemisphere,244
1608,volume.py::vol_circular_cylinder::372,"def vol_circular_cylinder(radius: float, height: float) -> float:
    r""""""
    | Calculate the Volume of a Circular Cylinder.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder

    :return: :math:`\pi \cdot radius^2 \cdot height`

    >>> vol_circular_cylinder(1, 1)
    3.141592653589793
    >>> vol_circular_cylinder(4, 3)
    150.79644737231007
    >>> vol_circular_cylinder(1.6, 1.6)
    12.867963509103795
    >>> vol_circular_cylinder(0, 0)
    0.0
    >>> vol_circular_cylinder(-1, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_circular_cylinder() only accepts non-negative values
    >>> vol_circular_cylinder(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_circular_cylinder() only accepts non-negative values
    """"""
    if height < 0 or radius < 0:
        raise ValueError(""vol_circular_cylinder() only accepts non-negative values"")
    # Volume is radius squared * height * pi
    return pow(radius, 2) * height * pi",data\repos\Python\maths\volume.py,vol_circular_cylinder,285
1609,volume.py::vol_hollow_circular_cylinder::402,"def vol_hollow_circular_cylinder(
    inner_radius: float, outer_radius: float, height: float
) -> float:
    """"""
    Calculate the Volume of a Hollow Circular Cylinder.

    >>> vol_hollow_circular_cylinder(1, 2, 3)
    28.274333882308138
    >>> vol_hollow_circular_cylinder(1.6, 2.6, 3.6)
    47.50088092227767
    >>> vol_hollow_circular_cylinder(-1, 2, 3)
    Traceback (most recent call last):
        ...
    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values
    >>> vol_hollow_circular_cylinder(1, -2, 3)
    Traceback (most recent call last):
        ...
    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values
    >>> vol_hollow_circular_cylinder(1, 2, -3)
    Traceback (most recent call last):
        ...
    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values
    >>> vol_hollow_circular_cylinder(2, 1, 3)
    Traceback (most recent call last):
        ...
    ValueError: outer_radius must be greater than inner_radius
    >>> vol_hollow_circular_cylinder(0, 0, 0)
    Traceback (most recent call last):
        ...
    ValueError: outer_radius must be greater than inner_radius
    """"""
    # Volume - (outer_radius squared - inner_radius squared) * pi * height
    if inner_radius < 0 or outer_radius < 0 or height < 0:
        raise ValueError(
            ""vol_hollow_circular_cylinder() only accepts non-negative values""
        )
    if outer_radius <= inner_radius:
        raise ValueError(""outer_radius must be greater than inner_radius"")
    return pi * (pow(outer_radius, 2) - pow(inner_radius, 2)) * height",data\repos\Python\maths\volume.py,vol_hollow_circular_cylinder,427
1610,volume.py::vol_conical_frustum::443,"def vol_conical_frustum(height: float, radius_1: float, radius_2: float) -> float:
    """"""
    | Calculate the Volume of a Conical Frustum.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Frustum

    >>> vol_conical_frustum(45, 7, 28)
    48490.482608158454
    >>> vol_conical_frustum(1, 1, 2)
    7.330382858376184
    >>> vol_conical_frustum(1.6, 2.6, 3.6)
    48.7240076620753
    >>> vol_conical_frustum(0, 0, 0)
    0.0
    >>> vol_conical_frustum(-2, 2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_conical_frustum() only accepts non-negative values
    >>> vol_conical_frustum(2, -2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_conical_frustum() only accepts non-negative values
    >>> vol_conical_frustum(2, 2, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_conical_frustum() only accepts non-negative values
    """"""
    # Volume is 1/3 * pi * height *
    #           (radius_1 squared + radius_2 squared + radius_1 * radius_2)
    if radius_1 < 0 or radius_2 < 0 or height < 0:
        raise ValueError(""vol_conical_frustum() only accepts non-negative values"")
    return (
        1
        / 3
        * pi
        * height
        * (pow(radius_1, 2) + pow(radius_2, 2) + radius_1 * radius_2)
    )",data\repos\Python\maths\volume.py,vol_conical_frustum,423
1611,volume.py::vol_torus::482,"def vol_torus(torus_radius: float, tube_radius: float) -> float:
    r""""""
    | Calculate the Volume of a Torus.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Torus

    :return: :math:`2 \pi^2 \cdot torus\_radius \cdot tube\_radius^2`

    >>> vol_torus(1, 1)
    19.739208802178716
    >>> vol_torus(4, 3)
    710.6115168784338
    >>> vol_torus(3, 4)
    947.4820225045784
    >>> vol_torus(1.6, 1.6)
    80.85179925372404
    >>> vol_torus(0, 0)
    0.0
    >>> vol_torus(-1, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_torus() only accepts non-negative values
    >>> vol_torus(1, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_torus() only accepts non-negative values
    """"""
    if torus_radius < 0 or tube_radius < 0:
        raise ValueError(""vol_torus() only accepts non-negative values"")
    return 2 * pow(pi, 2) * torus_radius * pow(tube_radius, 2)",data\repos\Python\maths\volume.py,vol_torus,301
1612,volume.py::vol_icosahedron::513,"def vol_icosahedron(tri_side: float) -> float:
    """"""
    | Calculate the Volume of an Icosahedron.
    | Wikipedia reference: https://en.wikipedia.org/wiki/Regular_icosahedron

    >>> from math import isclose
    >>> isclose(vol_icosahedron(2.5), 34.088984228514256)
    True
    >>> isclose(vol_icosahedron(10), 2181.694990624912374)
    True
    >>> isclose(vol_icosahedron(5), 272.711873828114047)
    True
    >>> isclose(vol_icosahedron(3.49), 92.740688412033628)
    True
    >>> vol_icosahedron(0)
    0.0
    >>> vol_icosahedron(-1)
    Traceback (most recent call last):
        ...
    ValueError: vol_icosahedron() only accepts non-negative values
    >>> vol_icosahedron(-0.2)
    Traceback (most recent call last):
        ...
    ValueError: vol_icosahedron() only accepts non-negative values
    """"""
    if tri_side < 0:
        raise ValueError(""vol_icosahedron() only accepts non-negative values"")
    return tri_side**3 * (3 + 5**0.5) * 5 / 12",data\repos\Python\maths\volume.py,vol_icosahedron,308
1613,volume.py::main::543,"def main():
    """"""Print the Results of Various Volume Calculations.""""""
    print(""Volumes:"")
    print(f""Cube: {vol_cube(2) = }"")  # = 8
    print(f""Cuboid: {vol_cuboid(2, 2, 2) = }"")  # = 8
    print(f""Cone: {vol_cone(2, 2) = }"")  # ~= 1.33
    print(f""Right Circular Cone: {vol_right_circ_cone(2, 2) = }"")  # ~= 8.38
    print(f""Prism: {vol_prism(2, 2) = }"")  # = 4
    print(f""Pyramid: {vol_pyramid(2, 2) = }"")  # ~= 1.33
    print(f""Sphere: {vol_sphere(2) = }"")  # ~= 33.5
    print(f""Hemisphere: {vol_hemisphere(2) = }"")  # ~= 16.75
    print(f""Circular Cylinder: {vol_circular_cylinder(2, 2) = }"")  # ~= 25.1
    print(f""Torus: {vol_torus(2, 2) = }"")  # ~= 157.9
    print(f""Conical Frustum: {vol_conical_frustum(2, 2, 4) = }"")  # ~= 58.6
    print(f""Spherical cap: {vol_spherical_cap(1, 2) = }"")  # ~= 5.24
    print(f""Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }"")  # ~= 21.21
    print(f""Spheres union: {vol_spheres_union(2, 2, 1) = }"")  # ~= 45.81
    print(
        f""Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }""
    )  # ~= 28.3
    print(f""Icosahedron: {vol_icosahedron(2.5) = }"")  # ~=34.09",data\repos\Python\maths\volume.py,main,488
1614,zellers_congruence.py::zeller::5,"def zeller(date_input: str) -> str:
    """"""
    | Zellers Congruence Algorithm
    | Find the day of the week for nearly any Gregorian or Julian calendar date

    >>> zeller('01-31-2010')
    'Your date 01-31-2010, is a Sunday!'

    Validate out of range month:

    >>> zeller('13-31-2010')
    Traceback (most recent call last):
        ...
    ValueError: Month must be between 1 - 12
    >>> zeller('.2-31-2010')
    Traceback (most recent call last):
        ...
    ValueError: invalid literal for int() with base 10: '.2'

    Validate out of range date:

    >>> zeller('01-33-2010')
    Traceback (most recent call last):
        ...
    ValueError: Date must be between 1 - 31
    >>> zeller('01-.4-2010')
    Traceback (most recent call last):
        ...
    ValueError: invalid literal for int() with base 10: '.4'

    Validate second separator:

    >>> zeller('01-31*2010')
    Traceback (most recent call last):
        ...
    ValueError: Date separator must be '-' or '/'

    Validate first separator:

    >>> zeller('01^31-2010')
    Traceback (most recent call last):
        ...
    ValueError: Date separator must be '-' or '/'

    Validate out of range year:

    >>> zeller('01-31-8999')
    Traceback (most recent call last):
        ...
    ValueError: Year out of range. There has to be some sort of limit...right?

    Test null input:

    >>> zeller()
    Traceback (most recent call last):
        ...
    TypeError: zeller() missing 1 required positional argument: 'date_input'

    Test length of `date_input`:

    >>> zeller('')
    Traceback (most recent call last):
        ...
    ValueError: Must be 10 characters long
    >>> zeller('01-31-19082939')
    Traceback (most recent call last):
        ...
    ValueError: Must be 10 characters long""""""

    # Days of the week for response
    days = {
        ""0"": ""Sunday"",
        ""1"": ""Monday"",
        ""2"": ""Tuesday"",
        ""3"": ""Wednesday"",
        ""4"": ""Thursday"",
        ""5"": ""Friday"",
        ""6"": ""Saturday"",
    }

    convert_datetime_days = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 0}

    # Validate
    if not 0 < len(date_input) < 11:
        raise ValueError(""Must be 10 characters long"")

    # Get month
    m: int = int(date_input[0] + date_input[1])
    # Validate
    if not 0 < m < 13:
        raise ValueError(""Month must be between 1 - 12"")

    sep_1: str = date_input[2]
    # Validate
    if sep_1 not in [""-"", ""/""]:
        raise ValueError(""Date separator must be '-' or '/'"")

    # Get day
    d: int = int(date_input[3] + date_input[4])
    # Validate
    if not 0 < d < 32:
        raise ValueError(""Date must be between 1 - 31"")

    # Get second separator
    sep_2: str = date_input[5]
    # Validate
    if sep_2 not in [""-"", ""/""]:
        raise ValueError(""Date separator must be '-' or '/'"")

    # Get year
    y: int = int(date_input[6] + date_input[7] + date_input[8] + date_input[9])
    # Arbitrary year range
    if not 45 < y < 8500:
        raise ValueError(
            ""Year out of range. There has to be some sort of limit...right?""
        )

    # Get datetime obj for validation
    dt_ck = datetime.date(int(y), int(m), int(d))

    # Start math
    if m <= 2:
        y = y - 1
        m = m + 12
    # maths var
    c: int = int(str(y)[:2])
    k: int = int(str(y)[2:])
    t: int = int(2.6 * m - 5.39)
    u: int = int(c / 4)
    v: int = int(k / 4)
    x: int = int(d + k)
    z: int = int(t + u + v + x)
    w: int = int(z - (2 * c))
    f: int = round(w % 7)
    # End math

    # Validate math
    if f != convert_datetime_days[dt_ck.weekday()]:
        raise AssertionError(""The date was evaluated incorrectly. Contact developer."")

    # Response
    response: str = f""Your date {date_input}, is a {days[str(f)]}!""
    return response",data\repos\Python\maths\zellers_congruence.py,zeller,1101
1615,binary_search_matrix.py::binary_search::1,"def binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:
    """"""
    This function carries out Binary search on a 1d array and
    return -1 if it do not exist
    array: A 1d sorted array
    value : the value meant to be searched
    >>> matrix = [1, 4, 7, 11, 15]
    >>> binary_search(matrix, 0, len(matrix) - 1, 1)
    0
    >>> binary_search(matrix, 0, len(matrix) - 1, 23)
    -1
    """"""

    r = int((lower_bound + upper_bound) // 2)
    if array[r] == value:
        return r
    if lower_bound >= upper_bound:
        return -1
    if array[r] < value:
        return binary_search(array, r + 1, upper_bound, value)
    else:
        return binary_search(array, lower_bound, r - 1, value)",data\repos\Python\matrix\binary_search_matrix.py,binary_search,221
1616,binary_search_matrix.py::mat_bin_search::25,"def mat_bin_search(value: int, matrix: list) -> list:
    """"""
    This function loops over a 2d matrix and calls binarySearch on
    the selected 1d array and returns [-1, -1] is it do not exist
    value : value meant to be searched
    matrix = a sorted 2d matrix
    >>> matrix = [[1, 4, 7, 11, 15],
    ...           [2, 5, 8, 12, 19],
    ...           [3, 6, 9, 16, 22],
    ...           [10, 13, 14, 17, 24],
    ...           [18, 21, 23, 26, 30]]
    >>> target = 1
    >>> mat_bin_search(target, matrix)
    [0, 0]
    >>> target = 34
    >>> mat_bin_search(target, matrix)
    [-1, -1]
    """"""
    index = 0
    if matrix[index][0] == value:
        return [index, 0]
    while index < len(matrix) and matrix[index][0] < value:
        r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)
        if r != -1:
            return [index, r]
        index += 1
    return [-1, -1]",data\repos\Python\matrix\binary_search_matrix.py,mat_bin_search,301
1617,count_islands_in_matrix.py::is_safe::12,"    def is_safe(self, i: int, j: int, visited: list[list[bool]]) -> bool:
        return (
            0 <= i < self.ROW
            and 0 <= j < self.COL
            and not visited[i][j]
            and self.graph[i][j]
        )",data\repos\Python\matrix\count_islands_in_matrix.py,is_safe,65
1618,count_islands_in_matrix.py::diffs::20,"    def diffs(self, i: int, j: int, visited: list[list[bool]]) -> None:
        # Checking all 8 elements surrounding nth element
        row_nbr = [-1, -1, -1, 0, 0, 1, 1, 1]  # Coordinate order
        col_nbr = [-1, 0, 1, -1, 1, -1, 0, 1]
        visited[i][j] = True  # Make those cells visited
        for k in range(8):
            if self.is_safe(i + row_nbr[k], j + col_nbr[k], visited):
                self.diffs(i + row_nbr[k], j + col_nbr[k], visited)",data\repos\Python\matrix\count_islands_in_matrix.py,diffs,155
1619,count_islands_in_matrix.py::count_islands::29,"    def count_islands(self) -> int:  # And finally, count all islands.
        visited = [[False for j in range(self.COL)] for i in range(self.ROW)]
        count = 0
        for i in range(self.ROW):
            for j in range(self.COL):
                if visited[i][j] is False and self.graph[i][j] == 1:
                    self.diffs(i, j, visited)
                    count += 1
        return count",data\repos\Python\matrix\count_islands_in_matrix.py,count_islands,101
1620,count_negative_numbers_in_sorted_matrix.py::generate_large_matrix::9,"def generate_large_matrix() -> list[list[int]]:
    """"""
    >>> generate_large_matrix() # doctest: +ELLIPSIS
    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]
    """"""
    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]",data\repos\Python\matrix\count_negative_numbers_in_sorted_matrix.py,generate_large_matrix,83
1621,count_negative_numbers_in_sorted_matrix.py::validate_grid::27,"def validate_grid(grid: list[list[int]]) -> None:
    """"""
    Validate that the rows and columns of the grid is sorted in decreasing order.
    >>> for grid in test_grids:
    ...     validate_grid(grid)
    """"""
    assert all(row == sorted(row, reverse=True) for row in grid)
    assert all(list(col) == sorted(col, reverse=True) for col in zip(*grid))",data\repos\Python\matrix\count_negative_numbers_in_sorted_matrix.py,validate_grid,84
1622,count_negative_numbers_in_sorted_matrix.py::find_negative_index::37,"def find_negative_index(array: list[int]) -> int:
    """"""
    Find the smallest negative index

    >>> find_negative_index([0,0,0,0])
    4
    >>> find_negative_index([4,3,2,-1])
    3
    >>> find_negative_index([1,0,-1,-10])
    2
    >>> find_negative_index([0,0,0,-1])
    3
    >>> find_negative_index([11,8,7,-3,-5,-9])
    3
    >>> find_negative_index([-1,-1,-2,-3])
    0
    >>> find_negative_index([5,1,0])
    3
    >>> find_negative_index([-5,-5,-5])
    0
    >>> find_negative_index([0])
    1
    >>> find_negative_index([])
    0
    """"""
    left = 0
    right = len(array) - 1

    # Edge cases such as no values or all numbers are negative.
    if not array or array[0] < 0:
        return 0

    while right + 1 > left:
        mid = (left + right) // 2
        num = array[mid]

        # Num must be negative and the index must be greater than or equal to 0.
        if num < 0 and array[mid - 1] >= 0:
            return mid

        if num >= 0:
            left = mid + 1
        else:
            right = mid - 1
    # No negative numbers so return the last index of the array + 1 which is the length.
    return len(array)",data\repos\Python\matrix\count_negative_numbers_in_sorted_matrix.py,find_negative_index,356
1623,count_negative_numbers_in_sorted_matrix.py::count_negatives_binary_search::85,"def count_negatives_binary_search(grid: list[list[int]]) -> int:
    """"""
    An O(m logn) solution that uses binary search in order to find the boundary between
    positive and negative numbers

    >>> [count_negatives_binary_search(grid) for grid in test_grids]
    [8, 0, 0, 3, 1498500]
    """"""
    total = 0
    bound = len(grid[0])

    for i in range(len(grid)):
        bound = find_negative_index(grid[i][:bound])
        total += bound
    return (len(grid) * len(grid[0])) - total",data\repos\Python\matrix\count_negative_numbers_in_sorted_matrix.py,count_negatives_binary_search,132
1624,count_negative_numbers_in_sorted_matrix.py::count_negatives_brute_force::102,"def count_negatives_brute_force(grid: list[list[int]]) -> int:
    """"""
    This solution is O(n^2) because it iterates through every column and row.

    >>> [count_negatives_brute_force(grid) for grid in test_grids]
    [8, 0, 0, 3, 1498500]
    """"""
    return len([number for row in grid for number in row if number < 0])",data\repos\Python\matrix\count_negative_numbers_in_sorted_matrix.py,count_negatives_brute_force,94
1625,count_negative_numbers_in_sorted_matrix.py::count_negatives_brute_force_with_break::112,"def count_negatives_brute_force_with_break(grid: list[list[int]]) -> int:
    """"""
    Similar to the brute force solution above but uses break in order to reduce the
    number of iterations.

    >>> [count_negatives_brute_force_with_break(grid) for grid in test_grids]
    [8, 0, 0, 3, 1498500]
    """"""
    total = 0
    for row in grid:
        for i, number in enumerate(row):
            if number < 0:
                total += len(row) - i
                break
    return total",data\repos\Python\matrix\count_negative_numbers_in_sorted_matrix.py,count_negatives_brute_force_with_break,125
1626,count_negative_numbers_in_sorted_matrix.py::benchmark::129,"def benchmark() -> None:
    """"""Benchmark our functions next to each other""""""
    from timeit import timeit

    print(""Running benchmarks"")
    setup = (
        ""from __main__ import count_negatives_binary_search, ""
        ""count_negatives_brute_force, count_negatives_brute_force_with_break, grid""
    )
    for func in (
        ""count_negatives_binary_search"",  # took 0.7727 seconds
        ""count_negatives_brute_force_with_break"",  # took 4.6505 seconds
        ""count_negatives_brute_force"",  # took 12.8160 seconds
    ):
        time = timeit(f""{func}(grid=grid)"", setup=setup, number=500)
        print(f""{func}() took {time:0.4f} seconds"")",data\repos\Python\matrix\count_negative_numbers_in_sorted_matrix.py,benchmark,174
1627,count_paths.py::depth_first_search::23,"def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:
    """"""
    Recursive Backtracking Depth First Search Algorithm

    Starting from top left of a matrix, count the number of
    paths that can reach the bottom right of a matrix.
    1 represents a block (inaccessible)
    0 represents a valid space (accessible)

    0  0  0  0
    1  1  0  0
    0  0  0  1
    0  1  0  0
    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]
    >>> depth_first_search(grid, 0, 0, set())
    2

    0  0  0  0  0
    0  1  1  1  0
    0  1  1  1  0
    0  0  0  0  0
    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]
    >>> depth_first_search(grid, 0, 0, set())
    2
    """"""
    row_length, col_length = len(grid), len(grid[0])
    if (
        min(row, col) < 0
        or row == row_length
        or col == col_length
        or (row, col) in visit
        or grid[row][col] == 1
    ):
        return 0
    if row == row_length - 1 and col == col_length - 1:
        return 1

    visit.add((row, col))

    count = 0
    count += depth_first_search(grid, row + 1, col, visit)
    count += depth_first_search(grid, row - 1, col, visit)
    count += depth_first_search(grid, row, col + 1, visit)
    count += depth_first_search(grid, row, col - 1, visit)

    visit.remove((row, col))
    return count",data\repos\Python\matrix\count_paths.py,depth_first_search,540
1628,cramers_rule_2x2.py::cramers_rule_2x2::5,"def cramers_rule_2x2(equation1: list[int], equation2: list[int]) -> tuple[float, float]:
    """"""
    Solves the system of linear equation in 2 variables.
    :param: equation1: list of 3 numbers
    :param: equation2: list of 3 numbers
    :return: String of result
    input format : [a1, b1, d1], [a2, b2, d2]
    determinant = [[a1, b1], [a2, b2]]
    determinant_x = [[d1, b1], [d2, b2]]
    determinant_y = [[a1, d1], [a2, d2]]

    >>> cramers_rule_2x2([2, 3, 0], [5, 1, 0])
    (0.0, 0.0)
    >>> cramers_rule_2x2([0, 4, 50], [2, 0, 26])
    (13.0, 12.5)
    >>> cramers_rule_2x2([11, 2, 30], [1, 0, 4])
    (4.0, -7.0)
    >>> cramers_rule_2x2([4, 7, 1], [1, 2, 0])
    (2.0, -1.0)

    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 6])
    Traceback (most recent call last):
        ...
    ValueError: Infinite solutions. (Consistent system)
    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 7])
    Traceback (most recent call last):
        ...
    ValueError: No solution. (Inconsistent system)
    >>> cramers_rule_2x2([1, 2, 3], [11, 22])
    Traceback (most recent call last):
        ...
    ValueError: Please enter a valid equation.
    >>> cramers_rule_2x2([0, 1, 6], [0, 0, 3])
    Traceback (most recent call last):
        ...
    ValueError: No solution. (Inconsistent system)
    >>> cramers_rule_2x2([0, 0, 6], [0, 0, 3])
    Traceback (most recent call last):
        ...
    ValueError: Both a & b of two equations can't be zero.
    >>> cramers_rule_2x2([1, 2, 3], [1, 2, 3])
    Traceback (most recent call last):
        ...
    ValueError: Infinite solutions. (Consistent system)
    >>> cramers_rule_2x2([0, 4, 50], [0, 3, 99])
    Traceback (most recent call last):
        ...
    ValueError: No solution. (Inconsistent system)
    """"""

    # Check if the input is valid
    if not len(equation1) == len(equation2) == 3:
        raise ValueError(""Please enter a valid equation."")
    if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:
        raise ValueError(""Both a & b of two equations can't be zero."")

    # Extract the coefficients
    a1, b1, c1 = equation1
    a2, b2, c2 = equation2

    # Calculate the determinants of the matrices
    determinant = a1 * b2 - a2 * b1
    determinant_x = c1 * b2 - c2 * b1
    determinant_y = a1 * c2 - a2 * c1

    # Check if the system of linear equations has a solution (using Cramer's rule)
    if determinant == 0:
        if determinant_x == determinant_y == 0:
            raise ValueError(""Infinite solutions. (Consistent system)"")
        else:
            raise ValueError(""No solution. (Inconsistent system)"")
    elif determinant_x == determinant_y == 0:
        # Trivial solution (Inconsistent system)
        return (0.0, 0.0)
    else:
        x = determinant_x / determinant
        y = determinant_y / determinant
        # Non-Trivial Solution (Consistent system)
        return (x, y)",data\repos\Python\matrix\cramers_rule_2x2.py,cramers_rule_2x2,958
1629,inverse_of_matrix.py::inverse_of_matrix::8,"def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:
    """"""
    A matrix multiplied with its inverse gives the identity matrix.
    This function finds the inverse of a 2x2 and 3x3 matrix.
    If the determinant of a matrix is 0, its inverse does not exist.

    Sources for fixing inaccurate float arithmetic:
    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python
    https://docs.python.org/3/library/decimal.html

    Doctests for 2x2
    >>> inverse_of_matrix([[2, 5], [2, 0]])
    [[0.0, 0.5], [0.2, -0.2]]
    >>> inverse_of_matrix([[2.5, 5], [1, 2]])
    Traceback (most recent call last):
        ...
    ValueError: This matrix has no inverse.
    >>> inverse_of_matrix([[12, -16], [-9, 0]])
    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]
    >>> inverse_of_matrix([[12, 3], [16, 8]])
    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]
    >>> inverse_of_matrix([[10, 5], [3, 2.5]])
    [[0.25, -0.5], [-0.3, 1.0]]

    Doctests for 3x3
    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])
    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]
    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])
    Traceback (most recent call last):
        ...
    ValueError: This matrix has no inverse.

    >>> inverse_of_matrix([[],[]])
    Traceback (most recent call last):
        ...
    ValueError: Please provide a matrix of size 2x2 or 3x3.

    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])
    Traceback (most recent call last):
        ...
    ValueError: Please provide a matrix of size 2x2 or 3x3.

    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])
    Traceback (most recent call last):
        ...
    ValueError: Please provide a matrix of size 2x2 or 3x3.

    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])
    Traceback (most recent call last):
        ...
    ValueError: This matrix has no inverse.

    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
    """"""

    d = Decimal

    # Check if the provided matrix has 2 rows and 2 columns
    # since this implementation only works for 2x2 matrices
    if len(matrix) == 2 and len(matrix[0]) == 2 and len(matrix[1]) == 2:
        # Calculate the determinant of the matrix
        determinant = float(
            d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1])
        )
        if determinant == 0:
            raise ValueError(""This matrix has no inverse."")

        # Creates a copy of the matrix with swapped positions of the elements
        swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]
        swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]
        swapped_matrix[1][0], swapped_matrix[0][1] = -matrix[1][0], -matrix[0][1]

        # Calculate the inverse of the matrix
        return [
            [(float(d(n)) / determinant) or 0.0 for n in row] for row in swapped_matrix
        ]
    elif (
        len(matrix) == 3
        and len(matrix[0]) == 3
        and len(matrix[1]) == 3
        and len(matrix[2]) == 3
    ):
        # Calculate the determinant of the matrix using Sarrus rule
        determinant = float(
            (
                (d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]))
                + (d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]))
                + (d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]))
            )
            - (
                (d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]))
                + (d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]))
                + (d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1]))
            )
        )
        if determinant == 0:
            raise ValueError(""This matrix has no inverse."")

        # Creating cofactor matrix
        cofactor_matrix = [
            [d(0.0), d(0.0), d(0.0)],
            [d(0.0), d(0.0), d(0.0)],
            [d(0.0), d(0.0), d(0.0)],
        ]
        cofactor_matrix[0][0] = (d(matrix[1][1]) * d(matrix[2][2])) - (
            d(matrix[1][2]) * d(matrix[2][1])
        )
        cofactor_matrix[0][1] = -(
            (d(matrix[1][0]) * d(matrix[2][2])) - (d(matrix[1][2]) * d(matrix[2][0]))
        )
        cofactor_matrix[0][2] = (d(matrix[1][0]) * d(matrix[2][1])) - (
            d(matrix[1][1]) * d(matrix[2][0])
        )
        cofactor_matrix[1][0] = -(
            (d(matrix[0][1]) * d(matrix[2][2])) - (d(matrix[0][2]) * d(matrix[2][1]))
        )
        cofactor_matrix[1][1] = (d(matrix[0][0]) * d(matrix[2][2])) - (
            d(matrix[0][2]) * d(matrix[2][0])
        )
        cofactor_matrix[1][2] = -(
            (d(matrix[0][0]) * d(matrix[2][1])) - (d(matrix[0][1]) * d(matrix[2][0]))
        )
        cofactor_matrix[2][0] = (d(matrix[0][1]) * d(matrix[1][2])) - (
            d(matrix[0][2]) * d(matrix[1][1])
        )
        cofactor_matrix[2][1] = -(
            (d(matrix[0][0]) * d(matrix[1][2])) - (d(matrix[0][2]) * d(matrix[1][0]))
        )
        cofactor_matrix[2][2] = (d(matrix[0][0]) * d(matrix[1][1])) - (
            d(matrix[0][1]) * d(matrix[1][0])
        )

        # Transpose the cofactor matrix (Adjoint matrix)
        adjoint_matrix = array(cofactor_matrix)
        for i in range(3):
            for j in range(3):
                adjoint_matrix[i][j] = cofactor_matrix[j][i]

        # Inverse of the matrix using the formula (1/determinant) * adjoint matrix
        inverse_matrix = array(cofactor_matrix)
        for i in range(3):
            for j in range(3):
                inverse_matrix[i][j] /= d(determinant)

        # Calculate the inverse of the matrix
        return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]
    raise ValueError(""Please provide a matrix of size 2x2 or 3x3."")",data\repos\Python\matrix\inverse_of_matrix.py,inverse_of_matrix,1924
1630,largest_square_area_in_matrix.py::largest_square_area_in_matrix_top_down_approch::46,"def largest_square_area_in_matrix_top_down_approch(
    rows: int, cols: int, mat: list[list[int]]
) -> int:
    """"""
    Function updates the largest_square_area[0], if recursive call found
    square with maximum area.

    We aren't using dp_array here, so the time complexity would be exponential.

    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])
    0
    """"""

    def update_area_of_max_square(row: int, col: int) -> int:
        # BASE CASE
        if row >= rows or col >= cols:
            return 0

        right = update_area_of_max_square(row, col + 1)
        diagonal = update_area_of_max_square(row + 1, col + 1)
        down = update_area_of_max_square(row + 1, col)

        if mat[row][col]:
            sub_problem_sol = 1 + min([right, diagonal, down])
            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)
            return sub_problem_sol
        else:
            return 0

    largest_square_area = [0]
    update_area_of_max_square(0, 0)
    return largest_square_area[0]",data\repos\Python\matrix\largest_square_area_in_matrix.py,largest_square_area_in_matrix_top_down_approch,305
1631,largest_square_area_in_matrix.py::largest_square_area_in_matrix_top_down_approch_with_dp::82,"def largest_square_area_in_matrix_top_down_approch_with_dp(
    rows: int, cols: int, mat: list[list[int]]
) -> int:
    """"""
    Function updates the largest_square_area[0], if recursive call found
    square with maximum area.

    We are using dp_array here, so the time complexity would be O(N^2).

    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])
    0
    """"""

    def update_area_of_max_square_using_dp_array(
        row: int, col: int, dp_array: list[list[int]]
    ) -> int:
        if row >= rows or col >= cols:
            return 0
        if dp_array[row][col] != -1:
            return dp_array[row][col]

        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)
        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)
        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)

        if mat[row][col]:
            sub_problem_sol = 1 + min([right, diagonal, down])
            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)
            dp_array[row][col] = sub_problem_sol
            return sub_problem_sol
        else:
            return 0

    largest_square_area = [0]
    dp_array = [[-1] * cols for _ in range(rows)]
    update_area_of_max_square_using_dp_array(0, 0, dp_array)

    return largest_square_area[0]",data\repos\Python\matrix\largest_square_area_in_matrix.py,largest_square_area_in_matrix_top_down_approch_with_dp,394
1632,largest_square_area_in_matrix.py::largest_square_area_in_matrix_bottom_up::124,"def largest_square_area_in_matrix_bottom_up(
    rows: int, cols: int, mat: list[list[int]]
) -> int:
    """"""
    Function updates the largest_square_area, using bottom up approach.

    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])
    0

    """"""
    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]
    largest_square_area = 0
    for row in range(rows - 1, -1, -1):
        for col in range(cols - 1, -1, -1):
            right = dp_array[row][col + 1]
            diagonal = dp_array[row + 1][col + 1]
            bottom = dp_array[row + 1][col]

            if mat[row][col] == 1:
                dp_array[row][col] = 1 + min(right, diagonal, bottom)
                largest_square_area = max(dp_array[row][col], largest_square_area)
            else:
                dp_array[row][col] = 0

    return largest_square_area",data\repos\Python\matrix\largest_square_area_in_matrix.py,largest_square_area_in_matrix_bottom_up,269
1633,largest_square_area_in_matrix.py::largest_square_area_in_matrix_bottom_up_space_optimization::153,"def largest_square_area_in_matrix_bottom_up_space_optimization(
    rows: int, cols: int, mat: list[list[int]]
) -> int:
    """"""
    Function updates the largest_square_area, using bottom up
    approach. with space optimization.

    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])
    0
    """"""
    current_row = [0] * (cols + 1)
    next_row = [0] * (cols + 1)
    largest_square_area = 0
    for row in range(rows - 1, -1, -1):
        for col in range(cols - 1, -1, -1):
            right = current_row[col + 1]
            diagonal = next_row[col + 1]
            bottom = next_row[col]

            if mat[row][col] == 1:
                current_row[col] = 1 + min(right, diagonal, bottom)
                largest_square_area = max(current_row[col], largest_square_area)
            else:
                current_row[col] = 0
        next_row = current_row

    return largest_square_area",data\repos\Python\matrix\largest_square_area_in_matrix.py,largest_square_area_in_matrix_bottom_up_space_optimization,278
1634,largest_square_area_in_matrix.py::update_area_of_max_square::61,"    def update_area_of_max_square(row: int, col: int) -> int:
        # BASE CASE
        if row >= rows or col >= cols:
            return 0

        right = update_area_of_max_square(row, col + 1)
        diagonal = update_area_of_max_square(row + 1, col + 1)
        down = update_area_of_max_square(row + 1, col)

        if mat[row][col]:
            sub_problem_sol = 1 + min([right, diagonal, down])
            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)
            return sub_problem_sol
        else:
            return 0",data\repos\Python\matrix\largest_square_area_in_matrix.py,update_area_of_max_square,142
1635,largest_square_area_in_matrix.py::update_area_of_max_square_using_dp_array::97,"    def update_area_of_max_square_using_dp_array(
        row: int, col: int, dp_array: list[list[int]]
    ) -> int:
        if row >= rows or col >= cols:
            return 0
        if dp_array[row][col] != -1:
            return dp_array[row][col]

        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)
        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)
        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)

        if mat[row][col]:
            sub_problem_sol = 1 + min([right, diagonal, down])
            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)
            dp_array[row][col] = sub_problem_sol
            return sub_problem_sol
        else:
            return 0",data\repos\Python\matrix\largest_square_area_in_matrix.py,update_area_of_max_square_using_dp_array,201
1636,matrix_based_game.py::validate_matrix_size::53,"def validate_matrix_size(size: int) -> None:
    """"""
    >>> validate_matrix_size(-1)
    Traceback (most recent call last):
        ...
    ValueError: Matrix size must be a positive integer.
    """"""
    if not isinstance(size, int) or size <= 0:
        raise ValueError(""Matrix size must be a positive integer."")",data\repos\Python\matrix\matrix_based_game.py,validate_matrix_size,71
1637,matrix_based_game.py::validate_matrix_content::64,"def validate_matrix_content(matrix: list[str], size: int) -> None:
    """"""
    Validates that the number of elements in the matrix matches the given size.

    >>> validate_matrix_content(['aaaa', 'aaaa', 'aaaa', 'aaaa'], 3)
    Traceback (most recent call last):
        ...
    ValueError: The matrix dont match with size.
    >>> validate_matrix_content(['aa%', 'aaa', 'aaa'], 3)
    Traceback (most recent call last):
        ...
    ValueError: Matrix rows can only contain letters and numbers.
    >>> validate_matrix_content(['aaa', 'aaa', 'aaaa'], 3)
    Traceback (most recent call last):
        ...
    ValueError: Each row in the matrix must have exactly 3 characters.
    """"""
    print(matrix)
    if len(matrix) != size:
        raise ValueError(""The matrix dont match with size."")
    for row in matrix:
        if len(row) != size:
            msg = f""Each row in the matrix must have exactly {size} characters.""
            raise ValueError(msg)
        if not all(char.isalnum() for char in row):
            raise ValueError(""Matrix rows can only contain letters and numbers."")",data\repos\Python\matrix\matrix_based_game.py,validate_matrix_content,245
1638,matrix_based_game.py::validate_moves::92,"def validate_moves(moves: list[tuple[int, int]], size: int) -> None:
    """"""
    >>> validate_moves([(1, 2), (-1, 0)], 3)
    Traceback (most recent call last):
        ...
    ValueError: Move is out of bounds for a matrix.
    """"""
    for move in moves:
        x, y = move
        if not (0 <= x < size and 0 <= y < size):
            raise ValueError(""Move is out of bounds for a matrix."")",data\repos\Python\matrix\matrix_based_game.py,validate_moves,109
1639,matrix_based_game.py::parse_moves::105,"def parse_moves(input_str: str) -> list[tuple[int, int]]:
    """"""
    >>> parse_moves(""0 1, 1 1"")
    [(0, 1), (1, 1)]
    >>> parse_moves(""0 1, 1 1, 2"")
    Traceback (most recent call last):
        ...
    ValueError: Each move must have exactly two numbers.
    >>> parse_moves(""0 1, 1 1, 2 4 5 6"")
    Traceback (most recent call last):
        ...
    ValueError: Each move must have exactly two numbers.
    """"""
    moves = []
    for pair in input_str.split("",""):
        parts = pair.strip().split()
        if len(parts) != 2:
            raise ValueError(""Each move must have exactly two numbers."")
        x, y = map(int, parts)
        moves.append((x, y))
    return moves",data\repos\Python\matrix\matrix_based_game.py,parse_moves,194
1640,matrix_based_game.py::find_repeat::128,"def find_repeat(
    matrix_g: list[list[str]], row: int, column: int, size: int
) -> set[tuple[int, int]]:
    """"""
    Finds all connected elements of the same type from a given position.

    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)
    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}
    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)
    set()
    """"""

    column = size - 1 - column
    visited = set()
    repeated = set()

    if (color := matrix_g[column][row]) != ""-"":

        def dfs(row_n: int, column_n: int) -> None:
            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:
                return
            if (row_n, column_n) in visited:
                return
            visited.add((row_n, column_n))
            if matrix_g[row_n][column_n] == color:
                repeated.add((row_n, column_n))
                dfs(row_n - 1, column_n)
                dfs(row_n + 1, column_n)
                dfs(row_n, column_n - 1)
                dfs(row_n, column_n + 1)

        dfs(column, row)

    return repeated",data\repos\Python\matrix\matrix_based_game.py,find_repeat,345
1641,matrix_based_game.py::increment_score::164,"def increment_score(count: int) -> int:
    """"""
    Calculates the score for a move based on the number of elements removed.

    >>> increment_score(3)
    6
    >>> increment_score(0)
    0
    """"""
    return int(count * (count + 1) / 2)",data\repos\Python\matrix\matrix_based_game.py,increment_score,66
1642,matrix_based_game.py::move_x::176,"def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:
    """"""
    Simulates gravity in a specific column.

    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)
    [['-', '-'], ['-', 'A'], ['-', 'C']]
    """"""

    new_list = []

    for row in range(size):
        if matrix_g[row][column] != ""-"":
            new_list.append(matrix_g[row][column])
        else:
            new_list.insert(0, matrix_g[row][column])
    for row in range(size):
        matrix_g[row][column] = new_list[row]
    return matrix_g",data\repos\Python\matrix\matrix_based_game.py,move_x,148
1643,matrix_based_game.py::move_y::196,"def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:
    """"""
    Shifts all columns leftward when an entire column becomes empty.

    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)
    [['A', '-'], ['-', '-'], ['-', 'C']]
    """"""

    empty_columns = []

    for column in range(size - 1, -1, -1):
        if all(matrix_g[row][column] == ""-"" for row in range(size)):
            empty_columns.append(column)

    for column in empty_columns:
        for col in range(column + 1, size):
            for row in range(size):
                matrix_g[row][col - 1] = matrix_g[row][col]
        for row in range(size):
            matrix_g[row][-1] = ""-""

    return matrix_g",data\repos\Python\matrix\matrix_based_game.py,move_y,182
1644,matrix_based_game.py::play::220,"def play(
    matrix_g: list[list[str]], pos_x: int, pos_y: int, size: int
) -> tuple[list[list[str]], int]:
    """"""
    Processes a single move, updating the matrix and calculating the score.

    >>> play([['R', 'G'], ['R', 'G']], 0, 0, 2)
    ([['G', '-'], ['G', '-']], 3)
    """"""

    same_colors = find_repeat(matrix_g, pos_x, pos_y, size)

    if len(same_colors) != 0:
        for pos in same_colors:
            matrix_g[pos[0]][pos[1]] = ""-""
        for column in range(size):
            matrix_g = move_x(matrix_g, column, size)

        matrix_g = move_y(matrix_g, size)

    return (matrix_g, increment_score(len(same_colors)))",data\repos\Python\matrix\matrix_based_game.py,play,184
1645,matrix_based_game.py::process_game::243,"def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:
    """"""Processes the game logic for the given matrix and moves.

    Args:
        size (int): Size of the game board.
        matrix (List[str]): Initial game matrix.
        moves (List[Tuple[int, int]]): List of moves as (x, y) coordinates.

    Returns:
        int: The total score obtained.
    >>> process_game(3, ['aaa', 'bbb', 'ccc'], [(0, 0)])
    6
    """"""

    game_matrix = [list(row) for row in matrix]
    total_score = 0

    for move in moves:
        pos_x, pos_y = move
        game_matrix, score = play(game_matrix, pos_x, pos_y, size)
        total_score += score

    return total_score",data\repos\Python\matrix\matrix_based_game.py,process_game,185
1646,matrix_based_game.py::dfs::146,"        def dfs(row_n: int, column_n: int) -> None:
            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:
                return
            if (row_n, column_n) in visited:
                return
            visited.add((row_n, column_n))
            if matrix_g[row_n][column_n] == color:
                repeated.add((row_n, column_n))
                dfs(row_n - 1, column_n)
                dfs(row_n + 1, column_n)
                dfs(row_n, column_n - 1)
                dfs(row_n, column_n + 1)",data\repos\Python\matrix\matrix_based_game.py,dfs,135
1647,matrix_class.py::columns::131,"    def columns(self) -> list[list[int]]:
        return [[row[i] for row in self.rows] for i in range(len(self.rows[0]))]",data\repos\Python\matrix\matrix_class.py,columns,33
1648,matrix_class.py::identity::150,"    def identity(self) -> Matrix:
        values = [
            [0 if column_num != row_num else 1 for column_num in range(self.num_rows)]
            for row_num in range(self.num_rows)
        ]
        return Matrix(values)",data\repos\Python\matrix\matrix_class.py,identity,50
1649,matrix_class.py::determinant::157,"    def determinant(self) -> int:
        if not self.is_square:
            return 0
        if self.order == (0, 0):
            return 1
        if self.order == (1, 1):
            return int(self.rows[0][0])
        if self.order == (2, 2):
            return int(
                (self.rows[0][0] * self.rows[1][1])
                - (self.rows[0][1] * self.rows[1][0])
            )
        else:
            return sum(
                self.rows[0][column] * self.cofactors().rows[0][column]
                for column in range(self.num_columns)
            )",data\repos\Python\matrix\matrix_class.py,determinant,147
1650,matrix_class.py::get_minor::178,"    def get_minor(self, row: int, column: int) -> int:
        values = [
            [
                self.rows[other_row][other_column]
                for other_column in range(self.num_columns)
                if other_column != column
            ]
            for other_row in range(self.num_rows)
            if other_row != row
        ]
        return Matrix(values).determinant()",data\repos\Python\matrix\matrix_class.py,get_minor,80
1651,matrix_class.py::get_cofactor::190,"    def get_cofactor(self, row: int, column: int) -> int:
        if (row + column) % 2 == 0:
            return self.get_minor(row, column)
        return -1 * self.get_minor(row, column)",data\repos\Python\matrix\matrix_class.py,get_cofactor,54
1652,matrix_class.py::minors::195,"    def minors(self) -> Matrix:
        return Matrix(
            [
                [self.get_minor(row, column) for column in range(self.num_columns)]
                for row in range(self.num_rows)
            ]
        )",data\repos\Python\matrix\matrix_class.py,minors,44
1653,matrix_class.py::cofactors::203,"    def cofactors(self) -> Matrix:
        return Matrix(
            [
                [
                    self.minors().rows[row][column]
                    if (row + column) % 2 == 0
                    else self.minors().rows[row][column] * -1
                    for column in range(self.minors().num_columns)
                ]
                for row in range(self.minors().num_rows)
            ]
        )",data\repos\Python\matrix\matrix_class.py,cofactors,86
1654,matrix_class.py::adjugate::216,"    def adjugate(self) -> Matrix:
        values = [
            [self.cofactors().rows[column][row] for column in range(self.num_columns)]
            for row in range(self.num_rows)
        ]
        return Matrix(values)",data\repos\Python\matrix\matrix_class.py,adjugate,50
1655,matrix_class.py::inverse::223,"    def inverse(self) -> Matrix:
        determinant = self.determinant()
        if not determinant:
            raise TypeError(""Only matrices with a non-zero determinant have an inverse"")
        return self.adjugate() * (1 / determinant)",data\repos\Python\matrix\matrix_class.py,inverse,49
1656,matrix_class.py::add_row::249,"    def add_row(self, row: list[int], position: int | None = None) -> None:
        type_error = TypeError(""Row must be a list containing all ints and/or floats"")
        if not isinstance(row, list):
            raise type_error
        for value in row:
            if not isinstance(value, (int, float)):
                raise type_error
        if len(row) != self.num_columns:
            raise ValueError(
                ""Row must be equal in length to the other rows in the matrix""
            )
        if position is None:
            self.rows.append(row)
        else:
            self.rows = [*self.rows[0:position], row, *self.rows[position:]]",data\repos\Python\matrix\matrix_class.py,add_row,142
1657,matrix_class.py::add_column::265,"    def add_column(self, column: list[int], position: int | None = None) -> None:
        type_error = TypeError(
            ""Column must be a list containing all ints and/or floats""
        )
        if not isinstance(column, list):
            raise type_error
        for value in column:
            if not isinstance(value, (int, float)):
                raise type_error
        if len(column) != self.num_rows:
            raise ValueError(
                ""Column must be equal in length to the other columns in the matrix""
            )
        if position is None:
            self.rows = [self.rows[i] + [column[i]] for i in range(self.num_rows)]
        else:
            self.rows = [
                [*self.rows[i][0:position], column[i], *self.rows[i][position:]]
                for i in range(self.num_rows)
            ]",data\repos\Python\matrix\matrix_class.py,add_column,179
1658,matrix_class.py::dot_product::359,"    def dot_product(cls, row: list[int], column: list[int]) -> int:
        return sum(row[i] * column[i] for i in range(len(row)))",data\repos\Python\matrix\matrix_class.py,dot_product,36
1659,matrix_equalization.py::array_equalization::4,"def array_equalization(vector: list[int], step_size: int) -> int:
    """"""
    This algorithm equalizes all elements of the input vector
    to a common value, by making the minimal number of
    ""updates"" under the constraint of a step size (step_size).

    >>> array_equalization([1, 1, 6, 2, 4, 6, 5, 1, 7, 2, 2, 1, 7, 2, 2], 4)
    4
    >>> array_equalization([22, 81, 88, 71, 22, 81, 632, 81, 81, 22, 92], 2)
    5
    >>> array_equalization([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5)
    0
    >>> array_equalization([22, 22, 22, 33, 33, 33], 2)
    2
    >>> array_equalization([1, 2, 3], 0)
    Traceback (most recent call last):
    ValueError: Step size must be positive and non-zero.
    >>> array_equalization([1, 2, 3], -1)
    Traceback (most recent call last):
    ValueError: Step size must be positive and non-zero.
    >>> array_equalization([1, 2, 3], 0.5)
    Traceback (most recent call last):
    ValueError: Step size must be an integer.
    >>> array_equalization([1, 2, 3], maxsize)
    1
    """"""
    if step_size <= 0:
        raise ValueError(""Step size must be positive and non-zero."")
    if not isinstance(step_size, int):
        raise ValueError(""Step size must be an integer."")

    unique_elements = set(vector)
    min_updates = maxsize

    for element in unique_elements:
        elem_index = 0
        updates = 0
        while elem_index < len(vector):
            if vector[elem_index] != element:
                updates += 1
                elem_index += step_size
            else:
                elem_index += 1
        min_updates = min(min_updates, updates)

    return min_updates",data\repos\Python\matrix\matrix_equalization.py,array_equalization,506
1660,matrix_multiplication_recursion.py::is_square::58,"def is_square(matrix: Matrix) -> bool:
    """"""
    >>> is_square([])
    True
    >>> is_square(matrix_1_to_4)
    True
    >>> is_square(matrix_5_to_9_high)
    False
    """"""
    len_matrix = len(matrix)
    return all(len(row) == len_matrix for row in matrix)",data\repos\Python\matrix\matrix_multiplication_recursion.py,is_square,72
1661,matrix_multiplication_recursion.py::matrix_multiply::71,"def matrix_multiply(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:
    """"""
    >>> matrix_multiply(matrix_1_to_4, matrix_5_to_8)
    [[19, 22], [43, 50]]
    """"""
    return [
        [sum(a * b for a, b in zip(row, col)) for col in zip(*matrix_b)]
        for row in matrix_a
    ]",data\repos\Python\matrix\matrix_multiplication_recursion.py,matrix_multiply,87
1662,matrix_multiplication_recursion.py::matrix_multiply_recursive::82,"def matrix_multiply_recursive(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:
    """"""
    :param matrix_a: A square Matrix.
    :param matrix_b: Another square Matrix with the same dimensions as matrix_a.
    :return: Result of matrix_a * matrix_b.
    :raises ValueError: If the matrices cannot be multiplied.

    >>> matrix_multiply_recursive([], [])
    []
    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_8)
    [[19, 22], [43, 50]]
    >>> matrix_multiply_recursive(matrix_count_up, matrix_unordered)
    [[37, 61, 74, 61], [105, 165, 166, 129], [173, 269, 258, 197], [241, 373, 350, 265]]
    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_wide)
    Traceback (most recent call last):
        ...
    ValueError: Invalid matrix dimensions
    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_high)
    Traceback (most recent call last):
        ...
    ValueError: Invalid matrix dimensions
    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_count_up)
    Traceback (most recent call last):
        ...
    ValueError: Invalid matrix dimensions
    """"""
    if not matrix_a or not matrix_b:
        return []
    if not all(
        (len(matrix_a) == len(matrix_b), is_square(matrix_a), is_square(matrix_b))
    ):
        raise ValueError(""Invalid matrix dimensions"")

    # Initialize the result matrix with zeros
    result = [[0] * len(matrix_b[0]) for _ in range(len(matrix_a))]

    # Recursive multiplication of matrices
    def multiply(
        i_loop: int,
        j_loop: int,
        k_loop: int,
        matrix_a: Matrix,
        matrix_b: Matrix,
        result: Matrix,
    ) -> None:
        """"""
        :param matrix_a: A square Matrix.
        :param matrix_b: Another square Matrix with the same dimensions as matrix_a.
        :param result: Result matrix
        :param i: Index used for iteration during multiplication.
        :param j: Index used for iteration during multiplication.
        :param k: Index used for iteration during multiplication.
        >>> 0 > 1  # Doctests in inner functions are never run
        True
        """"""
        if i_loop >= len(matrix_a):
            return
        if j_loop >= len(matrix_b[0]):
            return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)
        if k_loop >= len(matrix_b):
            return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)
        result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]
        return multiply(i_loop, j_loop, k_loop + 1, matrix_a, matrix_b, result)

    # Perform the recursive matrix multiplication
    multiply(0, 0, 0, matrix_a, matrix_b, result)
    return result",data\repos\Python\matrix\matrix_multiplication_recursion.py,matrix_multiply_recursive,671
1663,matrix_multiplication_recursion.py::multiply::119,"    def multiply(
        i_loop: int,
        j_loop: int,
        k_loop: int,
        matrix_a: Matrix,
        matrix_b: Matrix,
        result: Matrix,
    ) -> None:
        """"""
        :param matrix_a: A square Matrix.
        :param matrix_b: Another square Matrix with the same dimensions as matrix_a.
        :param result: Result matrix
        :param i: Index used for iteration during multiplication.
        :param j: Index used for iteration during multiplication.
        :param k: Index used for iteration during multiplication.
        >>> 0 > 1  # Doctests in inner functions are never run
        True
        """"""
        if i_loop >= len(matrix_a):
            return
        if j_loop >= len(matrix_b[0]):
            return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)
        if k_loop >= len(matrix_b):
            return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)
        result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]
        return multiply(i_loop, j_loop, k_loop + 1, matrix_a, matrix_b, result)",data\repos\Python\matrix\matrix_multiplication_recursion.py,multiply,268
1664,matrix_operation.py::add::10,"def add(*matrix_s: list[list[int]]) -> list[list[int]]:
    """"""
    >>> add([[1,2],[3,4]],[[2,3],[4,5]])
    [[3, 5], [7, 9]]
    >>> add([[1.2,2.4],[3,4]],[[2,3],[4,5]])
    [[3.2, 5.4], [7, 9]]
    >>> add([[1, 2], [4, 5]], [[3, 7], [3, 4]], [[3, 5], [5, 7]])
    [[7, 14], [12, 16]]
    >>> add([3], [4, 5])
    Traceback (most recent call last):
      ...
    TypeError: Expected a matrix, got int/list instead
    """"""
    if all(_check_not_integer(m) for m in matrix_s):
        for i in matrix_s[1:]:
            _verify_matrix_sizes(matrix_s[0], i)
        return [[sum(t) for t in zip(*m)] for m in zip(*matrix_s)]
    raise TypeError(""Expected a matrix, got int/list instead"")",data\repos\Python\matrix\matrix_operation.py,add,254
1665,matrix_operation.py::subtract::30,"def subtract(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:
    """"""
    >>> subtract([[1,2],[3,4]],[[2,3],[4,5]])
    [[-1, -1], [-1, -1]]
    >>> subtract([[1,2.5],[3,4]],[[2,3],[4,5.5]])
    [[-1, -0.5], [-1, -1.5]]
    >>> subtract([3], [4, 5])
    Traceback (most recent call last):
      ...
    TypeError: Expected a matrix, got int/list instead
    """"""
    if (
        _check_not_integer(matrix_a)
        and _check_not_integer(matrix_b)
        and _verify_matrix_sizes(matrix_a, matrix_b)
    ):
        return [[i - j for i, j in zip(*m)] for m in zip(matrix_a, matrix_b)]
    raise TypeError(""Expected a matrix, got int/list instead"")",data\repos\Python\matrix\matrix_operation.py,subtract,212
1666,matrix_operation.py::scalar_multiply::50,"def scalar_multiply(matrix: list[list[int]], n: float) -> list[list[float]]:
    """"""
    >>> scalar_multiply([[1,2],[3,4]],5)
    [[5, 10], [15, 20]]
    >>> scalar_multiply([[1.4,2.3],[3,4]],5)
    [[7.0, 11.5], [15, 20]]
    """"""
    return [[x * n for x in row] for row in matrix]",data\repos\Python\matrix\matrix_operation.py,scalar_multiply,102
1667,matrix_operation.py::multiply::60,"def multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:
    """"""
    >>> multiply([[1,2],[3,4]],[[5,5],[7,5]])
    [[19, 15], [43, 35]]
    >>> multiply([[1,2.5],[3,4.5]],[[5,5],[7,5]])
    [[22.5, 17.5], [46.5, 37.5]]
    >>> multiply([[1, 2, 3]], [[2], [3], [4]])
    [[20]]
    """"""
    if _check_not_integer(matrix_a) and _check_not_integer(matrix_b):
        rows, cols = _verify_matrix_sizes(matrix_a, matrix_b)

    if cols[0] != rows[1]:
        msg = (
            ""Cannot multiply matrix of dimensions ""
            f""({rows[0]},{cols[0]}) and ({rows[1]},{cols[1]})""
        )
        raise ValueError(msg)
    return [
        [sum(m * n for m, n in zip(i, j)) for j in zip(*matrix_b)] for i in matrix_a
    ]",data\repos\Python\matrix\matrix_operation.py,multiply,255
1668,matrix_operation.py::identity::83,"def identity(n: int) -> list[list[int]]:
    """"""
    :param n: dimension for nxn matrix
    :type n: int
    :return: Identity matrix of shape [n, n]
    >>> identity(3)
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    """"""
    n = int(n)
    return [[int(row == column) for column in range(n)] for row in range(n)]",data\repos\Python\matrix\matrix_operation.py,identity,106
1669,matrix_operation.py::transpose::95,"def transpose(
    matrix: list[list[int]], return_map: bool = True
) -> list[list[int]] | map[list[int]]:
    """"""
    >>> transpose([[1,2],[3,4]]) # doctest: +ELLIPSIS
    <map object at ...
    >>> transpose([[1,2],[3,4]], return_map=False)
    [[1, 3], [2, 4]]
    >>> transpose([1, [2, 3]])
    Traceback (most recent call last):
      ...
    TypeError: Expected a matrix, got int/list instead
    """"""
    if _check_not_integer(matrix):
        if return_map:
            return map(list, zip(*matrix))
        else:
            return list(map(list, zip(*matrix)))
    raise TypeError(""Expected a matrix, got int/list instead"")",data\repos\Python\matrix\matrix_operation.py,transpose,171
1670,matrix_operation.py::minor::116,"def minor(matrix: list[list[int]], row: int, column: int) -> list[list[int]]:
    """"""
    >>> minor([[1, 2], [3, 4]], 1, 1)
    [[1]]
    """"""
    minor = matrix[:row] + matrix[row + 1 :]
    return [row[:column] + row[column + 1 :] for row in minor]",data\repos\Python\matrix\matrix_operation.py,minor,83
1671,matrix_operation.py::determinant::125,"def determinant(matrix: list[list[int]]) -> Any:
    """"""
    >>> determinant([[1, 2], [3, 4]])
    -2
    >>> determinant([[1.5, 2.5], [3, 4]])
    -1.5
    """"""
    if len(matrix) == 1:
        return matrix[0][0]

    return sum(
        x * determinant(minor(matrix, 0, i)) * (-1) ** i
        for i, x in enumerate(matrix[0])
    )",data\repos\Python\matrix\matrix_operation.py,determinant,113
1672,matrix_operation.py::inverse::141,"def inverse(matrix: list[list[int]]) -> list[list[float]] | None:
    """"""
    >>> inverse([[1, 2], [3, 4]])
    [[-2.0, 1.0], [1.5, -0.5]]
    >>> inverse([[1, 1], [1, 1]])
    """"""
    # https://stackoverflow.com/questions/20047519/python-doctests-test-for-none
    det = determinant(matrix)
    if det == 0:
        return None

    matrix_minor = [
        [determinant(minor(matrix, i, j)) for j in range(len(matrix))]
        for i in range(len(matrix))
    ]

    cofactors = [
        [x * (-1) ** (row + col) for col, x in enumerate(matrix_minor[row])]
        for row in range(len(matrix))
    ]
    adjugate = list(transpose(cofactors))
    return scalar_multiply(adjugate, 1 / det)",data\repos\Python\matrix\matrix_operation.py,inverse,206
1673,matrix_operation.py::main::186,"def main() -> None:
    matrix_a = [[12, 10], [3, 9]]
    matrix_b = [[3, 4], [7, 4]]
    matrix_c = [[11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34], [41, 42, 43, 44]]
    matrix_d = [[3, 0, 2], [2, 0, -2], [0, 1, 1]]
    print(f""Add Operation, {add(matrix_a, matrix_b) = } \n"")
    print(f""Multiply Operation, {multiply(matrix_a, matrix_b) = } \n"")
    print(f""Identity: {identity(5)}\n"")
    print(f""Minor of {matrix_c} = {minor(matrix_c, 1, 2)} \n"")
    print(f""Determinant of {matrix_b} = {determinant(matrix_b)} \n"")
    print(f""Inverse of {matrix_d} = {inverse(matrix_d)}\n"")",data\repos\Python\matrix\matrix_operation.py,main,241
1674,max_area_of_island.py::is_safe::21,"def is_safe(row: int, col: int, rows: int, cols: int) -> bool:
    """"""
    Checking whether coordinate (row, col) is valid or not.

    >>> is_safe(0, 0, 5, 5)
    True
    >>> is_safe(-1,-1, 5, 5)
    False
    """"""
    return 0 <= row < rows and 0 <= col < cols",data\repos\Python\matrix\max_area_of_island.py,is_safe,92
1675,max_area_of_island.py::depth_first_search::33,"def depth_first_search(row: int, col: int, seen: set, mat: list[list[int]]) -> int:
    """"""
    Returns the current area of the island

    >>> depth_first_search(0, 0, set(), matrix)
    0
    """"""
    rows = len(mat)
    cols = len(mat[0])
    if is_safe(row, col, rows, cols) and (row, col) not in seen and mat[row][col] == 1:
        seen.add((row, col))
        return (
            1
            + depth_first_search(row + 1, col, seen, mat)
            + depth_first_search(row - 1, col, seen, mat)
            + depth_first_search(row, col + 1, seen, mat)
            + depth_first_search(row, col - 1, seen, mat)
        )
    else:
        return 0",data\repos\Python\matrix\max_area_of_island.py,depth_first_search,190
1676,max_area_of_island.py::find_max_area::55,"def find_max_area(mat: list[list[int]]) -> int:
    """"""
    Finds the area of all islands and returns the maximum area.

    >>> find_max_area(matrix)
    6
    """"""
    seen: set = set()

    max_area = 0
    for row, line in enumerate(mat):
        for col, item in enumerate(line):
            if item == 1 and (row, col) not in seen:
                # Maximizing the area
                max_area = max(max_area, depth_first_search(row, col, seen, mat))
    return max_area",data\repos\Python\matrix\max_area_of_island.py,find_max_area,119
1677,median_matrix.py::median::6,"def median(matrix: list[list[int]]) -> int:
    """"""
    Calculate the median of a sorted matrix.

    Args:
        matrix: A 2D matrix of integers.

    Returns:
        The median value of the matrix.

    Examples:
        >>> matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]
        >>> median(matrix)
        5

        >>> matrix = [[1, 2, 3], [4, 5, 6]]
        >>> median(matrix)
        3
    """"""
    # Flatten the matrix into a sorted 1D list
    linear = sorted(num for row in matrix for num in row)

    # Calculate the middle index
    mid = (len(linear) - 1) // 2

    # Return the median
    return linear[mid]",data\repos\Python\matrix\median_matrix.py,median,184
1678,nth_fibonacci_using_matrix_exponentiation.py::multiply::19,"def multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:
    matrix_c = []
    n = len(matrix_a)
    for i in range(n):
        list_1 = []
        for j in range(n):
            val = 0
            for k in range(n):
                val = val + matrix_a[i][k] * matrix_b[k][j]
            list_1.append(val)
        matrix_c.append(list_1)
    return matrix_c",data\repos\Python\matrix\nth_fibonacci_using_matrix_exponentiation.py,multiply,103
1679,nth_fibonacci_using_matrix_exponentiation.py::identity::33,"def identity(n: int) -> list[list[int]]:
    return [[int(row == column) for column in range(n)] for row in range(n)]",data\repos\Python\matrix\nth_fibonacci_using_matrix_exponentiation.py,identity,31
1680,nth_fibonacci_using_matrix_exponentiation.py::nth_fibonacci_matrix::37,"def nth_fibonacci_matrix(n: int) -> int:
    """"""
    >>> nth_fibonacci_matrix(100)
    354224848179261915075
    >>> nth_fibonacci_matrix(-100)
    -100
    """"""
    if n <= 1:
        return n
    res_matrix = identity(2)
    fibonacci_matrix = [[1, 1], [1, 0]]
    n = n - 1
    while n > 0:
        if n % 2 == 1:
            res_matrix = multiply(res_matrix, fibonacci_matrix)
        fibonacci_matrix = multiply(fibonacci_matrix, fibonacci_matrix)
        n = int(n / 2)
    return res_matrix[0][0]",data\repos\Python\matrix\nth_fibonacci_using_matrix_exponentiation.py,nth_fibonacci_matrix,153
1681,nth_fibonacci_using_matrix_exponentiation.py::nth_fibonacci_bruteforce::57,"def nth_fibonacci_bruteforce(n: int) -> int:
    """"""
    >>> nth_fibonacci_bruteforce(100)
    354224848179261915075
    >>> nth_fibonacci_bruteforce(-100)
    -100
    """"""
    if n <= 1:
        return n
    fib0 = 0
    fib1 = 1
    for _ in range(2, n + 1):
        fib0, fib1 = fib1, fib0 + fib1
    return fib1",data\repos\Python\matrix\nth_fibonacci_using_matrix_exponentiation.py,nth_fibonacci_bruteforce,118
1682,nth_fibonacci_using_matrix_exponentiation.py::main::73,"def main() -> None:
    for ordinal in ""0th 1st 2nd 3rd 10th 100th 1000th"".split():
        n = int("""".join(c for c in ordinal if c in ""0123456789""))  # 1000th --> 1000
        print(
            f""{ordinal} fibonacci number using matrix exponentiation is ""
            f""{nth_fibonacci_matrix(n)} and using bruteforce is ""
            f""{nth_fibonacci_bruteforce(n)}\n""
        )",data\repos\Python\matrix\nth_fibonacci_using_matrix_exponentiation.py,main,118
1683,pascal_triangle.py::print_pascal_triangle::11,"def print_pascal_triangle(num_rows: int) -> None:
    """"""
    Print Pascal's triangle for different number of rows
    >>> print_pascal_triangle(5)
        1
       1 1
      1 2 1
     1 3 3 1
    1 4 6 4 1
    """"""
    triangle = generate_pascal_triangle(num_rows)
    for row_idx in range(num_rows):
        # Print left spaces
        for _ in range(num_rows - row_idx - 1):
            print(end="" "")
        # Print row values
        for col_idx in range(row_idx + 1):
            if col_idx != row_idx:
                print(triangle[row_idx][col_idx], end="" "")
            else:
                print(triangle[row_idx][col_idx], end="""")
        print()",data\repos\Python\matrix\pascal_triangle.py,print_pascal_triangle,178
1684,pascal_triangle.py::generate_pascal_triangle::35,"def generate_pascal_triangle(num_rows: int) -> list[list[int]]:
    """"""
    Create Pascal's triangle for different number of rows
    >>> generate_pascal_triangle(0)
    []
    >>> generate_pascal_triangle(1)
    [[1]]
    >>> generate_pascal_triangle(2)
    [[1], [1, 1]]
    >>> generate_pascal_triangle(3)
    [[1], [1, 1], [1, 2, 1]]
    >>> generate_pascal_triangle(4)
    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]
    >>> generate_pascal_triangle(5)
    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
    >>> generate_pascal_triangle(-5)
    Traceback (most recent call last):
        ...
    ValueError: The input value of 'num_rows' should be greater than or equal to 0
    >>> generate_pascal_triangle(7.89)
    Traceback (most recent call last):
        ...
    TypeError: The input value of 'num_rows' should be 'int'
    """"""

    if not isinstance(num_rows, int):
        raise TypeError(""The input value of 'num_rows' should be 'int'"")

    if num_rows == 0:
        return []
    elif num_rows < 0:
        raise ValueError(
            ""The input value of 'num_rows' should be greater than or equal to 0""
        )

    triangle: list[list[int]] = []
    for current_row_idx in range(num_rows):
        current_row = populate_current_row(triangle, current_row_idx)
        triangle.append(current_row)
    return triangle",data\repos\Python\matrix\pascal_triangle.py,generate_pascal_triangle,389
1685,pascal_triangle.py::populate_current_row::77,"def populate_current_row(triangle: list[list[int]], current_row_idx: int) -> list[int]:
    """"""
    >>> triangle = [[1]]
    >>> populate_current_row(triangle, 1)
    [1, 1]
    """"""
    current_row = [-1] * (current_row_idx + 1)
    # first and last elements of current row are equal to 1
    current_row[0], current_row[-1] = 1, 1
    for current_col_idx in range(1, current_row_idx):
        calculate_current_element(
            triangle, current_row, current_row_idx, current_col_idx
        )
    return current_row",data\repos\Python\matrix\pascal_triangle.py,populate_current_row,138
1686,pascal_triangle.py::calculate_current_element::93,"def calculate_current_element(
    triangle: list[list[int]],
    current_row: list[int],
    current_row_idx: int,
    current_col_idx: int,
) -> None:
    """"""
    >>> triangle = [[1], [1, 1]]
    >>> current_row = [1, -1, 1]
    >>> calculate_current_element(triangle, current_row, 2, 1)
    >>> current_row
    [1, 2, 1]
    """"""
    above_to_left_elt = triangle[current_row_idx - 1][current_col_idx - 1]
    above_to_right_elt = triangle[current_row_idx - 1][current_col_idx]
    current_row[current_col_idx] = above_to_left_elt + above_to_right_elt",data\repos\Python\matrix\pascal_triangle.py,calculate_current_element,156
1687,pascal_triangle.py::generate_pascal_triangle_optimized::111,"def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:
    """"""
    This function returns a matrix representing the corresponding pascal's triangle
    according to the given input of number of rows of Pascal's triangle to be generated.
    It reduces the operations done to generate a row by half
    by eliminating redundant calculations.

    :param num_rows: Integer specifying the number of rows in the Pascal's triangle
    :return: 2-D List (matrix) representing the Pascal's triangle

    Return the Pascal's triangle of given rows
    >>> generate_pascal_triangle_optimized(3)
    [[1], [1, 1], [1, 2, 1]]
    >>> generate_pascal_triangle_optimized(1)
    [[1]]
    >>> generate_pascal_triangle_optimized(0)
    []
    >>> generate_pascal_triangle_optimized(-5)
    Traceback (most recent call last):
        ...
    ValueError: The input value of 'num_rows' should be greater than or equal to 0
    >>> generate_pascal_triangle_optimized(7.89)
    Traceback (most recent call last):
        ...
    TypeError: The input value of 'num_rows' should be 'int'
    """"""

    if not isinstance(num_rows, int):
        raise TypeError(""The input value of 'num_rows' should be 'int'"")

    if num_rows == 0:
        return []
    elif num_rows < 0:
        raise ValueError(
            ""The input value of 'num_rows' should be greater than or equal to 0""
        )

    result: list[list[int]] = [[1]]

    for row_index in range(1, num_rows):
        temp_row = [0] + result[-1] + [0]
        row_length = row_index + 1
        # Calculate the number of distinct elements in a row
        distinct_elements = sum(divmod(row_length, 2))
        row_first_half = [
            temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)
        ]
        row_second_half = row_first_half[: (row_index + 1) // 2]
        row_second_half.reverse()
        row = row_first_half + row_second_half
        result.append(row)

    return result",data\repos\Python\matrix\pascal_triangle.py,generate_pascal_triangle_optimized,483
1688,pascal_triangle.py::benchmark::166,"def benchmark() -> None:
    """"""
    Benchmark multiple functions, with three different length int values.
    """"""
    from collections.abc import Callable
    from timeit import timeit

    def benchmark_a_function(func: Callable, value: int) -> None:
        call = f""{func.__name__}({value})""
        timing = timeit(f""__main__.{call}"", setup=""import __main__"")
        # print(f""{call:38} = {func(value)} -- {timing:.4f} seconds"")
        print(f""{call:38} -- {timing:.4f} seconds"")

    for value in range(15):  # (1, 7, 14):
        for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):
            benchmark_a_function(func, value)
        print()",data\repos\Python\matrix\pascal_triangle.py,benchmark,174
1689,pascal_triangle.py::benchmark_a_function::173,"    def benchmark_a_function(func: Callable, value: int) -> None:
        call = f""{func.__name__}({value})""
        timing = timeit(f""__main__.{call}"", setup=""import __main__"")
        # print(f""{call:38} = {func(value)} -- {timing:.4f} seconds"")
        print(f""{call:38} -- {timing:.4f} seconds"")",data\repos\Python\matrix\pascal_triangle.py,benchmark_a_function,89
1690,rotate_matrix.py::make_matrix::11,"def make_matrix(row_size: int = 4) -> list[list[int]]:
    """"""
    >>> make_matrix()
    [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
    >>> make_matrix(1)
    [[1]]
    >>> make_matrix(-2)
    [[1, 2], [3, 4]]
    >>> make_matrix(3)
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    >>> make_matrix() == make_matrix(4)
    True
    """"""
    row_size = abs(row_size) or 4
    return [[1 + x + y * row_size for x in range(row_size)] for y in range(row_size)]",data\repos\Python\matrix\rotate_matrix.py,make_matrix,191
1691,rotate_matrix.py::rotate_90::28,"def rotate_90(matrix: list[list[int]]) -> list[list[int]]:
    """"""
    >>> rotate_90(make_matrix())
    [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]
    >>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))
    True
    """"""

    return reverse_row(transpose(matrix))",data\repos\Python\matrix\rotate_matrix.py,rotate_90,102
1692,rotate_matrix.py::rotate_180::40,"def rotate_180(matrix: list[list[int]]) -> list[list[int]]:
    """"""
    >>> rotate_180(make_matrix())
    [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]
    >>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))
    True
    """"""

    return reverse_row(reverse_column(matrix))",data\repos\Python\matrix\rotate_matrix.py,rotate_180,103
1693,rotate_matrix.py::rotate_270::52,"def rotate_270(matrix: list[list[int]]) -> list[list[int]]:
    """"""
    >>> rotate_270(make_matrix())
    [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]
    >>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))
    True
    """"""

    return reverse_column(transpose(matrix))",data\repos\Python\matrix\rotate_matrix.py,rotate_270,102
1694,rotate_matrix.py::transpose::64,"def transpose(matrix: list[list[int]]) -> list[list[int]]:
    matrix[:] = [list(x) for x in zip(*matrix)]
    return matrix",data\repos\Python\matrix\rotate_matrix.py,transpose,31
1695,rotate_matrix.py::reverse_column::74,"def reverse_column(matrix: list[list[int]]) -> list[list[int]]:
    matrix[:] = [x[::-1] for x in matrix]
    return matrix",data\repos\Python\matrix\rotate_matrix.py,reverse_column,31
1696,searching_in_sorted_matrix.py::search_in_a_sorted_matrix::4,"def search_in_a_sorted_matrix(mat: list[list[int]], m: int, n: int, key: float) -> None:
    """"""
    >>> search_in_a_sorted_matrix(
    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5)
    Key 5 found at row- 1 column- 2
    >>> search_in_a_sorted_matrix(
    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21)
    Key 21 not found
    >>> search_in_a_sorted_matrix(
    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1)
    Key 2.1 found at row- 1 column- 1
    >>> search_in_a_sorted_matrix(
    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2)
    Key 2.2 not found
    """"""
    i, j = m - 1, 0
    while i >= 0 and j < n:
        if key == mat[i][j]:
            print(f""Key {key} found at row- {i + 1} column- {j + 1}"")
            return
        if key < mat[i][j]:
            i -= 1
        else:
            j += 1
    print(f""Key {key} not found"")",data\repos\Python\matrix\searching_in_sorted_matrix.py,search_in_a_sorted_matrix,408
1697,searching_in_sorted_matrix.py::main::31,"def main() -> None:
    mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]
    x = int(input(""Enter the element to be searched:""))
    print(mat)
    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), x)",data\repos\Python\matrix\searching_in_sorted_matrix.py,main,81
1698,sherman_morrison.py::validate_indices::57,"    def validate_indices(self, loc: tuple[int, int]) -> bool:
        """"""
        <method Matrix.validate_indicies>
        Check if given indices are valid to pick element from matrix.
        Example:
        >>> a = Matrix(2, 6, 0)
        >>> a.validate_indices((2, 7))
        False
        >>> a.validate_indices((0, 0))
        True
        """"""
        if not (isinstance(loc, (list, tuple)) and len(loc) == 2):  # noqa: SIM114
            return False
        elif not (0 <= loc[0] < self.row and 0 <= loc[1] < self.column):
            return False
        else:
            return True",data\repos\Python\matrix\sherman_morrison.py,validate_indices,153
1699,sherman_morrison.py::transpose::180,"    def transpose(self) -> Matrix:
        """"""
        <method Matrix.transpose>
        Return self^T.
        Example:
        >>> a = Matrix(2, 3)
        >>> for r in range(2):
        ...     for c in range(3):
        ...             a[r,c] = r*c
        ...
        >>> a.transpose()
        Matrix consist of 3 rows and 2 columns
        [0, 0]
        [0, 1]
        [0, 2]
        """"""

        result = Matrix(self.column, self.row)
        for r in range(self.row):
            for c in range(self.column):
                result[c, r] = self[r, c]
        return result",data\repos\Python\matrix\sherman_morrison.py,transpose,149
1700,sherman_morrison.py::sherman_morrison::203,"    def sherman_morrison(self, u: Matrix, v: Matrix) -> Any:
        """"""
        <method Matrix.sherman_morrison>
        Apply Sherman-Morrison formula in O(n^2).
        To learn this formula, please look this:
        https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula
        This method returns (A + uv^T)^(-1) where A^(-1) is self. Returns None if it's
        impossible to calculate.
        Warning: This method doesn't check if self is invertible.
            Make sure self is invertible before execute this method.
        Example:
        >>> ainv = Matrix(3, 3, 0)
        >>> for i in range(3): ainv[i,i] = 1
        ...
        >>> u = Matrix(3, 1, 0)
        >>> u[0,0], u[1,0], u[2,0] = 1, 2, -3
        >>> v = Matrix(3, 1, 0)
        >>> v[0,0], v[1,0], v[2,0] = 4, -2, 5
        >>> ainv.sherman_morrison(u, v)
        Matrix consist of 3 rows and 3 columns
        [  1.2857142857142856, -0.14285714285714285,   0.3571428571428571]
        [  0.5714285714285714,   0.7142857142857143,   0.7142857142857142]
        [ -0.8571428571428571,  0.42857142857142855,  -0.0714285714285714]
        """"""

        # Size validation
        assert isinstance(u, Matrix)
        assert isinstance(v, Matrix)
        assert self.row == self.column == u.row == v.row  # u, v should be column vector
        assert u.column == v.column == 1  # u, v should be column vector

        # Calculate
        v_t = v.transpose()
        numerator_factor = (v_t * self * u)[0, 0] + 1
        if numerator_factor == 0:
            return None  # It's not invertible
        return self - ((self * u) * (v_t * self) * (1.0 / numerator_factor))",data\repos\Python\matrix\sherman_morrison.py,sherman_morrison,532
1701,sherman_morrison.py::test1::245,"    def test1() -> None:
        # a^(-1)
        ainv = Matrix(3, 3, 0)
        for i in range(3):
            ainv[i, i] = 1
        print(f""a^(-1) is {ainv}"")
        # u, v
        u = Matrix(3, 1, 0)
        u[0, 0], u[1, 0], u[2, 0] = 1, 2, -3
        v = Matrix(3, 1, 0)
        v[0, 0], v[1, 0], v[2, 0] = 4, -2, 5
        print(f""u is {u}"")
        print(f""v is {v}"")
        print(f""uv^T is {u * v.transpose()}"")
        # Sherman Morrison
        print(f""(a + uv^T)^(-1) is {ainv.sherman_morrison(u, v)}"")",data\repos\Python\matrix\sherman_morrison.py,test1,223
1702,sherman_morrison.py::single_line::44,"        def single_line(row_vector: list[float]) -> str:
            nonlocal string_format_identifier
            line = ""[""
            line += "", "".join(string_format_identifier % (obj,) for obj in row_vector)
            line += ""]""
            return line",data\repos\Python\matrix\sherman_morrison.py,single_line,52
1703,spiral_print.py::check_matrix::10,"def check_matrix(matrix: list[list[int]]) -> bool:
    # must be
    matrix = [list(row) for row in matrix]
    if matrix and isinstance(matrix, list):
        if isinstance(matrix[0], list):
            prev_len = 0
            for row in matrix:
                if prev_len == 0:
                    prev_len = len(row)
                    result = True
                else:
                    result = prev_len == len(row)
        else:
            result = True
    else:
        result = False

    return result",data\repos\Python\matrix\spiral_print.py,check_matrix,111
1704,spiral_print.py::spiral_print_clockwise::30,"def spiral_print_clockwise(a: list[list[int]]) -> None:
    """"""
    >>> spiral_print_clockwise([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
    1
    2
    3
    4
    8
    12
    11
    10
    9
    5
    6
    7
    """"""
    if check_matrix(a) and len(a) > 0:
        a = [list(row) for row in a]
        mat_row = len(a)
        if isinstance(a[0], list):
            mat_col = len(a[0])
        else:
            for dat in a:
                print(dat)
            return

        # horizotal printing increasing
        for i in range(mat_col):
            print(a[0][i])
        # vertical printing down
        for i in range(1, mat_row):
            print(a[i][mat_col - 1])
        # horizotal printing decreasing
        if mat_row > 1:
            for i in range(mat_col - 2, -1, -1):
                print(a[mat_row - 1][i])
        # vertical printing up
        for i in range(mat_row - 2, 0, -1):
            print(a[i][0])
        remain_mat = [row[1 : mat_col - 1] for row in a[1 : mat_row - 1]]
        if len(remain_mat) > 0:
            spiral_print_clockwise(remain_mat)
        else:
            return
    else:
        print(""Not a valid matrix"")
        return",data\repos\Python\matrix\spiral_print.py,spiral_print_clockwise,369
1705,spiral_print.py::spiral_traversal::82,"def spiral_traversal(matrix: list[list]) -> list[int]:
    """"""
    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]

    Example:
    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
    Algorithm:
        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the
                output of [step 2])
        Step 2. Now perform matrix's Transpose operation (Change rows to column
                and vice versa) and reverse the resultant matrix.
        Step 3. Pass the output of [2nd step], to same recursive function till
                base case hits.
    Dry Run:
    Stage 1.
    [1, 2, 3, 4] +   spiral_traversal([
        [8, 12], [7, 11], [6, 10], [5, 9]]
     ])
    Stage 2.
    [1, 2, 3, 4, 8, 12] + spiral_traversal([
        [11, 10, 9], [7, 6, 5]
    ])
    Stage 3.
    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([
        [5], [6], [7]
    ])
    Stage 4.
    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([
        [5], [6], [7]
    ])
    Stage 5.
    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])
    Stage 6.
    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])
    """"""
    if matrix:
        return list(matrix.pop(0)) + spiral_traversal(
            [list(row) for row in zip(*matrix)][::-1]
        )
    else:
        return []",data\repos\Python\matrix\spiral_print.py,spiral_traversal,572
1706,validate_sudoku_board.py::is_valid_sudoku_board::28,"def is_valid_sudoku_board(sudoku_board: list[list[str]]) -> bool:
    """"""
    This function validates (but does not solve) a sudoku board.
    The board may be valid but unsolvable.

    >>> is_valid_sudoku_board([
    ...  [""5"",""3"",""."",""."",""7"",""."",""."",""."","".""]
    ... ,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
    ... ,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
    ... ,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
    ... ,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
    ... ,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
    ... ,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
    ... ,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
    ... ,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
    ... ])
    True
    >>> is_valid_sudoku_board([
    ...  [""8"",""3"",""."",""."",""7"",""."",""."",""."","".""]
    ... ,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
    ... ,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
    ... ,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
    ... ,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
    ... ,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
    ... ,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
    ... ,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
    ... ,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
    ... ])
    False
    >>> is_valid_sudoku_board([
    ...  [""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9""]
    ... ,[""4"",""5"",""6"",""7"",""8"",""9"",""1"",""2"",""3""]
    ... ,[""7"",""8"",""9"",""1"",""2"",""3"",""4"",""5"",""6""]
    ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""]
    ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""]
    ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""]
    ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""]
    ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""]
    ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""]
    ... ])
    True
    >>> is_valid_sudoku_board([
    ...  [""1"",""2"",""3"",""."",""."",""."",""."",""."","".""]
    ... ,[""4"",""5"",""6"",""."",""."",""."",""."",""."","".""]
    ... ,[""7"",""8"",""9"",""."",""."",""."",""."",""."","".""]
    ... ,[""."",""."",""."",""4"",""5"",""6"",""."",""."","".""]
    ... ,[""."",""."",""."",""7"",""8"",""9"",""."",""."","".""]
    ... ,[""."",""."",""."",""1"",""2"",""3"",""."",""."","".""]
    ... ,[""."",""."",""."",""."",""."",""."",""7"",""8"",""9""]
    ... ,[""."",""."",""."",""."",""."",""."",""1"",""2"",""3""]
    ... ,[""."",""."",""."",""."",""."",""."",""4"",""5"",""6""]
    ... ])
    True
    >>> is_valid_sudoku_board([
    ...  [""1"",""2"",""3"",""."",""."",""."",""5"",""6"",""4""]
    ... ,[""4"",""5"",""6"",""."",""."",""."",""8"",""9"",""7""]
    ... ,[""7"",""8"",""9"",""."",""."",""."",""2"",""3"",""1""]
    ... ,[""."",""."",""."",""4"",""5"",""6"",""."",""."","".""]
    ... ,[""."",""."",""."",""7"",""8"",""9"",""."",""."","".""]
    ... ,[""."",""."",""."",""1"",""2"",""3"",""."",""."","".""]
    ... ,[""3"",""1"",""2"",""."",""."",""."",""7"",""8"",""9""]
    ... ,[""6"",""4"",""5"",""."",""."",""."",""1"",""2"",""3""]
    ... ,[""9"",""7"",""8"",""."",""."",""."",""4"",""5"",""6""]
    ... ])
    True
    >>> is_valid_sudoku_board([
    ...  [""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9""]
    ... ,[""2"",""."",""."",""."",""."",""."",""."",""."",""8""]
    ... ,[""3"",""."",""."",""."",""."",""."",""."",""."",""7""]
    ... ,[""4"",""."",""."",""."",""."",""."",""."",""."",""6""]
    ... ,[""5"",""."",""."",""."",""."",""."",""."",""."",""5""]
    ... ,[""6"",""."",""."",""."",""."",""."",""."",""."",""4""]
    ... ,[""7"",""."",""."",""."",""."",""."",""."",""."",""3""]
    ... ,[""8"",""."",""."",""."",""."",""."",""."",""."",""2""]
    ... ,[""9"",""8"",""7"",""6"",""5"",""4"",""3"",""2"",""1""]
    ... ])
    False
    >>> is_valid_sudoku_board([
    ...  [""1"",""2"",""3"",""8"",""9"",""7"",""5"",""6"",""4""]
    ... ,[""4"",""5"",""6"",""2"",""3"",""1"",""8"",""9"",""7""]
    ... ,[""7"",""8"",""9"",""5"",""6"",""4"",""2"",""3"",""1""]
    ... ,[""2"",""3"",""1"",""4"",""5"",""6"",""9"",""7"",""8""]
    ... ,[""5"",""6"",""4"",""7"",""8"",""9"",""3"",""1"",""2""]
    ... ,[""8"",""9"",""7"",""1"",""2"",""3"",""6"",""4"",""5""]
    ... ,[""3"",""1"",""2"",""6"",""4"",""5"",""7"",""8"",""9""]
    ... ,[""6"",""4"",""5"",""9"",""7"",""8"",""1"",""2"",""3""]
    ... ,[""9"",""7"",""8"",""3"",""1"",""2"",""4"",""5"",""6""]
    ... ])
    True
    >>> is_valid_sudoku_board([[""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""]])
    Traceback (most recent call last):
        ...
    ValueError: Sudoku boards must be 9x9 squares.
    >>> is_valid_sudoku_board(
    ...        [[""1""], [""2""], [""3""], [""4""], [""5""], [""6""], [""7""], [""8""], [""9""]]
    ...  )
    Traceback (most recent call last):
        ...
    ValueError: Sudoku boards must be 9x9 squares.
    """"""
    if len(sudoku_board) != NUM_SQUARES or (
        any(len(row) != NUM_SQUARES for row in sudoku_board)
    ):
        error_message = f""Sudoku boards must be {NUM_SQUARES}x{NUM_SQUARES} squares.""
        raise ValueError(error_message)

    row_values: defaultdict[int, set[str]] = defaultdict(set)
    col_values: defaultdict[int, set[str]] = defaultdict(set)
    box_values: defaultdict[tuple[int, int], set[str]] = defaultdict(set)

    for row in range(NUM_SQUARES):
        for col in range(NUM_SQUARES):
            value = sudoku_board[row][col]

            if value == EMPTY_CELL:
                continue

            box = (row // 3, col // 3)

            if (
                value in row_values[row]
                or value in col_values[col]
                or value in box_values[box]
            ):
                return False

            row_values[row].add(value)
            col_values[col].add(value)
            box_values[box].add(value)

    return True",data\repos\Python\matrix\validate_sudoku_board.py,is_valid_sudoku_board,1583
1707,ford_fulkerson.py::breadth_first_search::20,"def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:
    """"""
    This function returns True if there is a node that has not iterated.

    Args:
        graph: Adjacency matrix of graph
        source: Source
        sink: Sink
        parents: Parent list

    Returns:
        True if there is a node that has not iterated.

    >>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1])
    True
    >>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1])
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    """"""
    visited = [False] * len(graph)  # Mark all nodes as not visited
    queue = []  # breadth-first search queue

    # Source node
    queue.append(source)
    visited[source] = True

    while queue:
        u = queue.pop(0)  # Pop the front node
        # Traverse all adjacent nodes of u
        for ind, node in enumerate(graph[u]):
            if visited[ind] is False and node > 0:
                queue.append(ind)
                visited[ind] = True
                parents[ind] = u
    return visited[sink]",data\repos\Python\networking_flow\ford_fulkerson.py,breadth_first_search,295
1708,ford_fulkerson.py::ford_fulkerson::58,"def ford_fulkerson(graph: list, source: int, sink: int) -> int:
    """"""
    This function returns the maximum flow from source to sink in the given graph.

    CAUTION: This function changes the given graph.

    Args:
        graph: Adjacency matrix of graph
        source: Source
        sink: Sink

    Returns:
        Maximum flow

    >>> test_graph = [
    ...     [0, 16, 13, 0, 0, 0],
    ...     [0, 0, 10, 12, 0, 0],
    ...     [0, 4, 0, 0, 14, 0],
    ...     [0, 0, 9, 0, 0, 20],
    ...     [0, 0, 0, 7, 0, 4],
    ...     [0, 0, 0, 0, 0, 0],
    ... ]
    >>> ford_fulkerson(test_graph, 0, 5)
    23
    """"""
    # This array is filled by breadth-first search and to store path
    parent = [-1] * (len(graph))
    max_flow = 0

    # While there is a path from source to sink
    while breadth_first_search(graph, source, sink, parent):
        path_flow = int(1e9)  # Infinite value
        s = sink

        while s != source:
            # Find the minimum value in the selected path
            path_flow = min(path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow += path_flow
        v = sink

        while v != source:
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]

    return max_flow",data\repos\Python\networking_flow\ford_fulkerson.py,ford_fulkerson,403
1709,minimum_cut.py::bfs::13,"def bfs(graph, s, t, parent):
    # Return True if there is node that has not iterated.
    visited = [False] * len(graph)
    queue = [s]
    visited[s] = True

    while queue:
        u = queue.pop(0)
        for ind in range(len(graph[u])):
            if visited[ind] is False and graph[u][ind] > 0:
                queue.append(ind)
                visited[ind] = True
                parent[ind] = u

    return visited[t]",data\repos\Python\networking_flow\minimum_cut.py,bfs,109
1710,minimum_cut.py::mincut::30,"def mincut(graph, source, sink):
    """"""This array is filled by BFS and to store path
    >>> mincut(test_graph, source=0, sink=5)
    [(1, 3), (4, 3), (4, 5)]
    """"""
    parent = [-1] * (len(graph))
    max_flow = 0
    res = []
    temp = [i[:] for i in graph]  # Record original cut, copy.
    while bfs(graph, source, sink, parent):
        path_flow = float(""Inf"")
        s = sink

        while s != source:
            # Find the minimum value in select path
            path_flow = min(path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow += path_flow
        v = sink

        while v != source:
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]

    for i in range(len(graph)):
        for j in range(len(graph[0])):
            if graph[i][j] == 0 and temp[i][j] > 0:
                res.append((i, j))

    return res",data\repos\Python\networking_flow\minimum_cut.py,mincut,258
1711,back_propagation_neural_network.py::example::177,"def example():
    rng = np.random.default_rng()
    x = rng.normal(size=(10, 10))
    y = np.asarray(
        [
            [0.8, 0.4],
            [0.4, 0.3],
            [0.34, 0.45],
            [0.67, 0.32],
            [0.88, 0.67],
            [0.78, 0.77],
            [0.55, 0.66],
            [0.55, 0.43],
            [0.54, 0.1],
            [0.1, 0.5],
        ]
    )
    model = BPNN()
    for i in (10, 20, 30, 2):
        model.add_layer(DenseLayer(i))
    model.build()
    model.summary()
    model.train(xdata=x, ydata=y, train_round=100, accuracy=0.01)",data\repos\Python\neural_network\back_propagation_neural_network.py,example,205
1712,back_propagation_neural_network.py::initializer::53,"    def initializer(self, back_units):
        rng = np.random.default_rng()
        self.weight = np.asmatrix(rng.normal(0, 0.5, (self.units, back_units)))
        self.bias = np.asmatrix(rng.normal(0, 0.5, self.units)).T
        if self.activation is None:
            self.activation = sigmoid",data\repos\Python\neural_network\back_propagation_neural_network.py,initializer,74
1713,back_propagation_neural_network.py::cal_gradient::60,"    def cal_gradient(self):
        # activation function may be sigmoid or linear
        if self.activation == sigmoid:
            gradient_mat = np.dot(self.output, (1 - self.output).T)
            gradient_activation = np.diag(np.diag(gradient_mat))
        else:
            gradient_activation = 1
        return gradient_activation",data\repos\Python\neural_network\back_propagation_neural_network.py,cal_gradient,66
1714,back_propagation_neural_network.py::forward_propagation::69,"    def forward_propagation(self, xdata):
        self.xdata = xdata
        if self.is_input_layer:
            # input layer
            self.wx_plus_b = xdata
            self.output = xdata
            return xdata
        else:
            self.wx_plus_b = np.dot(self.weight, self.xdata) - self.bias
            self.output = self.activation(self.wx_plus_b)
            return self.output",data\repos\Python\neural_network\back_propagation_neural_network.py,forward_propagation,88
1715,back_propagation_neural_network.py::back_propagation::81,"    def back_propagation(self, gradient):
        gradient_activation = self.cal_gradient()  # i * i 
        gradient = np.asmatrix(np.dot(gradient.T, gradient_activation))

        self._gradient_weight = np.asmatrix(self.xdata)
        self._gradient_bias = -1
        self._gradient_x = self.weight

        self.gradient_weight = np.dot(gradient.T, self._gradient_weight.T)
        self.gradient_bias = gradient * self._gradient_bias
        self.gradient = np.dot(gradient, self._gradient_x).T
        # upgrade: the Negative gradient direction
        self.weight = self.weight - self.learn_rate * self.gradient_weight
        self.bias = self.bias - self.learn_rate * self.gradient_bias.T
        # updates the weights and bias according to learning rate (0.3 if undefined)
        return self.gradient",data\repos\Python\neural_network\back_propagation_neural_network.py,back_propagation,178
1716,back_propagation_neural_network.py::build::113,"    def build(self):
        for i, layer in enumerate(self.layers[:]):
            if i < 1:
                layer.is_input_layer = True
            else:
                layer.initializer(self.layers[i - 1].units)",data\repos\Python\neural_network\back_propagation_neural_network.py,build,47
1717,back_propagation_neural_network.py::summary::120,"    def summary(self):
        for i, layer in enumerate(self.layers[:]):
            print(f""------- layer {i} -------"")
            print(""weight.shape "", np.shape(layer.weight))
            print(""bias.shape "", np.shape(layer.bias))",data\repos\Python\neural_network\back_propagation_neural_network.py,summary,49
1718,back_propagation_neural_network.py::train::126,"    def train(self, xdata, ydata, train_round, accuracy):
        self.train_round = train_round
        self.accuracy = accuracy

        self.ax_loss.hlines(self.accuracy, 0, self.train_round * 1.1)

        x_shape = np.shape(xdata)
        for _ in range(train_round):
            all_loss = 0
            for row in range(x_shape[0]):
                _xdata = np.asmatrix(xdata[row, :]).T
                _ydata = np.asmatrix(ydata[row, :]).T

                # forward propagation
                for layer in self.layers:
                    _xdata = layer.forward_propagation(_xdata)

                loss, gradient = self.cal_loss(_ydata, _xdata)
                all_loss = all_loss + loss

                # back propagation: the input_layer does not upgrade
                for layer in self.layers[:0:-1]:
                    gradient = layer.back_propagation(gradient)

            mse = all_loss / x_shape[0]
            self.train_mse.append(mse)

            self.plot_loss()

            if mse < self.accuracy:
                print(""--------"")
                return mse
        return None",data\repos\Python\neural_network\back_propagation_neural_network.py,train,250
1719,back_propagation_neural_network.py::cal_loss::160,"    def cal_loss(self, ydata, ydata_):
        self.loss = np.sum(np.power((ydata - ydata_), 2))
        self.loss_gradient = 2 * (ydata_ - ydata)
        # vector (shape is the same as _ydata.shape)
        return self.loss, self.loss_gradient",data\repos\Python\neural_network\back_propagation_neural_network.py,cal_loss,69
1720,back_propagation_neural_network.py::plot_loss::166,"    def plot_loss(self):
        if self.ax_loss.lines:
            self.ax_loss.lines.remove(self.ax_loss.lines[0])
        self.ax_loss.plot(self.train_mse, ""r-"")
        plt.ion()
        plt.xlabel(""step"")
        plt.ylabel(""loss"")
        plt.show()
        plt.pause(0.1)",data\repos\Python\neural_network\back_propagation_neural_network.py,plot_loss,69
1721,convolution_neural_network.py::save_model::55,"    def save_model(self, save_path):
        # save model dict with pickle
        model_dic = {
            ""num_bp1"": self.num_bp1,
            ""num_bp2"": self.num_bp2,
            ""num_bp3"": self.num_bp3,
            ""conv1"": self.conv1,
            ""step_conv1"": self.step_conv1,
            ""size_pooling1"": self.size_pooling1,
            ""rate_weight"": self.rate_weight,
            ""rate_thre"": self.rate_thre,
            ""w_conv1"": self.w_conv1,
            ""wkj"": self.wkj,
            ""vji"": self.vji,
            ""thre_conv1"": self.thre_conv1,
            ""thre_bp2"": self.thre_bp2,
            ""thre_bp3"": self.thre_bp3,
        }
        with open(save_path, ""wb"") as f:
            pickle.dump(model_dic, f)

        print(f""Model saved: {save_path}"")",data\repos\Python\neural_network\convolution_neural_network.py,save_model,209
1722,convolution_neural_network.py::read_model::79,"    def read_model(cls, model_path):
        # read saved model
        with open(model_path, ""rb"") as f:
            model_dic = pickle.load(f)  # noqa: S301

        conv_get = model_dic.get(""conv1"")
        conv_get.append(model_dic.get(""step_conv1""))
        size_p1 = model_dic.get(""size_pooling1"")
        bp1 = model_dic.get(""num_bp1"")
        bp2 = model_dic.get(""num_bp2"")
        bp3 = model_dic.get(""num_bp3"")
        r_w = model_dic.get(""rate_weight"")
        r_t = model_dic.get(""rate_thre"")
        # create model instance
        conv_ins = CNN(conv_get, size_p1, bp1, bp2, bp3, r_w, r_t)
        # modify model parameter
        conv_ins.w_conv1 = model_dic.get(""w_conv1"")
        conv_ins.wkj = model_dic.get(""wkj"")
        conv_ins.vji = model_dic.get(""vji"")
        conv_ins.thre_conv1 = model_dic.get(""thre_conv1"")
        conv_ins.thre_bp2 = model_dic.get(""thre_bp2"")
        conv_ins.thre_bp3 = model_dic.get(""thre_bp3"")
        return conv_ins",data\repos\Python\neural_network\convolution_neural_network.py,read_model,273
1723,convolution_neural_network.py::convolute::109,"    def convolute(self, data, convs, w_convs, thre_convs, conv_step):
        # convolution process
        size_conv = convs[0]
        num_conv = convs[1]
        size_data = np.shape(data)[0]
        # get the data slice of original image data, data_focus
        data_focus = []
        for i_focus in range(0, size_data - size_conv + 1, conv_step):
            for j_focus in range(0, size_data - size_conv + 1, conv_step):
                focus = data[
                    i_focus : i_focus + size_conv, j_focus : j_focus + size_conv
                ]
                data_focus.append(focus)
        # calculate the feature map of every single kernel, and saved as list of matrix
        data_featuremap = []
        size_feature_map = int((size_data - size_conv) / conv_step + 1)
        for i_map in range(num_conv):
            featuremap = []
            for i_focus in range(len(data_focus)):
                net_focus = (
                    np.sum(np.multiply(data_focus[i_focus], w_convs[i_map]))
                    - thre_convs[i_map]
                )
                featuremap.append(self.sig(net_focus))
            featuremap = np.asmatrix(featuremap).reshape(
                size_feature_map, size_feature_map
            )
            data_featuremap.append(featuremap)

        # expanding the data slice to one dimension
        focus1_list = []
        for each_focus in data_focus:
            focus1_list.extend(self.Expand_Mat(each_focus))
        focus_list = np.asarray(focus1_list)
        return focus_list, data_featuremap",data\repos\Python\neural_network\convolution_neural_network.py,convolute,346
1724,convolution_neural_network.py::pooling::145,"    def pooling(self, featuremaps, size_pooling, pooling_type=""average_pool""):
        # pooling process
        size_map = len(featuremaps[0])
        size_pooled = int(size_map / size_pooling)
        featuremap_pooled = []
        for i_map in range(len(featuremaps)):
            feature_map = featuremaps[i_map]
            map_pooled = []
            for i_focus in range(0, size_map, size_pooling):
                for j_focus in range(0, size_map, size_pooling):
                    focus = feature_map[
                        i_focus : i_focus + size_pooling,
                        j_focus : j_focus + size_pooling,
                    ]
                    if pooling_type == ""average_pool"":
                        # average pooling
                        map_pooled.append(np.average(focus))
                    elif pooling_type == ""max_pooling"":
                        # max pooling
                        map_pooled.append(np.max(focus))
            map_pooled = np.asmatrix(map_pooled).reshape(size_pooled, size_pooled)
            featuremap_pooled.append(map_pooled)
        return featuremap_pooled",data\repos\Python\neural_network\convolution_neural_network.py,pooling,226
1725,convolution_neural_network.py::train::212,"    def train(
        self, patterns, datas_train, datas_teach, n_repeat, error_accuracy, draw_e=bool
    ):
        # model training
        print(""----------------------Start Training-------------------------"")
        print(("" - - Shape: Train_Data  "", np.shape(datas_train)))
        print(("" - - Shape: Teach_Data  "", np.shape(datas_teach)))
        rp = 0
        all_mse = []
        mse = 10000
        while rp < n_repeat and mse >= error_accuracy:
            error_count = 0
            print(f""-------------Learning Time {rp}--------------"")
            for p in range(len(datas_train)):
                # print('------------Learning Image: %d--------------'%p)
                data_train = np.asmatrix(datas_train[p])
                data_teach = np.asarray(datas_teach[p])
                data_focus1, data_conved1 = self.convolute(
                    data_train,
                    self.conv1,
                    self.w_conv1,
                    self.thre_conv1,
                    conv_step=self.step_conv1,
                )
                data_pooled1 = self.pooling(data_conved1, self.size_pooling1)
                shape_featuremap1 = np.shape(data_conved1)
                """"""
                print('  -----original shape   ', np.shape(data_train))
                print('  ---- after convolution  ',np.shape(data_conv1))
                print('  -----after pooling  ',np.shape(data_pooled1))
               """"""
                data_bp_input = self._expand(data_pooled1)
                bp_out1 = data_bp_input

                bp_net_j = np.dot(bp_out1, self.vji.T) - self.thre_bp2
                bp_out2 = self.sig(bp_net_j)
                bp_net_k = np.dot(bp_out2, self.wkj.T) - self.thre_bp3
                bp_out3 = self.sig(bp_net_k)

                # --------------Model Leaning ------------------------
                # calculate error and gradient---------------
                pd_k_all = np.multiply(
                    (data_teach - bp_out3), np.multiply(bp_out3, (1 - bp_out3))
                )
                pd_j_all = np.multiply(
                    np.dot(pd_k_all, self.wkj), np.multiply(bp_out2, (1 - bp_out2))
                )
                pd_i_all = np.dot(pd_j_all, self.vji)

                pd_conv1_pooled = pd_i_all / (self.size_pooling1 * self.size_pooling1)
                pd_conv1_pooled = pd_conv1_pooled.T.getA().tolist()
                pd_conv1_all = self._calculate_gradient_from_pool(
                    data_conved1,
                    pd_conv1_pooled,
                    shape_featuremap1[0],
                    shape_featuremap1[1],
                    self.size_pooling1,
                )
                # weight and threshold learning process---------
                # convolution layer
                for k_conv in range(self.conv1[1]):
                    pd_conv_list = self._expand_mat(pd_conv1_all[k_conv])
                    delta_w = self.rate_weight * np.dot(pd_conv_list, data_focus1)

                    self.w_conv1[k_conv] = self.w_conv1[k_conv] + delta_w.reshape(
                        (self.conv1[0], self.conv1[0])
                    )

                    self.thre_conv1[k_conv] = (
                        self.thre_conv1[k_conv]
                        - np.sum(pd_conv1_all[k_conv]) * self.rate_thre
                    )
                # all connected layer
                self.wkj = self.wkj + pd_k_all.T * bp_out2 * self.rate_weight
                self.vji = self.vji + pd_j_all.T * bp_out1 * self.rate_weight
                self.thre_bp3 = self.thre_bp3 - pd_k_all * self.rate_thre
                self.thre_bp2 = self.thre_bp2 - pd_j_all * self.rate_thre
                # calculate the sum error of all single image
                errors = np.sum(abs(data_teach - bp_out3))
                error_count += errors
                # print('   ----Teach      ',data_teach)
                # print('   ----BP_output  ',bp_out3)
            rp = rp + 1
            mse = error_count / patterns
            all_mse.append(mse)

        def draw_error():
            yplot = [error_accuracy for i in range(int(n_repeat * 1.2))]
            plt.plot(all_mse, ""+-"")
            plt.plot(yplot, ""r--"")
            plt.xlabel(""Learning Times"")
            plt.ylabel(""All_mse"")
            plt.grid(True, alpha=0.5)
            plt.show()

        print(""------------------Training Complete---------------------"")
        print(("" - - Training epoch: "", rp, f""     - - Mse: {mse:.6f}""))
        if draw_e:
            draw_error()
        return mse",data\repos\Python\neural_network\convolution_neural_network.py,train,1014
1726,convolution_neural_network.py::predict::313,"    def predict(self, datas_test):
        # model predict
        produce_out = []
        print(""-------------------Start Testing-------------------------"")
        print(("" - - Shape: Test_Data  "", np.shape(datas_test)))
        for p in range(len(datas_test)):
            data_test = np.asmatrix(datas_test[p])
            _data_focus1, data_conved1 = self.convolute(
                data_test,
                self.conv1,
                self.w_conv1,
                self.thre_conv1,
                conv_step=self.step_conv1,
            )
            data_pooled1 = self.pooling(data_conved1, self.size_pooling1)
            data_bp_input = self._expand(data_pooled1)

            bp_out1 = data_bp_input
            bp_net_j = bp_out1 * self.vji.T - self.thre_bp2
            bp_out2 = self.sig(bp_net_j)
            bp_net_k = bp_out2 * self.wkj.T - self.thre_bp3
            bp_out3 = self.sig(bp_net_k)
            produce_out.extend(bp_out3.getA().tolist())
        res = [list(map(self.do_round, each)) for each in produce_out]
        return np.asarray(res)",data\repos\Python\neural_network\convolution_neural_network.py,predict,250
1727,convolution_neural_network.py::convolution::339,"    def convolution(self, data):
        # return the data of image after convoluting process so we can check it out
        data_test = np.asmatrix(data)
        _data_focus1, data_conved1 = self.convolute(
            data_test,
            self.conv1,
            self.w_conv1,
            self.thre_conv1,
            conv_step=self.step_conv1,
        )
        data_pooled1 = self.pooling(data_conved1, self.size_pooling1)

        return data_conved1, data_pooled1",data\repos\Python\neural_network\convolution_neural_network.py,convolution,113
1728,convolution_neural_network.py::draw_error::298,"        def draw_error():
            yplot = [error_accuracy for i in range(int(n_repeat * 1.2))]
            plt.plot(all_mse, ""+-"")
            plt.plot(yplot, ""r--"")
            plt.xlabel(""Learning Times"")
            plt.ylabel(""All_mse"")
            plt.grid(True, alpha=0.5)
            plt.show()",data\repos\Python\neural_network\convolution_neural_network.py,draw_error,75
1729,input_data.py::read_data_sets::270,"def read_data_sets(
    train_dir,
    fake_data=False,
    one_hot=False,
    dtype=dtypes.float32,
    reshape=True,
    validation_size=5000,
    seed=None,
    source_url=DEFAULT_SOURCE_URL,
):
    if fake_data:

        def fake():
            return _DataSet(
                [], [], fake_data=True, one_hot=one_hot, dtype=dtype, seed=seed
            )

        train = fake()
        validation = fake()
        test = fake()
        return _Datasets(train=train, validation=validation, test=test)

    if not source_url:  # empty string check
        source_url = DEFAULT_SOURCE_URL

    train_images_file = ""train-images-idx3-ubyte.gz""
    train_labels_file = ""train-labels-idx1-ubyte.gz""
    test_images_file = ""t10k-images-idx3-ubyte.gz""
    test_labels_file = ""t10k-labels-idx1-ubyte.gz""

    local_file = _maybe_download(
        train_images_file, train_dir, source_url + train_images_file
    )
    with gfile.Open(local_file, ""rb"") as f:
        train_images = _extract_images(f)

    local_file = _maybe_download(
        train_labels_file, train_dir, source_url + train_labels_file
    )
    with gfile.Open(local_file, ""rb"") as f:
        train_labels = _extract_labels(f, one_hot=one_hot)

    local_file = _maybe_download(
        test_images_file, train_dir, source_url + test_images_file
    )
    with gfile.Open(local_file, ""rb"") as f:
        test_images = _extract_images(f)

    local_file = _maybe_download(
        test_labels_file, train_dir, source_url + test_labels_file
    )
    with gfile.Open(local_file, ""rb"") as f:
        test_labels = _extract_labels(f, one_hot=one_hot)

    if not 0 <= validation_size <= len(train_images):
        msg = (
            ""Validation size should be between 0 and ""
            f""{len(train_images)}. Received: {validation_size}.""
        )
        raise ValueError(msg)

    validation_images = train_images[:validation_size]
    validation_labels = train_labels[:validation_size]
    train_images = train_images[validation_size:]
    train_labels = train_labels[validation_size:]

    options = {""dtype"": dtype, ""reshape"": reshape, ""seed"": seed}

    train = _DataSet(train_images, train_labels, **options)
    validation = _DataSet(validation_images, validation_labels, **options)
    test = _DataSet(test_images, test_labels, **options)

    return _Datasets(train=train, validation=validation, test=test)",data\repos\Python\neural_network\input_data.py,read_data_sets,572
1730,input_data.py::next_batch::200,"    def next_batch(self, batch_size, fake_data=False, shuffle=True):
        """"""Return the next `batch_size` examples from this data set.""""""
        if fake_data:
            fake_image = [1] * 784
            fake_label = [1] + [0] * 9 if self.one_hot else 0
            return (
                [fake_image for _ in range(batch_size)],
                [fake_label for _ in range(batch_size)],
            )
        start = self._index_in_epoch
        # Shuffle for the first epoch
        if self._epochs_completed == 0 and start == 0 and shuffle:
            perm0 = np.arange(self._num_examples)
            self._rng.shuffle(perm0)
            self._images = self.images[perm0]
            self._labels = self.labels[perm0]
        # Go to the next epoch
        if start + batch_size > self._num_examples:
            # Finished epoch
            self._epochs_completed += 1
            # Get the rest examples in this epoch
            rest_num_examples = self._num_examples - start
            images_rest_part = self._images[start : self._num_examples]
            labels_rest_part = self._labels[start : self._num_examples]
            # Shuffle the data
            if shuffle:
                perm = np.arange(self._num_examples)
                self._rng.shuffle(perm)
                self._images = self.images[perm]
                self._labels = self.labels[perm]
            # Start next epoch
            start = 0
            self._index_in_epoch = batch_size - rest_num_examples
            end = self._index_in_epoch
            images_new_part = self._images[start:end]
            labels_new_part = self._labels[start:end]
            return (
                np.concatenate((images_rest_part, images_new_part), axis=0),
                np.concatenate((labels_rest_part, labels_new_part), axis=0),
            )
        else:
            self._index_in_epoch += batch_size
            end = self._index_in_epoch
            return self._images[start:end], self._labels[start:end]",data\repos\Python\neural_network\input_data.py,next_batch,436
1731,input_data.py::fake::282,"        def fake():
            return _DataSet(
                [], [], fake_data=True, one_hot=one_hot, dtype=dtype, seed=seed
            )",data\repos\Python\neural_network\input_data.py,fake,32
1732,simple_neural_network.py::sigmoid_function::11,"def sigmoid_function(value: float, deriv: bool = False) -> float:
    """"""Return the sigmoid function of a float.

    >>> sigmoid_function(3.5)
    0.9706877692486436
    >>> sigmoid_function(3.5, True)
    -8.75
    """"""
    if deriv:
        return value * (1 - value)
    return 1 / (1 + math.exp(-value))",data\repos\Python\neural_network\simple_neural_network.py,sigmoid_function,91
1733,simple_neural_network.py::forward_propagation::28,"def forward_propagation(expected: int, number_propagations: int) -> float:
    """"""Return the value found after the forward propagation training.

    >>> res = forward_propagation(32, 450_000)  # Was 10_000_000
    >>> res > 31 and res < 33
    True

    >>> res = forward_propagation(32, 1000)
    >>> res > 31 and res < 33
    False
    """"""

    # Random weight
    weight = float(2 * (random.randint(1, 100)) - 1)

    for _ in range(number_propagations):
        # Forward propagation
        layer_1 = sigmoid_function(INITIAL_VALUE * weight)
        # How much did we miss?
        layer_1_error = (expected / 100) - layer_1
        # Error delta
        layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)
        # Update weight
        weight += INITIAL_VALUE * layer_1_delta

    return layer_1 * 100",data\repos\Python\neural_network\simple_neural_network.py,forward_propagation,228
1734,two_hidden_layers_neural_network.py::sigmoid::226,"def sigmoid(value: np.ndarray) -> np.ndarray:
    """"""
    Applies sigmoid activation function.

    return normalized values

    >>> sigmoid(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))
    array([[0.73105858, 0.5       , 0.88079708],
           [0.73105858, 0.5       , 0.5       ]])
    """"""
    return 1 / (1 + np.exp(-value))",data\repos\Python\neural_network\two_hidden_layers_neural_network.py,sigmoid,110
1735,two_hidden_layers_neural_network.py::sigmoid_derivative::239,"def sigmoid_derivative(value: np.ndarray) -> np.ndarray:
    """"""
    Provides the derivative value of the sigmoid function.

    returns derivative of the sigmoid value

    >>> sigmoid_derivative(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))
    array([[ 0.,  0., -2.],
           [ 0.,  0.,  0.]])
    """"""
    return (value) * (1 - (value))",data\repos\Python\neural_network\two_hidden_layers_neural_network.py,sigmoid_derivative,103
1736,two_hidden_layers_neural_network.py::example::252,"def example() -> int:
    """"""
    Example for ""how to use the neural network class and use the
    respected methods for the desired output"".
    Calls the TwoHiddenLayerNeuralNetwork class and
    provides the fixed input output values to the model.
    Model is trained for a fixed amount of iterations then the predict method is called.
    In this example the output is divided into 2 classes i.e. binary classification,
    the two classes are represented by '0' and '1'.

    >>> example() in (0, 1)
    True
    """"""
    # Input values.
    test_input = np.array(
        (
            [0, 0, 0],
            [0, 0, 1],
            [0, 1, 0],
            [0, 1, 1],
            [1, 0, 0],
            [1, 0, 1],
            [1, 1, 0],
            [1, 1, 1],
        ),
        dtype=np.float64,
    )

    # True output values for the given input values.
    output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)

    # Calling neural network class.
    neural_network = TwoHiddenLayerNeuralNetwork(
        input_array=test_input, output_array=output
    )

    # Calling training function.
    # Set give_loss to True if you want to see loss in every iteration.
    neural_network.train(output=output, iterations=10, give_loss=False)

    return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))",data\repos\Python\neural_network\two_hidden_layers_neural_network.py,example,357
1737,two_hidden_layers_neural_network.py::feedforward::53,"    def feedforward(self) -> np.ndarray:
        """"""
        The information moves in only one direction i.e. forward from the input nodes,
        through the two hidden nodes and to the output nodes.
        There are no cycles or loops in the network.

        Return layer_between_second_hidden_layer_and_output
            (i.e the last layer of the neural network).

        >>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)
        >>> output_val = np.array(([0], [0], [0]), dtype=float)
        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
        >>> res = nn.feedforward()
        >>> array_sum = np.sum(res)
        >>> bool(np.isnan(array_sum))
        False
        """"""
        # Layer_between_input_and_first_hidden_layer is the layer connecting the
        # input nodes with the first hidden layer nodes.
        self.layer_between_input_and_first_hidden_layer = sigmoid(
            np.dot(self.input_array, self.input_layer_and_first_hidden_layer_weights)
        )

        # layer_between_first_hidden_layer_and_second_hidden_layer is the layer
        # connecting the first hidden set of nodes with the second hidden set of nodes.
        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(
            np.dot(
                self.layer_between_input_and_first_hidden_layer,
                self.first_hidden_layer_and_second_hidden_layer_weights,
            )
        )

        # layer_between_second_hidden_layer_and_output is the layer connecting
        # second hidden layer with the output node.
        self.layer_between_second_hidden_layer_and_output = sigmoid(
            np.dot(
                self.layer_between_first_hidden_layer_and_second_hidden_layer,
                self.second_hidden_layer_and_output_layer_weights,
            )
        )

        return self.layer_between_second_hidden_layer_and_output",data\repos\Python\neural_network\two_hidden_layers_neural_network.py,feedforward,383
1738,two_hidden_layers_neural_network.py::back_propagation::96,"    def back_propagation(self) -> None:
        """"""
        Function for fine-tuning the weights of the neural net based on the
        error rate obtained in the previous epoch (i.e., iteration).
        Updation is done using derivative of sogmoid activation function.

        >>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)
        >>> output_val = np.array(([0], [0], [0]), dtype=float)
        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
        >>> res = nn.feedforward()
        >>> nn.back_propagation()
        >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights
        >>> bool((res == updated_weights).all())
        False
        """"""

        updated_second_hidden_layer_and_output_layer_weights = np.dot(
            self.layer_between_first_hidden_layer_and_second_hidden_layer.T,
            2
            * (self.output_array - self.predicted_output)
            * sigmoid_derivative(self.predicted_output),
        )
        updated_first_hidden_layer_and_second_hidden_layer_weights = np.dot(
            self.layer_between_input_and_first_hidden_layer.T,
            np.dot(
                2
                * (self.output_array - self.predicted_output)
                * sigmoid_derivative(self.predicted_output),
                self.second_hidden_layer_and_output_layer_weights.T,
            )
            * sigmoid_derivative(
                self.layer_between_first_hidden_layer_and_second_hidden_layer
            ),
        )
        updated_input_layer_and_first_hidden_layer_weights = np.dot(
            self.input_array.T,
            np.dot(
                np.dot(
                    2
                    * (self.output_array - self.predicted_output)
                    * sigmoid_derivative(self.predicted_output),
                    self.second_hidden_layer_and_output_layer_weights.T,
                )
                * sigmoid_derivative(
                    self.layer_between_first_hidden_layer_and_second_hidden_layer
                ),
                self.first_hidden_layer_and_second_hidden_layer_weights.T,
            )
            * sigmoid_derivative(self.layer_between_input_and_first_hidden_layer),
        )

        self.input_layer_and_first_hidden_layer_weights += (
            updated_input_layer_and_first_hidden_layer_weights
        )
        self.first_hidden_layer_and_second_hidden_layer_weights += (
            updated_first_hidden_layer_and_second_hidden_layer_weights
        )
        self.second_hidden_layer_and_output_layer_weights += (
            updated_second_hidden_layer_and_output_layer_weights
        )",data\repos\Python\neural_network\two_hidden_layers_neural_network.py,back_propagation,498
1739,two_hidden_layers_neural_network.py::train::157,"    def train(self, output: np.ndarray, iterations: int, give_loss: bool) -> None:
        """"""
        Performs the feedforwarding and back propagation process for the
        given number of iterations.
        Every iteration will update the weights of neural network.

        output : real output values,required for calculating loss.
        iterations : number of times the weights are to be updated.
        give_loss : boolean value, If True then prints loss for each iteration,
                    If False then nothing is printed

        >>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)
        >>> output_val = np.array(([0], [1], [1]), dtype=float)
        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
        >>> first_iteration_weights = nn.feedforward()
        >>> nn.back_propagation()
        >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights
        >>> bool((first_iteration_weights == updated_weights).all())
        False
        """"""
        for iteration in range(1, iterations + 1):
            self.output = self.feedforward()
            self.back_propagation()
            if give_loss:
                loss = np.mean(np.square(output - self.feedforward()))
                print(f""Iteration {iteration} Loss: {loss}"")",data\repos\Python\neural_network\two_hidden_layers_neural_network.py,train,283
1740,two_hidden_layers_neural_network.py::predict::184,"    def predict(self, input_arr: np.ndarray) -> int:
        """"""
        Predict's the output for the given input values using
        the trained neural network.

        The output value given by the model ranges in-between 0 and 1.
        The predict function returns 1 if the model value is greater
        than the threshold value else returns 0,
        as the real output values are in binary.

        >>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)
        >>> output_val = np.array(([0], [1], [1]), dtype=float)
        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
        >>> nn.train(output_val, 1000, False)
        >>> nn.predict([0, 1, 0]) in (0, 1)
        True
        """"""

        # Input values for which the predictions are to be made.
        self.array = input_arr

        self.layer_between_input_and_first_hidden_layer = sigmoid(
            np.dot(self.array, self.input_layer_and_first_hidden_layer_weights)
        )

        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(
            np.dot(
                self.layer_between_input_and_first_hidden_layer,
                self.first_hidden_layer_and_second_hidden_layer_weights,
            )
        )

        self.layer_between_second_hidden_layer_and_output = sigmoid(
            np.dot(
                self.layer_between_first_hidden_layer_and_second_hidden_layer,
                self.second_hidden_layer_and_output_layer_weights,
            )
        )

        return int((self.layer_between_second_hidden_layer_and_output > 0.6)[0])",data\repos\Python\neural_network\two_hidden_layers_neural_network.py,predict,349
1741,activity_selection.py::print_max_activities::11,"def print_max_activities(start: list[int], finish: list[int]) -> None:
    """"""
    >>> start = [1, 3, 0, 5, 8, 5]
    >>> finish = [2, 4, 6, 7, 9, 9]
    >>> print_max_activities(start, finish)
    The following activities are selected:
    0,1,3,4,
    """"""
    n = len(finish)
    print(""The following activities are selected:"")

    # The first activity is always selected
    i = 0
    print(i, end="","")

    # Consider rest of the activities
    for j in range(n):
        # If this activity has start time greater than
        # or equal to the finish time of previously
        # selected activity, then select it
        if start[j] >= finish[i]:
            print(j, end="","")
            i = j",data\repos\Python\other\activity_selection.py,print_max_activities,197
1742,alternative_list_arrange.py::alternative_list_arrange::1,"def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:
    """"""
    The method arranges two lists as one list in alternative forms of the list elements.
    :param first_input_list:
    :param second_input_list:
    :return: List
    >>> alternative_list_arrange([1, 2, 3, 4, 5], [""A"", ""B"", ""C""])
    [1, 'A', 2, 'B', 3, 'C', 4, 5]
    >>> alternative_list_arrange([""A"", ""B"", ""C""], [1, 2, 3, 4, 5])
    ['A', 1, 'B', 2, 'C', 3, 4, 5]
    >>> alternative_list_arrange([""X"", ""Y"", ""Z""], [9, 8, 7, 6])
    ['X', 9, 'Y', 8, 'Z', 7, 6]
    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])
    [1, 2, 3, 4, 5]
    """"""
    first_input_list_length: int = len(first_input_list)
    second_input_list_length: int = len(second_input_list)
    abs_length: int = (
        first_input_list_length
        if first_input_list_length > second_input_list_length
        else second_input_list_length
    )
    output_result_list: list = []
    for char_count in range(abs_length):
        if char_count < first_input_list_length:
            output_result_list.append(first_input_list[char_count])
        if char_count < second_input_list_length:
            output_result_list.append(second_input_list[char_count])

    return output_result_list",data\repos\Python\other\alternative_list_arrange.py,alternative_list_arrange,383
1743,bankers_algorithm.py::main::103,"    def main(self, **kwargs) -> None:
        """"""
        Utilize various methods in this class to simulate the Banker's algorithm
            :Return: None

        >>> BankersAlgorithm(test_claim_vector, test_allocated_res_table,
        ...    test_maximum_claim_table).main(describe=True)
                 Allocated Resource Table
        P1       2        0        1        1
        <BLANKLINE>
        P2       0        1        2        1
        <BLANKLINE>
        P3       4        0        0        3
        <BLANKLINE>
        P4       0        2        1        0
        <BLANKLINE>
        P5       1        0        3        0
        <BLANKLINE>
                 System Resource Table
        P1       3        2        1        4
        <BLANKLINE>
        P2       0        2        5        2
        <BLANKLINE>
        P3       5        1        0        5
        <BLANKLINE>
        P4       1        5        3        0
        <BLANKLINE>
        P5       3        0        3        3
        <BLANKLINE>
        Current Usage by Active Processes: 8 5 9 7
        Initial Available Resources:       1 2 2 2
        __________________________________________________
        <BLANKLINE>
        Process 3 is executing.
        Updated available resource stack for processes: 5 2 2 5
        The process is in a safe state.
        <BLANKLINE>
        Process 1 is executing.
        Updated available resource stack for processes: 7 2 3 6
        The process is in a safe state.
        <BLANKLINE>
        Process 2 is executing.
        Updated available resource stack for processes: 7 3 5 7
        The process is in a safe state.
        <BLANKLINE>
        Process 4 is executing.
        Updated available resource stack for processes: 7 5 6 7
        The process is in a safe state.
        <BLANKLINE>
        Process 5 is executing.
        Updated available resource stack for processes: 8 5 9 7
        The process is in a safe state.
        <BLANKLINE>
        """"""
        need_list = self.__need()
        alloc_resources_table = self.__allocated_resources_table
        available_resources = self.__available_resources()
        need_index_manager = self.__need_index_manager()
        for kw, val in kwargs.items():
            if kw and val is True:
                self.__pretty_data()
        print(""_"" * 50 + ""\n"")
        while need_list:
            safe = False
            for each_need in need_list:
                execution = True
                for index, need in enumerate(each_need):
                    if need > available_resources[index]:
                        execution = False
                        break
                if execution:
                    safe = True
                    # get the original index of the process from ind_ctrl db
                    for original_need_index, need_clone in need_index_manager.items():
                        if each_need == need_clone:
                            process_number = original_need_index
                    print(f""Process {process_number + 1} is executing."")
                    # remove the process run from stack
                    need_list.remove(each_need)
                    # update available/freed resources stack
                    available_resources = np.array(available_resources) + np.array(
                        alloc_resources_table[process_number]
                    )
                    print(
                        ""Updated available resource stack for processes: ""
                        + "" "".join([str(x) for x in available_resources])
                    )
                    break
            if safe:
                print(""The process is in a safe state.\n"")
            else:
                print(""System in unsafe state. Aborting...\n"")
                break",data\repos\Python\other\bankers_algorithm.py,main,838
1744,davis_putnam_logemann_loveland.py::generate_clause::123,"def generate_clause() -> Clause:
    """"""
    | Randomly generate a clause.
    | All literals have the name Ax, where x is an integer from ``1`` to ``5``.
    """"""
    literals = []
    no_of_literals = random.randint(1, 5)
    base_var = ""A""
    i = 0
    while i < no_of_literals:
        var_no = random.randint(1, 5)
        var_name = base_var + str(var_no)
        var_complement = random.randint(0, 1)
        if var_complement == 1:
            var_name += ""'""
        if var_name in literals:
            i -= 1
        else:
            literals.append(var_name)
        i += 1
    return Clause(literals)",data\repos\Python\other\davis_putnam_logemann_loveland.py,generate_clause,165
1745,davis_putnam_logemann_loveland.py::generate_formula::146,"def generate_formula() -> Formula:
    """"""
    Randomly generate a formula.
    """"""
    clauses: set[Clause] = set()
    no_of_clauses = random.randint(1, 10)
    while len(clauses) < no_of_clauses:
        clauses.add(generate_clause())
    return Formula(clauses)",data\repos\Python\other\davis_putnam_logemann_loveland.py,generate_formula,67
1746,davis_putnam_logemann_loveland.py::generate_parameters::157,"def generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:
    """"""
    | Return the clauses and symbols from a formula.
    | A symbol is the uncomplemented form of a literal.

    For example,
      * Symbol of A3 is A3.
      * Symbol of A5' is A5.

    >>> formula = Formula([Clause([""A1"", ""A2'"", ""A3""]), Clause([""A5'"", ""A2'"", ""A1""])])
    >>> clauses, symbols = generate_parameters(formula)
    >>> clauses_list = [str(i) for i in clauses]
    >>> clauses_list
    [""{A1 , A2' , A3}"", ""{A5' , A2' , A1}""]
    >>> symbols
    ['A1', 'A2', 'A3', 'A5']
    """"""
    clauses = formula.clauses
    symbols_set = []
    for clause in formula.clauses:
        for literal in clause.literals:
            symbol = literal[:2]
            if symbol not in symbols_set:
                symbols_set.append(symbol)
    return clauses, symbols_set",data\repos\Python\other\davis_putnam_logemann_loveland.py,generate_parameters,238
1747,davis_putnam_logemann_loveland.py::find_pure_symbols::184,"def find_pure_symbols(
    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]
) -> tuple[list[str], dict[str, bool | None]]:
    """"""
    | Return pure symbols and their values to satisfy clause.
    | Pure symbols are symbols in a formula that exist only in one form,
    | either complemented or otherwise.
    | For example,
    |   {{A4 , A3 , A5' , A1 , A3'} , {A4} , {A3}} has pure symbols A4, A5' and A1.

    This has the following steps:
      1. Ignore clauses that have already evaluated to be ``True``.
      2. Find symbols that occur only in one form in the rest of the clauses.
      3. Assign value ``True`` or ``False`` depending on whether the symbols occurs
         in normal or complemented form respectively.

    >>> formula = Formula([Clause([""A1"", ""A2'"", ""A3""]), Clause([""A5'"", ""A2'"", ""A1""])])
    >>> clauses, symbols = generate_parameters(formula)
    >>> pure_symbols, values = find_pure_symbols(clauses, symbols, {})
    >>> pure_symbols
    ['A1', 'A2', 'A3', 'A5']
    >>> values
    {'A1': True, 'A2': False, 'A3': True, 'A5': False}
    """"""
    pure_symbols = []
    assignment: dict[str, bool | None] = {}
    literals = []

    for clause in clauses:
        if clause.evaluate(model):
            continue
        for literal in clause.literals:
            literals.append(literal)

    for s in symbols:
        sym = s + ""'""
        if (s in literals and sym not in literals) or (
            s not in literals and sym in literals
        ):
            pure_symbols.append(s)
    for p in pure_symbols:
        assignment[p] = None
    for s in pure_symbols:
        sym = s + ""'""
        if s in literals:
            assignment[s] = True
        elif sym in literals:
            assignment[s] = False
    return pure_symbols, assignment",data\repos\Python\other\davis_putnam_logemann_loveland.py,find_pure_symbols,466
1748,davis_putnam_logemann_loveland.py::find_unit_clauses::235,"def find_unit_clauses(
    clauses: list[Clause],
    model: dict[str, bool | None],  # noqa: ARG001
) -> tuple[list[str], dict[str, bool | None]]:
    """"""
    Returns the unit symbols and their values to satisfy clause.

    Unit symbols are symbols in a formula that are:
      - Either the only symbol in a clause
      - Or all other literals in that clause have been assigned ``False``

    This has the following steps:
      1. Find symbols that are the only occurrences in a clause.
      2. Find symbols in a clause where all other literals are assigned ``False``.
      3. Assign ``True`` or ``False`` depending on whether the symbols occurs in
         normal or complemented form respectively.

    >>> clause1 = Clause([""A4"", ""A3"", ""A5'"", ""A1"", ""A3'""])
    >>> clause2 = Clause([""A4""])
    >>> clause3 = Clause([""A3""])
    >>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))
    >>> unit_clauses, values = find_unit_clauses(clauses, {})
    >>> unit_clauses
    ['A4', 'A3']
    >>> values
    {'A4': True, 'A3': True}
    """"""
    unit_symbols = []
    for clause in clauses:
        if len(clause) == 1:
            unit_symbols.append(next(iter(clause.literals.keys())))
        else:
            f_count, n_count = 0, 0
            for literal, value in clause.literals.items():
                if value is False:
                    f_count += 1
                elif value is None:
                    sym = literal
                    n_count += 1
            if f_count == len(clause) - 1 and n_count == 1:
                unit_symbols.append(sym)
    assignment: dict[str, bool | None] = {}
    for i in unit_symbols:
        symbol = i[:2]
        assignment[symbol] = len(i) == 2
    unit_symbols = [i[:2] for i in unit_symbols]

    return unit_symbols, assignment",data\repos\Python\other\davis_putnam_logemann_loveland.py,find_unit_clauses,456
1749,davis_putnam_logemann_loveland.py::dpll_algorithm::285,"def dpll_algorithm(
    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]
) -> tuple[bool | None, dict[str, bool | None] | None]:
    """"""
    Returns the model if the formula is satisfiable, else ``None``

    This has the following steps:
      1. If every clause in clauses is ``True``, return ``True``.
      2. If some clause in clauses is ``False``, return ``False``.
      3. Find pure symbols.
      4. Find unit symbols.

    >>> formula = Formula([Clause([""A4"", ""A3"", ""A5'"", ""A1"", ""A3'""]), Clause([""A4""])])
    >>> clauses, symbols = generate_parameters(formula)
    >>> soln, model = dpll_algorithm(clauses, symbols, {})
    >>> soln
    True
    >>> model
    {'A4': True}
    """"""
    check_clause_all_true = True
    for clause in clauses:
        clause_check = clause.evaluate(model)
        if clause_check is False:
            return False, None
        elif clause_check is None:
            check_clause_all_true = False
            continue

    if check_clause_all_true:
        return True, model

    try:
        pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)
    except RecursionError:
        print(""raises a RecursionError and is"")
        return None, {}
    p = None
    if len(pure_symbols) > 0:
        p, value = pure_symbols[0], assignment[pure_symbols[0]]

    if p:
        tmp_model = model
        tmp_model[p] = value
        tmp_symbols = list(symbols)
        if p in tmp_symbols:
            tmp_symbols.remove(p)
        return dpll_algorithm(clauses, tmp_symbols, tmp_model)

    unit_symbols, assignment = find_unit_clauses(clauses, model)
    p = None
    if len(unit_symbols) > 0:
        p, value = unit_symbols[0], assignment[unit_symbols[0]]
    if p:
        tmp_model = model
        tmp_model[p] = value
        tmp_symbols = list(symbols)
        if p in tmp_symbols:
            tmp_symbols.remove(p)
        return dpll_algorithm(clauses, tmp_symbols, tmp_model)
    p = symbols[0]
    rest = symbols[1:]
    tmp1, tmp2 = model, model
    tmp1[p], tmp2[p] = True, False

    return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)",data\repos\Python\other\davis_putnam_logemann_loveland.py,dpll_algorithm,560
1750,davis_putnam_logemann_loveland.py::assign::61,"    def assign(self, model: dict[str, bool | None]) -> None:
        """"""
        Assign values to literals of the clause as given by model.
        """"""
        for literal in self.literals:
            symbol = literal[:2]
            if symbol in model:
                value = model[symbol]
            else:
                continue
            # Complement assignment if literal is in complemented form
            if value is not None and literal.endswith(""'""):
                value = not value
            self.literals[literal] = value",data\repos\Python\other\davis_putnam_logemann_loveland.py,assign,107
1751,davis_putnam_logemann_loveland.py::evaluate::76,"    def evaluate(self, model: dict[str, bool | None]) -> bool | None:
        """"""
        Evaluates the clause with the assignments in model.

        This has the following steps:
          1. Return ``True`` if both a literal and its complement exist in the clause.
          2. Return ``True`` if a single literal has the assignment ``True``.
          3. Return ``None`` (unable to complete evaluation)
             if a literal has no assignment.
          4. Compute disjunction of all values assigned in clause.
        """"""
        for literal in self.literals:
            symbol = literal.rstrip(""'"") if literal.endswith(""'"") else literal + ""'""
            if symbol in self.literals:
                return True

        self.assign(model)
        for value in self.literals.values():
            if value in (True, None):
                return value
        return any(self.literals.values())",data\repos\Python\other\davis_putnam_logemann_loveland.py,evaluate,188
1752,doomsday.py::get_week_day::17,"def get_week_day(year: int, month: int, day: int) -> str:
    """"""Returns the week-day name out of a given date.

    >>> get_week_day(2020, 10, 24)
    'Saturday'
    >>> get_week_day(2017, 10, 24)
    'Tuesday'
    >>> get_week_day(2019, 5, 3)
    'Friday'
    >>> get_week_day(1970, 9, 16)
    'Wednesday'
    >>> get_week_day(1870, 8, 13)
    'Saturday'
    >>> get_week_day(2040, 3, 14)
    'Wednesday'

    """"""
    # minimal input check:
    assert len(str(year)) > 2, ""year should be in YYYY format""
    assert 1 <= month <= 12, ""month should be between 1 to 12""
    assert 1 <= day <= 31, ""day should be between 1 to 31""

    # Doomsday algorithm:
    century = year // 100
    century_anchor = (5 * (century % 4) + 2) % 7
    centurian = year % 100
    centurian_m = centurian % 12
    dooms_day = (
        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor
    ) % 7
    day_anchor = (
        DOOMSDAY_NOT_LEAP[month - 1]
        if year % 4 != 0 or (centurian == 0 and year % 400 != 0)
        else DOOMSDAY_LEAP[month - 1]
    )
    week_day = (dooms_day + day - day_anchor) % 7
    return WEEK_DAY_NAMES[week_day]",data\repos\Python\other\doomsday.py,get_week_day,402
1753,fischer_yates_shuffle.py::fisher_yates_shuffle::13,"def fisher_yates_shuffle(data: list) -> list[Any]:
    for _ in range(len(data)):
        a = random.randint(0, len(data) - 1)
        b = random.randint(0, len(data) - 1)
        data[a], data[b] = data[b], data[a]
    return data",data\repos\Python\other\fischer_yates_shuffle.py,fisher_yates_shuffle,69
1754,gauss_easter.py::gauss_easter::9,"def gauss_easter(year: int) -> datetime:
    """"""
    Calculation Gregorian easter date for given year

    >>> gauss_easter(2007)
    datetime.datetime(2007, 4, 8, 0, 0, tzinfo=datetime.timezone.utc)

    >>> gauss_easter(2008)
    datetime.datetime(2008, 3, 23, 0, 0, tzinfo=datetime.timezone.utc)

    >>> gauss_easter(2020)
    datetime.datetime(2020, 4, 12, 0, 0, tzinfo=datetime.timezone.utc)

    >>> gauss_easter(2021)
    datetime.datetime(2021, 4, 4, 0, 0, tzinfo=datetime.timezone.utc)
    """"""
    metonic_cycle = year % 19
    julian_leap_year = year % 4
    non_leap_year = year % 7
    leap_day_inhibits = math.floor(year / 100)
    lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)
    leap_day_reinstall_number = leap_day_inhibits / 4
    secular_moon_shift = (
        15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number
    ) % 30
    century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7

    # days to be added to March 21
    days_to_add = (19 * metonic_cycle + secular_moon_shift) % 30

    # PHM -> Paschal Full Moon
    days_from_phm_to_sunday = (
        2 * julian_leap_year
        + 4 * non_leap_year
        + 6 * days_to_add
        + century_starting_point
    ) % 7

    if days_to_add == 29 and days_from_phm_to_sunday == 6:
        return datetime(year, 4, 19, tzinfo=UTC)
    elif days_to_add == 28 and days_from_phm_to_sunday == 6:
        return datetime(year, 4, 18, tzinfo=UTC)
    else:
        return datetime(year, 3, 22, tzinfo=UTC) + timedelta(
            days=int(days_to_add + days_from_phm_to_sunday)
        )",data\repos\Python\other\gauss_easter.py,gauss_easter,513
1755,graham_scan.py::angle_comparer::28,"def angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:
    """"""Return the angle toward to point from (minx, miny)

    :param point: The target point
           minx: The starting point's x
           miny: The starting point's y
    :return: the angle

    Examples:
    >>> angle_comparer((1,1), 0, 0)
    45.0

    >>> angle_comparer((100,1), 10, 10)
    -5.710593137499642

    >>> angle_comparer((5,5), 2, 3)
    33.690067525979785
    """"""
    # sort the points accorgind to the angle from the lowest and the most left point
    x, y = point
    return degrees(atan2(y - miny, x - minx))",data\repos\Python\other\graham_scan.py,angle_comparer,198
1756,graham_scan.py::check_direction::51,"def check_direction(
    starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]
) -> Direction:
    """"""Return the direction toward to the line from via to target from starting

    :param starting: The starting point
           via: The via point
           target: The target point
    :return: the Direction

    Examples:
    >>> check_direction((1,1), (2,2), (3,3))
    Direction.straight

    >>> check_direction((60,1), (-50,199), (30,2))
    Direction.left

    >>> check_direction((0,0), (5,5), (10,0))
    Direction.right
    """"""
    x0, y0 = starting
    x1, y1 = via
    x2, y2 = target
    via_angle = degrees(atan2(y1 - y0, x1 - x0))
    via_angle %= 360
    target_angle = degrees(atan2(y2 - y0, x2 - x0))
    target_angle %= 360
    # t-
    #  \ \
    #   \ v
    #    \|
    #     s
    # via_angle is always lower than target_angle, if direction is left.
    # If they are same, it means they are on a same line of convex hull.
    if target_angle > via_angle:
        return Direction.left
    elif target_angle == via_angle:
        return Direction.straight
    else:
        return Direction.right",data\repos\Python\other\graham_scan.py,check_direction,326
1757,graham_scan.py::graham_scan::93,"def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:
    """"""Pure implementation of graham scan algorithm in Python

    :param points: The unique points on coordinates.
    :return: The points on convex hell.

    Examples:
    >>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])
    [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]

    >>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])
    [(0, 0), (1, 0), (1, 1), (0, 1)]

    >>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])
    [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]

    >>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])
    [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]
    """"""

    if len(points) <= 2:
        # There is no convex hull
        raise ValueError(""graham_scan: argument must contain more than 3 points."")
    if len(points) == 3:
        return points
    # find the lowest and the most left point
    minidx = 0
    miny, minx = maxsize, maxsize
    for i, point in enumerate(points):
        x = point[0]
        y = point[1]
        if y < miny:
            miny = y
            minx = x
            minidx = i
        if y == miny and x < minx:
            minx = x
            minidx = i

    # remove the lowest and the most left point from points for preparing for sort
    points.pop(minidx)

    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))
    # This insert actually costs complexity,
    # and you should instead add (minx, miny) into stack later.
    # I'm using insert just for easy understanding.
    sorted_points.insert(0, (minx, miny))

    stack: deque[tuple[int, int]] = deque()
    stack.append(sorted_points[0])
    stack.append(sorted_points[1])
    stack.append(sorted_points[2])
    # The first 3 points lines are towards the left because we sort them by their angle
    # from minx, miny.
    current_direction = Direction.left

    for i in range(3, len(sorted_points)):
        while True:
            starting = stack[-2]
            via = stack[-1]
            target = sorted_points[i]
            next_direction = check_direction(starting, via, target)

            if next_direction == Direction.left:
                current_direction = Direction.left
                break
            if next_direction == Direction.straight:
                if current_direction == Direction.left:
                    # We keep current_direction as left.
                    # Because if the straight line keeps as straight,
                    # we want to know if this straight line is towards left.
                    break
                elif current_direction == Direction.right:
                    # If the straight line is towards right,
                    # every previous points on that straight line is not convex hull.
                    stack.pop()
            if next_direction == Direction.right:
                stack.pop()
        stack.append(sorted_points[i])
    return list(stack)",data\repos\Python\other\graham_scan.py,graham_scan,834
1758,greedy.py::build_menu::23,"def build_menu(name, value, weight):
    menu = []
    for i in range(len(value)):
        menu.append(Things(name[i], value[i], weight[i]))
    return menu",data\repos\Python\other\greedy.py,build_menu,38
1759,greedy.py::greedy::30,"def greedy(item, max_cost, key_func):
    items_copy = sorted(item, key=key_func, reverse=True)
    result = []
    total_value, total_cost = 0.0, 0.0
    for i in range(len(items_copy)):
        if (total_cost + items_copy[i].get_weight()) <= max_cost:
            result.append(items_copy[i])
            total_cost += items_copy[i].get_weight()
            total_value += items_copy[i].get_value()
    return (result, total_value)",data\repos\Python\other\greedy.py,greedy,108
1760,greedy.py::test_greedy::42,"def test_greedy():
    """"""
    >>> food = [""Burger"", ""Pizza"", ""Coca Cola"", ""Rice"",
    ...         ""Sambhar"", ""Chicken"", ""Fries"", ""Milk""]
    >>> value = [80, 100, 60, 70, 50, 110, 90, 60]
    >>> weight = [40, 60, 40, 70, 100, 85, 55, 70]
    >>> foods = build_menu(food, value, weight)
    >>> foods  # doctest: +NORMALIZE_WHITESPACE
    [Things(Burger, 80, 40), Things(Pizza, 100, 60), Things(Coca Cola, 60, 40),
     Things(Rice, 70, 70), Things(Sambhar, 50, 100), Things(Chicken, 110, 85),
     Things(Fries, 90, 55), Things(Milk, 60, 70)]
    >>> greedy(foods, 500, Things.get_value)  # doctest: +NORMALIZE_WHITESPACE
    ([Things(Chicken, 110, 85), Things(Pizza, 100, 60), Things(Fries, 90, 55),
      Things(Burger, 80, 40), Things(Rice, 70, 70), Things(Coca Cola, 60, 40),
      Things(Milk, 60, 70)], 570.0)
    """"""",data\repos\Python\other\greedy.py,test_greedy,326
1761,guess_the_number_search.py::temp_input_value::16,"def temp_input_value(
    min_val: int = 10, max_val: int = 1000, option: bool = True
) -> int:
    """"""
    Temporary input values for tests

    >>> temp_input_value(option=True)
    10

    >>> temp_input_value(option=False)
    1000

    >>> temp_input_value(min_val=100, option=True)
    100

    >>> temp_input_value(min_val=100, max_val=50)
    Traceback (most recent call last):
        ...
    ValueError: Invalid value for min_val or max_val (min_value < max_value)

    >>> temp_input_value(""ten"",""fifty"",1)
    Traceback (most recent call last):
        ...
    AssertionError: Invalid type of value(s) specified to function!

    >>> temp_input_value(min_val=-100, max_val=500)
    -100

    >>> temp_input_value(min_val=-5100, max_val=-100)
    -5100
    """"""
    assert (
        isinstance(min_val, int)
        and isinstance(max_val, int)
        and isinstance(option, bool)
    ), ""Invalid type of value(s) specified to function!""

    if min_val > max_val:
        raise ValueError(""Invalid value for min_val or max_val (min_value < max_value)"")
    return min_val if option else max_val",data\repos\Python\other\guess_the_number_search.py,temp_input_value,281
1762,guess_the_number_search.py::get_avg::58,"def get_avg(number_1: int, number_2: int) -> int:
    """"""
    Return the mid-number(whole) of two integers a and b

    >>> get_avg(10, 15)
    12

    >>> get_avg(20, 300)
    160

    >>> get_avg(""abcd"", 300)
    Traceback (most recent call last):
        ...
    TypeError: can only concatenate str (not ""int"") to str

    >>> get_avg(10.5,50.25)
    30
    """"""
    return int((number_1 + number_2) / 2)",data\repos\Python\other\guess_the_number_search.py,get_avg,134
1763,guess_the_number_search.py::guess_the_number::79,"def guess_the_number(lower: int, higher: int, to_guess: int) -> None:
    """"""
    The `guess_the_number` function that guess the number by some operations
    and using inner functions

    >>> guess_the_number(10, 1000, 17)
    started...
    guess the number : 17
    details : [505, 257, 133, 71, 40, 25, 17]

    >>> guess_the_number(-10000, 10000, 7)
    started...
    guess the number : 7
    details : [0, 5000, 2500, 1250, 625, 312, 156, 78, 39, 19, 9, 4, 6, 7]

    >>> guess_the_number(10, 1000, ""a"")
    Traceback (most recent call last):
        ...
    AssertionError: argument values must be type of ""int""

    >>> guess_the_number(10, 1000, 5)
    Traceback (most recent call last):
        ...
    ValueError: guess value must be within the range of lower and higher value

    >>> guess_the_number(10000, 100, 5)
    Traceback (most recent call last):
        ...
    ValueError: argument value for lower and higher must be(lower > higher)
    """"""
    assert (
        isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)
    ), 'argument values must be type of ""int""'

    if lower > higher:
        raise ValueError(""argument value for lower and higher must be(lower > higher)"")

    if not lower < to_guess < higher:
        raise ValueError(
            ""guess value must be within the range of lower and higher value""
        )

    def answer(number: int) -> str:
        """"""
        Returns value by comparing with entered `to_guess` number
        """"""
        if number > to_guess:
            return ""high""
        elif number < to_guess:
            return ""low""
        else:
            return ""same""

    print(""started..."")

    last_lowest = lower
    last_highest = higher

    last_numbers = []

    while True:
        number = get_avg(last_lowest, last_highest)
        last_numbers.append(number)

        if answer(number) == ""low"":
            last_lowest = number
        elif answer(number) == ""high"":
            last_highest = number
        else:
            break

    print(f""guess the number : {last_numbers[-1]}"")
    print(f""details : {last_numbers!s}"")",data\repos\Python\other\guess_the_number_search.py,guess_the_number,553
1764,guess_the_number_search.py::main::154,"def main() -> None:
    """"""
    starting point or function of script
    """"""
    lower = int(input(""Enter lower value : "").strip())
    higher = int(input(""Enter high value : "").strip())
    guess = int(input(""Enter value to guess : "").strip())
    guess_the_number(lower, higher, guess)",data\repos\Python\other\guess_the_number_search.py,main,68
1765,guess_the_number_search.py::answer::121,"    def answer(number: int) -> str:
        """"""
        Returns value by comparing with entered `to_guess` number
        """"""
        if number > to_guess:
            return ""high""
        elif number < to_guess:
            return ""low""
        else:
            return ""same""",data\repos\Python\other\guess_the_number_search.py,answer,59
1766,h_index.py::h_index::28,"def h_index(citations: list[int]) -> int:
    """"""
    Return H-index of citations

    >>> h_index([3, 0, 6, 1, 5])
    3
    >>> h_index([1, 3, 1])
    1
    >>> h_index([1, 2, 3])
    2
    >>> h_index('test')
    Traceback (most recent call last):
        ...
    ValueError: The citations should be a list of non negative integers.
    >>> h_index([1,2,'3'])
    Traceback (most recent call last):
        ...
    ValueError: The citations should be a list of non negative integers.
    >>> h_index([1,2,-3])
    Traceback (most recent call last):
        ...
    ValueError: The citations should be a list of non negative integers.
    """"""

    # validate:
    if not isinstance(citations, list) or not all(
        isinstance(item, int) and item >= 0 for item in citations
    ):
        raise ValueError(""The citations should be a list of non negative integers."")

    citations.sort()
    len_citations = len(citations)

    for i in range(len_citations):
        if citations[len_citations - 1 - i] <= i:
            return i

    return len_citations",data\repos\Python\other\h_index.py,h_index,280
1767,least_recently_used.py::refer::50,"    def refer(self, x: T) -> None:
        """"""
        Looks for a page in the cache store and adds reference to the set.
        Remove the least recently used key if the store is full.
        Update store to reflect recent access.
        """"""
        if x not in self.key_reference:
            if len(self.dq_store) == LRUCache._MAX_CAPACITY:
                last_element = self.dq_store.pop()
                self.key_reference.remove(last_element)
        else:
            self.dq_store.remove(x)

        self.dq_store.appendleft(x)
        self.key_reference.add(x)",data\repos\Python\other\least_recently_used.py,refer,123
1768,least_recently_used.py::display::66,"    def display(self) -> None:
        """"""
        Prints all the elements in the store.
        """"""
        for k in self.dq_store:
            print(k)",data\repos\Python\other\least_recently_used.py,display,34
1769,lfu_cache.py::add::114,"    def add(self, node: DoubleLinkedListNode[T, U]) -> None:
        """"""
        Adds the given node at the tail of the list and shifting it to proper position
        """"""

        previous = self.rear.prev

        # All nodes other than self.head are guaranteed to have non-None previous
        assert previous is not None

        previous.next = node
        node.prev = previous
        self.rear.prev = node
        node.next = self.rear
        node.freq += 1
        self._position_node(node)",data\repos\Python\other\lfu_cache.py,add,113
1770,lfu_cache.py::remove::145,"    def remove(
        self, node: DoubleLinkedListNode[T, U]
    ) -> DoubleLinkedListNode[T, U] | None:
        """"""
        Removes and returns the given node from the list

        Returns None if node.prev or node.next is None
        """"""

        if node.prev is None or node.next is None:
            return None

        node.prev.next = node.next
        node.next.prev = node.prev
        node.prev = None
        node.next = None
        return node",data\repos\Python\other\lfu_cache.py,remove,103
1771,lfu_cache.py::get::232,"    def get(self, key: T) -> U | None:
        """"""
        Returns the value for the input key and updates the Double Linked List. Returns
        Returns None if key is not present in cache
        """"""

        if key in self.cache:
            self.hits += 1
            value_node: DoubleLinkedListNode[T, U] = self.cache[key]
            node = self.list.remove(self.cache[key])
            assert node == value_node

            # node is guaranteed not None because it is in self.cache
            assert node is not None
            self.list.add(node)
            return node.val
        self.miss += 1
        return None",data\repos\Python\other\lfu_cache.py,get,136
1772,lfu_cache.py::put::251,"    def put(self, key: T, value: U) -> None:
        """"""
        Sets the value for the input key and updates the Double Linked List
        """"""

        if key not in self.cache:
            if self.num_keys >= self.capacity:
                # delete first node when over capacity
                first_node = self.list.head.next

                # guaranteed to have a non-None first node when num_keys > 0
                # explain to type checker via assertions
                assert first_node is not None
                assert first_node.key is not None
                assert self.list.remove(first_node) is not None
                # first_node guaranteed to be in list

                del self.cache[first_node.key]
                self.num_keys -= 1
            self.cache[key] = DoubleLinkedListNode(key, value)
            self.list.add(self.cache[key])
            self.num_keys += 1

        else:
            node = self.list.remove(self.cache[key])
            assert node is not None  # node guaranteed to be in list
            node.val = value
            self.list.add(node)",data\repos\Python\other\lfu_cache.py,put,221
1773,lfu_cache.py::decorator::281,"    def decorator(
        cls: type[LFUCache[T, U]], size: int = 128
    ) -> Callable[[Callable[[T], U]], Callable[..., U]]:
        """"""
        Decorator version of LFU Cache

        Decorated function must be function of T -> U
        """"""

        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:
            # variable to map the decorator functions to their respective instance
            decorator_function_to_instance_map: dict[
                Callable[[T], U], LFUCache[T, U]
            ] = {}

            def cache_decorator_wrapper(*args: T) -> U:
                if func not in decorator_function_to_instance_map:
                    decorator_function_to_instance_map[func] = LFUCache(size)

                result = decorator_function_to_instance_map[func].get(args[0])
                if result is None:
                    result = func(*args)
                    decorator_function_to_instance_map[func].put(args[0], result)
                return result

            def cache_info() -> LFUCache[T, U]:
                return decorator_function_to_instance_map[func]

            setattr(cache_decorator_wrapper, ""cache_info"", cache_info)  # noqa: B010

            return cache_decorator_wrapper

        return cache_decorator_inner",data\repos\Python\other\lfu_cache.py,decorator,263
1774,lfu_cache.py::cache_decorator_inner::290,"        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:
            # variable to map the decorator functions to their respective instance
            decorator_function_to_instance_map: dict[
                Callable[[T], U], LFUCache[T, U]
            ] = {}

            def cache_decorator_wrapper(*args: T) -> U:
                if func not in decorator_function_to_instance_map:
                    decorator_function_to_instance_map[func] = LFUCache(size)

                result = decorator_function_to_instance_map[func].get(args[0])
                if result is None:
                    result = func(*args)
                    decorator_function_to_instance_map[func].put(args[0], result)
                return result

            def cache_info() -> LFUCache[T, U]:
                return decorator_function_to_instance_map[func]

            setattr(cache_decorator_wrapper, ""cache_info"", cache_info)  # noqa: B010

            return cache_decorator_wrapper",data\repos\Python\other\lfu_cache.py,cache_decorator_inner,194
1775,lfu_cache.py::cache_decorator_wrapper::296,"            def cache_decorator_wrapper(*args: T) -> U:
                if func not in decorator_function_to_instance_map:
                    decorator_function_to_instance_map[func] = LFUCache(size)

                result = decorator_function_to_instance_map[func].get(args[0])
                if result is None:
                    result = func(*args)
                    decorator_function_to_instance_map[func].put(args[0], result)
                return result",data\repos\Python\other\lfu_cache.py,cache_decorator_wrapper,87
1776,linear_congruential_generator.py::next_number::29,"    def next_number(self):
        """"""
        The smallest number that can be generated is zero.
        The largest number that can be generated is modulo-1. modulo is set in the
        constructor.
        """"""
        self.seed = (self.multiplier * self.seed + self.increment) % self.modulo
        return self.seed",data\repos\Python\other\linear_congruential_generator.py,next_number,67
1777,lru_cache.py::add::112,"    def add(self, node: DoubleLinkedListNode[T, U]) -> None:
        """"""
        Adds the given node to the end of the list (before rear)
        """"""

        previous = self.rear.prev

        # All nodes other than self.head are guaranteed to have non-None previous
        assert previous is not None

        previous.next = node
        node.prev = previous
        self.rear.prev = node
        node.next = self.rear",data\repos\Python\other\lru_cache.py,add,95
1778,lru_cache.py::remove::127,"    def remove(
        self, node: DoubleLinkedListNode[T, U]
    ) -> DoubleLinkedListNode[T, U] | None:
        """"""
        Removes and returns the given node from the list

        Returns None if node.prev or node.next is None
        """"""

        if node.prev is None or node.next is None:
            return None

        node.prev.next = node.next
        node.next.prev = node.prev
        node.prev = None
        node.next = None
        return node",data\repos\Python\other\lru_cache.py,remove,103
1779,lru_cache.py::get::246,"    def get(self, key: T) -> U | None:
        """"""
        Returns the value for the input key and updates the Double Linked List.
        Returns None if key is not present in cache
        """"""
        # Note: pythonic interface would throw KeyError rather than return None

        if key in self.cache:
            self.hits += 1
            value_node: DoubleLinkedListNode[T, U] = self.cache[key]
            node = self.list.remove(self.cache[key])
            assert node == value_node

            # node is guaranteed not None because it is in self.cache
            assert node is not None
            self.list.add(node)
            return node.val
        self.miss += 1
        return None",data\repos\Python\other\lru_cache.py,get,149
1780,lru_cache.py::put::266,"    def put(self, key: T, value: U) -> None:
        """"""
        Sets the value for the input key and updates the Double Linked List
        """"""

        if key not in self.cache:
            if self.num_keys >= self.capacity:
                # delete first node (oldest) when over capacity
                first_node = self.list.head.next

                # guaranteed to have a non-None first node when num_keys > 0
                # explain to type checker via assertions
                assert first_node is not None
                assert first_node.key is not None
                assert (
                    self.list.remove(first_node) is not None
                )  # node guaranteed to be in list assert node.key is not None

                del self.cache[first_node.key]
                self.num_keys -= 1
            self.cache[key] = DoubleLinkedListNode(key, value)
            self.list.add(self.cache[key])
            self.num_keys += 1

        else:
            # bump node to the end of the list, update value
            node = self.list.remove(self.cache[key])
            assert node is not None  # node guaranteed to be in list
            node.val = value
            self.list.add(node)",data\repos\Python\other\lru_cache.py,put,248
1781,lru_cache.py::decorator::298,"    def decorator(
        cls, size: int = 128
    ) -> Callable[[Callable[[T], U]], Callable[..., U]]:
        """"""
        Decorator version of LRU Cache

        Decorated function must be function of T -> U
        """"""

        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:
            # variable to map the decorator functions to their respective instance
            decorator_function_to_instance_map: dict[
                Callable[[T], U], LRUCache[T, U]
            ] = {}

            def cache_decorator_wrapper(*args: T) -> U:
                if func not in decorator_function_to_instance_map:
                    decorator_function_to_instance_map[func] = LRUCache(size)

                result = decorator_function_to_instance_map[func].get(args[0])
                if result is None:
                    result = func(*args)
                    decorator_function_to_instance_map[func].put(args[0], result)
                return result

            def cache_info() -> LRUCache[T, U]:
                return decorator_function_to_instance_map[func]

            setattr(cache_decorator_wrapper, ""cache_info"", cache_info)  # noqa: B010

            return cache_decorator_wrapper

        return cache_decorator_inner",data\repos\Python\other\lru_cache.py,decorator,254
1782,lru_cache.py::cache_decorator_inner::307,"        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:
            # variable to map the decorator functions to their respective instance
            decorator_function_to_instance_map: dict[
                Callable[[T], U], LRUCache[T, U]
            ] = {}

            def cache_decorator_wrapper(*args: T) -> U:
                if func not in decorator_function_to_instance_map:
                    decorator_function_to_instance_map[func] = LRUCache(size)

                result = decorator_function_to_instance_map[func].get(args[0])
                if result is None:
                    result = func(*args)
                    decorator_function_to_instance_map[func].put(args[0], result)
                return result

            def cache_info() -> LRUCache[T, U]:
                return decorator_function_to_instance_map[func]

            setattr(cache_decorator_wrapper, ""cache_info"", cache_info)  # noqa: B010

            return cache_decorator_wrapper",data\repos\Python\other\lru_cache.py,cache_decorator_inner,194
1783,lru_cache.py::cache_decorator_wrapper::313,"            def cache_decorator_wrapper(*args: T) -> U:
                if func not in decorator_function_to_instance_map:
                    decorator_function_to_instance_map[func] = LRUCache(size)

                result = decorator_function_to_instance_map[func].get(args[0])
                if result is None:
                    result = func(*args)
                    decorator_function_to_instance_map[func].put(args[0], result)
                return result",data\repos\Python\other\lru_cache.py,cache_decorator_wrapper,87
1784,magicdiamondpattern.py::floyd::5,"def floyd(n):
    """"""
    Print the upper half of a diamond pattern with '*' characters.

    Args:
        n (int): Size of the pattern.

    Examples:
        >>> floyd(3)
        '  * \\n * * \\n* * * \\n'

        >>> floyd(5)
        '    * \\n   * * \\n  * * * \\n * * * * \\n* * * * * \\n'
    """"""
    result = """"
    for i in range(n):
        for _ in range(n - i - 1):  # printing spaces
            result += "" ""
        for _ in range(i + 1):  # printing stars
            result += ""* ""
        result += ""\n""
    return result",data\repos\Python\other\magicdiamondpattern.py,floyd,161
1785,magicdiamondpattern.py::reverse_floyd::30,"def reverse_floyd(n):
    """"""
    Print the lower half of a diamond pattern with '*' characters.

    Args:
        n (int): Size of the pattern.

    Examples:
        >>> reverse_floyd(3)
        '* * * \\n * * \\n  * \\n   '

        >>> reverse_floyd(5)
        '* * * * * \\n * * * * \\n  * * * \\n   * * \\n    * \\n     '
    """"""
    result = """"
    for i in range(n, 0, -1):
        for _ in range(i, 0, -1):  # printing stars
            result += ""* ""
        result += ""\n""
        for _ in range(n - i + 1, 0, -1):  # printing spaces
            result += "" ""
    return result",data\repos\Python\other\magicdiamondpattern.py,reverse_floyd,179
1786,magicdiamondpattern.py::pretty_print::55,"def pretty_print(n):
    """"""
    Print a complete diamond pattern with '*' characters.

    Args:
        n (int): Size of the pattern.

    Examples:
        >>> pretty_print(0)
        '       ...       ....        nothing printing :('

        >>> pretty_print(3)
        '  * \\n * * \\n* * * \\n* * * \\n * * \\n  * \\n   '
    """"""
    if n <= 0:
        return ""       ...       ....        nothing printing :(""
    upper_half = floyd(n)  # upper half
    lower_half = reverse_floyd(n)  # lower half
    return upper_half + lower_half",data\repos\Python\other\magicdiamondpattern.py,pretty_print,144
1787,majority_vote_algorithm.py::majority_vote::11,"def majority_vote(votes: list[int], votes_needed_to_win: int) -> list[int]:
    """"""
    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 3)
    [2]
    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 2)
    []
    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 4)
    [1, 2, 3]
    """"""
    majority_candidate_counter: Counter[int] = Counter()
    for vote in votes:
        majority_candidate_counter[vote] += 1
        if len(majority_candidate_counter) == votes_needed_to_win:
            majority_candidate_counter -= Counter(set(majority_candidate_counter))
    majority_candidate_counter = Counter(
        vote for vote in votes if vote in majority_candidate_counter
    )
    return [
        vote
        for vote in majority_candidate_counter
        if majority_candidate_counter[vote] > len(votes) / votes_needed_to_win
    ]",data\repos\Python\other\majority_vote_algorithm.py,majority_vote,237
1788,maximum_subsequence.py::max_subsequence_sum::4,"def max_subsequence_sum(nums: Sequence[int] | None = None) -> int:
    """"""Return the maximum possible sum amongst all non - empty subsequences.

    Raises:
      ValueError: when nums is empty.

    >>> max_subsequence_sum([1,2,3,4,-2])
    10
    >>> max_subsequence_sum([-2, -3, -1, -4, -6])
    -1
    >>> max_subsequence_sum([])
    Traceback (most recent call last):
        . . .
    ValueError: Input sequence should not be empty
    >>> max_subsequence_sum()
    Traceback (most recent call last):
        . . .
    ValueError: Input sequence should not be empty
    """"""
    if nums is None or not nums:
        raise ValueError(""Input sequence should not be empty"")

    ans = nums[0]
    for i in range(1, len(nums)):
        num = nums[i]
        ans = max(ans, ans + num, num)

    return ans",data\repos\Python\other\maximum_subsequence.py,max_subsequence_sum,211
1789,nested_brackets.py::is_balanced::17,"def is_balanced(s: str) -> bool:
    """"""
    >>> is_balanced("""")
    True
    >>> is_balanced(""()"")
    True
    >>> is_balanced(""[]"")
    True
    >>> is_balanced(""{}"")
    True
    >>> is_balanced(""()[]{}"")
    True
    >>> is_balanced(""(())"")
    True
    >>> is_balanced(""[["")
    False
    >>> is_balanced(""([{}])"")
    True
    >>> is_balanced(""(()[)]"")
    False
    >>> is_balanced(""([)]"")
    False
    >>> is_balanced(""[[()]]"")
    True
    >>> is_balanced(""(()(()))"")
    True
    >>> is_balanced(""]"")
    False
    >>> is_balanced(""Life is a bowl of cherries."")
    True
    >>> is_balanced(""Life is a bowl of che{}ies."")
    True
    >>> is_balanced(""Life is a bowl of che}{ies."")
    False
    """"""
    open_to_closed = {""{"": ""}"", ""["": ""]"", ""("": "")""}
    stack = []
    for symbol in s:
        if symbol in open_to_closed:
            stack.append(symbol)
        elif symbol in open_to_closed.values() and (
            not stack or open_to_closed[stack.pop()] != symbol
        ):
            return False
    return not stack  # stack should be empty",data\repos\Python\other\nested_brackets.py,is_balanced,299
1790,nested_brackets.py::main::64,"def main():
    s = input(""Enter sequence of brackets: "")
    print(f""'{s}' is {'' if is_balanced(s) else 'not '}balanced."")",data\repos\Python\other\nested_brackets.py,main,36
1791,number_container_system.py::binary_search_delete::20,"    def binary_search_delete(self, array: list | str | range, item: int) -> list[int]:
        """"""
        Removes the item from the sorted array and returns
        the new array.

        >>> NumberContainer().binary_search_delete([1,2,3], 2)
        [1, 3]
        >>> NumberContainer().binary_search_delete([0, 0, 0], 0)
        [0, 0]
        >>> NumberContainer().binary_search_delete([-1, -1, -1], -1)
        [-1, -1]
        >>> NumberContainer().binary_search_delete([-1, 0], 0)
        [-1]
        >>> NumberContainer().binary_search_delete([-1, 0], -1)
        [0]
        >>> NumberContainer().binary_search_delete(range(7), 3)
        [0, 1, 2, 4, 5, 6]
        >>> NumberContainer().binary_search_delete([1.1, 2.2, 3.3], 2.2)
        [1.1, 3.3]
        >>> NumberContainer().binary_search_delete(""abcde"", ""c"")
        ['a', 'b', 'd', 'e']
        >>> NumberContainer().binary_search_delete([0, -1, 2, 4], 0)
        Traceback (most recent call last):
            ...
        ValueError: Either the item is not in the array or the array was unsorted
        >>> NumberContainer().binary_search_delete([2, 0, 4, -1, 11], -1)
        Traceback (most recent call last):
            ...
        ValueError: Either the item is not in the array or the array was unsorted
        >>> NumberContainer().binary_search_delete(125, 1)
        Traceback (most recent call last):
            ...
        TypeError: binary_search_delete() only accepts either a list, range or str
        """"""
        if isinstance(array, (range, str)):
            array = list(array)
        elif not isinstance(array, list):
            raise TypeError(
                ""binary_search_delete() only accepts either a list, range or str""
            )

        low = 0
        high = len(array) - 1

        while low <= high:
            mid = (low + high) // 2
            if array[mid] == item:
                array.pop(mid)
                return array
            elif array[mid] < item:
                low = mid + 1
            else:
                high = mid - 1
        raise ValueError(
            ""Either the item is not in the array or the array was unsorted""
        )",data\repos\Python\other\number_container_system.py,binary_search_delete,561
1792,number_container_system.py::binary_search_insert::77,"    def binary_search_insert(self, array: list | str | range, index: int) -> list[int]:
        """"""
        Inserts the index into the sorted array
        at the correct position.

        >>> NumberContainer().binary_search_insert([1,2,3], 2)
        [1, 2, 2, 3]
        >>> NumberContainer().binary_search_insert([0,1,3], 2)
        [0, 1, 2, 3]
        >>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 103], 51)
        [-5, -3, 0, 0, 11, 51, 103]
        >>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 100, 103], 101)
        [-5, -3, 0, 0, 11, 100, 101, 103]
        >>> NumberContainer().binary_search_insert(range(10), 4)
        [0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9]
        >>> NumberContainer().binary_search_insert(""abd"", ""c"")
        ['a', 'b', 'c', 'd']
        >>> NumberContainer().binary_search_insert(131, 23)
        Traceback (most recent call last):
            ...
        TypeError: binary_search_insert() only accepts either a list, range or str
        """"""
        if isinstance(array, (range, str)):
            array = list(array)
        elif not isinstance(array, list):
            raise TypeError(
                ""binary_search_insert() only accepts either a list, range or str""
            )

        low = 0
        high = len(array) - 1

        while low <= high:
            mid = (low + high) // 2
            if array[mid] == index:
                # If the item already exists in the array,
                # insert it after the existing item
                array.insert(mid + 1, index)
                return array
            elif array[mid] < index:
                low = mid + 1
            else:
                high = mid - 1

        # If the item doesn't exist in the array, insert it at the appropriate position
        array.insert(low, index)
        return array",data\repos\Python\other\number_container_system.py,binary_search_insert,508
1793,number_container_system.py::change::125,"    def change(self, index: int, number: int) -> None:
        """"""
        Changes (sets) the index as number

        >>> cont = NumberContainer()
        >>> cont.change(0, 10)
        >>> cont.change(0, 20)
        >>> cont.change(-13, 20)
        >>> cont.change(-100030, 20032903290)
        """"""
        # Remove previous index
        if index in self.indexmap:
            n = self.indexmap[index]
            if len(self.numbermap[n]) == 1:
                del self.numbermap[n]
            else:
                self.numbermap[n] = self.binary_search_delete(self.numbermap[n], index)

        # Set new index
        self.indexmap[index] = number

        # Number not seen before or empty so insert number value
        if number not in self.numbermap:
            self.numbermap[number] = [index]

        # Here we need to perform a binary search insertion in order to insert
        # The item in the correct place
        else:
            self.numbermap[number] = self.binary_search_insert(
                self.numbermap[number], index
            )",data\repos\Python\other\number_container_system.py,change,240
1794,number_container_system.py::find::157,"    def find(self, number: int) -> int:
        """"""
        Returns the smallest index where the number is.

        >>> cont = NumberContainer()
        >>> cont.find(10)
        -1
        >>> cont.change(0, 10)
        >>> cont.find(10)
        0
        >>> cont.change(0, 20)
        >>> cont.find(10)
        -1
        >>> cont.find(20)
        0
        """"""
        # Simply return the 0th index (smallest) of the indexes found (or -1)
        return self.numbermap.get(number, [-1])[0]",data\repos\Python\other\number_container_system.py,find,132
1795,password.py::password_generator::6,"def password_generator(length: int = 8) -> str:
    """"""
    Password Generator allows you to generate a random password of length N.

    >>> len(password_generator())
    8
    >>> len(password_generator(length=16))
    16
    >>> len(password_generator(257))
    257
    >>> len(password_generator(length=0))
    0
    >>> len(password_generator(-1))
    0
    """"""
    chars = ascii_letters + digits + punctuation
    return """".join(secrets.choice(chars) for _ in range(length))",data\repos\Python\other\password.py,password_generator,116
1796,password.py::alternative_password_generator::28,"def alternative_password_generator(chars_incl: str, i: int) -> str:
    # Password Generator = full boot with random_number, random_letters, and
    # random_character FUNCTIONS
    # Put your code here...
    i -= len(chars_incl)
    quotient = i // 3
    remainder = i % 3
    # chars = chars_incl + random_letters(ascii_letters, i / 3 + remainder) +
    #     random_number(digits, i / 3) + random_characters(punctuation, i / 3)
    chars = (
        chars_incl
        + random(ascii_letters, quotient + remainder)
        + random(digits, quotient)
        + random(punctuation, quotient)
    )
    list_of_chars = list(chars)
    shuffle(list_of_chars)
    return """".join(list_of_chars)",data\repos\Python\other\password.py,alternative_password_generator,174
1797,password.py::random::50,"def random(chars_incl: str, i: int) -> str:
    return """".join(secrets.choice(chars_incl) for _ in range(i))",data\repos\Python\other\password.py,random,32
1798,password.py::is_strong_password::54,"def is_strong_password(password: str, min_length: int = 8) -> bool:
    """"""
    This will check whether a given password is strong or not. The password must be at
    least as long as the provided minimum length, and it must contain at least 1
    lowercase letter, 1 uppercase letter, 1 number and 1 special character.

    >>> is_strong_password('Hwea7$2!')
    True
    >>> is_strong_password('Sh0r1')
    False
    >>> is_strong_password('Hello123')
    False
    >>> is_strong_password('Hello1238udfhiaf038fajdvjjf!jaiuFhkqi1')
    True
    >>> is_strong_password('0')
    False
    """"""

    if len(password) < min_length:
        return False

    upper = any(char in ascii_uppercase for char in password)
    lower = any(char in ascii_lowercase for char in password)
    num = any(char in digits for char in password)
    spec_char = any(char in punctuation for char in password)

    return upper and lower and num and spec_char",data\repos\Python\other\password.py,is_strong_password,244
1799,password.py::main::83,"def main():
    length = int(input(""Please indicate the max length of your password: "").strip())
    chars_incl = input(
        ""Please indicate the characters that must be in your password: ""
    ).strip()
    print(""Password generated:"", password_generator(length))
    print(
        ""Alternative Password generated:"",
        alternative_password_generator(chars_incl, length),
    )
    print(""[If you are thinking of using this password, You better save it.]"")",data\repos\Python\other\password.py,main,95
1800,scoring_algorithm.py::get_data::27,"def get_data(source_data: list[list[float]]) -> list[list[float]]:
    """"""
    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])
    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]
    """"""
    data_lists: list[list[float]] = []
    for data in source_data:
        for i, el in enumerate(data):
            if len(data_lists) < i + 1:
                data_lists.append([])
            data_lists[i].append(float(el))
    return data_lists",data\repos\Python\other\scoring_algorithm.py,get_data,156
1801,scoring_algorithm.py::calculate_each_score::41,"def calculate_each_score(
    data_lists: list[list[float]], weights: list[int]
) -> list[list[float]]:
    """"""
    >>> calculate_each_score([[20, 23, 22], [60, 90, 50], [2012, 2015, 2011]],
    ...                      [0, 0, 1])
    [[1.0, 0.0, 0.33333333333333337], [0.75, 0.0, 1.0], [0.25, 1.0, 0.0]]
    """"""
    score_lists: list[list[float]] = []
    for dlist, weight in zip(data_lists, weights):
        mind = min(dlist)
        maxd = max(dlist)

        score: list[float] = []
        # for weight 0 score is 1 - actual score
        if weight == 0:
            for item in dlist:
                try:
                    score.append(1 - ((item - mind) / (maxd - mind)))
                except ZeroDivisionError:
                    score.append(1)

        elif weight == 1:
            for item in dlist:
                try:
                    score.append((item - mind) / (maxd - mind))
                except ZeroDivisionError:
                    score.append(0)

        # weight not 0 or 1
        else:
            msg = f""Invalid weight of {weight:f} provided""
            raise ValueError(msg)

        score_lists.append(score)

    return score_lists",data\repos\Python\other\scoring_algorithm.py,calculate_each_score,319
1802,scoring_algorithm.py::generate_final_scores::80,"def generate_final_scores(score_lists: list[list[float]]) -> list[float]:
    """"""
    >>> generate_final_scores([[1.0, 0.0, 0.33333333333333337],
    ...                        [0.75, 0.0, 1.0],
    ...                        [0.25, 1.0, 0.0]])
    [2.0, 1.0, 1.3333333333333335]
    """"""
    # initialize final scores
    final_scores: list[float] = [0 for i in range(len(score_lists[0]))]

    for slist in score_lists:
        for j, ele in enumerate(slist):
            final_scores[j] = final_scores[j] + ele

    return final_scores",data\repos\Python\other\scoring_algorithm.py,generate_final_scores,163
1803,scoring_algorithm.py::procentual_proximity::97,"def procentual_proximity(
    source_data: list[list[float]], weights: list[int]
) -> list[list[float]]:
    """"""
    | `weights` - ``int`` list
    | possible values - ``0`` / ``1``

        * ``0`` if lower values have higher weight in the data set
        * ``1`` if higher values have higher weight in the data set

    >>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1])
    [[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]
    """"""

    data_lists = get_data(source_data)
    score_lists = calculate_each_score(data_lists, weights)
    final_scores = generate_final_scores(score_lists)

    # append scores to source data
    for i, ele in enumerate(final_scores):
        source_data[i].append(ele)

    return source_data",data\repos\Python\other\scoring_algorithm.py,procentual_proximity,242
1804,sdes.py::apply_table::1,"def apply_table(inp, table):
    """"""
    >>> apply_table(""0123456789"", list(range(10)))
    '9012345678'
    >>> apply_table(""0123456789"", list(range(9, -1, -1)))
    '8765432109'
    """"""
    res = """"
    for i in table:
        res += inp[i - 1]
    return res",data\repos\Python\other\sdes.py,apply_table,83
1805,sdes.py::left_shift::14,"def left_shift(data):
    """"""
    >>> left_shift(""0123456789"")
    '1234567890'
    """"""
    return data[1:] + data[0]",data\repos\Python\other\sdes.py,left_shift,37
1806,sdes.py::xor::22,"def xor(a, b):
    """"""
    >>> xor(""01010101"", ""00001111"")
    '01011010'
    """"""
    res = """"
    for i in range(len(a)):
        if a[i] == b[i]:
            res += ""0""
        else:
            res += ""1""
    return res",data\repos\Python\other\sdes.py,xor,68
1807,sdes.py::apply_sbox::36,"def apply_sbox(s, data):
    row = int(""0b"" + data[0] + data[-1], 2)
    col = int(""0b"" + data[1:3], 2)
    return bin(s[row][col])[2:]",data\repos\Python\other\sdes.py,apply_sbox,57
1808,sdes.py::function::42,"def function(expansion, s0, s1, key, message):
    left = message[:4]
    right = message[4:]
    temp = apply_table(right, expansion)
    temp = xor(temp, key)
    left_bin_str = apply_sbox(s0, temp[:4])
    right_bin_str = apply_sbox(s1, temp[4:])
    left_bin_str = ""0"" * (2 - len(left_bin_str)) + left_bin_str
    right_bin_str = ""0"" * (2 - len(right_bin_str)) + right_bin_str
    temp = apply_table(left_bin_str + right_bin_str, p4_table)
    temp = xor(left, temp)
    return temp + right",data\repos\Python\other\sdes.py,function,150
1809,tower_of_hanoi.py::move_tower::1,"def move_tower(height, from_pole, to_pole, with_pole):
    """"""
    >>> move_tower(3, 'A', 'B', 'C')
    moving disk from A to B
    moving disk from A to C
    moving disk from B to C
    moving disk from A to B
    moving disk from C to A
    moving disk from C to B
    moving disk from A to B
    """"""
    if height >= 1:
        move_tower(height - 1, from_pole, with_pole, to_pole)
        move_disk(from_pole, to_pole)
        move_tower(height - 1, with_pole, to_pole, from_pole)",data\repos\Python\other\tower_of_hanoi.py,move_tower,155
1810,tower_of_hanoi.py::main::22,"def main():
    height = int(input(""Height of hanoi: "").strip())
    move_tower(height, ""A"", ""B"", ""C"")",data\repos\Python\other\tower_of_hanoi.py,main,32
1811,word_search.py::visualise_word_search::347,"def visualise_word_search(
    board: list[list[str | None]] | None = None, *, add_fake_chars: bool = True
) -> None:
    """"""
    Graphically displays the word search in the terminal.

    >>> ws = WordSearch(WORDS, 5, 5)
    >>> ws.insert_north(""cat"", [4], [4])
    >>> visualise_word_search(
    ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE
    # # # # #
    # # # # #
    # # # # t
    # # # # a
    # # # # c
    >>> ws.insert_northeast(""snake"", [4], [4, 3, 2, 1, 0])
    >>> visualise_word_search(
    ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE
    # # # # e
    # # # k #
    # # a # t
    # n # # a
    s # # # c
    """"""
    if board is None:
        word_search = WordSearch(WORDS, WIDTH, HEIGHT)
        word_search.generate_board()
        board = word_search.board

    result = """"
    for row in range(len(board)):
        for col in range(len(board[0])):
            character = ""#""
            if (letter := board[row][col]) is not None:
                character = letter
            # Empty char, so add a fake char
            elif add_fake_chars:
                character = chr(randint(97, 122))
            result += f""{character} ""
        result += ""\n""
    print(result, end="""")",data\repos\Python\other\word_search.py,visualise_word_search,361
1812,word_search.py::insert_north::36,"    def insert_north(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_north(""cat"", [2], [2])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, None, 't'],
        [None, None, 'a'],
        [None, None, 'c']]
        >>> ws.insert_north(""at"", [0, 1, 2], [2, 1])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, 't', 't'],
        [None, 'a', 'a'],
        [None, None, 'c']]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Check if there is space above the row to fit in the word
            if word_length > row + 1:
                continue

            # Attempt to insert the word into each column
            for col in cols:
                # Only check to be made here is if there are existing letters
                # above the column that will be overwritten
                letters_above = [self.board[row - i][col] for i in range(word_length)]
                if all(letter is None for letter in letters_above):
                    # Successful, insert the word north
                    for i in range(word_length):
                        self.board[row - i][col] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_north,334
1813,word_search.py::insert_northeast::68,"    def insert_northeast(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_northeast(""cat"", [2], [0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, None, 't'],
        [None, 'a', None],
        ['c', None, None]]
        >>> ws.insert_northeast(""at"", [0, 1], [2, 1, 0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, 't', 't'],
        ['a', 'a', None],
        ['c', None, None]]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Check if there is space for the word above the row
            if word_length > row + 1:
                continue

            # Attempt to insert the word into each column
            for col in cols:
                # Check if there is space to the right of the word as well as above
                if word_length + col > self.width:
                    continue

                # Check if there are existing letters
                # to the right of the column that will be overwritten
                letters_diagonal_left = [
                    self.board[row - i][col + i] for i in range(word_length)
                ]
                if all(letter is None for letter in letters_diagonal_left):
                    # Successful, insert the word northeast
                    for i in range(word_length):
                        self.board[row - i][col + i] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_northeast,371
1814,word_search.py::insert_east::106,"    def insert_east(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_east(""cat"", [1], [0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, None, None],
        ['c', 'a', 't'],
        [None, None, None]]
        >>> ws.insert_east(""at"", [1, 0], [2, 1, 0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, 'a', 't'],
        ['c', 'a', 't'],
        [None, None, None]]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Attempt to insert the word into each column
            for col in cols:
                # Check if there is space to the right of the word
                if word_length + col > self.width:
                    continue

                # Check if there are existing letters
                # to the right of the column that will be overwritten
                letters_left = [self.board[row][col + i] for i in range(word_length)]
                if all(letter is None for letter in letters_left):
                    # Successful, insert the word east
                    for i in range(word_length):
                        self.board[row][col + i] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_east,327
1815,word_search.py::insert_southeast::138,"    def insert_southeast(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_southeast(""cat"", [0], [0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [['c', None, None],
        [None, 'a', None],
        [None, None, 't']]
        >>> ws.insert_southeast(""at"", [1, 0], [2, 1, 0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [['c', None, None],
        ['a', 'a', None],
        [None, 't', 't']]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Check if there is space for the word below the row
            if word_length + row > self.height:
                continue

            # Attempt to insert the word into each column
            for col in cols:
                # Check if there is space to the right of the word as well as below
                if word_length + col > self.width:
                    continue

                # Check if there are existing letters
                # to the right of the column that will be overwritten
                letters_diagonal_left = [
                    self.board[row + i][col + i] for i in range(word_length)
                ]
                if all(letter is None for letter in letters_diagonal_left):
                    # Successful, insert the word southeast
                    for i in range(word_length):
                        self.board[row + i][col + i] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_southeast,371
1816,word_search.py::insert_south::176,"    def insert_south(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_south(""cat"", [0], [0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [['c', None, None],
        ['a', None, None],
        ['t', None, None]]
        >>> ws.insert_south(""at"", [2, 1, 0], [0, 1, 2])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [['c', None, None],
        ['a', 'a', None],
        ['t', 't', None]]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Check if there is space below the row to fit in the word
            if word_length + row > self.height:
                continue

            # Attempt to insert the word into each column
            for col in cols:
                # Only check to be made here is if there are existing letters
                # below the column that will be overwritten
                letters_below = [self.board[row + i][col] for i in range(word_length)]
                if all(letter is None for letter in letters_below):
                    # Successful, insert the word south
                    for i in range(word_length):
                        self.board[row + i][col] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_south,331
1817,word_search.py::insert_southwest::208,"    def insert_southwest(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_southwest(""cat"", [0], [2])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, None, 'c'],
        [None, 'a', None],
        ['t', None, None]]
        >>> ws.insert_southwest(""at"", [1, 2], [2, 1, 0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, None, 'c'],
        [None, 'a', 'a'],
        ['t', 't', None]]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Check if there is space for the word below the row
            if word_length + row > self.height:
                continue

            # Attempt to insert the word into each column
            for col in cols:
                # Check if there is space to the left of the word as well as below
                if word_length > col + 1:
                    continue

                # Check if there are existing letters
                # to the right of the column that will be overwritten
                letters_diagonal_left = [
                    self.board[row + i][col - i] for i in range(word_length)
                ]
                if all(letter is None for letter in letters_diagonal_left):
                    # Successful, insert the word southwest
                    for i in range(word_length):
                        self.board[row + i][col - i] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_southwest,372
1818,word_search.py::insert_west::246,"    def insert_west(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_west(""cat"", [1], [2])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [[None, None, None],
        ['t', 'a', 'c'],
        [None, None, None]]
        >>> ws.insert_west(""at"", [1, 0], [1, 2, 0])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [['t', 'a', None],
        ['t', 'a', 'c'],
        [None, None, None]]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Attempt to insert the word into each column
            for col in cols:
                # Check if there is space to the left of the word
                if word_length > col + 1:
                    continue

                # Check if there are existing letters
                # to the left of the column that will be overwritten
                letters_left = [self.board[row][col - i] for i in range(word_length)]
                if all(letter is None for letter in letters_left):
                    # Successful, insert the word west
                    for i in range(word_length):
                        self.board[row][col - i] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_west,326
1819,word_search.py::insert_northwest::278,"    def insert_northwest(self, word: str, rows: list[int], cols: list[int]) -> None:
        """"""
        >>> ws = WordSearch(WORDS, 3, 3)
        >>> ws.insert_northwest(""cat"", [2], [2])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [['t', None, None],
        [None, 'a', None],
        [None, None, 'c']]
        >>> ws.insert_northwest(""at"", [1, 2], [0, 1])
        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE
        [['t', None, None],
        ['t', 'a', None],
        [None, 'a', 'c']]
        """"""
        word_length = len(word)
        # Attempt to insert the word into each row and when successful, exit
        for row in rows:
            # Check if there is space for the word above the row
            if word_length > row + 1:
                continue

            # Attempt to insert the word into each column
            for col in cols:
                # Check if there is space to the left of the word as well as above
                if word_length > col + 1:
                    continue

                # Check if there are existing letters
                # to the right of the column that will be overwritten
                letters_diagonal_left = [
                    self.board[row - i][col - i] for i in range(word_length)
                ]
                if all(letter is None for letter in letters_diagonal_left):
                    # Successful, insert the word northwest
                    for i in range(word_length):
                        self.board[row - i][col - i] = word[i]
                    return",data\repos\Python\other\word_search.py,insert_northwest,368
1820,word_search.py::generate_board::316,"    def generate_board(self) -> None:
        """"""
        Generates a board with a random direction for each word.

        >>> wt = WordSearch(WORDS, WIDTH, HEIGHT)
        >>> wt.generate_board()
        >>> len(list(filter(lambda word: word is not None, sum(wt.board, start=[])))
        ... ) == sum(map(lambda word: len(word), WORDS))
        True
        """"""
        directions = (
            self.insert_north,
            self.insert_northeast,
            self.insert_east,
            self.insert_southeast,
            self.insert_south,
            self.insert_southwest,
            self.insert_west,
            self.insert_northwest,
        )
        for word in self.words:
            # Shuffle the row order and column order that is used when brute forcing
            # the insertion of the word
            rows, cols = list(range(self.height)), list(range(self.width))
            shuffle(rows)
            shuffle(cols)

            # Insert the word via the direction
            choice(directions)(word, rows, cols)",data\repos\Python\other\word_search.py,generate_board,215
1821,altitude_pressure.py::get_altitude_at_pressure::11,"def get_altitude_at_pressure(pressure: float) -> float:
    """"""
    This method calculates the altitude from Pressure wrt to
    Sea level pressure as reference .Pressure is in Pascals
    https://en.wikipedia.org/wiki/Pressure_altitude
    https://community.bosch-sensortec.com/t5/Question-and-answers/How-to-calculate-the-altitude-from-the-pressure-sensor-data/qaq-p/5702

    H = 44330 * [1 - (P/p0)^(1/5.255) ]

    Where :
    H = altitude (m)
    P = measured pressure
    p0 = reference pressure at sea level 101325 Pa

    Examples:
    >>> get_altitude_at_pressure(pressure=100_000)
    105.47836610778828
    >>> get_altitude_at_pressure(pressure=101_325)
    0.0
    >>> get_altitude_at_pressure(pressure=80_000)
    1855.873388064995
    >>> get_altitude_at_pressure(pressure=201_325)
    Traceback (most recent call last):
      ...
    ValueError: Value Higher than Pressure at Sea Level !
    >>> get_altitude_at_pressure(pressure=-80_000)
    Traceback (most recent call last):
      ...
    ValueError: Atmospheric Pressure can not be negative !
    """"""

    if pressure > 101325:
        raise ValueError(""Value Higher than Pressure at Sea Level !"")
    if pressure < 0:
        raise ValueError(""Atmospheric Pressure can not be negative !"")
    return 44_330 * (1 - (pressure / 101_325) ** (1 / 5.5255))",data\repos\Python\physics\altitude_pressure.py,get_altitude_at_pressure,368
1822,archimedes_principle_of_buoyant_force.py::archimedes_principle::15,"def archimedes_principle(
    fluid_density: float, volume: float, gravity: float = g
) -> float:
    """"""
    Args:
        fluid_density: density of fluid (kg/m^3)
        volume: volume of object/liquid being displaced by the object (m^3)
        gravity: Acceleration from gravity. Gravitational force on the system,
            The default is Earth Gravity
    returns:
        the buoyant force on an object in Newtons

    >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)
    19600.0
    >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)
    4885.3
    >>> archimedes_principle(fluid_density=997, volume=0.7)
    6844.061035
    >>> archimedes_principle(fluid_density=997, volume=-0.7)
    Traceback (most recent call last):
        ...
    ValueError: Impossible object volume
    >>> archimedes_principle(fluid_density=0, volume=0.7)
    Traceback (most recent call last):
        ...
    ValueError: Impossible fluid density
    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)
    0.0
    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)
    Traceback (most recent call last):
        ...
    ValueError: Impossible gravity
    """"""

    if fluid_density <= 0:
        raise ValueError(""Impossible fluid density"")
    if volume <= 0:
        raise ValueError(""Impossible object volume"")
    if gravity < 0:
        raise ValueError(""Impossible gravity"")

    return fluid_density * gravity * volume",data\repos\Python\physics\archimedes_principle_of_buoyant_force.py,archimedes_principle,390
1823,basic_orbital_capture.py::capture_radii::20,"def capture_radii(
    target_body_radius: float, target_body_mass: float, projectile_velocity: float
) -> float:
    """"""
    Input Params:
    -------------
    target_body_radius: Radius of the central body SI units: meters | m
    target_body_mass: Mass of the central body SI units: kilograms | kg
    projectile_velocity: Velocity of object moving toward central body
        SI units: meters/second | m/s
    Returns:
    --------
    >>> capture_radii(6.957e8, 1.99e30, 25000.0)
    17209590691.0
    >>> capture_radii(-6.957e8, 1.99e30, 25000.0)
    Traceback (most recent call last):
        ...
    ValueError: Radius cannot be less than 0
    >>> capture_radii(6.957e8, -1.99e30, 25000.0)
    Traceback (most recent call last):
        ...
    ValueError: Mass cannot be less than 0
    >>> capture_radii(6.957e8, 1.99e30, c+1)
    Traceback (most recent call last):
        ...
    ValueError: Cannot go beyond speed of light

    Returned SI units:
    ------------------
    meters | m
    """"""

    if target_body_mass < 0:
        raise ValueError(""Mass cannot be less than 0"")
    if target_body_radius < 0:
        raise ValueError(""Radius cannot be less than 0"")
    if projectile_velocity > c:
        raise ValueError(""Cannot go beyond speed of light"")

    escape_velocity_squared = (2 * G * target_body_mass) / target_body_radius
    capture_radius = target_body_radius * sqrt(
        1 + escape_velocity_squared / pow(projectile_velocity, 2)
    )
    return round(capture_radius, 0)",data\repos\Python\physics\basic_orbital_capture.py,capture_radii,402
1824,basic_orbital_capture.py::capture_area::66,"def capture_area(capture_radius: float) -> float:
    """"""
    Input Param:
    ------------
    capture_radius: The radius of orbital capture and impact for a central body of
    mass M and a projectile moving towards it with velocity v
        SI units: meters | m
    Returns:
    --------
    >>> capture_area(17209590691)
    9.304455331329126e+20
    >>> capture_area(-1)
    Traceback (most recent call last):
        ...
    ValueError: Cannot have a capture radius less than 0

    Returned SI units:
    ------------------
    meters*meters | m**2
    """"""

    if capture_radius < 0:
        raise ValueError(""Cannot have a capture radius less than 0"")
    sigma = pi * pow(capture_radius, 2)
    return round(sigma, 0)",data\repos\Python\physics\basic_orbital_capture.py,capture_area,180
1825,casimir_effect.py::casimir_force::49,"def casimir_force(force: float, area: float, distance: float) -> dict[str, float]:
    """"""
    Input Parameters
    ----------------
    force -> Casimir Force : magnitude in Newtons

    area -> Surface area of each plate : magnitude in square meters

    distance -> Distance between two plates : distance in Meters

    Returns
    -------
    result : dict name, value pair of the parameter having Zero as it's value

    Returns the value of one of the parameters specified as 0, provided the values of
    other parameters are given.
    >>> casimir_force(force = 0, area = 4, distance = 0.03)
    {'force': 6.4248189174864216e-21}

    >>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)
    {'distance': 1.0323056015031114e-05}

    >>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)
    {'area': 0.06688838837354052}

    >>> casimir_force(force = 3457e-12, area = 0, distance = 0)
    Traceback (most recent call last):
        ...
    ValueError: One and only one argument must be 0

    >>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)
    Traceback (most recent call last):
        ...
    ValueError: Distance can not be negative

    >>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)
    Traceback (most recent call last):
        ...
    ValueError: Magnitude of force can not be negative
    """"""

    if (force, area, distance).count(0) != 1:
        raise ValueError(""One and only one argument must be 0"")
    if force < 0:
        raise ValueError(""Magnitude of force can not be negative"")
    if distance < 0:
        raise ValueError(""Distance can not be negative"")
    if area < 0:
        raise ValueError(""Area can not be negative"")
    if force == 0:
        force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (
            240 * (distance) ** 4
        )
        return {""force"": force}
    elif area == 0:
        area = (240 * force * (distance) ** 4) / (
            REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2
        )
        return {""area"": area}
    elif distance == 0:
        distance = (
            (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)
        ) ** (1 / 4)
        return {""distance"": distance}
    raise ValueError(""One and only one argument must be 0"")",data\repos\Python\physics\casimir_effect.py,casimir_force,638
1826,center_of_mass.py::center_of_mass::34,"def center_of_mass(particles: list[Particle]) -> Coord3D:
    """"""
    Input Parameters
    ----------------
    particles: list(Particle):
    A list of particles where each particle is a tuple with it's (x, y, z) position and
    it's mass.

    Returns
    -------
    Coord3D:
    A tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two
    decimal places.

    Examples
    --------
    >>> center_of_mass([
    ...     Particle(1.5, 4, 3.4, 4),
    ...     Particle(5, 6.8, 7, 8.1),
    ...     Particle(9.4, 10.1, 11.6, 12)
    ... ])
    Coord3D(x=6.61, y=7.98, z=8.69)

    >>> center_of_mass([
    ...     Particle(1, 2, 3, 4),
    ...     Particle(5, 6, 7, 8),
    ...     Particle(9, 10, 11, 12)
    ... ])
    Coord3D(x=6.33, y=7.33, z=8.33)

    >>> center_of_mass([
    ...     Particle(1, 2, 3, -4),
    ...     Particle(5, 6, 7, 8),
    ...     Particle(9, 10, 11, 12)
    ... ])
    Traceback (most recent call last):
        ...
    ValueError: Mass of all particles must be greater than 0

    >>> center_of_mass([
    ...     Particle(1, 2, 3, 0),
    ...     Particle(5, 6, 7, 8),
    ...     Particle(9, 10, 11, 12)
    ... ])
    Traceback (most recent call last):
        ...
    ValueError: Mass of all particles must be greater than 0

    >>> center_of_mass([])
    Traceback (most recent call last):
        ...
    ValueError: No particles provided
    """"""
    if not particles:
        raise ValueError(""No particles provided"")

    if any(particle.mass <= 0 for particle in particles):
        raise ValueError(""Mass of all particles must be greater than 0"")

    total_mass = sum(particle.mass for particle in particles)

    center_of_mass_x = round(
        sum(particle.x * particle.mass for particle in particles) / total_mass, 2
    )
    center_of_mass_y = round(
        sum(particle.y * particle.mass for particle in particles) / total_mass, 2
    )
    center_of_mass_z = round(
        sum(particle.z * particle.mass for particle in particles) / total_mass, 2
    )
    return Coord3D(center_of_mass_x, center_of_mass_y, center_of_mass_z)",data\repos\Python\physics\center_of_mass.py,center_of_mass,632
1827,centripetal_force.py::centripetal::24,"def centripetal(mass: float, velocity: float, radius: float) -> float:
    """"""
    The Centripetal Force formula is given as: (m*v*v)/r

    >>> round(centripetal(15.5,-30,10),2)
    1395.0
    >>> round(centripetal(10,15,5),2)
    450.0
    >>> round(centripetal(20,-50,15),2)
    3333.33
    >>> round(centripetal(12.25,40,25),2)
    784.0
    >>> round(centripetal(50,100,50),2)
    10000.0
    """"""
    if mass < 0:
        raise ValueError(""The mass of the body cannot be negative"")
    if radius <= 0:
        raise ValueError(""The radius is always a positive non zero integer"")
    return (mass * (velocity) ** 2) / radius",data\repos\Python\physics\centripetal_force.py,centripetal,214
1828,coulombs_law.py::coulombs_law::18,"def coulombs_law(q1: float, q2: float, radius: float) -> float:
    """"""
    Calculate the electrostatic force of attraction or repulsion
    between two point charges

    >>> coulombs_law(15.5, 20, 15)
    12382849136.06
    >>> coulombs_law(1, 15, 5)
    5392531075.38
    >>> coulombs_law(20, -50, 15)
    -39944674632.44
    >>> coulombs_law(-5, -8, 10)
    3595020716.92
    >>> coulombs_law(50, 100, 50)
    17975103584.6
    """"""
    if radius <= 0:
        raise ValueError(""The radius is always a positive number"")
    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)",data\repos\Python\physics\coulombs_law.py,coulombs_law,223
1829,doppler_frequency.py::doppler_effect::47,"def doppler_effect(
    org_freq: float, wave_vel: float, obs_vel: float, src_vel: float
) -> float:
    """"""
    Input Parameters:
    -----------------
    org_freq: frequency of the wave when the source is stationary
    wave_vel: velocity of the wave in the medium
    obs_vel: velocity of the observer, +ve if the observer is moving towards the source
    src_vel: velocity of the source, +ve if the source is moving towards the observer

    Returns:
    --------
    f: frequency of the wave as perceived by the observer

    Docstring Tests:
    >>> doppler_effect(100, 330, 10, 0)  # observer moving towards the source
    103.03030303030303
    >>> doppler_effect(100, 330, -10, 0)  # observer moving away from the source
    96.96969696969697
    >>> doppler_effect(100, 330, 0, 10)  # source moving towards the observer
    103.125
    >>> doppler_effect(100, 330, 0, -10)  # source moving away from the observer
    97.05882352941177
    >>> doppler_effect(100, 330, 10, 10)  # source & observer moving towards each other
    106.25
    >>> doppler_effect(100, 330, -10, -10)  # source and observer moving away
    94.11764705882354
    >>> doppler_effect(100, 330, 10, 330)  # source moving at same speed as the wave
    Traceback (most recent call last):
        ...
    ZeroDivisionError: Division by zero implies vs=v and observer in front of the source
    >>> doppler_effect(100, 330, 10, 340)  # source moving faster than the wave
    Traceback (most recent call last):
        ...
    ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)
    >>> doppler_effect(100, 330, -340, 10)  # observer moving faster than the wave
    Traceback (most recent call last):
        ...
    ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)
    """"""

    if wave_vel == src_vel:
        raise ZeroDivisionError(
            ""Division by zero implies vs=v and observer in front of the source""
        )
    doppler_freq = (org_freq * (wave_vel + obs_vel)) / (wave_vel - src_vel)
    if doppler_freq <= 0:
        raise ValueError(
            ""Non-positive frequency implies vs>v or v0>v (in the opposite direction)""
        )
    return doppler_freq",data\repos\Python\physics\doppler_frequency.py,doppler_effect,600
1830,escape_velocity.py::escape_velocity::4,"def escape_velocity(mass: float, radius: float) -> float:
    """"""
    Calculates the escape velocity needed to break free from a celestial body's
    gravitational field.

    The formula used is:
        v = sqrt(2 * G * M / R)

    where:
        v = escape velocity (m/s)
        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)
        M = mass of the celestial body (kg)
        R = radius from the center of mass (m)

    Source:
        https://en.wikipedia.org/wiki/Escape_velocity

    Args:
        mass (float): Mass of the celestial body in kilograms.
        radius (float): Radius from the center of mass in meters.

    Returns:
        float: Escape velocity in meters per second, rounded to 3 decimal places.

    Examples:
        >>> escape_velocity(mass=5.972e24, radius=6.371e6)  # Earth
        11185.978
        >>> escape_velocity(mass=7.348e22, radius=1.737e6)  # Moon
        2376.307
        >>> escape_velocity(mass=1.898e27, radius=6.9911e7)  # Jupiter
        60199.545
        >>> escape_velocity(mass=0, radius=1.0)
        0.0
        >>> escape_velocity(mass=1.0, radius=0)
        Traceback (most recent call last):
            ...
        ZeroDivisionError: Radius cannot be zero.
    """"""
    gravitational_constant = 6.67430e-11  # m^3 kg^-1 s^-2

    if radius == 0:
        raise ZeroDivisionError(""Radius cannot be zero."")

    velocity = math.sqrt(2 * gravitational_constant * mass / radius)
    return round(velocity, 3)",data\repos\Python\physics\escape_velocity.py,escape_velocity,404
1831,grahams_law.py::validate::20,"def validate(*values: float) -> bool:
    """"""
    Input Parameters:
    -----------------
    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)
    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)
    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

    Returns:
    --------
    >>> validate(2.016, 4.002)
    True
    >>> validate(-2.016, 4.002)
    False
    >>> validate()
    False
    """"""
    result = len(values) > 0 and all(value > 0.0 for value in values)
    return result",data\repos\Python\physics\grahams_law.py,validate,192
1832,grahams_law.py::effusion_ratio::42,"def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:
    """"""
    Input Parameters:
    -----------------
    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

    Returns:
    --------
    >>> effusion_ratio(2.016, 4.002)
    1.408943
    >>> effusion_ratio(-2.016, 4.002)
    ValueError('Input Error: Molar mass values must greater than 0.')
    >>> effusion_ratio(2.016)
    Traceback (most recent call last):
      ...
    TypeError: effusion_ratio() missing 1 required positional argument: 'molar_mass_2'
    """"""
    return (
        round(sqrt(molar_mass_2 / molar_mass_1), 6)
        if validate(molar_mass_1, molar_mass_2)
        else ValueError(""Input Error: Molar mass values must greater than 0."")
    )",data\repos\Python\physics\grahams_law.py,effusion_ratio,239
1833,grahams_law.py::first_effusion_rate::67,"def first_effusion_rate(
    effusion_rate: float, molar_mass_1: float, molar_mass_2: float
) -> float | ValueError:
    """"""
    Input Parameters:
    -----------------
    effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)
    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

    Returns:
    --------
    >>> first_effusion_rate(1, 2.016, 4.002)
    1.408943
    >>> first_effusion_rate(-1, 2.016, 4.002)
    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
    >>> first_effusion_rate(1)
    Traceback (most recent call last):
      ...
    TypeError: first_effusion_rate() missing 2 required positional arguments: \
'molar_mass_1' and 'molar_mass_2'
    >>> first_effusion_rate(1, 2.016)
    Traceback (most recent call last):
      ...
    TypeError: first_effusion_rate() missing 1 required positional argument: \
'molar_mass_2'
    """"""
    return (
        round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)
        if validate(effusion_rate, molar_mass_1, molar_mass_2)
        else ValueError(
            ""Input Error: Molar mass and effusion rate values must greater than 0.""
        )
    )",data\repos\Python\physics\grahams_law.py,first_effusion_rate,359
1834,grahams_law.py::second_effusion_rate::103,"def second_effusion_rate(
    effusion_rate: float, molar_mass_1: float, molar_mass_2: float
) -> float | ValueError:
    """"""
    Input Parameters:
    -----------------
    effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)
    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

    Returns:
    --------
    >>> second_effusion_rate(1, 2.016, 4.002)
    0.709752
    >>> second_effusion_rate(-1, 2.016, 4.002)
    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
    >>> second_effusion_rate(1)
    Traceback (most recent call last):
      ...
    TypeError: second_effusion_rate() missing 2 required positional arguments: \
'molar_mass_1' and 'molar_mass_2'
    >>> second_effusion_rate(1, 2.016)
    Traceback (most recent call last):
      ...
    TypeError: second_effusion_rate() missing 1 required positional argument: \
'molar_mass_2'
    """"""
    return (
        round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)
        if validate(effusion_rate, molar_mass_1, molar_mass_2)
        else ValueError(
            ""Input Error: Molar mass and effusion rate values must greater than 0.""
        )
    )",data\repos\Python\physics\grahams_law.py,second_effusion_rate,359
1835,grahams_law.py::first_molar_mass::139,"def first_molar_mass(
    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float
) -> float | ValueError:
    """"""
    Input Parameters:
    -----------------
    molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)
    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)
    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)

    Returns:
    --------
    >>> first_molar_mass(2, 1.408943, 0.709752)
    0.507524
    >>> first_molar_mass(-1, 2.016, 4.002)
    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
    >>> first_molar_mass(1)
    Traceback (most recent call last):
      ...
    TypeError: first_molar_mass() missing 2 required positional arguments: \
'effusion_rate_1' and 'effusion_rate_2'
    >>> first_molar_mass(1, 2.016)
    Traceback (most recent call last):
      ...
    TypeError: first_molar_mass() missing 1 required positional argument: \
'effusion_rate_2'
    """"""
    return (
        round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)
        if validate(molar_mass, effusion_rate_1, effusion_rate_2)
        else ValueError(
            ""Input Error: Molar mass and effusion rate values must greater than 0.""
        )
    )",data\repos\Python\physics\grahams_law.py,first_molar_mass,368
1836,grahams_law.py::second_molar_mass::175,"def second_molar_mass(
    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float
) -> float | ValueError:
    """"""
    Input Parameters:
    -----------------
    molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)
    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)
    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)

    Returns:
    --------
    >>> second_molar_mass(2, 1.408943, 0.709752)
    1.970351
    >>> second_molar_mass(-2, 1.408943, 0.709752)
    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
    >>> second_molar_mass(1)
    Traceback (most recent call last):
      ...
    TypeError: second_molar_mass() missing 2 required positional arguments: \
'effusion_rate_1' and 'effusion_rate_2'
    >>> second_molar_mass(1, 2.016)
    Traceback (most recent call last):
      ...
    TypeError: second_molar_mass() missing 1 required positional argument: \
'effusion_rate_2'
    """"""
    return (
        round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)
        if validate(molar_mass, effusion_rate_1, effusion_rate_2)
        else ValueError(
            ""Input Error: Molar mass and effusion rate values must greater than 0.""
        )
    )",data\repos\Python\physics\grahams_law.py,second_molar_mass,371
1837,horizontal_projectile_motion.py::check_args::27,"def check_args(init_velocity: float, angle: float) -> None:
    """"""
    Check that the arguments are valid
    """"""

    # Ensure valid instance
    if not isinstance(init_velocity, (int, float)):
        raise TypeError(""Invalid velocity. Should be an integer or float."")

    if not isinstance(angle, (int, float)):
        raise TypeError(""Invalid angle. Should be an integer or float."")

    # Ensure valid angle
    if angle > 90 or angle < 1:
        raise ValueError(""Invalid angle. Range is 1-90 degrees."")

    # Ensure valid velocity
    if init_velocity < 0:
        raise ValueError(""Invalid velocity. Should be a positive number."")",data\repos\Python\physics\horizontal_projectile_motion.py,check_args,144
1838,horizontal_projectile_motion.py::horizontal_distance::48,"def horizontal_distance(init_velocity: float, angle: float) -> float:
    r""""""
    Returns the horizontal distance that the object cover

    Formula:
        .. math::
            \frac{v_0^2 \cdot \sin(2 \alpha)}{g}

            v_0 - \text{initial velocity}

            \alpha - \text{angle}

    >>> horizontal_distance(30, 45)
    91.77
    >>> horizontal_distance(100, 78)
    414.76
    >>> horizontal_distance(-1, 20)
    Traceback (most recent call last):
        ...
    ValueError: Invalid velocity. Should be a positive number.
    >>> horizontal_distance(30, -20)
    Traceback (most recent call last):
        ...
    ValueError: Invalid angle. Range is 1-90 degrees.
    """"""
    check_args(init_velocity, angle)
    radians = deg_to_rad(2 * angle)
    return round(init_velocity**2 * sin(radians) / g, 2)",data\repos\Python\physics\horizontal_projectile_motion.py,horizontal_distance,215
1839,horizontal_projectile_motion.py::max_height::78,"def max_height(init_velocity: float, angle: float) -> float:
    r""""""
    Returns the maximum height that the object reach

    Formula:
        .. math::
            \frac{v_0^2 \cdot \sin^2 (\alpha)}{2 g}

            v_0 - \text{initial velocity}

            \alpha - \text{angle}

    >>> max_height(30, 45)
    22.94
    >>> max_height(100, 78)
    487.82
    >>> max_height(""a"", 20)
    Traceback (most recent call last):
        ...
    TypeError: Invalid velocity. Should be an integer or float.
    >>> horizontal_distance(30, ""b"")
    Traceback (most recent call last):
        ...
    TypeError: Invalid angle. Should be an integer or float.
    """"""
    check_args(init_velocity, angle)
    radians = deg_to_rad(angle)
    return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)",data\repos\Python\physics\horizontal_projectile_motion.py,max_height,219
1840,horizontal_projectile_motion.py::total_time::108,"def total_time(init_velocity: float, angle: float) -> float:
    r""""""
    Returns total time of the motion

    Formula:
        .. math::
            \frac{2 v_0 \cdot \sin (\alpha)}{g}

            v_0 - \text{initial velocity}

            \alpha - \text{angle}

    >>> total_time(30, 45)
    4.33
    >>> total_time(100, 78)
    19.95
    >>> total_time(-10, 40)
    Traceback (most recent call last):
        ...
    ValueError: Invalid velocity. Should be a positive number.
    >>> total_time(30, ""b"")
    Traceback (most recent call last):
        ...
    TypeError: Invalid angle. Should be an integer or float.
    """"""
    check_args(init_velocity, angle)
    radians = deg_to_rad(angle)
    return round(2 * init_velocity * sin(radians) / g, 2)",data\repos\Python\physics\horizontal_projectile_motion.py,total_time,207
1841,horizontal_projectile_motion.py::test_motion::138,"def test_motion() -> None:
    """"""
    Test motion

    >>> test_motion()
    """"""
    v0, angle = 25, 20
    assert horizontal_distance(v0, angle) == 40.97
    assert max_height(v0, angle) == 3.73
    assert total_time(v0, angle) == 1.74",data\repos\Python\physics\horizontal_projectile_motion.py,test_motion,76
1842,hubble_parameter.py::hubble_parameter::30,"def hubble_parameter(
    hubble_constant: float,
    radiation_density: float,
    matter_density: float,
    dark_energy: float,
    redshift: float,
) -> float:
    """"""
    Input Parameters
    ----------------
    hubble_constant: Hubble constante is the expansion rate today usually
    given in km/(s*Mpc)

    radiation_density: relative radiation density today

    matter_density: relative mass density today

    dark_energy: relative dark energy density today

    redshift: the light redshift

    Returns
    -------
    result : Hubble parameter in and the unit km/s/Mpc (the unit can be
    changed if you want, just need to change the unit of the Hubble constant)

    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,
    ... matter_density=-0.3, dark_energy=0.7, redshift=1)
    Traceback (most recent call last):
    ...
    ValueError: All input parameters must be positive

    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,
    ... matter_density= 1.2, dark_energy=0.7, redshift=1)
    Traceback (most recent call last):
    ...
    ValueError: Relative densities cannot be greater than one

    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,
    ... matter_density= 0.3, dark_energy=0.7, redshift=0)
    68.3
    """"""
    parameters = [redshift, radiation_density, matter_density, dark_energy]
    if any(p < 0 for p in parameters):
        raise ValueError(""All input parameters must be positive"")

    if any(p > 1 for p in parameters[1:4]):
        raise ValueError(""Relative densities cannot be greater than one"")
    else:
        curvature = 1 - (matter_density + radiation_density + dark_energy)

        e_2 = (
            radiation_density * (redshift + 1) ** 4
            + matter_density * (redshift + 1) ** 3
            + curvature * (redshift + 1) ** 2
            + dark_energy
        )

        hubble = hubble_constant * e_2 ** (1 / 2)
        return hubble",data\repos\Python\physics\hubble_parameter.py,hubble_parameter,500
1843,ideal_gas_law.py::pressure_of_gas_system::24,"def pressure_of_gas_system(moles: float, kelvin: float, volume: float) -> float:
    """"""
    >>> pressure_of_gas_system(2, 100, 5)
    332.57848
    >>> pressure_of_gas_system(0.5, 273, 0.004)
    283731.01575
    >>> pressure_of_gas_system(3, -0.46, 23.5)
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter positive value.
    """"""
    if moles < 0 or kelvin < 0 or volume < 0:
        raise ValueError(""Invalid inputs. Enter positive value."")
    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / volume",data\repos\Python\physics\ideal_gas_law.py,pressure_of_gas_system,160
1844,ideal_gas_law.py::volume_of_gas_system::40,"def volume_of_gas_system(moles: float, kelvin: float, pressure: float) -> float:
    """"""
    >>> volume_of_gas_system(2, 100, 5)
    332.57848
    >>> volume_of_gas_system(0.5, 273, 0.004)
    283731.01575
    >>> volume_of_gas_system(3, -0.46, 23.5)
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter positive value.
    """"""
    if moles < 0 or kelvin < 0 or pressure < 0:
        raise ValueError(""Invalid inputs. Enter positive value."")
    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / pressure",data\repos\Python\physics\ideal_gas_law.py,volume_of_gas_system,160
1845,ideal_gas_law.py::temperature_of_gas_system::56,"def temperature_of_gas_system(moles: float, volume: float, pressure: float) -> float:
    """"""
    >>> temperature_of_gas_system(2, 100, 5)
    30.068090996146232
    >>> temperature_of_gas_system(11, 5009, 1000)
    54767.66101807144
    >>> temperature_of_gas_system(3, -0.46, 23.5)
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter positive value.
    """"""
    if moles < 0 or volume < 0 or pressure < 0:
        raise ValueError(""Invalid inputs. Enter positive value."")

    return pressure * volume / (moles * UNIVERSAL_GAS_CONSTANT)",data\repos\Python\physics\ideal_gas_law.py,temperature_of_gas_system,162
1846,ideal_gas_law.py::moles_of_gas_system::73,"def moles_of_gas_system(kelvin: float, volume: float, pressure: float) -> float:
    """"""
    >>> moles_of_gas_system(100, 5, 10)
    0.06013618199229246
    >>> moles_of_gas_system(110, 5009, 1000)
    5476.766101807144
    >>> moles_of_gas_system(3, -0.46, 23.5)
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter positive value.
    """"""
    if kelvin < 0 or volume < 0 or pressure < 0:
        raise ValueError(""Invalid inputs. Enter positive value."")

    return pressure * volume / (kelvin * UNIVERSAL_GAS_CONSTANT)",data\repos\Python\physics\ideal_gas_law.py,moles_of_gas_system,168
1847,in_static_equilibrium.py::polar_force::11,"def polar_force(
    magnitude: float, angle: float, radian_mode: bool = False
) -> list[float]:
    """"""
    Resolves force along rectangular components.
    (force, angle) => (force_x, force_y)
    >>> import math
    >>> force = polar_force(10, 45)
    >>> math.isclose(force[0], 7.071067811865477)
    True
    >>> math.isclose(force[1], 7.0710678118654755)
    True
    >>> force = polar_force(10, 3.14, radian_mode=True)
    >>> math.isclose(force[0], -9.999987317275396)
    True
    >>> math.isclose(force[1], 0.01592652916486828)
    True
    """"""
    if radian_mode:
        return [magnitude * cos(angle), magnitude * sin(angle)]
    return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]",data\repos\Python\physics\in_static_equilibrium.py,polar_force,210
1848,in_static_equilibrium.py::in_static_equilibrium::34,"def in_static_equilibrium(
    forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1
) -> bool:
    """"""
    Check if a system is in equilibrium.
    It takes two numpy.array objects.
    forces ==>  [
                        [force1_x, force1_y],
                        [force2_x, force2_y],
                        ....]
    location ==>  [
                        [x1, y1],
                        [x2, y2],
                        ....]
    >>> force = array([[1, 1], [-1, 2]])
    >>> location = array([[1, 0], [10, 0]])
    >>> in_static_equilibrium(force, location)
    False
    """"""
    # summation of moments is zero
    moments: NDArray[float64] = cross(location, forces)
    sum_moments: float = sum(moments)
    return bool(abs(sum_moments) < eps)",data\repos\Python\physics\in_static_equilibrium.py,in_static_equilibrium,203
1849,kinetic_energy.py::kinetic_energy::21,"def kinetic_energy(mass: float, velocity: float) -> float:
    """"""
    Calculate kinetic energy.

    The kinetic energy of a non-rotating object of mass m traveling at a speed v is mv

    >>> kinetic_energy(10,10)
    500.0
    >>> kinetic_energy(0,10)
    0.0
    >>> kinetic_energy(10,0)
    0.0
    >>> kinetic_energy(20,-20)
    4000.0
    >>> kinetic_energy(0,0)
    0.0
    >>> kinetic_energy(2,2)
    4.0
    >>> kinetic_energy(100,100)
    500000.0
    """"""
    if mass < 0:
        raise ValueError(""The mass of a body cannot be negative"")
    return 0.5 * mass * abs(velocity) * abs(velocity)",data\repos\Python\physics\kinetic_energy.py,kinetic_energy,194
1850,lens_formulae.py::focal_length_of_lens::51,"def focal_length_of_lens(
    object_distance_from_lens: float, image_distance_from_lens: float
) -> float:
    """"""
    Doctests:
    >>> from math import isclose
    >>> isclose(focal_length_of_lens(10,4), 6.666666666666667)
    True
    >>> from math import isclose
    >>> isclose(focal_length_of_lens(2.7,5.8), -5.0516129032258075)
    True
    >>> focal_length_of_lens(0, 20)  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter non zero values with respect
    to the sign convention.
    """"""

    if object_distance_from_lens == 0 or image_distance_from_lens == 0:
        raise ValueError(
            ""Invalid inputs. Enter non zero values with respect to the sign convention.""
        )
    focal_length = 1 / (
        (1 / image_distance_from_lens) - (1 / object_distance_from_lens)
    )
    return focal_length",data\repos\Python\physics\lens_formulae.py,focal_length_of_lens,233
1851,lens_formulae.py::object_distance::79,"def object_distance(
    focal_length_of_lens: float, image_distance_from_lens: float
) -> float:
    """"""
    Doctests:
    >>> from math import isclose
    >>> isclose(object_distance(10,40), -13.333333333333332)
    True

    >>> from math import isclose
    >>> isclose(object_distance(6.2,1.5), 1.9787234042553192)
    True

    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter non zero values with respect
    to the sign convention.
    """"""

    if image_distance_from_lens == 0 or focal_length_of_lens == 0:
        raise ValueError(
            ""Invalid inputs. Enter non zero values with respect to the sign convention.""
        )

    object_distance = 1 / ((1 / image_distance_from_lens) - (1 / focal_length_of_lens))
    return object_distance",data\repos\Python\physics\lens_formulae.py,object_distance,219
1852,lens_formulae.py::image_distance::108,"def image_distance(
    focal_length_of_lens: float, object_distance_from_lens: float
) -> float:
    """"""
    Doctests:
    >>> from math import isclose
    >>> isclose(image_distance(50,40), 22.22222222222222)
    True
    >>> from math import isclose
    >>> isclose(image_distance(5.3,7.9), 3.1719696969696973)
    True

    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter non zero values with respect
    to the sign convention.
    """"""
    if object_distance_from_lens == 0 or focal_length_of_lens == 0:
        raise ValueError(
            ""Invalid inputs. Enter non zero values with respect to the sign convention.""
        )
    image_distance = 1 / ((1 / object_distance_from_lens) + (1 / focal_length_of_lens))
    return image_distance",data\repos\Python\physics\lens_formulae.py,image_distance,219
1853,lorentz_transformation_four_vector.py::beta::41,"def beta(velocity: float) -> float:
    """"""
    Calculates  = v/c, the given velocity as a fraction of c
    >>> beta(c)
    1.0
    >>> beta(199792458)
    0.666435904801848
    >>> beta(1e5)
    0.00033356409519815205
    >>> beta(0.2)
    Traceback (most recent call last):
      ...
    ValueError: Speed must be greater than or equal to 1!
    """"""
    if velocity > c:
        raise ValueError(""Speed must not exceed light speed 299,792,458 [m/s]!"")
    elif velocity < 1:
        # Usually the speed should be much higher than 1 (c order of magnitude)
        raise ValueError(""Speed must be greater than or equal to 1!"")

    return velocity / c",data\repos\Python\physics\lorentz_transformation_four_vector.py,beta,184
1854,lorentz_transformation_four_vector.py::gamma::64,"def gamma(velocity: float) -> float:
    """"""
    Calculate the Lorentz factor y = 1 / (1 - v/c) for a given velocity
    >>> gamma(4)
    1.0000000000000002
    >>> gamma(1e5)
    1.0000000556325075
    >>> gamma(3e7)
    1.005044845777813
    >>> gamma(2.8e8)
    2.7985595722318277
    >>> gamma(299792451)
    4627.49902669495
    >>> gamma(0.3)
    Traceback (most recent call last):
      ...
    ValueError: Speed must be greater than or equal to 1!
    >>> gamma(2 * c)
    Traceback (most recent call last):
      ...
    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!
    """"""
    return 1 / sqrt(1 - beta(velocity) ** 2)",data\repos\Python\physics\lorentz_transformation_four_vector.py,gamma,223
1855,lorentz_transformation_four_vector.py::transformation_matrix::89,"def transformation_matrix(velocity: float) -> np.ndarray:
    """"""
    Calculate the Lorentz transformation matrix for movement in the x direction:

    | y  -  0  0|
    |-  y   0  0|
    | 0   0   1  0|
    | 0   0   0  1|

    where y is the Lorentz factor and  is the velocity as a fraction of c
    >>> transformation_matrix(29979245)
    array([[ 1.00503781, -0.10050378,  0.        ,  0.        ],
           [-0.10050378,  1.00503781,  0.        ,  0.        ],
           [ 0.        ,  0.        ,  1.        ,  0.        ],
           [ 0.        ,  0.        ,  0.        ,  1.        ]])
    >>> transformation_matrix(19979245.2)
    array([[ 1.00222811, -0.06679208,  0.        ,  0.        ],
           [-0.06679208,  1.00222811,  0.        ,  0.        ],
           [ 0.        ,  0.        ,  1.        ,  0.        ],
           [ 0.        ,  0.        ,  0.        ,  1.        ]])
    >>> transformation_matrix(1)
    array([[ 1.00000000e+00, -3.33564095e-09,  0.00000000e+00,
             0.00000000e+00],
           [-3.33564095e-09,  1.00000000e+00,  0.00000000e+00,
             0.00000000e+00],
           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00,
             0.00000000e+00],
           [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
             1.00000000e+00]])
    >>> transformation_matrix(0)
    Traceback (most recent call last):
      ...
    ValueError: Speed must be greater than or equal to 1!
    >>> transformation_matrix(c * 1.5)
    Traceback (most recent call last):
      ...
    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!
    """"""
    return np.array(
        [
            [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],
            [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1],
        ]
    )",data\repos\Python\physics\lorentz_transformation_four_vector.py,transformation_matrix,682
1856,lorentz_transformation_four_vector.py::transform::137,"def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:
    """"""
    Calculate a Lorentz transformation for movement in the x direction given a
    velocity and a four-vector for an inertial reference frame

    If no four-vector is given, then calculate the transformation symbolically
    with variables
    >>> transform(29979245, np.array([1, 2, 3, 4]))
    array([ 3.01302757e+08, -3.01302729e+07,  3.00000000e+00,  4.00000000e+00])
    >>> transform(29979245)
    array([1.00503781498831*ct - 0.100503778816875*x,
           -0.100503778816875*ct + 1.00503781498831*x, 1.0*y, 1.0*z],
          dtype=object)
    >>> transform(19879210.2)
    array([1.0022057787097*ct - 0.066456172618675*x,
           -0.066456172618675*ct + 1.0022057787097*x, 1.0*y, 1.0*z],
          dtype=object)
    >>> transform(299792459, np.array([1, 1, 1, 1]))
    Traceback (most recent call last):
      ...
    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!
    >>> transform(-1, np.array([1, 1, 1, 1]))
    Traceback (most recent call last):
      ...
    ValueError: Speed must be greater than or equal to 1!
    """"""
    # Ensure event is not empty
    if event is None:
        event = np.array([ct, x, y, z])  # Symbolic four vector
    else:
        event[0] *= c  # x0 is ct (speed of light * time)

    return transformation_matrix(velocity) @ event",data\repos\Python\physics\lorentz_transformation_four_vector.py,transform,446
1857,malus_law.py::malus_law::40,"def malus_law(initial_intensity: float, angle: float) -> float:
    """"""
    >>> round(malus_law(10,45),2)
    5.0
    >>> round(malus_law(100,60),2)
    25.0
    >>> round(malus_law(50,150),2)
    37.5
    >>> round(malus_law(75,270),2)
    0.0
    >>> round(malus_law(10,-900),2)
    Traceback (most recent call last):
        ...
    ValueError: In Malus Law, the angle is in the range 0-360 degrees
    >>> round(malus_law(10,900),2)
    Traceback (most recent call last):
        ...
    ValueError: In Malus Law, the angle is in the range 0-360 degrees
    >>> round(malus_law(-100,900),2)
    Traceback (most recent call last):
        ...
    ValueError: The value of intensity cannot be negative
    >>> round(malus_law(100,180),2)
    100.0
    >>> round(malus_law(100,360),2)
    100.0
    """"""

    if initial_intensity < 0:
        raise ValueError(""The value of intensity cannot be negative"")
        # handling of negative values of initial intensity
    if angle < 0 or angle > 360:
        raise ValueError(""In Malus Law, the angle is in the range 0-360 degrees"")
        # handling of values out of allowed range
    return initial_intensity * (math.cos(math.radians(angle)) ** 2)",data\repos\Python\physics\malus_law.py,malus_law,356
1858,mass_energy_equivalence.py::energy_from_mass::24,"def energy_from_mass(mass: float) -> float:
    """"""
    Calculates the Energy equivalence of the Mass using E = mc
    in SI units J from Mass in kg.

    mass (float): Mass of body.

    Usage example:
    >>> energy_from_mass(124.56)
    1.11948945063458e+19
    >>> energy_from_mass(320)
    2.8760165719578165e+19
    >>> energy_from_mass(0)
    0.0
    >>> energy_from_mass(-967.9)
    Traceback (most recent call last):
        ...
    ValueError: Mass can't be negative.

    """"""
    if mass < 0:
        raise ValueError(""Mass can't be negative."")
    return mass * c**2",data\repos\Python\physics\mass_energy_equivalence.py,energy_from_mass,166
1859,mass_energy_equivalence.py::mass_from_energy::49,"def mass_from_energy(energy: float) -> float:
    """"""
    Calculates the Mass equivalence of the Energy using m = E/c
    in SI units kg from Energy in J.

    energy (float): Mass of body.

    Usage example:
    >>> mass_from_energy(124.56)
    1.3859169098203872e-15
    >>> mass_from_energy(320)
    3.560480179371579e-15
    >>> mass_from_energy(0)
    0.0
    >>> mass_from_energy(-967.9)
    Traceback (most recent call last):
        ...
    ValueError: Energy can't be negative.

    """"""
    if energy < 0:
        raise ValueError(""Energy can't be negative."")
    return energy / c**2",data\repos\Python\physics\mass_energy_equivalence.py,mass_from_energy,167
1860,mirror_formulae.py::focal_length::61,"def focal_length(distance_of_object: float, distance_of_image: float) -> float:
    """"""
    >>> from math import isclose
    >>> isclose(focal_length(10, 20), 6.66666666666666)
    True
    >>> from math import isclose
    >>> isclose(focal_length(9.5, 6.7), 3.929012346)
    True
    >>> focal_length(0, 20)  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter non zero values with respect
    to the sign convention.
    """"""

    if distance_of_object == 0 or distance_of_image == 0:
        raise ValueError(
            ""Invalid inputs. Enter non zero values with respect to the sign convention.""
        )
    focal_length = 1 / ((1 / distance_of_object) + (1 / distance_of_image))
    return focal_length",data\repos\Python\physics\mirror_formulae.py,focal_length,206
1861,mirror_formulae.py::object_distance::84,"def object_distance(focal_length: float, distance_of_image: float) -> float:
    """"""
    >>> from math import isclose
    >>> isclose(object_distance(30, 20), -60.0)
    True
    >>> from math import isclose
    >>> isclose(object_distance(10.5, 11.7), 102.375)
    True
    >>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter non zero values with respect
    to the sign convention.
    """"""

    if distance_of_image == 0 or focal_length == 0:
        raise ValueError(
            ""Invalid inputs. Enter non zero values with respect to the sign convention.""
        )
    object_distance = 1 / ((1 / focal_length) - (1 / distance_of_image))
    return object_distance",data\repos\Python\physics\mirror_formulae.py,object_distance,196
1862,mirror_formulae.py::image_distance::107,"def image_distance(focal_length: float, distance_of_object: float) -> float:
    """"""
    >>> from math import isclose
    >>> isclose(image_distance(10, 40), 13.33333333)
    True
    >>> from math import isclose
    >>> isclose(image_distance(1.5, 6.7), 1.932692308)
    True
    >>> image_distance(0, 0)  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    ValueError: Invalid inputs. Enter non zero values with respect
    to the sign convention.
    """"""

    if distance_of_object == 0 or focal_length == 0:
        raise ValueError(
            ""Invalid inputs. Enter non zero values with respect to the sign convention.""
        )
    image_distance = 1 / ((1 / focal_length) - (1 / distance_of_object))
    return image_distance",data\repos\Python\physics\mirror_formulae.py,image_distance,200
1863,newtons_law_of_gravitation.py::gravitational_law::28,"def gravitational_law(
    force: float, mass_1: float, mass_2: float, distance: float
) -> dict[str, float]:
    """"""
    Input Parameters
    ----------------
    force : magnitude in Newtons

    mass_1 : mass in Kilograms

    mass_2 : mass in Kilograms

    distance : distance in Meters

    Returns
    -------
    result : dict name, value pair of the parameter having Zero as it's value

    Returns the value of one of the parameters specified as 0, provided the values of
    other parameters are given.
    >>> gravitational_law(force=0, mass_1=5, mass_2=10, distance=20)
    {'force': 8.342875e-12}

    >>> gravitational_law(force=7367.382, mass_1=0, mass_2=74, distance=3048)
    {'mass_1': 1.385816317292268e+19}

    >>> gravitational_law(force=36337.283, mass_1=0, mass_2=0, distance=35584)
    Traceback (most recent call last):
        ...
    ValueError: One and only one argument must be 0

    >>> gravitational_law(force=36337.283, mass_1=-674, mass_2=0, distance=35584)
    Traceback (most recent call last):
        ...
    ValueError: Mass can not be negative

    >>> gravitational_law(force=-847938e12, mass_1=674, mass_2=0, distance=9374)
    Traceback (most recent call last):
        ...
    ValueError: Gravitational force can not be negative
    """"""

    product_of_mass = mass_1 * mass_2

    if (force, mass_1, mass_2, distance).count(0) != 1:
        raise ValueError(""One and only one argument must be 0"")
    if force < 0:
        raise ValueError(""Gravitational force can not be negative"")
    if distance < 0:
        raise ValueError(""Distance can not be negative"")
    if mass_1 < 0 or mass_2 < 0:
        raise ValueError(""Mass can not be negative"")
    if force == 0:
        force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)
        return {""force"": force}
    elif mass_1 == 0:
        mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)
        return {""mass_1"": mass_1}
    elif mass_2 == 0:
        mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)
        return {""mass_2"": mass_2}
    elif distance == 0:
        distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5
        return {""distance"": distance}
    raise ValueError(""One and only one argument must be 0"")",data\repos\Python\physics\newtons_law_of_gravitation.py,gravitational_law,655
1864,newtons_second_law_of_motion.py::newtons_second_law_of_motion::65,"def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:
    """"""
    Calculates force from `mass` and `acceleration`

    >>> newtons_second_law_of_motion(10, 10)
    100
    >>> newtons_second_law_of_motion(2.0, 1)
    2.0
    """"""
    force = 0.0
    try:
        force = mass * acceleration
    except Exception:
        return -0.0
    return force",data\repos\Python\physics\newtons_second_law_of_motion.py,newtons_second_law_of_motion,110
1865,n_body_simulation.py::update_step::185,"def update_step(
    body_system: BodySystem, delta_time: float, patches: list[plt.Circle]
) -> None:
    """"""
    Updates the body-system and applies the change to the patch-list used for plotting

    >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])
    >>> patches_1 = [plt.Circle((body.position_x, body.position_y), body.size,
    ... fc=body.color)for body in body_system_1.bodies] #doctest: +ELLIPSIS
    >>> update_step(body_system_1, 1, patches_1)
    >>> patches_1[0].center
    (0.01, 0.0)

    >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)
    >>> patches_2 = [plt.Circle((body.position_x, body.position_y), body.size,
    ... fc=body.color)for body in body_system_2.bodies] #doctest: +ELLIPSIS
    >>> update_step(body_system_2, 1, patches_2)
    >>> patches_2[0].center
    (-9.0, 0.0)
    """"""
    # Update the positions of the bodies
    body_system.update_system(delta_time)

    # Update the positions of the patches
    for patch, body in zip(patches, body_system.bodies):
        patch.center = (body.position_x, body.position_y)",data\repos\Python\physics\n_body_simulation.py,update_step,340
1866,n_body_simulation.py::plot::213,"def plot(
    title: str,
    body_system: BodySystem,
    x_start: float = -1,
    x_end: float = 1,
    y_start: float = -1,
    y_end: float = 1,
) -> None:
    """"""
    Utility function to plot how the given body-system evolves over time.
    No doctest provided since this function does not have a return value.
    """"""
    fig = plt.figure()
    fig.canvas.manager.set_window_title(title)
    ax = plt.axes(
        xlim=(x_start, x_end), ylim=(y_start, y_end)
    )  # Set section to be plotted
    plt.gca().set_aspect(""equal"")  # Fix aspect ratio

    # Each body is drawn as a patch by the plt-function
    patches = [
        plt.Circle((body.position_x, body.position_y), body.size, fc=body.color)
        for body in body_system.bodies
    ]

    for patch in patches:
        ax.add_patch(patch)

    # Function called at each step of the animation
    def update(frame: int) -> list[plt.Circle]:  # noqa: ARG001
        update_step(body_system, DELTA_TIME, patches)
        return patches

    anim = animation.FuncAnimation(  # noqa: F841
        fig, update, interval=INTERVAL, blit=True
    )

    plt.show()",data\repos\Python\physics\n_body_simulation.py,plot,293
1867,n_body_simulation.py::example_1::253,"def example_1() -> BodySystem:
    """"""
    Example 1: figure-8 solution to the 3-body-problem
    This example can be seen as a test of the implementation: given the right
    initial conditions, the bodies should move in a figure-8.
    (initial conditions taken from http://www.artcompsci.org/vol_1/v1_web/node56.html)
    >>> body_system = example_1()
    >>> len(body_system)
    3
    """"""

    position_x = 0.9700436
    position_y = -0.24308753
    velocity_x = 0.466203685
    velocity_y = 0.43236573

    bodies1 = [
        Body(position_x, position_y, velocity_x, velocity_y, size=0.2, color=""red""),
        Body(-position_x, -position_y, velocity_x, velocity_y, size=0.2, color=""green""),
        Body(0, 0, -2 * velocity_x, -2 * velocity_y, size=0.2, color=""blue""),
    ]
    return BodySystem(bodies1, time_factor=3)",data\repos\Python\physics\n_body_simulation.py,example_1,249
1868,n_body_simulation.py::example_2::277,"def example_2() -> BodySystem:
    """"""
    Example 2: Moon's orbit around the earth
    This example can be seen as a test of the implementation: given the right
    initial conditions, the moon should orbit around the earth as it actually does.
    (mass, velocity and distance taken from https://en.wikipedia.org/wiki/Earth
    and https://en.wikipedia.org/wiki/Moon)
    No doctest provided since this function does not have a return value.
    """"""

    moon_mass = 7.3476e22
    earth_mass = 5.972e24
    velocity_dif = 1022
    earth_moon_distance = 384399000
    gravitation_constant = 6.674e-11

    # Calculation of the respective velocities so that total impulse is zero,
    # i.e. the two bodies together don't move
    moon_velocity = earth_mass * velocity_dif / (earth_mass + moon_mass)
    earth_velocity = moon_velocity - velocity_dif

    moon = Body(-earth_moon_distance, 0, 0, moon_velocity, moon_mass, 10000000, ""grey"")
    earth = Body(0, 0, 0, earth_velocity, earth_mass, 50000000, ""blue"")
    return BodySystem([earth, moon], gravitation_constant, time_factor=1000000)",data\repos\Python\physics\n_body_simulation.py,example_2,291
1869,n_body_simulation.py::example_3::303,"def example_3() -> BodySystem:
    """"""
    Example 3: Random system with many bodies.
    No doctest provided since this function does not have a return value.
    """"""

    bodies = []
    for _ in range(10):
        velocity_x = random.uniform(-0.5, 0.5)
        velocity_y = random.uniform(-0.5, 0.5)

        # Bodies are created pairwise with opposite velocities so that the
        # total impulse remains zero
        bodies.append(
            Body(
                random.uniform(-0.5, 0.5),
                random.uniform(-0.5, 0.5),
                velocity_x,
                velocity_y,
                size=0.05,
            )
        )
        bodies.append(
            Body(
                random.uniform(-0.5, 0.5),
                random.uniform(-0.5, 0.5),
                -velocity_x,
                -velocity_y,
                size=0.05,
            )
        )
    return BodySystem(bodies, 0.01, 10, 0.1)",data\repos\Python\physics\n_body_simulation.py,example_3,229
1870,n_body_simulation.py::update_velocity::59,"    def update_velocity(
        self, force_x: float, force_y: float, delta_time: float
    ) -> None:
        """"""
        Euler algorithm for velocity

        >>> body_1 = Body(0.,0.,0.,0.)
        >>> body_1.update_velocity(1.,0.,1.)
        >>> body_1.velocity
        (1.0, 0.0)

        >>> body_1.update_velocity(1.,0.,1.)
        >>> body_1.velocity
        (2.0, 0.0)

        >>> body_2 = Body(0.,0.,5.,0.)
        >>> body_2.update_velocity(0.,-10.,10.)
        >>> body_2.velocity
        (5.0, -100.0)

        >>> body_2.update_velocity(0.,-10.,10.)
        >>> body_2.velocity
        (5.0, -200.0)
        """"""
        self.velocity_x += force_x * delta_time
        self.velocity_y += force_y * delta_time",data\repos\Python\physics\n_body_simulation.py,update_velocity,221
1871,n_body_simulation.py::update_position::86,"    def update_position(self, delta_time: float) -> None:
        """"""
        Euler algorithm for position

        >>> body_1 = Body(0.,0.,1.,0.)
        >>> body_1.update_position(1.)
        >>> body_1.position
        (1.0, 0.0)

        >>> body_1.update_position(1.)
        >>> body_1.position
        (2.0, 0.0)

        >>> body_2 = Body(10.,10.,0.,-2.)
        >>> body_2.update_position(1.)
        >>> body_2.position
        (10.0, 8.0)

        >>> body_2.update_position(1.)
        >>> body_2.position
        (10.0, 6.0)
        """"""
        self.position_x += self.velocity_x * delta_time
        self.position_y += self.velocity_y * delta_time",data\repos\Python\physics\n_body_simulation.py,update_position,192
1872,n_body_simulation.py::update_system::136,"    def update_system(self, delta_time: float) -> None:
        """"""
        For each body, loop through all other bodies to calculate the total
        force they exert on it. Use that force to update the body's velocity.

        >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])
        >>> len(body_system_1)
        2
        >>> body_system_1.update_system(1)
        >>> body_system_1.bodies[0].position
        (0.01, 0.0)
        >>> body_system_1.bodies[0].velocity
        (0.01, 0.0)

        >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)
        >>> body_system_2.update_system(1)
        >>> body_system_2.bodies[0].position
        (-9.0, 0.0)
        >>> body_system_2.bodies[0].velocity
        (0.1, 0.0)
        """"""
        for body1 in self.bodies:
            force_x = 0.0
            force_y = 0.0
            for body2 in self.bodies:
                if body1 != body2:
                    dif_x = body2.position_x - body1.position_x
                    dif_y = body2.position_y - body1.position_y

                    # Calculation of the distance using Pythagoras's theorem
                    # Extra factor due to the softening technique
                    distance = (dif_x**2 + dif_y**2 + self.softening_factor) ** (1 / 2)

                    # Newton's law of universal gravitation.
                    force_x += (
                        self.gravitation_constant * body2.mass * dif_x / distance**3
                    )
                    force_y += (
                        self.gravitation_constant * body2.mass * dif_y / distance**3
                    )

            # Update the body's velocity once all the force components have been added
            body1.update_velocity(force_x, force_y, delta_time * self.time_factor)

        # Update the positions only after all the velocities have been updated
        for body in self.bodies:
            body.update_position(delta_time * self.time_factor)",data\repos\Python\physics\n_body_simulation.py,update_system,499
1873,n_body_simulation.py::update::242,"    def update(frame: int) -> list[plt.Circle]:  # noqa: ARG001
        update_step(body_system, DELTA_TIME, patches)
        return patches",data\repos\Python\physics\n_body_simulation.py,update,35
1874,orbital_transfer_work.py::orbital_transfer_work::1,"def orbital_transfer_work(
    mass_central: float, mass_object: float, r_initial: float, r_final: float
) -> str:
    """"""
    Calculates the work required to move an object from one orbit to another in a
    gravitational field based on the change in total mechanical energy.

    The formula used is:
        W = (G * M * m / 2) * (1/r_initial - 1/r_final)

    where:
        W = work done (Joules)
        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)
        M = mass of the central body (kg)
        m = mass of the orbiting object (kg)
        r_initial = initial orbit radius (m)
        r_final = final orbit radius (m)

    Args:
        mass_central (float): Mass of the central body (kg)
        mass_object (float): Mass of the object being moved (kg)
        r_initial (float): Initial orbital radius (m)
        r_final (float): Final orbital radius (m)

    Returns:
        str: Work done in Joules as a string in scientific notation (3 decimals)

    Examples:
        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)
        '2.811e+09'
        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)
        '-1.405e+09'
        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)
        '1.514e+11'
    """"""
    gravitational_constant = 6.67430e-11

    if r_initial <= 0 or r_final <= 0:
        raise ValueError(""Orbital radii must be greater than zero."")

    work = (gravitational_constant * mass_central * mass_object / 2) * (
        1 / r_initial - 1 / r_final
    )
    return f""{work:.3e}""",data\repos\Python\physics\orbital_transfer_work.py,orbital_transfer_work,454
1875,period_of_pendulum.py::period_of_pendulum::30,"def period_of_pendulum(length: float) -> float:
    """"""
    >>> period_of_pendulum(1.23)
    2.2252155506257845
    >>> period_of_pendulum(2.37)
    3.0888278441908574
    >>> period_of_pendulum(5.63)
    4.76073193364765
    >>> period_of_pendulum(-12)
    Traceback (most recent call last):
        ...
    ValueError: The length should be non-negative
    >>> period_of_pendulum(0)
    0.0
    """"""
    if length < 0:
        raise ValueError(""The length should be non-negative"")
    return 2 * pi * (length / g) ** 0.5",data\repos\Python\physics\period_of_pendulum.py,period_of_pendulum,167
1876,photoelectric_effect.py::maximum_kinetic_energy::27,"def maximum_kinetic_energy(
    frequency: float, work_function: float, in_ev: bool = False
) -> float:
    """"""
    Calculates the maximum kinetic energy of emitted electron from the surface.
    if the maximum kinetic energy is zero then no electron will be emitted
    or given electromagnetic wave frequency is small.

    frequency (float): Frequency of electromagnetic wave.
    work_function (float): Work function of the surface.
    in_ev (optional)(bool): Pass True if values are in eV.

    Usage example:
    >>> maximum_kinetic_energy(1000000,2)
    0
    >>> maximum_kinetic_energy(1000000,2,True)
    0
    >>> maximum_kinetic_energy(10000000000000000,2,True)
    39.357000000000006
    >>> maximum_kinetic_energy(-9,20)
    Traceback (most recent call last):
        ...
    ValueError: Frequency can't be negative.

    >>> maximum_kinetic_energy(1000,""a"")
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for -: 'float' and 'str'

    """"""
    if frequency < 0:
        raise ValueError(""Frequency can't be negative."")
    if in_ev:
        return max(PLANCK_CONSTANT_EVS * frequency - work_function, 0)
    return max(PLANCK_CONSTANT_JS * frequency - work_function, 0)",data\repos\Python\physics\photoelectric_effect.py,maximum_kinetic_energy,307
1877,potential_energy.py::potential_energy::31,"def potential_energy(mass: float, height: float) -> float:
    # function will accept mass and height as parameters and return potential energy
    """"""
    >>> potential_energy(10,10)
    980.665
    >>> potential_energy(0,5)
    0.0
    >>> potential_energy(8,0)
    0.0
    >>> potential_energy(10,5)
    490.3325
    >>> potential_energy(0,0)
    0.0
    >>> potential_energy(2,8)
    156.9064
    >>> potential_energy(20,100)
    19613.3
    """"""
    if mass < 0:
        # handling of negative values of mass
        raise ValueError(""The mass of a body cannot be negative"")
    if height < 0:
        # handling of negative values of height
        raise ValueError(""The height above the ground cannot be negative"")
    return mass * g * height",data\repos\Python\physics\potential_energy.py,potential_energy,207
1878,rainfall_intensity.py::rainfall_intensity::17,"def rainfall_intensity(
    coefficient_k: float,
    coefficient_a: float,
    coefficient_b: float,
    coefficient_c: float,
    return_period: float,
    duration: float,
) -> float:
    """"""
    Calculate the intensity of a rainfall event for a given duration and return period.
    It's based on the Sherman intensity-duration-frequency curve:

    I = k * T^a / (D + b)^c

    where:
        I = Intensity of the rainfall event [mm/h]
        k, a, b, c = Coefficients obtained through statistical distribution adjust
        T = Return period in years
        D = Rainfall event duration in minutes

    Parameters
    ----------
    coefficient_k : float
        Coefficient obtained through statistical distribution adjust.
    coefficient_a : float
        Coefficient obtained through statistical distribution adjust.
    coefficient_b : float
        Coefficient obtained through statistical distribution adjust.
    coefficient_c : float
        Coefficient obtained through statistical distribution adjust.
    return_period : float
        Return period in years.
    duration : float
        Rainfall event duration in minutes.

    Returns
    -------
    intensity : float
        Intensity of the rainfall event in mm/h.

    Raises
    ------
    ValueError
        If any of the parameters are not positive.

    Examples
    --------

    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 60)
    49.83339231138578

    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 30)
    77.36319588106228

    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 5, 60)
    43.382487747633625

    >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, -0.2, 11.6, 0.81, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, 0.2, -11.6, 0.81, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, 0.2, 11.6, -0.81, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, 0, 11.6, 0.81, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, 0.2, 0, 0.81, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, 0.2, 11.6, 0, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 0, 60)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 0)
    Traceback (most recent call last):
    ...
    ValueError: All parameters must be positive.

    """"""
    if (
        coefficient_k <= 0
        or coefficient_a <= 0
        or coefficient_b <= 0
        or coefficient_c <= 0
        or return_period <= 0
        or duration <= 0
    ):
        raise ValueError(""All parameters must be positive."")
    intensity = (coefficient_k * (return_period**coefficient_a)) / (
        (duration + coefficient_b) ** coefficient_c
    )
    return intensity",data\repos\Python\physics\rainfall_intensity.py,rainfall_intensity,973
1879,reynolds_number.py::reynolds_number::33,"def reynolds_number(
    density: float, velocity: float, diameter: float, viscosity: float
) -> float:
    """"""
    >>> reynolds_number(900, 2.5, 0.05, 0.4)
    281.25
    >>> reynolds_number(450, 3.86, 0.078, 0.23)
    589.0695652173912
    >>> reynolds_number(234, -4.5, 0.3, 0.44)
    717.9545454545454
    >>> reynolds_number(-90, 2, 0.045, 1)
    Traceback (most recent call last):
        ...
    ValueError: please ensure that density, diameter and viscosity are positive
    >>> reynolds_number(0, 2, -0.4, -2)
    Traceback (most recent call last):
        ...
    ValueError: please ensure that density, diameter and viscosity are positive
    """"""

    if density <= 0 or diameter <= 0 or viscosity <= 0:
        raise ValueError(
            ""please ensure that density, diameter and viscosity are positive""
        )
    return (density * abs(velocity) * diameter) / viscosity",data\repos\Python\physics\reynolds_number.py,reynolds_number,269
1880,rms_speed_of_molecule.py::rms_speed_of_molecule::26,"def rms_speed_of_molecule(temperature: float, molar_mass: float) -> float:
    """"""
    >>> rms_speed_of_molecule(100, 2)
    35.315279554323226
    >>> rms_speed_of_molecule(273, 12)
    23.821458421977443
    """"""
    if temperature < 0:
        raise Exception(""Temperature cannot be less than 0 K"")
    if molar_mass <= 0:
        raise Exception(""Molar mass cannot be less than or equal to 0 kg/mol"")
    else:
        return (3 * UNIVERSAL_GAS_CONSTANT * temperature / molar_mass) ** 0.5",data\repos\Python\physics\rms_speed_of_molecule.py,rms_speed_of_molecule,143
1881,shear_stress.py::shear_stress::12,"def shear_stress(
    stress: float,
    tangential_force: float,
    area: float,
) -> tuple[str, float]:
    """"""
    This function can calculate any one of the three -
    1. Shear Stress
    2. Tangential Force
    3. Cross-sectional Area
    This is calculated from the other two provided values
    Examples -
    >>> shear_stress(stress=25, tangential_force=100, area=0)
    ('area', 4.0)
    >>> shear_stress(stress=0, tangential_force=1600, area=200)
    ('stress', 8.0)
    >>> shear_stress(stress=1000, tangential_force=0, area=1200)
    ('tangential_force', 1200000)
    """"""
    if (stress, tangential_force, area).count(0) != 1:
        raise ValueError(""You cannot supply more or less than 2 values"")
    elif stress < 0:
        raise ValueError(""Stress cannot be negative"")
    elif tangential_force < 0:
        raise ValueError(""Tangential Force cannot be negative"")
    elif area < 0:
        raise ValueError(""Area cannot be negative"")
    elif stress == 0:
        return (
            ""stress"",
            tangential_force / area,
        )
    elif tangential_force == 0:
        return (
            ""tangential_force"",
            stress * area,
        )
    else:
        return (
            ""area"",
            tangential_force / stress,
        )",data\repos\Python\physics\shear_stress.py,shear_stress,331
1882,speeds_of_gas_molecules.py::avg_speed_of_molecule::54,"def avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:
    """"""
    Takes the temperature (in K) and molar mass (in kg/mol) of a gas
    and returns the average speed of a molecule in the gas (in m/s).

    Examples:

    >>> avg_speed_of_molecule(273, 0.028) # nitrogen at 273 K
    454.3488755062257
    >>> avg_speed_of_molecule(300, 0.032) # oxygen at 300 K
    445.5257273433045
    >>> avg_speed_of_molecule(-273, 0.028) # invalid temperature
    Traceback (most recent call last):
        ...
    Exception: Absolute temperature cannot be less than 0 K
    >>> avg_speed_of_molecule(273, 0) # invalid molar mass
    Traceback (most recent call last):
        ...
    Exception: Molar mass should be greater than 0 kg/mol
    """"""

    if temperature < 0:
        raise Exception(""Absolute temperature cannot be less than 0 K"")
    if molar_mass <= 0:
        raise Exception(""Molar mass should be greater than 0 kg/mol"")
    return (8 * R * temperature / (pi * molar_mass)) ** 0.5",data\repos\Python\physics\speeds_of_gas_molecules.py,avg_speed_of_molecule,284
1883,speeds_of_gas_molecules.py::mps_speed_of_molecule::82,"def mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:
    """"""
    Takes the temperature (in K) and molar mass (in kg/mol) of a gas
    and returns the most probable speed of a molecule in the gas (in m/s).

    Examples:

    >>> mps_speed_of_molecule(273, 0.028) # nitrogen at 273 K
    402.65620702280023
    >>> mps_speed_of_molecule(300, 0.032) # oxygen at 300 K
    394.8368955535605
    >>> mps_speed_of_molecule(-273, 0.028) # invalid temperature
    Traceback (most recent call last):
        ...
    Exception: Absolute temperature cannot be less than 0 K
    >>> mps_speed_of_molecule(273, 0) # invalid molar mass
    Traceback (most recent call last):
        ...
    Exception: Molar mass should be greater than 0 kg/mol
    """"""

    if temperature < 0:
        raise Exception(""Absolute temperature cannot be less than 0 K"")
    if molar_mass <= 0:
        raise Exception(""Molar mass should be greater than 0 kg/mol"")
    return (2 * R * temperature / molar_mass) ** 0.5",data\repos\Python\physics\speeds_of_gas_molecules.py,mps_speed_of_molecule,287
1884,speed_of_sound.py::speed_of_sound_in_a_fluid::23,"def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:
    """"""
    Calculates the speed of sound in a fluid from its density and bulk modulus

    Examples:
    Example 1 --> Water 20C: bulk_modulus= 2.15MPa, density=998kg/m
    Example 2 --> Mercury 20C: bulk_modulus= 28.5MPa, density=13600kg/m

    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)
    1467.7563207952705
    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)
    1447.614670861731
    """"""

    if density <= 0:
        raise ValueError(""Impossible fluid density"")
    if bulk_modulus <= 0:
        raise ValueError(""Impossible bulk modulus"")

    return (bulk_modulus / density) ** 0.5",data\repos\Python\physics\speed_of_sound.py,speed_of_sound_in_a_fluid,218
1885,terminal_velocity.py::terminal_velocity::27,"def terminal_velocity(
    mass: float, density: float, area: float, drag_coefficient: float
) -> float:
    """"""
    >>> terminal_velocity(1, 25, 0.6, 0.77)
    1.3031197996044768
    >>> terminal_velocity(2, 100, 0.45, 0.23)
    1.9467947148674276
    >>> terminal_velocity(5, 50, 0.2, 0.5)
    4.428690551393267
    >>> terminal_velocity(-5, 50, -0.2, -2)
    Traceback (most recent call last):
        ...
    ValueError: mass, density, area and the drag coefficient all need to be positive
    >>> terminal_velocity(3, -20, -1, 2)
    Traceback (most recent call last):
        ...
    ValueError: mass, density, area and the drag coefficient all need to be positive
    >>> terminal_velocity(-2, -1, -0.44, -1)
    Traceback (most recent call last):
        ...
    ValueError: mass, density, area and the drag coefficient all need to be positive
    """"""
    if mass <= 0 or density <= 0 or area <= 0 or drag_coefficient <= 0:
        raise ValueError(
            ""mass, density, area and the drag coefficient all need to be positive""
        )
    return ((2 * mass * g) / (density * area * drag_coefficient)) ** 0.5",data\repos\Python\physics\terminal_velocity.py,terminal_velocity,333
1886,q_fourier_transform.py::quantum_fourier_transform::21,"def quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:
    """"""
    # >>> quantum_fourier_transform(2)
    # {'00': 2500, '01': 2500, '11': 2500, '10': 2500}
    # quantum circuit for number_of_qubits = 3:
                                               
    qr_0:  H X
                                 P(/2)  
    qr_1:  H 
           P(/4)  P(/2)                
    qr_2:  H X
          
    cr: 3/
    Args:
        n : number of qubits
    Returns:
        qiskit.result.counts.Counts: distribute counts.

    >>> quantum_fourier_transform(2)
    {'00': 2500, '01': 2500, '10': 2500, '11': 2500}
    >>> quantum_fourier_transform(-1)
    Traceback (most recent call last):
        ...
    ValueError: number of qubits must be > 0.
    >>> quantum_fourier_transform('a')
    Traceback (most recent call last):
        ...
    TypeError: number of qubits must be a integer.
    >>> quantum_fourier_transform(100)
    Traceback (most recent call last):
        ...
    ValueError: number of qubits too large to simulate(>10).
    >>> quantum_fourier_transform(0.5)
    Traceback (most recent call last):
        ...
    ValueError: number of qubits must be exact integer.
    """"""
    if isinstance(number_of_qubits, str):
        raise TypeError(""number of qubits must be a integer."")
    if number_of_qubits <= 0:
        raise ValueError(""number of qubits must be > 0."")
    if math.floor(number_of_qubits) != number_of_qubits:
        raise ValueError(""number of qubits must be exact integer."")
    if number_of_qubits > 10:
        raise ValueError(""number of qubits too large to simulate(>10)."")

    qr = QuantumRegister(number_of_qubits, ""qr"")
    cr = ClassicalRegister(number_of_qubits, ""cr"")

    quantum_circuit = QuantumCircuit(qr, cr)

    counter = number_of_qubits

    for i in range(counter):
        quantum_circuit.h(number_of_qubits - i - 1)
        counter -= 1
        for j in range(counter):
            quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)

    for k in range(number_of_qubits // 2):
        quantum_circuit.swap(k, number_of_qubits - k - 1)

    # measure all the qubits
    quantum_circuit.measure(qr, cr)
    # simulate with 10000 shots
    backend = Aer.get_backend(""qasm_simulator"")
    job = execute(quantum_circuit, backend, shots=10000)

    return job.result().get_counts(quantum_circuit)",data\repos\Python\quantum\q_fourier_transform.py,quantum_fourier_transform,761
1887,first_come_first_served.py::calculate_waiting_times::8,"def calculate_waiting_times(duration_times: list[int]) -> list[int]:
    """"""
    This function calculates the waiting time of some processes that have a
    specified duration time.
        Return: The waiting time for each process.
    >>> calculate_waiting_times([5, 10, 15])
    [0, 5, 15]
    >>> calculate_waiting_times([1, 2, 3, 4, 5])
    [0, 1, 3, 6, 10]
    >>> calculate_waiting_times([10, 3])
    [0, 10]
    """"""
    waiting_times = [0] * len(duration_times)
    for i in range(1, len(duration_times)):
        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]
    return waiting_times",data\repos\Python\scheduling\first_come_first_served.py,calculate_waiting_times,174
1888,first_come_first_served.py::calculate_turnaround_times::26,"def calculate_turnaround_times(
    duration_times: list[int], waiting_times: list[int]
) -> list[int]:
    """"""
    This function calculates the turnaround time of some processes.
        Return: The time difference between the completion time and the
                arrival time.
                Practically waiting_time + duration_time
    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])
    [5, 15, 30]
    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])
    [1, 3, 6, 10, 15]
    >>> calculate_turnaround_times([10, 3], [0, 10])
    [10, 13]
    """"""
    return [
        duration_time + waiting_times[i]
        for i, duration_time in enumerate(duration_times)
    ]",data\repos\Python\scheduling\first_come_first_served.py,calculate_turnaround_times,200
1889,first_come_first_served.py::calculate_average_turnaround_time::47,"def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:
    """"""
    This function calculates the average of the turnaround times
        Return: The average of the turnaround times.
    >>> calculate_average_turnaround_time([0, 5, 16])
    7.0
    >>> calculate_average_turnaround_time([1, 5, 8, 12])
    6.5
    >>> calculate_average_turnaround_time([10, 24])
    17.0
    """"""
    return sum(turnaround_times) / len(turnaround_times)",data\repos\Python\scheduling\first_come_first_served.py,calculate_average_turnaround_time,120
1890,first_come_first_served.py::calculate_average_waiting_time::61,"def calculate_average_waiting_time(waiting_times: list[int]) -> float:
    """"""
    This function calculates the average of the waiting times
        Return: The average of the waiting times.
    >>> calculate_average_waiting_time([0, 5, 16])
    7.0
    >>> calculate_average_waiting_time([1, 5, 8, 12])
    6.5
    >>> calculate_average_waiting_time([10, 24])
    17.0
    """"""
    return sum(waiting_times) / len(waiting_times)",data\repos\Python\scheduling\first_come_first_served.py,calculate_average_waiting_time,116
1891,highest_response_ratio_next.py::calculate_turn_around_time::13,"def calculate_turn_around_time(
    process_name: list, arrival_time: list, burst_time: list, no_of_process: int
) -> list:
    """"""
    Calculate the turn around time of each processes

    Return: The turn around time time for each process.
    >>> calculate_turn_around_time([""A"", ""B"", ""C""], [3, 5, 8], [2, 4, 6], 3)
    [2, 4, 7]
    >>> calculate_turn_around_time([""A"", ""B"", ""C""], [0, 2, 4], [3, 5, 7], 3)
    [3, 6, 11]
    """"""

    current_time = 0
    # Number of processes finished
    finished_process_count = 0
    # Displays the finished process.
    # If it is 0, the performance is completed if it is 1, before the performance.
    finished_process = [0] * no_of_process
    # List to include calculation results
    turn_around_time = [0] * no_of_process

    # Sort by arrival time.
    burst_time = [burst_time[i] for i in np.argsort(arrival_time)]
    process_name = [process_name[i] for i in np.argsort(arrival_time)]
    arrival_time.sort()

    while no_of_process > finished_process_count:
        """"""
        If the current time is less than the arrival time of
        the process that arrives first among the processes that have not been performed,
        change the current time.
        """"""
        i = 0
        while finished_process[i] == 1:
            i += 1
        current_time = max(current_time, arrival_time[i])

        response_ratio = 0
        # Index showing the location of the process being performed
        loc = 0
        # Saves the current response ratio.
        temp = 0
        for i in range(no_of_process):
            if finished_process[i] == 0 and arrival_time[i] <= current_time:
                temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[
                    i
                ]
            if response_ratio < temp:
                response_ratio = temp
                loc = i

        # Calculate the turn around time
        turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]
        current_time += burst_time[loc]
        # Indicates that the process has been performed.
        finished_process[loc] = 1
        # Increase finished_process_count by 1
        finished_process_count += 1

    return turn_around_time",data\repos\Python\scheduling\highest_response_ratio_next.py,calculate_turn_around_time,557
1892,highest_response_ratio_next.py::calculate_waiting_time::76,"def calculate_waiting_time(
    process_name: list,  # noqa: ARG001
    turn_around_time: list,
    burst_time: list,
    no_of_process: int,
) -> list:
    """"""
    Calculate the waiting time of each processes.

    Return: The waiting time for each process.
    >>> calculate_waiting_time([""A"", ""B"", ""C""], [2, 4, 7], [2, 4, 6], 3)
    [0, 0, 1]
    >>> calculate_waiting_time([""A"", ""B"", ""C""], [3, 6, 11], [3, 5, 7], 3)
    [0, 1, 4]
    """"""

    waiting_time = [0] * no_of_process
    for i in range(no_of_process):
        waiting_time[i] = turn_around_time[i] - burst_time[i]
    return waiting_time",data\repos\Python\scheduling\highest_response_ratio_next.py,calculate_waiting_time,198
1893,job_sequence_with_deadline.py::max_tasks::28,"def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:
    """"""
    Create a list of Task objects that are sorted so the highest rewards come first.
    Return a list of those task ids that can be completed before i becomes too high.
    >>> max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)])
    [2, 0]
    >>> max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)])
    [3, 2]
    >>> max_tasks([(9, 10)])
    [0]
    >>> max_tasks([(-9, 10)])
    []
    >>> max_tasks([])
    []
    >>> max_tasks([(0, 10), (0, 20), (0, 30), (0, 40)])
    []
    >>> max_tasks([(-1, 10), (-2, 20), (-3, 30), (-4, 40)])
    []
    """"""
    tasks = sorted(
        (
            Task(task_id, deadline, reward)
            for task_id, (deadline, reward) in enumerate(tasks_info)
        ),
        key=attrgetter(""reward""),
        reverse=True,
    )
    return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]",data\repos\Python\scheduling\job_sequence_with_deadline.py,max_tasks,293
1894,job_sequencing_with_deadline.py::job_sequencing_with_deadlines::1,"def job_sequencing_with_deadlines(jobs: list) -> list:
    """"""
    Function to find the maximum profit by doing jobs in a given time frame

    Args:
        jobs [list]: A list of tuples of (job_id, deadline, profit)

    Returns:
        max_profit [int]: Maximum profit that can be earned by doing jobs
        in a given time frame

    Examples:
    >>> job_sequencing_with_deadlines(
    ... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)])
    [2, 60]
    >>> job_sequencing_with_deadlines(
    ... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)])
    [2, 127]
    """"""

    # Sort the jobs in descending order of profit
    jobs = sorted(jobs, key=lambda value: value[2], reverse=True)

    # Create a list of size equal to the maximum deadline
    # and initialize it with -1
    max_deadline = max(jobs, key=lambda value: value[1])[1]
    time_slots = [-1] * max_deadline

    # Finding the maximum profit and the count of jobs
    count = 0
    max_profit = 0
    for job in jobs:
        # Find a free time slot for this job
        # (Note that we start from the last possible slot)
        for i in range(job[1] - 1, -1, -1):
            if time_slots[i] == -1:
                time_slots[i] = job[0]
                count += 1
                max_profit += job[2]
                break
    return [count, max_profit]",data\repos\Python\scheduling\job_sequencing_with_deadline.py,job_sequencing_with_deadlines,406
1895,multi_level_feedback_queue.py::calculate_sequence_of_finish_queue::43,"    def calculate_sequence_of_finish_queue(self) -> list[str]:
        """"""
        This method returns the sequence of finished processes
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> _ = mlfq.multi_level_feedback_queue()
        >>> mlfq.calculate_sequence_of_finish_queue()
        ['P2', 'P4', 'P1', 'P3']
        """"""
        sequence = []
        for i in range(len(self.finish_queue)):
            sequence.append(self.finish_queue[i].process_name)
        return sequence",data\repos\Python\scheduling\multi_level_feedback_queue.py,calculate_sequence_of_finish_queue,194
1896,multi_level_feedback_queue.py::calculate_waiting_time::60,"    def calculate_waiting_time(self, queue: list[Process]) -> list[int]:
        """"""
        This method calculates waiting time of processes
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> _ = mlfq.multi_level_feedback_queue()
        >>> mlfq.calculate_waiting_time([P1, P2, P3, P4])
        [83, 17, 94, 101]
        """"""
        waiting_times = []
        for i in range(len(queue)):
            waiting_times.append(queue[i].waiting_time)
        return waiting_times",data\repos\Python\scheduling\multi_level_feedback_queue.py,calculate_waiting_time,202
1897,multi_level_feedback_queue.py::calculate_turnaround_time::77,"    def calculate_turnaround_time(self, queue: list[Process]) -> list[int]:
        """"""
        This method calculates turnaround time of processes
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> _ = mlfq.multi_level_feedback_queue()
        >>> mlfq.calculate_turnaround_time([P1, P2, P3, P4])
        [136, 34, 162, 125]
        """"""
        turnaround_times = []
        for i in range(len(queue)):
            turnaround_times.append(queue[i].turnaround_time)
        return turnaround_times",data\repos\Python\scheduling\multi_level_feedback_queue.py,calculate_turnaround_time,205
1898,multi_level_feedback_queue.py::calculate_completion_time::94,"    def calculate_completion_time(self, queue: list[Process]) -> list[int]:
        """"""
        This method calculates completion time of processes
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> _ = mlfq.multi_level_feedback_queue()
        >>> mlfq.calculate_turnaround_time([P1, P2, P3, P4])
        [136, 34, 162, 125]
        """"""
        completion_times = []
        for i in range(len(queue)):
            completion_times.append(queue[i].stop_time)
        return completion_times",data\repos\Python\scheduling\multi_level_feedback_queue.py,calculate_completion_time,203
1899,multi_level_feedback_queue.py::calculate_remaining_burst_time_of_processes::111,"    def calculate_remaining_burst_time_of_processes(
        self, queue: deque[Process]
    ) -> list[int]:
        """"""
        This method calculate remaining burst time of processes
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> finish_queue, ready_queue = mlfq.round_robin(deque([P1, P2, P3, P4]), 17)
        >>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)
        [0]
        >>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue)
        [36, 51, 7]
        >>> finish_queue, ready_queue = mlfq.round_robin(ready_queue, 25)
        >>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)
        [0, 0]
        >>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue)
        [11, 26]
        """"""
        return [q.burst_time for q in queue]",data\repos\Python\scheduling\multi_level_feedback_queue.py,calculate_remaining_burst_time_of_processes,297
1900,multi_level_feedback_queue.py::update_waiting_time::134,"    def update_waiting_time(self, process: Process) -> int:
        """"""
        This method updates waiting times of unfinished processes
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> mlfq.current_time = 10
        >>> P1.stop_time = 5
        >>> mlfq.update_waiting_time(P1)
        5
        """"""
        process.waiting_time += self.current_time - process.stop_time
        return process.waiting_time",data\repos\Python\scheduling\multi_level_feedback_queue.py,update_waiting_time,183
1901,multi_level_feedback_queue.py::first_come_first_served::150,"    def first_come_first_served(self, ready_queue: deque[Process]) -> deque[Process]:
        """"""
        FCFS(First Come, First Served)
        FCFS will be applied to MLFQ's last queue
        A first came process will be finished at first
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> _ = mlfq.first_come_first_served(mlfq.ready_queue)
        >>> mlfq.calculate_sequence_of_finish_queue()
        ['P1', 'P2', 'P3', 'P4']
        """"""
        finished: deque[Process] = deque()  # sequence deque of finished process
        while len(ready_queue) != 0:
            cp = ready_queue.popleft()  # current process

            # if process's arrival time is later than current time, update current time
            if self.current_time < cp.arrival_time:
                self.current_time += cp.arrival_time

            # update waiting time of current process
            self.update_waiting_time(cp)
            # update current time
            self.current_time += cp.burst_time
            # finish the process and set the process's burst-time 0
            cp.burst_time = 0
            # set the process's turnaround time because it is finished
            cp.turnaround_time = self.current_time - cp.arrival_time
            # set the completion time
            cp.stop_time = self.current_time
            # add the process to queue that has finished queue
            finished.append(cp)

        self.finish_queue.extend(finished)  # add finished process to finish queue
        # FCFS will finish all remaining processes
        return finished",data\repos\Python\scheduling\multi_level_feedback_queue.py,first_come_first_served,434
1902,multi_level_feedback_queue.py::round_robin::189,"    def round_robin(
        self, ready_queue: deque[Process], time_slice: int
    ) -> tuple[deque[Process], deque[Process]]:
        """"""
        RR(Round Robin)
        RR will be applied to MLFQ's all queues except last queue
        All processes can't use CPU for time more than time_slice
        If the process consume CPU up to time_slice, it will go back to ready queue
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> finish_queue, ready_queue = mlfq.round_robin(mlfq.ready_queue, 17)
        >>> mlfq.calculate_sequence_of_finish_queue()
        ['P2']
        """"""
        finished: deque[Process] = deque()  # sequence deque of terminated process
        # just for 1 cycle and unfinished processes will go back to queue
        for _ in range(len(ready_queue)):
            cp = ready_queue.popleft()  # current process

            # if process's arrival time is later than current time, update current time
            if self.current_time < cp.arrival_time:
                self.current_time += cp.arrival_time

            # update waiting time of unfinished processes
            self.update_waiting_time(cp)
            # if the burst time of process is bigger than time-slice
            if cp.burst_time > time_slice:
                # use CPU for only time-slice
                self.current_time += time_slice
                # update remaining burst time
                cp.burst_time -= time_slice
                # update end point time
                cp.stop_time = self.current_time
                # locate the process behind the queue because it is not finished
                ready_queue.append(cp)
            else:
                # use CPU for remaining burst time
                self.current_time += cp.burst_time
                # set burst time 0 because the process is finished
                cp.burst_time = 0
                # set the finish time
                cp.stop_time = self.current_time
                # update the process' turnaround time because it is finished
                cp.turnaround_time = self.current_time - cp.arrival_time
                # add the process to queue that has finished queue
                finished.append(cp)

        self.finish_queue.extend(finished)  # add finished process to finish queue
        # return finished processes queue and remaining processes queue
        return finished, ready_queue",data\repos\Python\scheduling\multi_level_feedback_queue.py,round_robin,575
1903,multi_level_feedback_queue.py::multi_level_feedback_queue::243,"    def multi_level_feedback_queue(self) -> deque[Process]:
        """"""
        MLFQ(Multi Level Feedback Queue)
        >>> P1 = Process(""P1"", 0, 53)
        >>> P2 = Process(""P2"", 0, 17)
        >>> P3 = Process(""P3"", 0, 68)
        >>> P4 = Process(""P4"", 0, 24)
        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
        >>> finish_queue = mlfq.multi_level_feedback_queue()
        >>> mlfq.calculate_sequence_of_finish_queue()
        ['P2', 'P4', 'P1', 'P3']
        """"""

        #  all queues except last one have round_robin algorithm
        for i in range(self.number_of_queues - 1):
            _finished, self.ready_queue = self.round_robin(
                self.ready_queue, self.time_slices[i]
            )
        #  the last queue has first_come_first_served algorithm
        self.first_come_first_served(self.ready_queue)

        return self.finish_queue",data\repos\Python\scheduling\multi_level_feedback_queue.py,multi_level_feedback_queue,251
1904,non_preemptive_shortest_job_first.py::calculate_waitingtime::13,"def calculate_waitingtime(
    arrival_time: list[int], burst_time: list[int], no_of_processes: int
) -> list[int]:
    """"""
    Calculate the waiting time of each processes

    Return: The waiting time for each process.
    >>> calculate_waitingtime([0,1,2], [10, 5, 8], 3)
    [0, 9, 13]
    >>> calculate_waitingtime([1,2,2,4], [4, 6, 3, 1], 4)
    [0, 7, 4, 1]
    >>> calculate_waitingtime([0,0,0], [12, 2, 10],3)
    [12, 0, 2]
    """"""

    waiting_time = [0] * no_of_processes
    remaining_time = [0] * no_of_processes

    # Initialize remaining_time to waiting_time.

    for i in range(no_of_processes):
        remaining_time[i] = burst_time[i]
    ready_process: list[int] = []

    completed = 0
    total_time = 0

    # When processes are not completed,
    # A process whose arrival time has passed \
    # and has remaining execution time is put into the ready_process.
    # The shortest process in the ready_process, target_process is executed.

    while completed != no_of_processes:
        ready_process = []
        target_process = -1

        for i in range(no_of_processes):
            if (arrival_time[i] <= total_time) and (remaining_time[i] > 0):
                ready_process.append(i)

        if len(ready_process) > 0:
            target_process = ready_process[0]
            for i in ready_process:
                if remaining_time[i] < remaining_time[target_process]:
                    target_process = i
            total_time += burst_time[target_process]
            completed += 1
            remaining_time[target_process] = 0
            waiting_time[target_process] = (
                total_time - arrival_time[target_process] - burst_time[target_process]
            )
        else:
            total_time += 1

    return waiting_time",data\repos\Python\scheduling\non_preemptive_shortest_job_first.py,calculate_waitingtime,447
1905,non_preemptive_shortest_job_first.py::calculate_turnaroundtime::70,"def calculate_turnaroundtime(
    burst_time: list[int], no_of_processes: int, waiting_time: list[int]
) -> list[int]:
    """"""
    Calculate the turnaround time of each process.

    Return: The turnaround time for each process.
    >>> calculate_turnaroundtime([0,1,2], 3, [0, 10, 15])
    [0, 11, 17]
    >>> calculate_turnaroundtime([1,2,2,4], 4, [1, 8, 5, 4])
    [2, 10, 7, 8]
    >>> calculate_turnaroundtime([0,0,0], 3, [12, 0, 2])
    [12, 0, 2]
    """"""

    turn_around_time = [0] * no_of_processes
    for i in range(no_of_processes):
        turn_around_time[i] = burst_time[i] + waiting_time[i]
    return turn_around_time",data\repos\Python\scheduling\non_preemptive_shortest_job_first.py,calculate_turnaroundtime,212
1906,round_robin.py::calculate_waiting_times::12,"def calculate_waiting_times(burst_times: list[int]) -> list[int]:
    """"""
    Calculate the waiting times of a list of processes that have a specified duration.

    Return: The waiting time for each process.
    >>> calculate_waiting_times([10, 5, 8])
    [13, 10, 13]
    >>> calculate_waiting_times([4, 6, 3, 1])
    [5, 8, 9, 6]
    >>> calculate_waiting_times([12, 2, 10])
    [12, 2, 12]
    """"""
    quantum = 2
    rem_burst_times = list(burst_times)
    waiting_times = [0] * len(burst_times)
    t = 0
    while True:
        done = True
        for i, burst_time in enumerate(burst_times):
            if rem_burst_times[i] > 0:
                done = False
                if rem_burst_times[i] > quantum:
                    t += quantum
                    rem_burst_times[i] -= quantum
                else:
                    t += rem_burst_times[i]
                    waiting_times[i] = t - burst_time
                    rem_burst_times[i] = 0
        if done is True:
            return waiting_times",data\repos\Python\scheduling\round_robin.py,calculate_waiting_times,267
1907,round_robin.py::calculate_turn_around_times::44,"def calculate_turn_around_times(
    burst_times: list[int], waiting_times: list[int]
) -> list[int]:
    """"""
    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])
    [1, 3, 6]
    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])
    [20, 9, 18]
    """"""
    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]",data\repos\Python\scheduling\round_robin.py,calculate_turn_around_times,121
1908,shortest_job_first.py::calculate_waitingtime::12,"def calculate_waitingtime(
    arrival_time: list[int], burst_time: list[int], no_of_processes: int
) -> list[int]:
    """"""
    Calculate the waiting time of each processes
    Return: List of waiting times.
    >>> calculate_waitingtime([1,2,3,4],[3,3,5,1],4)
    [0, 3, 5, 0]
    >>> calculate_waitingtime([1,2,3],[2,5,1],3)
    [0, 2, 0]
    >>> calculate_waitingtime([2,3],[5,1],2)
    [1, 0]
    """"""
    remaining_time = [0] * no_of_processes
    waiting_time = [0] * no_of_processes
    # Copy the burst time into remaining_time[]
    for i in range(no_of_processes):
        remaining_time[i] = burst_time[i]

    complete = 0
    increment_time = 0
    minm = 999999999
    short = 0
    check = False

    # Process until all processes are completed
    while complete != no_of_processes:
        for j in range(no_of_processes):
            if (
                arrival_time[j] <= increment_time
                and remaining_time[j] > 0
                and remaining_time[j] < minm
            ):
                minm = remaining_time[j]
                short = j
                check = True

        if not check:
            increment_time += 1
            continue
        remaining_time[short] -= 1

        minm = remaining_time[short]
        if minm == 0:
            minm = 999999999

        if remaining_time[short] == 0:
            complete += 1
            check = False

            # Find finish time of current process
            finish_time = increment_time + 1

            # Calculate waiting time
            finar = finish_time - arrival_time[short]
            waiting_time[short] = finar - burst_time[short]

            waiting_time[short] = max(waiting_time[short], 0)

        # Increment time
        increment_time += 1
    return waiting_time",data\repos\Python\scheduling\shortest_job_first.py,calculate_waitingtime,462
1909,shortest_job_first.py::calculate_turnaroundtime::76,"def calculate_turnaroundtime(
    burst_time: list[int], no_of_processes: int, waiting_time: list[int]
) -> list[int]:
    """"""
    Calculate the turn around time of each Processes
    Return: list of turn around times.
    >>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])
    [3, 6, 10, 1]
    >>> calculate_turnaroundtime([3,3], 2, [0,3])
    [3, 6]
    >>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])
    [9, 10, 4]
    """"""
    turn_around_time = [0] * no_of_processes
    for i in range(no_of_processes):
        turn_around_time[i] = burst_time[i] + waiting_time[i]
    return turn_around_time",data\repos\Python\scheduling\shortest_job_first.py,calculate_turnaroundtime,198
1910,shortest_job_first.py::calculate_average_times::95,"def calculate_average_times(
    waiting_time: list[int], turn_around_time: list[int], no_of_processes: int
) -> None:
    """"""
    This function calculates the average of the waiting & turnaround times
    Prints: Average Waiting time & Average Turn Around Time
    >>> calculate_average_times([0,3,5,0],[3,6,10,1],4)
    Average waiting time = 2.00000
    Average turn around time = 5.0
    >>> calculate_average_times([2,3],[3,6],2)
    Average waiting time = 2.50000
    Average turn around time = 4.5
    >>> calculate_average_times([10,4,3],[2,7,6],3)
    Average waiting time = 5.66667
    Average turn around time = 5.0
    """"""
    total_waiting_time = 0
    total_turn_around_time = 0
    for i in range(no_of_processes):
        total_waiting_time = total_waiting_time + waiting_time[i]
        total_turn_around_time = total_turn_around_time + turn_around_time[i]
    print(f""Average waiting time = {total_waiting_time / no_of_processes:.5f}"")
    print(""Average turn around time ="", total_turn_around_time / no_of_processes)",data\repos\Python\scheduling\shortest_job_first.py,calculate_average_times,282
1911,build_directory_md.py::good_file_paths::7,"def good_file_paths(top_dir: str = ""."") -> Iterator[str]:
    for dir_path, dir_names, filenames in os.walk(top_dir):
        dir_names[:] = [
            d
            for d in dir_names
            if d != ""scripts"" and d[0] not in ""._"" and ""venv"" not in d
        ]
        for filename in filenames:
            if filename == ""__init__.py"":
                continue
            if os.path.splitext(filename)[1] in ("".py"", "".ipynb""):
                yield os.path.join(dir_path, filename).lstrip(""./"")",data\repos\Python\scripts\build_directory_md.py,good_file_paths,125
1912,build_directory_md.py::md_prefix::21,"def md_prefix(indent: int) -> str:
    """"""
    Markdown prefix based on indent for bullet points

    >>> md_prefix(0)
    '\\n##'
    >>> md_prefix(1)
    '  *'
    >>> md_prefix(2)
    '    *'
    >>> md_prefix(3)
    '      *'
    """"""
    return f""{indent * '  '}*"" if indent else ""\n##""",data\repos\Python\scripts\build_directory_md.py,md_prefix,89
1913,build_directory_md.py::print_path::37,"def print_path(old_path: str, new_path: str) -> str:
    old_parts = old_path.split(os.sep)
    for i, new_part in enumerate(new_path.split(os.sep)):
        if (i + 1 > len(old_parts) or old_parts[i] != new_part) and new_part:
            print(f""{md_prefix(i)} {new_part.replace('_', ' ').title()}"")
    return new_path",data\repos\Python\scripts\build_directory_md.py,print_path,87
1914,build_directory_md.py::print_directory_md::45,"def print_directory_md(top_dir: str = ""."") -> None:
    old_path = """"
    for filepath in sorted(good_file_paths(top_dir)):
        filepath, filename = os.path.split(filepath)
        if filepath != old_path:
            old_path = print_path(old_path, filepath)
        indent = (filepath.count(os.sep) + 1) if filepath else 0
        url = f""{filepath}/{filename}"".replace("" "", ""%20"")
        filename = os.path.splitext(filename.replace(""_"", "" "").title())[0]
        print(f""{md_prefix(indent)} [{filename}]({url})"")",data\repos\Python\scripts\build_directory_md.py,print_directory_md,124
1915,validate_solutions.py::convert_path_to_module::30,"def convert_path_to_module(file_path: pathlib.Path) -> ModuleType:
    """"""Converts a file path to a Python module""""""
    spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))
    module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]
    spec.loader.exec_module(module)  # type: ignore[union-attr]
    return module",data\repos\Python\scripts\validate_solutions.py,convert_path_to_module,84
1916,validate_solutions.py::all_solution_file_paths::38,"def all_solution_file_paths() -> list[pathlib.Path]:
    """"""Collects all the solution file path in the Project Euler directory""""""
    solution_file_paths = []
    for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():
        if problem_dir_path.is_file() or problem_dir_path.name.startswith(""_""):
            continue
        for file_path in problem_dir_path.iterdir():
            if file_path.suffix != "".py"" or file_path.name.startswith((""_"", ""test"")):
                continue
            solution_file_paths.append(file_path)
    return solution_file_paths",data\repos\Python\scripts\validate_solutions.py,all_solution_file_paths,115
1917,validate_solutions.py::get_files_url::51,"def get_files_url() -> str:
    """"""Return the pull request number which triggered this action.""""""
    with open(os.environ[""GITHUB_EVENT_PATH""]) as file:
        event = json.load(file)
    return event[""pull_request""][""url""] + ""/files""",data\repos\Python\scripts\validate_solutions.py,get_files_url,54
1918,validate_solutions.py::added_solution_file_path::58,"def added_solution_file_path() -> list[pathlib.Path]:
    """"""Collects only the solution file path which got added in the current
    pull request.

    This will only be triggered if the script is ran from GitHub Actions.
    """"""
    solution_file_paths = []
    headers = {
        ""Accept"": ""application/vnd.github.v3+json"",
        ""Authorization"": ""token "" + os.environ[""GITHUB_TOKEN""],
    }
    files = httpx.get(get_files_url(), headers=headers, timeout=10).json()
    for file in files:
        filepath = pathlib.Path.cwd().joinpath(file[""filename""])
        if (
            filepath.suffix != "".py""
            or filepath.name.startswith((""_"", ""test""))
            or not filepath.name.startswith(""sol"")
        ):
            continue
        solution_file_paths.append(filepath)
    return solution_file_paths",data\repos\Python\scripts\validate_solutions.py,added_solution_file_path,175
1919,validate_solutions.py::collect_solution_file_paths::82,"def collect_solution_file_paths() -> list[pathlib.Path]:
    # Return only if there are any, otherwise default to all solutions
    if (
        os.environ.get(""CI"")
        and os.environ.get(""GITHUB_EVENT_NAME"") == ""pull_request""
        and (filepaths := added_solution_file_path())
    ):
        return filepaths
    return all_solution_file_paths()",data\repos\Python\scripts\validate_solutions.py,collect_solution_file_paths,78
1920,validate_solutions.py::test_project_euler::98,"def test_project_euler(solution_path: pathlib.Path) -> None:
    """"""Testing for all Project Euler solutions""""""
    # problem_[extract this part] and pad it with zeroes for width 3
    problem_number: str = solution_path.parent.name[8:].zfill(3)
    expected: str = PROBLEM_ANSWERS[problem_number]
    solution_module = convert_path_to_module(solution_path)
    answer = str(solution_module.solution())
    answer = hashlib.sha256(answer.encode()).hexdigest()
    assert answer == expected, (
        f""Expected solution to {problem_number} to have hash {expected}, got {answer}""
    )",data\repos\Python\scripts\validate_solutions.py,test_project_euler,132
1921,binary_search.py::bisect_left::18,"def bisect_left(
    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1
) -> int:
    """"""
    Locates the first element in a sorted array that is larger or equal to a given
    value.

    It has the same interface as
    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item to bisect
    :param lo: lowest index to consider (as in sorted_collection[lo:hi])
    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])
    :return: index i such that all values in sorted_collection[lo:i] are < item and all
        values in sorted_collection[i:hi] are >= item.

    Examples:
    >>> bisect_left([0, 5, 7, 10, 15], 0)
    0
    >>> bisect_left([0, 5, 7, 10, 15], 6)
    2
    >>> bisect_left([0, 5, 7, 10, 15], 20)
    5
    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)
    3
    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)
    2
    """"""
    if hi < 0:
        hi = len(sorted_collection)

    while lo < hi:
        mid = lo + (hi - lo) // 2
        if sorted_collection[mid] < item:
            lo = mid + 1
        else:
            hi = mid

    return lo",data\repos\Python\searches\binary_search.py,bisect_left,398
1922,binary_search.py::bisect_right::60,"def bisect_right(
    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1
) -> int:
    """"""
    Locates the first element in a sorted array that is larger than a given value.

    It has the same interface as
    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item to bisect
    :param lo: lowest index to consider (as in sorted_collection[lo:hi])
    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])
    :return: index i such that all values in sorted_collection[lo:i] are <= item and
        all values in sorted_collection[i:hi] are > item.

    Examples:
    >>> bisect_right([0, 5, 7, 10, 15], 0)
    1
    >>> bisect_right([0, 5, 7, 10, 15], 15)
    5
    >>> bisect_right([0, 5, 7, 10, 15], 6)
    2
    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)
    3
    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)
    2
    """"""
    if hi < 0:
        hi = len(sorted_collection)

    while lo < hi:
        mid = lo + (hi - lo) // 2
        if sorted_collection[mid] <= item:
            lo = mid + 1
        else:
            hi = mid

    return lo",data\repos\Python\searches\binary_search.py,bisect_right,394
1923,binary_search.py::insort_left::101,"def insort_left(
    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1
) -> None:
    """"""
    Inserts a given value into a sorted array before other values with the same value.

    It has the same interface as
    https://docs.python.org/3/library/bisect.html#bisect.insort_left .

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item to insert
    :param lo: lowest index to consider (as in sorted_collection[lo:hi])
    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])

    Examples:
    >>> sorted_collection = [0, 5, 7, 10, 15]
    >>> insort_left(sorted_collection, 6)
    >>> sorted_collection
    [0, 5, 6, 7, 10, 15]
    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]
    >>> item = (5, 5)
    >>> insort_left(sorted_collection, item)
    >>> sorted_collection
    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]
    >>> item is sorted_collection[1]
    True
    >>> item is sorted_collection[2]
    False
    >>> sorted_collection = [0, 5, 7, 10, 15]
    >>> insort_left(sorted_collection, 20)
    >>> sorted_collection
    [0, 5, 7, 10, 15, 20]
    >>> sorted_collection = [0, 5, 7, 10, 15]
    >>> insort_left(sorted_collection, 15, 1, 3)
    >>> sorted_collection
    [0, 5, 7, 15, 10, 15]
    """"""
    sorted_collection.insert(bisect_left(sorted_collection, item, lo, hi), item)",data\repos\Python\searches\binary_search.py,insort_left,460
1924,binary_search.py::insort_right::141,"def insort_right(
    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1
) -> None:
    """"""
    Inserts a given value into a sorted array after other values with the same value.

    It has the same interface as
    https://docs.python.org/3/library/bisect.html#bisect.insort_right .

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item to insert
    :param lo: lowest index to consider (as in sorted_collection[lo:hi])
    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])

    Examples:
    >>> sorted_collection = [0, 5, 7, 10, 15]
    >>> insort_right(sorted_collection, 6)
    >>> sorted_collection
    [0, 5, 6, 7, 10, 15]
    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]
    >>> item = (5, 5)
    >>> insort_right(sorted_collection, item)
    >>> sorted_collection
    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]
    >>> item is sorted_collection[1]
    False
    >>> item is sorted_collection[2]
    True
    >>> sorted_collection = [0, 5, 7, 10, 15]
    >>> insort_right(sorted_collection, 20)
    >>> sorted_collection
    [0, 5, 7, 10, 15, 20]
    >>> sorted_collection = [0, 5, 7, 10, 15]
    >>> insort_right(sorted_collection, 15, 1, 3)
    >>> sorted_collection
    [0, 5, 7, 15, 10, 15]
    """"""
    sorted_collection.insert(bisect_right(sorted_collection, item, lo, hi), item)",data\repos\Python\searches\binary_search.py,insort_right,460
1925,binary_search.py::binary_search::181,"def binary_search(sorted_collection: list[int], item: int) -> int:
    """"""Pure implementation of a binary search algorithm in Python

    Be careful collection must be ascending sorted otherwise, the result will be
    unpredictable

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of the found item or -1 if the item is not found

    Examples:
    >>> binary_search([0, 5, 7, 10, 15], 0)
    0
    >>> binary_search([0, 5, 7, 10, 15], 15)
    4
    >>> binary_search([0, 5, 7, 10, 15], 5)
    1
    >>> binary_search([0, 5, 7, 10, 15], 6)
    -1
    """"""
    if list(sorted_collection) != sorted(sorted_collection):
        raise ValueError(""sorted_collection must be sorted in ascending order"")
    left = 0
    right = len(sorted_collection) - 1

    while left <= right:
        midpoint = left + (right - left) // 2
        current_item = sorted_collection[midpoint]
        if current_item == item:
            return midpoint
        elif item < current_item:
            right = midpoint - 1
        else:
            left = midpoint + 1
    return -1",data\repos\Python\searches\binary_search.py,binary_search,309
1926,binary_search.py::binary_search_std_lib::218,"def binary_search_std_lib(sorted_collection: list[int], item: int) -> int:
    """"""Pure implementation of a binary search algorithm in Python using stdlib

    Be careful collection must be ascending sorted otherwise, the result will be
    unpredictable

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of the found item or -1 if the item is not found

    Examples:
    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)
    0
    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)
    4
    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)
    1
    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)
    -1
    """"""
    if list(sorted_collection) != sorted(sorted_collection):
        raise ValueError(""sorted_collection must be sorted in ascending order"")
    index = bisect.bisect_left(sorted_collection, item)
    if index != len(sorted_collection) and sorted_collection[index] == item:
        return index
    return -1",data\repos\Python\searches\binary_search.py,binary_search_std_lib,273
1927,binary_search.py::binary_search_by_recursion::246,"def binary_search_by_recursion(
    sorted_collection: list[int], item: int, left: int = 0, right: int = -1
) -> int:
    """"""Pure implementation of a binary search algorithm in Python by recursion

    Be careful collection must be ascending sorted otherwise, the result will be
    unpredictable
    First recursion should be started with left=0 and right=(len(sorted_collection)-1)

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of the found item or -1 if the item is not found

    Examples:
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)
    0
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)
    4
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)
    1
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)
    -1
    """"""
    if right < 0:
        right = len(sorted_collection) - 1
    if list(sorted_collection) != sorted(sorted_collection):
        raise ValueError(""sorted_collection must be sorted in ascending order"")
    if right < left:
        return -1

    midpoint = left + (right - left) // 2

    if sorted_collection[midpoint] == item:
        return midpoint
    elif sorted_collection[midpoint] > item:
        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)
    else:
        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",data\repos\Python\searches\binary_search.py,binary_search_by_recursion,407
1928,binary_search.py::exponential_search::286,"def exponential_search(sorted_collection: list[int], item: int) -> int:
    """"""Pure implementation of an exponential search algorithm in Python
    Resources used:
    https://en.wikipedia.org/wiki/Exponential_search

    Be careful collection must be ascending sorted otherwise, result will be
    unpredictable

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of the found item or -1 if the item is not found

    the order of this algorithm is O(lg I) where I is index position of item if exist

    Examples:
    >>> exponential_search([0, 5, 7, 10, 15], 0)
    0
    >>> exponential_search([0, 5, 7, 10, 15], 15)
    4
    >>> exponential_search([0, 5, 7, 10, 15], 5)
    1
    >>> exponential_search([0, 5, 7, 10, 15], 6)
    -1
    """"""
    if list(sorted_collection) != sorted(sorted_collection):
        raise ValueError(""sorted_collection must be sorted in ascending order"")
    bound = 1
    while bound < len(sorted_collection) and sorted_collection[bound] < item:
        bound *= 2
    left = bound // 2
    right = min(bound, len(sorted_collection) - 1)
    last_result = binary_search_by_recursion(
        sorted_collection=sorted_collection, item=item, left=left, right=right
    )
    if last_result is None:
        return -1
    return last_result",data\repos\Python\searches\binary_search.py,exponential_search,357
1929,binary_tree_traversal.py::build_tree::17,"def build_tree() -> TreeNode:
    print(""\n********Press N to stop entering at any point of time********\n"")
    check = input(""Enter the value of the root node: "").strip().lower()
    q: queue.Queue = queue.Queue()
    tree_node = TreeNode(int(check))
    q.put(tree_node)
    while not q.empty():
        node_found = q.get()
        msg = f""Enter the left node of {node_found.data}: ""
        check = input(msg).strip().lower() or ""n""
        if check == ""n"":
            return tree_node
        left_node = TreeNode(int(check))
        node_found.left = left_node
        q.put(left_node)
        msg = f""Enter the right node of {node_found.data}: ""
        check = input(msg).strip().lower() or ""n""
        if check == ""n"":
            return tree_node
        right_node = TreeNode(int(check))
        node_found.right = right_node
        q.put(right_node)
    raise ValueError(""Something went wrong"")",data\repos\Python\searches\binary_tree_traversal.py,build_tree,216
1930,binary_tree_traversal.py::pre_order::42,"def pre_order(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> pre_order(root)
    1,2,4,5,3,6,7,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    print(node.data, end="","")
    pre_order(node.left)
    pre_order(node.right)",data\repos\Python\searches\binary_tree_traversal.py,pre_order,195
1931,binary_tree_traversal.py::in_order::64,"def in_order(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> in_order(root)
    4,2,5,1,6,3,7,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    in_order(node.left)
    print(node.data, end="","")
    in_order(node.right)",data\repos\Python\searches\binary_tree_traversal.py,in_order,195
1932,binary_tree_traversal.py::post_order::86,"def post_order(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> post_order(root)
    4,5,2,6,7,3,1,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    post_order(node.left)
    post_order(node.right)
    print(node.data, end="","")",data\repos\Python\searches\binary_tree_traversal.py,post_order,195
1933,binary_tree_traversal.py::level_order::108,"def level_order(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> level_order(root)
    1,2,3,4,5,6,7,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    q: queue.Queue = queue.Queue()
    q.put(node)
    while not q.empty():
        node_dequeued = q.get()
        print(node_dequeued.data, end="","")
        if node_dequeued.left:
            q.put(node_dequeued.left)
        if node_dequeued.right:
            q.put(node_dequeued.right)",data\repos\Python\searches\binary_tree_traversal.py,level_order,243
1934,binary_tree_traversal.py::level_order_actual::136,"def level_order_actual(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> level_order_actual(root)
    1,
    2,3,
    4,5,6,7,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    q: queue.Queue = queue.Queue()
    q.put(node)
    while not q.empty():
        list_ = []
        while not q.empty():
            node_dequeued = q.get()
            print(node_dequeued.data, end="","")
            if node_dequeued.left:
                list_.append(node_dequeued.left)
            if node_dequeued.right:
                list_.append(node_dequeued.right)
        print()
        for inner_node in list_:
            q.put(inner_node)",data\repos\Python\searches\binary_tree_traversal.py,level_order_actual,279
1935,binary_tree_traversal.py::pre_order_iter::172,"def pre_order_iter(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> pre_order_iter(root)
    1,2,4,5,3,6,7,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    stack: list[TreeNode] = []
    n = node
    while n or stack:
        while n:  # start from root node, find its left child
            print(n.data, end="","")
            stack.append(n)
            n = n.left
        # end of while means current node doesn't have left child
        n = stack.pop()
        # start to traverse its right child
        n = n.right",data\repos\Python\searches\binary_tree_traversal.py,pre_order_iter,266
1936,binary_tree_traversal.py::in_order_iter::202,"def in_order_iter(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> in_order_iter(root)
    4,2,5,1,6,3,7,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    stack: list[TreeNode] = []
    n = node
    while n or stack:
        while n:
            stack.append(n)
            n = n.left
        n = stack.pop()
        print(n.data, end="","")
        n = n.right",data\repos\Python\searches\binary_tree_traversal.py,in_order_iter,231
1937,binary_tree_traversal.py::post_order_iter::230,"def post_order_iter(node: TreeNode) -> None:
    """"""
    >>> root = TreeNode(1)
    >>> tree_node2 = TreeNode(2)
    >>> tree_node3 = TreeNode(3)
    >>> tree_node4 = TreeNode(4)
    >>> tree_node5 = TreeNode(5)
    >>> tree_node6 = TreeNode(6)
    >>> tree_node7 = TreeNode(7)
    >>> root.left, root.right = tree_node2, tree_node3
    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
    >>> post_order_iter(root)
    4,5,2,6,7,3,1,
    """"""
    if not isinstance(node, TreeNode) or not node:
        return
    stack1, stack2 = [], []
    n = node
    stack1.append(n)
    while stack1:  # to find the reversed order of post order, store it in stack2
        n = stack1.pop()
        if n.left:
            stack1.append(n.left)
        if n.right:
            stack1.append(n.right)
        stack2.append(n)
    while stack2:  # pop up from stack2 will be the post order
        print(stack2.pop().data, end="","")",data\repos\Python\searches\binary_tree_traversal.py,post_order_iter,285
1938,binary_tree_traversal.py::prompt::261,"def prompt(s: str = """", width=50, char=""*"") -> str:
    if not s:
        return ""\n"" + width * char
    left, extra = divmod(width - len(s) - 2, 2)
    return f""{left * char} {s} {(left + extra) * char}""",data\repos\Python\searches\binary_tree_traversal.py,prompt,71
1939,double_linear_search.py::double_linear_search::4,"def double_linear_search(array: list[int], search_item: int) -> int:
    """"""
    Iterate through the array from both sides to find the index of search_item.

    :param array: the array to be searched
    :param search_item: the item to be searched
    :return the index of search_item, if search_item is in array, else -1

    Examples:
    >>> double_linear_search([1, 5, 5, 10], 1)
    0
    >>> double_linear_search([1, 5, 5, 10], 5)
    1
    >>> double_linear_search([1, 5, 5, 10], 100)
    -1
    >>> double_linear_search([1, 5, 5, 10], 10)
    3
    """"""
    # define the start and end index of the given array
    start_ind, end_ind = 0, len(array) - 1
    while start_ind <= end_ind:
        if array[start_ind] == search_item:
            return start_ind
        elif array[end_ind] == search_item:
            return end_ind
        else:
            start_ind += 1
            end_ind -= 1
    # returns -1 if search_item is not found in array
    return -1",data\repos\Python\searches\double_linear_search.py,double_linear_search,282
1940,double_linear_search_recursion.py::search::1,"def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:
    """"""
    Iterate through the array to find the index of key using recursion.
    :param list_data: the list to be searched
    :param key: the key to be searched
    :param left: the index of first element
    :param right: the index of last element
    :return: the index of key value if found, -1 otherwise.

    >>> search(list(range(0, 11)), 5)
    5
    >>> search([1, 2, 4, 5, 3], 4)
    2
    >>> search([1, 2, 4, 5, 3], 6)
    -1
    >>> search([5], 5)
    0
    >>> search([], 1)
    -1
    """"""
    right = right or len(list_data) - 1
    if left > right:
        return -1
    elif list_data[left] == key:
        return left
    elif list_data[right] == key:
        return right
    else:
        return search(list_data, key, left + 1, right - 1)",data\repos\Python\searches\double_linear_search_recursion.py,search,270
1941,exponential_search.py::binary_search_by_recursion::19,"def binary_search_by_recursion(
    sorted_collection: list[int], item: int, left: int = 0, right: int = -1
) -> int:
    """"""Pure implementation of binary search algorithm in Python using recursion

    Be careful: the collection must be ascending sorted otherwise, the result will be
    unpredictable.

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :param left: starting index for the search
    :param right: ending index for the search
    :return: index of the found item or -1 if the item is not found

    Examples:
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)
    0
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)
    4
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)
    1
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)
    -1
    """"""
    if right < 0:
        right = len(sorted_collection) - 1
    if list(sorted_collection) != sorted(sorted_collection):
        raise ValueError(""sorted_collection must be sorted in ascending order"")
    if right < left:
        return -1

    midpoint = left + (right - left) // 2

    if sorted_collection[midpoint] == item:
        return midpoint
    elif sorted_collection[midpoint] > item:
        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)
    else:
        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",data\repos\Python\searches\exponential_search.py,binary_search_by_recursion,411
1942,exponential_search.py::exponential_search::60,"def exponential_search(sorted_collection: list[int], item: int) -> int:
    """"""
    Pure implementation of an exponential search algorithm in Python.
    For more information, refer to:
    https://en.wikipedia.org/wiki/Exponential_search

    Be careful: the collection must be ascending sorted, otherwise the result will be
    unpredictable.

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of the found item or -1 if the item is not found

    The time complexity of this algorithm is O(log i) where i is the index of the item.

    Examples:
    >>> exponential_search([0, 5, 7, 10, 15], 0)
    0
    >>> exponential_search([0, 5, 7, 10, 15], 15)
    4
    >>> exponential_search([0, 5, 7, 10, 15], 5)
    1
    >>> exponential_search([0, 5, 7, 10, 15], 6)
    -1
    """"""
    if list(sorted_collection) != sorted(sorted_collection):
        raise ValueError(""sorted_collection must be sorted in ascending order"")

    if sorted_collection[0] == item:
        return 0

    bound = 1
    while bound < len(sorted_collection) and sorted_collection[bound] < item:
        bound *= 2

    left = bound // 2
    right = min(bound, len(sorted_collection) - 1)
    return binary_search_by_recursion(sorted_collection, item, left, right)",data\repos\Python\searches\exponential_search.py,exponential_search,349
1943,fibonacci_search.py::fibonacci::18,"def fibonacci(k: int) -> int:
    """"""Finds fibonacci number in index k.

    Parameters
    ----------
    k :
        Index of fibonacci.

    Returns
    -------
    int
        Fibonacci number in position k.

    >>> fibonacci(0)
    0
    >>> fibonacci(2)
    1
    >>> fibonacci(5)
    5
    >>> fibonacci(15)
    610
    >>> fibonacci('a')
    Traceback (most recent call last):
    TypeError: k must be an integer.
    >>> fibonacci(-5)
    Traceback (most recent call last):
    ValueError: k integer must be greater or equal to zero.
    """"""
    if not isinstance(k, int):
        raise TypeError(""k must be an integer."")
    if k < 0:
        raise ValueError(""k integer must be greater or equal to zero."")
    if k == 0:
        return 0
    elif k == 1:
        return 1
    else:
        return fibonacci(k - 1) + fibonacci(k - 2)",data\repos\Python\searches\fibonacci_search.py,fibonacci,222
1944,fibonacci_search.py::fibonacci_search::58,"def fibonacci_search(arr: list, val: int) -> int:
    """"""A pure Python implementation of a fibonacci search algorithm.

    Parameters
    ----------
    arr
        List of sorted elements.
    val
        Element to search in list.

    Returns
    -------
    int
        The index of the element in the array.
        -1 if the element is not found.

    >>> fibonacci_search([4, 5, 6, 7], 4)
    0
    >>> fibonacci_search([4, 5, 6, 7], -10)
    -1
    >>> fibonacci_search([-18, 2], -18)
    0
    >>> fibonacci_search([5], 5)
    0
    >>> fibonacci_search(['a', 'c', 'd'], 'c')
    1
    >>> fibonacci_search(['a', 'c', 'd'], 'f')
    -1
    >>> fibonacci_search([], 1)
    -1
    >>> fibonacci_search([.1, .4 , 7], .4)
    1
    >>> fibonacci_search([], 9)
    -1
    >>> fibonacci_search(list(range(100)), 63)
    63
    >>> fibonacci_search(list(range(100)), 99)
    99
    >>> fibonacci_search(list(range(-100, 100, 3)), -97)
    1
    >>> fibonacci_search(list(range(-100, 100, 3)), 0)
    -1
    >>> fibonacci_search(list(range(-100, 100, 5)), 0)
    20
    >>> fibonacci_search(list(range(-100, 100, 5)), 95)
    39
    """"""
    len_list = len(arr)
    # Find m such that F_m >= n where F_i is the i_th fibonacci number.
    i = 0
    while True:
        if fibonacci(i) >= len_list:
            fibb_k = i
            break
        i += 1
    offset = 0
    while fibb_k > 0:
        index_k = min(
            offset + fibonacci(fibb_k - 1), len_list - 1
        )  # Prevent out of range
        item_k_1 = arr[index_k]
        if item_k_1 == val:
            return index_k
        elif val < item_k_1:
            fibb_k -= 1
        elif val > item_k_1:
            offset += fibonacci(fibb_k - 1)
            fibb_k -= 2
    return -1",data\repos\Python\searches\fibonacci_search.py,fibonacci_search,546
1945,hill_climbing.py::hill_climbing::86,"def hill_climbing(
    search_prob,
    find_max: bool = True,
    max_x: float = math.inf,
    min_x: float = -math.inf,
    max_y: float = math.inf,
    min_y: float = -math.inf,
    visualization: bool = False,
    max_iter: int = 10000,
) -> SearchProblem:
    """"""
    Implementation of the hill climbling algorithm.
    We start with a given state, find all its neighbors,
    move towards the neighbor which provides the maximum (or minimum) change.
    We keep doing this until we are at a state where we do not have any
    neighbors which can improve the solution.
        Args:
            search_prob: The search state at the start.
            find_max: If True, the algorithm should find the maximum else the minimum.
            max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.
            visualization: If True, a matplotlib graph is displayed.
            max_iter: number of times to run the iteration.
        Returns a search state having the maximum (or minimum) score.
    """"""
    current_state = search_prob
    scores = []  # list to store the current score at each iteration
    iterations = 0
    solution_found = False
    visited = set()
    while not solution_found and iterations < max_iter:
        visited.add(current_state)
        iterations += 1
        current_score = current_state.score()
        scores.append(current_score)
        neighbors = current_state.get_neighbors()
        max_change = -math.inf
        min_change = math.inf
        next_state = None  # to hold the next best neighbor
        for neighbor in neighbors:
            if neighbor in visited:
                continue  # do not want to visit the same state again
            if (
                neighbor.x > max_x
                or neighbor.x < min_x
                or neighbor.y > max_y
                or neighbor.y < min_y
            ):
                continue  # neighbor outside our bounds
            change = neighbor.score() - current_score
            if find_max:  # finding max
                # going to direction with greatest ascent
                if change > max_change and change > 0:
                    max_change = change
                    next_state = neighbor
            elif change < min_change and change < 0:  # finding min
                # to direction with greatest descent
                min_change = change
                next_state = neighbor
        if next_state is not None:
            # we found at least one neighbor which improved the current state
            current_state = next_state
        else:
            # since we have no neighbor that improves the solution we stop the search
            solution_found = True

    if visualization:
        from matplotlib import pyplot as plt

        plt.plot(range(iterations), scores)
        plt.xlabel(""Iterations"")
        plt.ylabel(""Function values"")
        plt.show()

    return current_state",data\repos\Python\searches\hill_climbing.py,hill_climbing,608
1946,hill_climbing.py::score::25,"    def score(self) -> int:
        """"""
        Returns the output of the function called with current x and y coordinates.
        >>> def test_function(x, y):
        ...     return x + y
        >>> SearchProblem(0, 0, 1, test_function).score()  # 0 + 0 = 0
        0
        >>> SearchProblem(5, 7, 1, test_function).score()  # 5 + 7 = 12
        12
        """"""
        return self.function(self.x, self.y)",data\repos\Python\searches\hill_climbing.py,score,120
1947,hill_climbing.py::get_neighbors::37,"    def get_neighbors(self):
        """"""
        Returns a list of coordinates of neighbors adjacent to the current coordinates.

        Neighbors:
        | 0 | 1 | 2 |
        | 3 | _ | 4 |
        | 5 | 6 | 7 |
        """"""
        step_size = self.step_size
        return [
            SearchProblem(x, y, step_size, self.function)
            for x, y in (
                (self.x - step_size, self.y - step_size),
                (self.x - step_size, self.y),
                (self.x - step_size, self.y + step_size),
                (self.x, self.y - step_size),
                (self.x, self.y + step_size),
                (self.x + step_size, self.y - step_size),
                (self.x + step_size, self.y),
                (self.x + step_size, self.y + step_size),
            )
        ]",data\repos\Python\searches\hill_climbing.py,get_neighbors,195
1948,interpolation_search.py::interpolation_search::6,"def interpolation_search(sorted_collection: list[int], item: int) -> int | None:
    """"""
    Searches for an item in a sorted collection by interpolation search algorithm.

    Args:
        sorted_collection: sorted list of integers
        item: item value to search

    Returns:
        int: The index of the found item, or None if the item is not found.
    Examples:
    >>> interpolation_search([1, 2, 3, 4, 5], 2)
    1
    >>> interpolation_search([1, 2, 3, 4, 5], 4)
    3
    >>> interpolation_search([1, 2, 3, 4, 5], 6) is None
    True
    >>> interpolation_search([], 1) is None
    True
    >>> interpolation_search([100], 100)
    0
    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None
    True
    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None
    True
    >>> interpolation_search([1, 2, 3, 4, 5], 2)
    1
    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None
    True
    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None
    True
    >>> interpolation_search([1, 2, 3, 4, 5], 2)
    1
    >>> interpolation_search([5, 5, 5, 5, 5], 3) is None
    True
    """"""
    left = 0
    right = len(sorted_collection) - 1

    while left <= right:
        # avoid divided by 0 during interpolation
        if sorted_collection[left] == sorted_collection[right]:
            if sorted_collection[left] == item:
                return left
            return None

        point = left + ((item - sorted_collection[left]) * (right - left)) // (
            sorted_collection[right] - sorted_collection[left]
        )

        # out of range check
        if point < 0 or point >= len(sorted_collection):
            return None

        current_item = sorted_collection[point]
        if current_item == item:
            return point
        if point < left:
            right = left
            left = point
        elif point > right:
            left = right
            right = point
        elif item < current_item:
            right = point - 1
        else:
            left = point + 1
    return None",data\repos\Python\searches\interpolation_search.py,interpolation_search,579
1949,interpolation_search.py::interpolation_search_by_recursion::76,"def interpolation_search_by_recursion(
    sorted_collection: list[int], item: int, left: int = 0, right: int | None = None
) -> int | None:
    """"""Pure implementation of interpolation search algorithm in Python by recursion
    Be careful collection must be ascending sorted, otherwise result will be
    unpredictable
    First recursion should be started with left=0 and right=(len(sorted_collection)-1)

    Args:
        sorted_collection: some sorted collection with comparable items
        item: item value to search
        left: left index in collection
        right: right index in collection

    Returns:
        index of item in collection or None if item is not present

    Examples:
    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 0)
    0
    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 15)
    4
    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 5)
    1
    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 100) is None
    True
    >>> interpolation_search_by_recursion([5, 5, 5, 5, 5], 3) is None
    True
    """"""
    if right is None:
        right = len(sorted_collection) - 1
    # avoid divided by 0 during interpolation
    if sorted_collection[left] == sorted_collection[right]:
        if sorted_collection[left] == item:
            return left
        return None

    point = left + ((item - sorted_collection[left]) * (right - left)) // (
        sorted_collection[right] - sorted_collection[left]
    )

    # out of range check
    if point < 0 or point >= len(sorted_collection):
        return None

    if sorted_collection[point] == item:
        return point
    if point < left:
        return interpolation_search_by_recursion(sorted_collection, item, point, left)
    if point > right:
        return interpolation_search_by_recursion(sorted_collection, item, right, left)
    if sorted_collection[point] > item:
        return interpolation_search_by_recursion(
            sorted_collection, item, left, point - 1
        )
    return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)",data\repos\Python\searches\interpolation_search.py,interpolation_search_by_recursion,518
1950,jump_search.py::jump_search::23,"def jump_search(arr: Sequence[T], item: T) -> int:
    """"""
    Python implementation of the jump search algorithm.
    Return the index if the `item` is found, otherwise return -1.

    Examples:
    >>> jump_search([0, 1, 2, 3, 4, 5], 3)
    3
    >>> jump_search([-5, -2, -1], -1)
    2
    >>> jump_search([0, 5, 10, 20], 8)
    -1
    >>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)
    10
    >>> jump_search([""aa"", ""bb"", ""cc"", ""dd"", ""ee"", ""ff""], ""ee"")
    4
    """"""

    arr_size = len(arr)
    block_size = int(math.sqrt(arr_size))

    prev = 0
    step = block_size
    while arr[min(step, arr_size) - 1] < item:
        prev = step
        step += block_size
        if prev >= arr_size:
            return -1

    while arr[prev] < item:
        prev += 1
        if prev == min(step, arr_size):
            return -1
    if arr[prev] == item:
        return prev
    return -1",data\repos\Python\searches\jump_search.py,jump_search,323
1951,linear_search.py::linear_search::12,"def linear_search(sequence: list, target: int) -> int:
    """"""A pure Python implementation of a linear search algorithm

    :param sequence: a collection with comparable items (as sorted items not required
        in Linear Search)
    :param target: item value to search
    :return: index of found item or -1 if item is not found

    Examples:
    >>> linear_search([0, 5, 7, 10, 15], 0)
    0
    >>> linear_search([0, 5, 7, 10, 15], 15)
    4
    >>> linear_search([0, 5, 7, 10, 15], 5)
    1
    >>> linear_search([0, 5, 7, 10, 15], 6)
    -1
    """"""
    for index, item in enumerate(sequence):
        if item == target:
            return index
    return -1",data\repos\Python\searches\linear_search.py,linear_search,207
1952,linear_search.py::rec_linear_search::36,"def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:
    """"""
    A pure Python implementation of a recursive linear search algorithm

    :param sequence: a collection with comparable items (as sorted items not required
        in Linear Search)
    :param low: Lower bound of the array
    :param high: Higher bound of the array
    :param target: The element to be found
    :return: Index of the key or -1 if key not found

    Examples:
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)
    0
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)
    4
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)
    1
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)
    -1
    """"""
    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):
        raise Exception(""Invalid upper or lower bound!"")
    if high < low:
        return -1
    if sequence[low] == target:
        return low
    if sequence[high] == target:
        return high
    return rec_linear_search(sequence, low + 1, high - 1, target)",data\repos\Python\searches\linear_search.py,rec_linear_search,331
1953,median_of_medians.py::median_of_five::12,"def median_of_five(arr: list) -> int:
    """"""
    Return the median of the input list
    :param arr: Array to find median of
    :return: median of arr

    >>> median_of_five([2, 4, 5, 7, 899])
    5
    >>> median_of_five([5, 7, 899, 54, 32])
    32
    >>> median_of_five([5, 4, 3, 2])
    4
    >>> median_of_five([3, 5, 7, 10, 2])
    5
    """"""
    arr = sorted(arr)
    return arr[len(arr) // 2]",data\repos\Python\searches\median_of_medians.py,median_of_five,152
1954,median_of_medians.py::median_of_medians::31,"def median_of_medians(arr: list) -> int:
    """"""
    Return a pivot to partition data on by calculating
    Median of medians of input data
    :param arr: The data to be checked (a list)
    :return: median of medians of input array

    >>> median_of_medians([2, 4, 5, 7, 899, 54, 32])
    54
    >>> median_of_medians([5, 7, 899, 54, 32])
    32
    >>> median_of_medians([5, 4, 3, 2])
    4
    >>> median_of_medians([3, 5, 7, 10, 2, 12])
    12
    """"""

    if len(arr) <= 5:
        return median_of_five(arr)
    medians = []
    i = 0
    while i < len(arr):
        if (i + 4) <= len(arr):
            medians.append(median_of_five(arr[i:].copy()))
        else:
            medians.append(median_of_five(arr[i : i + 5].copy()))
        i += 5
    return median_of_medians(medians)",data\repos\Python\searches\median_of_medians.py,median_of_medians,264
1955,median_of_medians.py::quick_select::61,"def quick_select(arr: list, target: int) -> int:
    """"""
    Two way partition the data into smaller and greater lists,
    in relationship to the pivot
    :param arr: The data to be searched (a list)
    :param target: The rank to be searched
    :return: element at rank target

    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)
    32
    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)
    2
    >>> quick_select([5, 4, 3, 2], 2)
    3
    >>> quick_select([3, 5, 7, 10, 2, 12], 3)
    5
    """"""

    # Invalid Input
    if target > len(arr):
        return -1

    # x is the estimated pivot by median of medians algorithm
    x = median_of_medians(arr)
    left = []
    right = []
    check = False
    for i in range(len(arr)):
        if arr[i] < x:
            left.append(arr[i])
        elif arr[i] > x:
            right.append(arr[i])
        elif arr[i] == x and not check:
            check = True
        else:
            right.append(arr[i])
    rank_x = len(left) + 1
    if rank_x == target:
        answer = x
    elif rank_x > target:
        answer = quick_select(left, target)
    elif rank_x < target:
        answer = quick_select(right, target - rank_x)
    return answer",data\repos\Python\searches\median_of_medians.py,quick_select,362
1956,quick_select.py::quick_select::30,"def quick_select(items: list, index: int):
    """"""
    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)
    54
    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)
    4
    >>> quick_select([5, 4, 3, 2], 2)
    4
    >>> quick_select([3, 5, 7, 10, 2, 12], 3)
    7
    """"""
    # index = len(items) // 2 when trying to find the median
    #   (value of index when items is sorted)

    # invalid input
    if index >= len(items) or index < 0:
        return None

    pivot = items[random.randint(0, len(items) - 1)]
    count = 0
    smaller, equal, larger = _partition(items, pivot)
    count = len(equal)
    m = len(smaller)

    # index is the pivot
    if m <= index < m + count:
        return pivot
    # must be in smaller
    elif m > index:
        return quick_select(smaller, index)
    # must be in larger
    else:
        return quick_select(larger, index - (m + count))",data\repos\Python\searches\quick_select.py,quick_select,297
1957,quick_select.py::median::65,"def median(items: list):
    """"""
    One common application of Quickselect is finding the median, which is
    the middle element (or average of the two middle elements) in a sorted dataset.
    It works efficiently on unsorted lists by partially sorting the data without
    fully sorting the entire list.

    >>> median([3, 2, 2, 9, 9])
    3

    >>> median([2, 2, 9, 9, 9, 3])
    6.0
    """"""
    mid, rem = divmod(len(items), 2)
    if rem != 0:
        return quick_select(items=items, index=mid)
    else:
        low_mid = quick_select(items=items, index=mid - 1)
        high_mid = quick_select(items=items, index=mid)
        return (low_mid + high_mid) / 2",data\repos\Python\searches\quick_select.py,median,192
1958,sentinel_linear_search.py::sentinel_linear_search::14,"def sentinel_linear_search(sequence, target):
    """"""Pure implementation of sentinel linear search algorithm in Python

    :param sequence: some sequence with comparable items
    :param target: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> sentinel_linear_search([0, 5, 7, 10, 15], 0)
    0

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 15)
    4

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 5)
    1

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)

    """"""
    sequence.append(target)

    index = 0
    while sequence[index] != target:
        index += 1

    sequence.pop()

    if index == len(sequence):
        return None

    return index",data\repos\Python\searches\sentinel_linear_search.py,sentinel_linear_search,209
1959,simple_binary_search.py::binary_search::14,"def binary_search(a_list: list[int], item: int) -> bool:
    """"""
    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
    >>> binary_search(test_list, 3)
    False
    >>> binary_search(test_list, 13)
    True
    >>> binary_search([4, 4, 5, 6, 7], 4)
    True
    >>> binary_search([4, 4, 5, 6, 7], -10)
    False
    >>> binary_search([-18, 2], -18)
    True
    >>> binary_search([5], 5)
    True
    >>> binary_search(['a', 'c', 'd'], 'c')
    True
    >>> binary_search(['a', 'c', 'd'], 'f')
    False
    >>> binary_search([], 1)
    False
    >>> binary_search([-.1, .1 , .8], .1)
    True
    >>> binary_search(range(-5000, 5000, 10), 80)
    True
    >>> binary_search(range(-5000, 5000, 10), 1255)
    False
    >>> binary_search(range(0, 10000, 5), 2)
    False
    """"""
    if len(a_list) == 0:
        return False
    midpoint = len(a_list) // 2
    if a_list[midpoint] == item:
        return True
    if item < a_list[midpoint]:
        return binary_search(a_list[:midpoint], item)
    else:
        return binary_search(a_list[midpoint + 1 :], item)",data\repos\Python\searches\simple_binary_search.py,binary_search,369
1960,simulated_annealing.py::simulated_annealing::9,"def simulated_annealing(
    search_prob,
    find_max: bool = True,
    max_x: float = math.inf,
    min_x: float = -math.inf,
    max_y: float = math.inf,
    min_y: float = -math.inf,
    visualization: bool = False,
    start_temperate: float = 100,
    rate_of_decrease: float = 0.01,
    threshold_temp: float = 1,
) -> Any:
    """"""
    Implementation of the simulated annealing algorithm. We start with a given state,
    find all its neighbors. Pick a random neighbor, if that neighbor improves the
    solution, we move in that direction, if that neighbor does not improve the solution,
    we generate a random real number between 0 and 1, if the number is within a certain
    range (calculated using temperature) we move in that direction, else we pick
    another neighbor randomly and repeat the process.

    Args:
        search_prob: The search state at the start.
        find_max: If True, the algorithm should find the minimum else the minimum.
        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.
        visualization: If True, a matplotlib graph is displayed.
        start_temperate: the initial temperate of the system when the program starts.
        rate_of_decrease: the rate at which the temperate decreases in each iteration.
        threshold_temp: the threshold temperature below which we end the search
    Returns a search state having the maximum (or minimum) score.
    """"""
    search_end = False
    current_state = search_prob
    current_temp = start_temperate
    scores = []
    iterations = 0
    best_state = None

    while not search_end:
        current_score = current_state.score()
        if best_state is None or current_score > best_state.score():
            best_state = current_state
        scores.append(current_score)
        iterations += 1
        next_state = None
        neighbors = current_state.get_neighbors()
        while (
            next_state is None and neighbors
        ):  # till we do not find a neighbor that we can move to
            index = random.randint(0, len(neighbors) - 1)  # picking a random neighbor
            picked_neighbor = neighbors.pop(index)
            change = picked_neighbor.score() - current_score

            if (
                picked_neighbor.x > max_x
                or picked_neighbor.x < min_x
                or picked_neighbor.y > max_y
                or picked_neighbor.y < min_y
            ):
                continue  # neighbor outside our bounds

            if not find_max:
                change = change * -1  # in case we are finding minimum
            if change > 0:  # improves the solution
                next_state = picked_neighbor
            else:
                probability = (math.e) ** (
                    change / current_temp
                )  # probability generation function
                if random.random() < probability:  # random number within probability
                    next_state = picked_neighbor
        current_temp = current_temp - (current_temp * rate_of_decrease)

        if current_temp < threshold_temp or next_state is None:
            # temperature below threshold, or could not find a suitable neighbor
            search_end = True
        else:
            current_state = next_state

    if visualization:
        from matplotlib import pyplot as plt

        plt.plot(range(iterations), scores)
        plt.xlabel(""Iterations"")
        plt.ylabel(""Function values"")
        plt.show()
    return best_state",data\repos\Python\searches\simulated_annealing.py,simulated_annealing,740
1961,tabu_search.py::generate_neighbours::32,"def generate_neighbours(path):
    """"""
    Pure implementation of generating a dictionary of neighbors and the cost with each
    neighbor, given a path file that includes a graph.

    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)
    :return dict_of_neighbours: Dictionary with key each node and value a list of lists
        with the neighbors of the node and the cost (distance) for each neighbor.

    Example of dict_of_neighbours:
    >>) dict_of_neighbours[a]
    [[b,20],[c,18],[d,22],[e,26]]

    This indicates the neighbors of node (city) 'a', which has neighbor the node 'b'
    with distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and
    the node 'e' with distance 26.
    """"""

    dict_of_neighbours = {}

    with open(path) as f:
        for line in f:
            if line.split()[0] not in dict_of_neighbours:
                _list = []
                _list.append([line.split()[1], line.split()[2]])
                dict_of_neighbours[line.split()[0]] = _list
            else:
                dict_of_neighbours[line.split()[0]].append(
                    [line.split()[1], line.split()[2]]
                )
            if line.split()[1] not in dict_of_neighbours:
                _list = []
                _list.append([line.split()[0], line.split()[2]])
                dict_of_neighbours[line.split()[1]] = _list
            else:
                dict_of_neighbours[line.split()[1]].append(
                    [line.split()[0], line.split()[2]]
                )

    return dict_of_neighbours",data\repos\Python\searches\tabu_search.py,generate_neighbours,374
1962,tabu_search.py::generate_first_solution::74,"def generate_first_solution(path, dict_of_neighbours):
    """"""
    Pure implementation of generating the first solution for the Tabu search to start,
    with the redundant resolution strategy. That means that we start from the starting
    node (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node
    (let's assume is node 'c'), then we go to the nearest city of the node 'c', etc.
    till we have visited all cities and return to the starting node.

    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)
    :param dict_of_neighbours: Dictionary with key each node and value a list of lists
        with the neighbors of the node and the cost (distance) for each neighbor.
    :return first_solution: The solution for the first iteration of Tabu search using
        the redundant resolution strategy in a list.
    :return distance_of_first_solution: The total distance that Travelling Salesman
        will travel, if he follows the path in first_solution.
    """"""

    with open(path) as f:
        start_node = f.read(1)
    end_node = start_node

    first_solution = []

    visiting = start_node

    distance_of_first_solution = 0
    while visiting not in first_solution:
        minim = 10000
        for k in dict_of_neighbours[visiting]:
            if int(k[1]) < int(minim) and k[0] not in first_solution:
                minim = k[1]
                best_node = k[0]

        first_solution.append(visiting)
        distance_of_first_solution = distance_of_first_solution + int(minim)
        visiting = best_node

    first_solution.append(end_node)

    position = 0
    for k in dict_of_neighbours[first_solution[-2]]:
        if k[0] == start_node:
            break
        position += 1

    distance_of_first_solution = (
        distance_of_first_solution
        + int(dict_of_neighbours[first_solution[-2]][position][1])
        - 10000
    )
    return first_solution, distance_of_first_solution",data\repos\Python\searches\tabu_search.py,generate_first_solution,457
1963,tabu_search.py::find_neighborhood::127,"def find_neighborhood(solution, dict_of_neighbours):
    """"""
    Pure implementation of generating the neighborhood (sorted by total distance of
    each solution from lowest to highest) of a solution with 1-1 exchange method, that
    means we exchange each node in a solution with each other node and generating a
    number of solution named neighborhood.

    :param solution: The solution in which we want to find the neighborhood.
    :param dict_of_neighbours: Dictionary with key each node and value a list of lists
        with the neighbors of the node and the cost (distance) for each neighbor.
    :return neighborhood_of_solution: A list that includes the solutions and the total
        distance of each solution (in form of list) that are produced with 1-1 exchange
        from the solution that the method took as an input

    Example:
    >>> find_neighborhood(['a', 'c', 'b', 'd', 'e', 'a'],
    ...                   {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']],
    ...                    'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']],
    ...                    'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']],
    ...                    'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']],
    ...                    'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]}
    ...                   )  # doctest: +NORMALIZE_WHITESPACE
    [['a', 'e', 'b', 'd', 'c', 'a', 90],
     ['a', 'c', 'd', 'b', 'e', 'a', 90],
     ['a', 'd', 'b', 'c', 'e', 'a', 93],
     ['a', 'c', 'b', 'e', 'd', 'a', 102],
     ['a', 'c', 'e', 'd', 'b', 'a', 113],
     ['a', 'b', 'c', 'd', 'e', 'a', 119]]
    """"""

    neighborhood_of_solution = []

    for n in solution[1:-1]:
        idx1 = solution.index(n)
        for kn in solution[1:-1]:
            idx2 = solution.index(kn)
            if n == kn:
                continue

            _tmp = copy.deepcopy(solution)
            _tmp[idx1] = kn
            _tmp[idx2] = n

            distance = 0

            for k in _tmp[:-1]:
                next_node = _tmp[_tmp.index(k) + 1]
                for i in dict_of_neighbours[k]:
                    if i[0] == next_node:
                        distance = distance + int(i[1])
            _tmp.append(distance)

            if _tmp not in neighborhood_of_solution:
                neighborhood_of_solution.append(_tmp)

    index_of_last_item_in_the_list = len(neighborhood_of_solution[0]) - 1

    neighborhood_of_solution.sort(key=lambda x: x[index_of_last_item_in_the_list])
    return neighborhood_of_solution",data\repos\Python\searches\tabu_search.py,find_neighborhood,709
1964,tabu_search.py::tabu_search::188,"def tabu_search(
    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size
):
    """"""
    Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in
    Python.

    :param first_solution: The solution for the first iteration of Tabu search using
        the redundant resolution strategy in a list.
    :param distance_of_first_solution: The total distance that Travelling Salesman will
        travel, if he follows the path in first_solution.
    :param dict_of_neighbours: Dictionary with key each node and value a list of lists
        with the neighbors of the node and the cost (distance) for each neighbor.
    :param iters: The number of iterations that Tabu search will execute.
    :param size: The size of Tabu List.
    :return best_solution_ever: The solution with the lowest distance that occurred
        during the execution of Tabu search.
    :return best_cost: The total distance that Travelling Salesman will travel, if he
        follows the path in best_solution ever.
    """"""
    count = 1
    solution = first_solution
    tabu_list = []
    best_cost = distance_of_first_solution
    best_solution_ever = solution

    while count <= iters:
        neighborhood = find_neighborhood(solution, dict_of_neighbours)
        index_of_best_solution = 0
        best_solution = neighborhood[index_of_best_solution]
        best_cost_index = len(best_solution) - 1

        found = False
        while not found:
            i = 0
            while i < len(best_solution):
                if best_solution[i] != solution[i]:
                    first_exchange_node = best_solution[i]
                    second_exchange_node = solution[i]
                    break
                i = i + 1

            if [first_exchange_node, second_exchange_node] not in tabu_list and [
                second_exchange_node,
                first_exchange_node,
            ] not in tabu_list:
                tabu_list.append([first_exchange_node, second_exchange_node])
                found = True
                solution = best_solution[:-1]
                cost = neighborhood[index_of_best_solution][best_cost_index]
                if cost < best_cost:
                    best_cost = cost
                    best_solution_ever = solution
            else:
                index_of_best_solution = index_of_best_solution + 1
                best_solution = neighborhood[index_of_best_solution]

        if len(tabu_list) >= size:
            tabu_list.pop(0)

        count = count + 1

    return best_solution_ever, best_cost",data\repos\Python\searches\tabu_search.py,tabu_search,535
1965,tabu_search.py::main::253,"def main(args=None):
    dict_of_neighbours = generate_neighbours(args.File)

    first_solution, distance_of_first_solution = generate_first_solution(
        args.File, dict_of_neighbours
    )

    best_sol, best_cost = tabu_search(
        first_solution,
        distance_of_first_solution,
        dict_of_neighbours,
        args.Iterations,
        args.Size,
    )

    print(f""Best solution: {best_sol}, with total distance: {best_cost}."")",data\repos\Python\searches\tabu_search.py,main,99
1966,ternary_search.py::lin_search::20,"def lin_search(left: int, right: int, array: list[int], target: int) -> int:
    """"""Perform linear search in list. Returns -1 if element is not found.

    Parameters
    ----------
    left : int
        left index bound.
    right : int
        right index bound.
    array : List[int]
        List of elements to be searched on
    target : int
        Element that is searched

    Returns
    -------
    int
        index of element that is looked for.

    Examples
    --------
    >>> lin_search(0, 4, [4, 5, 6, 7], 7)
    3
    >>> lin_search(0, 3, [4, 5, 6, 7], 7)
    -1
    >>> lin_search(0, 2, [-18, 2], -18)
    0
    >>> lin_search(0, 1, [5], 5)
    0
    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')
    1
    >>> lin_search(0, 3, [.1, .4 , -.1], .1)
    0
    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)
    2
    """"""
    for i in range(left, right):
        if array[i] == target:
            return i
    return -1",data\repos\Python\searches\ternary_search.py,lin_search,319
1967,ternary_search.py::ite_ternary_search::62,"def ite_ternary_search(array: list[int], target: int) -> int:
    """"""Iterative method of the ternary search algorithm.
    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
    >>> ite_ternary_search(test_list, 3)
    -1
    >>> ite_ternary_search(test_list, 13)
    4
    >>> ite_ternary_search([4, 5, 6, 7], 4)
    0
    >>> ite_ternary_search([4, 5, 6, 7], -10)
    -1
    >>> ite_ternary_search([-18, 2], -18)
    0
    >>> ite_ternary_search([5], 5)
    0
    >>> ite_ternary_search(['a', 'c', 'd'], 'c')
    1
    >>> ite_ternary_search(['a', 'c', 'd'], 'f')
    -1
    >>> ite_ternary_search([], 1)
    -1
    >>> ite_ternary_search([.1, .4 , -.1], .1)
    0
    """"""

    left = 0
    right = len(array)
    while left <= right:
        if right - left < precision:
            return lin_search(left, right, array, target)

        one_third = (left + right) // 3 + 1
        two_third = 2 * (left + right) // 3 + 1

        if array[one_third] == target:
            return one_third
        elif array[two_third] == target:
            return two_third

        elif target < array[one_third]:
            right = one_third - 1
        elif array[two_third] < target:
            left = two_third + 1

        else:
            left = one_third + 1
            right = two_third - 1
    return -1",data\repos\Python\searches\ternary_search.py,ite_ternary_search,448
1968,ternary_search.py::rec_ternary_search::112,"def rec_ternary_search(left: int, right: int, array: list[int], target: int) -> int:
    """"""Recursive method of the ternary search algorithm.

    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
    >>> rec_ternary_search(0, len(test_list), test_list, 3)
    -1
    >>> rec_ternary_search(4, len(test_list), test_list, 42)
    8
    >>> rec_ternary_search(0, 2, [4, 5, 6, 7], 4)
    0
    >>> rec_ternary_search(0, 3, [4, 5, 6, 7], -10)
    -1
    >>> rec_ternary_search(0, 1, [-18, 2], -18)
    0
    >>> rec_ternary_search(0, 1, [5], 5)
    0
    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'c')
    1
    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'f')
    -1
    >>> rec_ternary_search(0, 0, [], 1)
    -1
    >>> rec_ternary_search(0, 3, [.1, .4 , -.1], .1)
    0
    """"""
    if left < right:
        if right - left < precision:
            return lin_search(left, right, array, target)
        one_third = (left + right) // 3 + 1
        two_third = 2 * (left + right) // 3 + 1

        if array[one_third] == target:
            return one_third
        elif array[two_third] == target:
            return two_third

        elif target < array[one_third]:
            return rec_ternary_search(left, one_third - 1, array, target)
        elif array[two_third] < target:
            return rec_ternary_search(two_third + 1, right, array, target)
        else:
            return rec_ternary_search(one_third + 1, two_third - 1, array, target)
    else:
        return -1",data\repos\Python\searches\ternary_search.py,rec_ternary_search,522
1969,bead_sort.py::bead_sort::7,"def bead_sort(sequence: list) -> list:
    """"""
    >>> bead_sort([6, 11, 12, 4, 1, 5])
    [1, 4, 5, 6, 11, 12]

    >>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1])
    [1, 2, 3, 4, 5, 6, 7, 8, 9]

    >>> bead_sort([5, 0, 4, 3])
    [0, 3, 4, 5]

    >>> bead_sort([8, 2, 1])
    [1, 2, 8]

    >>> bead_sort([1, .9, 0.0, 0, -1, -.9])
    Traceback (most recent call last):
        ...
    TypeError: Sequence must be list of non-negative integers

    >>> bead_sort(""Hello world"")
    Traceback (most recent call last):
        ...
    TypeError: Sequence must be list of non-negative integers
    """"""
    if any(not isinstance(x, int) or x < 0 for x in sequence):
        raise TypeError(""Sequence must be list of non-negative integers"")
    for _ in range(len(sequence)):
        for i, (rod_upper, rod_lower) in enumerate(zip(sequence, sequence[1:])):  # noqa: RUF007
            if rod_upper > rod_lower:
                sequence[i] -= rod_upper - rod_lower
                sequence[i + 1] += rod_upper - rod_lower
    return sequence",data\repos\Python\sorts\bead_sort.py,bead_sort,349
1970,binary_insertion_sort.py::binary_insertion_sort::14,"def binary_insertion_sort(collection: list) -> list:
    """"""
    Sorts a list using the binary insertion sort algorithm.

    :param collection: A mutable ordered collection with comparable items.
    :return: The same collection ordered in ascending order.

    Examples:
    >>> binary_insertion_sort([0, 4, 1234, 4, 1])
    [0, 1, 4, 4, 1234]
    >>> binary_insertion_sort([]) == sorted([])
    True
    >>> binary_insertion_sort([-1, -2, -3]) == sorted([-1, -2, -3])
    True
    >>> lst = ['d', 'a', 'b', 'e', 'c']
    >>> binary_insertion_sort(lst) == sorted(lst)
    True
    >>> import random
    >>> collection = random.sample(range(-50, 50), 100)
    >>> binary_insertion_sort(collection) == sorted(collection)
    True
    >>> import string
    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)
    >>> binary_insertion_sort(collection) == sorted(collection)
    True
    """"""

    n = len(collection)
    for i in range(1, n):
        value_to_insert = collection[i]
        low = 0
        high = i - 1

        while low <= high:
            mid = (low + high) // 2
            if value_to_insert < collection[mid]:
                high = mid - 1
            else:
                low = mid + 1
        for j in range(i, low, -1):
            collection[j] = collection[j - 1]
        collection[low] = value_to_insert
    return collection",data\repos\Python\sorts\binary_insertion_sort.py,binary_insertion_sort,366
1971,bitonic_sort.py::comp_and_swap::10,"def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:
    """"""Compare the value at given index1 and index2 of the array and swap them as per
    the given direction.

    The parameter direction indicates the sorting direction, ASCENDING(1) or
    DESCENDING(0); if (a[i] > a[j]) agrees with the direction, then a[i] and a[j] are
    interchanged.

    >>> arr = [12, 42, -21, 1]
    >>> comp_and_swap(arr, 1, 2, 1)
    >>> arr
    [12, -21, 42, 1]

    >>> comp_and_swap(arr, 1, 2, 0)
    >>> arr
    [12, 42, -21, 1]

    >>> comp_and_swap(arr, 0, 3, 1)
    >>> arr
    [1, 42, -21, 12]

    >>> comp_and_swap(arr, 0, 3, 0)
    >>> arr
    [12, 42, -21, 1]
    """"""
    if (direction == 1 and array[index1] > array[index2]) or (
        direction == 0 and array[index1] < array[index2]
    ):
        array[index1], array[index2] = array[index2], array[index1]",data\repos\Python\sorts\bitonic_sort.py,comp_and_swap,306
1972,bitonic_sort.py::bitonic_merge::41,"def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:
    """"""
    It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in
    descending if direction = 0.
    The sequence to be sorted starts at index position low, the parameter length is the
    number of elements to be sorted.

    >>> arr = [12, 42, -21, 1]
    >>> bitonic_merge(arr, 0, 4, 1)
    >>> arr
    [-21, 1, 12, 42]

    >>> bitonic_merge(arr, 0, 4, 0)
    >>> arr
    [42, 12, 1, -21]
    """"""
    if length > 1:
        middle = int(length / 2)
        for i in range(low, low + middle):
            comp_and_swap(array, i, i + middle, direction)
        bitonic_merge(array, low, middle, direction)
        bitonic_merge(array, low + middle, middle, direction)",data\repos\Python\sorts\bitonic_sort.py,bitonic_merge,232
1973,bitonic_sort.py::bitonic_sort::65,"def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:
    """"""
    This function first produces a bitonic sequence by recursively sorting its two
    halves in opposite sorting orders, and then calls bitonic_merge to make them in the
    same order.

    >>> arr = [12, 34, 92, -23, 0, -121, -167, 145]
    >>> bitonic_sort(arr, 0, 8, 1)
    >>> arr
    [-167, -121, -23, 0, 12, 34, 92, 145]

    >>> bitonic_sort(arr, 0, 8, 0)
    >>> arr
    [145, 92, 34, 12, 0, -23, -121, -167]
    """"""
    if length > 1:
        middle = int(length / 2)
        bitonic_sort(array, low, middle, 1)
        bitonic_sort(array, low + middle, middle, 0)
        bitonic_merge(array, low, length, direction)",data\repos\Python\sorts\bitonic_sort.py,bitonic_sort,240
1974,bogo_sort.py::bogo_sort::19,"def bogo_sort(collection):
    """"""Pure implementation of the bogosort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> bogo_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> bogo_sort([])
    []
    >>> bogo_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""

    def is_sorted(collection):
        for i in range(len(collection) - 1):
            if collection[i] > collection[i + 1]:
                return False
        return True

    while not is_sorted(collection):
        random.shuffle(collection)
    return collection",data\repos\Python\sorts\bogo_sort.py,bogo_sort,173
1975,bogo_sort.py::is_sorted::33,"    def is_sorted(collection):
        for i in range(len(collection) - 1):
            if collection[i] > collection[i + 1]:
                return False
        return True",data\repos\Python\sorts\bogo_sort.py,is_sorted,37
1976,bubble_sort.py::bubble_sort_iterative::4,"def bubble_sort_iterative(collection: list[Any]) -> list[Any]:
    """"""Pure implementation of bubble sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> bubble_sort_iterative([0, 5, 2, 3, 2])
    [0, 2, 2, 3, 5]
    >>> bubble_sort_iterative([])
    []
    >>> bubble_sort_iterative([-2, -45, -5])
    [-45, -5, -2]
    >>> bubble_sort_iterative([-23, 0, 6, -4, 34])
    [-23, -4, 0, 6, 34]
    >>> bubble_sort_iterative([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])
    True
    >>> bubble_sort_iterative([]) == sorted([])
    True
    >>> bubble_sort_iterative([-2, -45, -5]) == sorted([-2, -45, -5])
    True
    >>> bubble_sort_iterative([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])
    True
    >>> bubble_sort_iterative(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])
    True
    >>> bubble_sort_iterative(['z', 'a', 'y', 'b', 'x', 'c'])
    ['a', 'b', 'c', 'x', 'y', 'z']
    >>> bubble_sort_iterative([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])
    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]
    >>> bubble_sort_iterative([1, 3.3, 5, 7.7, 2, 4.4, 6])
    [1, 2, 3.3, 4.4, 5, 6, 7.7]
    >>> import random
    >>> collection_arg = random.sample(range(-50, 50), 100)
    >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)
    True
    >>> import string
    >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)
    >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)
    True
    """"""
    length = len(collection)
    for i in reversed(range(length)):
        swapped = False
        for j in range(i):
            if collection[j] > collection[j + 1]:
                swapped = True
                collection[j], collection[j + 1] = collection[j + 1], collection[j]
        if not swapped:
            break  # Stop iteration if the collection is sorted.
    return collection",data\repos\Python\sorts\bubble_sort.py,bubble_sort_iterative,670
1977,bubble_sort.py::bubble_sort_recursive::57,"def bubble_sort_recursive(collection: list[Any]) -> list[Any]:
    """"""It is similar iterative bubble sort but recursive.

    :param collection: mutable ordered sequence of elements
    :return: the same list in ascending order

    Examples:
    >>> bubble_sort_recursive([0, 5, 2, 3, 2])
    [0, 2, 2, 3, 5]
    >>> bubble_sort_iterative([])
    []
    >>> bubble_sort_recursive([-2, -45, -5])
    [-45, -5, -2]
    >>> bubble_sort_recursive([-23, 0, 6, -4, 34])
    [-23, -4, 0, 6, 34]
    >>> bubble_sort_recursive([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])
    True
    >>> bubble_sort_recursive([]) == sorted([])
    True
    >>> bubble_sort_recursive([-2, -45, -5]) == sorted([-2, -45, -5])
    True
    >>> bubble_sort_recursive([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])
    True
    >>> bubble_sort_recursive(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])
    True
    >>> bubble_sort_recursive(['z', 'a', 'y', 'b', 'x', 'c'])
    ['a', 'b', 'c', 'x', 'y', 'z']
    >>> bubble_sort_recursive([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])
    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]
    >>> bubble_sort_recursive([1, 3.3, 5, 7.7, 2, 4.4, 6])
    [1, 2, 3.3, 4.4, 5, 6, 7.7]
    >>> bubble_sort_recursive(['a', 'Z', 'B', 'C', 'A', 'c'])
    ['A', 'B', 'C', 'Z', 'a', 'c']
    >>> import random
    >>> collection_arg = random.sample(range(-50, 50), 100)
    >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)
    True
    >>> import string
    >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)
    >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)
    True
    """"""
    length = len(collection)
    swapped = False
    for i in range(length - 1):
        if collection[i] > collection[i + 1]:
            collection[i], collection[i + 1] = collection[i + 1], collection[i]
            swapped = True

    return collection if not swapped else bubble_sort_recursive(collection)",data\repos\Python\sorts\bubble_sort.py,bubble_sort_recursive,679
1978,bucket_sort.py::bucket_sort::34,"def bucket_sort(my_list: list, bucket_count: int = 10) -> list:
    """"""
    >>> data = [-1, 2, -5, 0]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [9, 8, 7, 6, -12]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [.4, 1.2, .1, .2, -.9]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> bucket_sort([]) == sorted([])
    True
    >>> data = [-1e10, 1e10]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> import random
    >>> collection = random.sample(range(-50, 50), 50)
    >>> bucket_sort(collection) == sorted(collection)
    True
    >>> data = [1, 2, 2, 1, 1, 3]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [5, 5, 5, 5, 5]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [1000, -1000, 500, -500, 0]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [5.5, 2.2, -1.1, 3.3, 0.0]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> bucket_sort([1]) == [1]
    True
    >>> data = [-1.1, -1.5, -3.4, 2.5, 3.6, -3.3]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [9, 2, 7, 1, 5]
    >>> bucket_sort(data) == sorted(data)
    True
    """"""

    if len(my_list) == 0 or bucket_count <= 0:
        return []

    min_value, max_value = min(my_list), max(my_list)
    if min_value == max_value:
        return my_list

    bucket_size = (max_value - min_value) / bucket_count
    buckets: list[list] = [[] for _ in range(bucket_count)]

    for val in my_list:
        index = min(int((val - min_value) / bucket_size), bucket_count - 1)
        buckets[index].append(val)

    return [val for bucket in buckets for val in sorted(bucket)]",data\repos\Python\sorts\bucket_sort.py,bucket_sort,553
1979,circle_sort.py::circle_sort::12,"def circle_sort(collection: list) -> list:
    """"""A pure Python implementation of circle sort algorithm

    :param collection: a mutable collection of comparable items in any order
    :return: the same collection in ascending order

    Examples:
    >>> circle_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> circle_sort([])
    []
    >>> circle_sort([-2, 5, 0, -45])
    [-45, -2, 0, 5]
    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])
    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)
    True
    """"""

    if len(collection) < 2:
        return collection

    def circle_sort_util(collection: list, low: int, high: int) -> bool:
        """"""
        >>> arr = [5,4,3,2,1]
        >>> circle_sort_util(lst, 0, 2)
        True
        >>> arr
        [3, 4, 5, 2, 1]
        """"""

        swapped = False

        if low == high:
            return swapped

        left = low
        right = high

        while left < right:
            if collection[left] > collection[right]:
                collection[left], collection[right] = (
                    collection[right],
                    collection[left],
                )
                swapped = True

            left += 1
            right -= 1

        if left == right and collection[left] > collection[right + 1]:
            collection[left], collection[right + 1] = (
                collection[right + 1],
                collection[left],
            )

            swapped = True

        mid = low + int((high - low) / 2)
        left_swap = circle_sort_util(collection, low, mid)
        right_swap = circle_sort_util(collection, mid + 1, high)

        return swapped or left_swap or right_swap

    is_not_sorted = True

    while is_not_sorted is True:
        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)

    return collection",data\repos\Python\sorts\circle_sort.py,circle_sort,477
1980,circle_sort.py::circle_sort_util::33,"    def circle_sort_util(collection: list, low: int, high: int) -> bool:
        """"""
        >>> arr = [5,4,3,2,1]
        >>> circle_sort_util(lst, 0, 2)
        True
        >>> arr
        [3, 4, 5, 2, 1]
        """"""

        swapped = False

        if low == high:
            return swapped

        left = low
        right = high

        while left < right:
            if collection[left] > collection[right]:
                collection[left], collection[right] = (
                    collection[right],
                    collection[left],
                )
                swapped = True

            left += 1
            right -= 1

        if left == right and collection[left] > collection[right + 1]:
            collection[left], collection[right + 1] = (
                collection[right + 1],
                collection[left],
            )

            swapped = True

        mid = low + int((high - low) / 2)
        left_swap = circle_sort_util(collection, low, mid)
        right_swap = circle_sort_util(collection, mid + 1, high)

        return swapped or left_swap or right_swap",data\repos\Python\sorts\circle_sort.py,circle_sort_util,250
1981,cocktail_shaker_sort.py::cocktail_shaker_sort::8,"def cocktail_shaker_sort(arr: list[int]) -> list[int]:
    """"""
    Sorts a list using the Cocktail Shaker Sort algorithm.

    :param arr: List of elements to be sorted.
    :return: Sorted list.

    >>> cocktail_shaker_sort([4, 5, 2, 1, 2])
    [1, 2, 2, 4, 5]
    >>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])
    [-4, 0, 1, 2, 5, 11]
    >>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])
    [-2.4, 0.1, 2.2, 4.4]
    >>> cocktail_shaker_sort([1, 2, 3, 4, 5])
    [1, 2, 3, 4, 5]
    >>> cocktail_shaker_sort([-4, -5, -24, -7, -11])
    [-24, -11, -7, -5, -4]
    >>> cocktail_shaker_sort([""elderberry"", ""banana"", ""date"", ""apple"", ""cherry""])
    ['apple', 'banana', 'cherry', 'date', 'elderberry']
    >>> cocktail_shaker_sort((-4, -5, -24, -7, -11))
    Traceback (most recent call last):
        ...
    TypeError: 'tuple' object does not support item assignment
    """"""
    start, end = 0, len(arr) - 1

    while start < end:
        swapped = False

        # Pass from left to right
        for i in range(start, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True

        if not swapped:
            break

        end -= 1  # Decrease the end pointer after each pass

        # Pass from right to left
        for i in range(end, start, -1):
            if arr[i] < arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]
                swapped = True

        if not swapped:
            break

        start += 1  # Increase the start pointer after each pass

    return arr",data\repos\Python\sorts\cocktail_shaker_sort.py,cocktail_shaker_sort,524
1982,comb_sort.py::comb_sort::22,"def comb_sort(data: list) -> list:
    """"""Pure implementation of comb sort algorithm in Python
    :param data: mutable collection with comparable items
    :return: the same collection in ascending order
    Examples:
    >>> comb_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> comb_sort([])
    []
    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])
    [-15, -7, 0, 2, 3, 8, 45, 99]
    """"""
    shrink_factor = 1.3
    gap = len(data)
    completed = False

    while not completed:
        # Update the gap value for a next comb
        gap = int(gap / shrink_factor)
        if gap <= 1:
            completed = True

        index = 0
        while index + gap < len(data):
            if data[index] > data[index + gap]:
                # Swap values
                data[index], data[index + gap] = data[index + gap], data[index]
                completed = False
            index += 1

    return data",data\repos\Python\sorts\comb_sort.py,comb_sort,264
1983,counting_sort.py::counting_sort::12,"def counting_sort(collection):
    """"""Pure implementation of counting sort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> counting_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> counting_sort([])
    []
    >>> counting_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    # if the collection is empty, returns empty
    if collection == []:
        return []

    # get some information about the collection
    coll_len = len(collection)
    coll_max = max(collection)
    coll_min = min(collection)

    # create the counting array
    counting_arr_length = coll_max + 1 - coll_min
    counting_arr = [0] * counting_arr_length

    # count how much a number appears in the collection
    for number in collection:
        counting_arr[number - coll_min] += 1

    # sum each position with it's predecessors. now, counting_arr[i] tells
    # us how many elements <= i has in the collection
    for i in range(1, counting_arr_length):
        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]

    # create the output collection
    ordered = [0] * coll_len

    # place the elements in the output, respecting the original order (stable
    # sort) from end to begin, updating counting_arr
    for i in reversed(range(coll_len)):
        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]
        counting_arr[collection[i] - coll_min] -= 1

    return ordered",data\repos\Python\sorts\counting_sort.py,counting_sort,381
1984,counting_sort.py::counting_sort_string::59,"def counting_sort_string(string):
    """"""
    >>> counting_sort_string(""thisisthestring"")
    'eghhiiinrsssttt'
    """"""
    return """".join([chr(i) for i in counting_sort([ord(c) for c in string])])",data\repos\Python\sorts\counting_sort.py,counting_sort_string,54
1985,cycle_sort.py::cycle_sort::7,"def cycle_sort(array: list) -> list:
    """"""
    >>> cycle_sort([4, 3, 2, 1])
    [1, 2, 3, 4]

    >>> cycle_sort([-4, 20, 0, -50, 100, -1])
    [-50, -4, -1, 0, 20, 100]

    >>> cycle_sort([-.1, -.2, 1.3, -.8])
    [-0.8, -0.2, -0.1, 1.3]

    >>> cycle_sort([])
    []
    """"""
    array_len = len(array)
    for cycle_start in range(array_len - 1):
        item = array[cycle_start]

        pos = cycle_start
        for i in range(cycle_start + 1, array_len):
            if array[i] < item:
                pos += 1

        if pos == cycle_start:
            continue

        while item == array[pos]:
            pos += 1

        array[pos], item = item, array[pos]
        while pos != cycle_start:
            pos = cycle_start
            for i in range(cycle_start + 1, array_len):
                if array[i] < item:
                    pos += 1

            while item == array[pos]:
                pos += 1

            array[pos], item = item, array[pos]

    return array",data\repos\Python\sorts\cycle_sort.py,cycle_sort,296
1986,cyclic_sort.py::cyclic_sort::15,"def cyclic_sort(nums: list[int]) -> list[int]:
    """"""
    Sorts the input list of n integers from 1 to n in-place
    using the Cyclic Sort algorithm.

    :param nums: List of n integers from 1 to n to be sorted.
    :return: The same list sorted in ascending order.

    Time complexity: O(n), where n is the number of integers in the list.

    Examples:
    >>> cyclic_sort([])
    []
    >>> cyclic_sort([3, 5, 2, 1, 4])
    [1, 2, 3, 4, 5]
    """"""

    # Perform cyclic sort
    index = 0
    while index < len(nums):
        # Calculate the correct index for the current element
        correct_index = nums[index] - 1
        # If the current element is not at its correct position,
        # swap it with the element at its correct index
        if index != correct_index:
            nums[index], nums[correct_index] = nums[correct_index], nums[index]
        else:
            # If the current element is already in its correct position,
            # move to the next element
            index += 1

    return nums",data\repos\Python\sorts\cyclic_sort.py,cyclic_sort,258
1987,double_sort.py::double_sort::4,"def double_sort(collection: list[Any]) -> list[Any]:
    """"""This sorting algorithm sorts an array using the principle of bubble sort,
    but does it both from left to right and right to left.
    Hence, it's called ""Double sort""
    :param collection: mutable ordered sequence of elements
    :return: the same collection in ascending order
    Examples:
    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])
    [-7, -6, -5, -4, -3, -2, -1]
    >>> double_sort([])
    []
    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])
    [-6, -5, -4, -3, -2, -1]
    >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])
    True
    """"""
    no_of_elements = len(collection)
    for _ in range(
        int(((no_of_elements - 1) / 2) + 1)
    ):  # we don't need to traverse to end of list as
        for j in range(no_of_elements - 1):
            # apply the bubble sort algorithm from left to right (or forwards)
            if collection[j + 1] < collection[j]:
                collection[j], collection[j + 1] = collection[j + 1], collection[j]
            # apply the bubble sort algorithm from right to left (or backwards)
            if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:
                (
                    collection[no_of_elements - 1 - j],
                    collection[no_of_elements - 2 - j],
                ) = (
                    collection[no_of_elements - 2 - j],
                    collection[no_of_elements - 1 - j],
                )
    return collection",data\repos\Python\sorts\double_sort.py,double_sort,407
1988,dutch_national_flag_sort.py::dutch_national_flag_sort::33,"def dutch_national_flag_sort(sequence: list) -> list:
    """"""
    A pure Python implementation of Dutch National Flag sort algorithm.
    :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence
    :return: The same collection in ascending order

    >>> dutch_national_flag_sort([])
    []
    >>> dutch_national_flag_sort([0])
    [0]
    >>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2])
    [0, 0, 1, 1, 2, 2]
    >>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1])
    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]
    >>> dutch_national_flag_sort(""abacab"")
    Traceback (most recent call last):
      ...
    ValueError: The elements inside the sequence must contains only (0, 1, 2) values
    >>> dutch_national_flag_sort(""Abacab"")
    Traceback (most recent call last):
      ...
    ValueError: The elements inside the sequence must contains only (0, 1, 2) values
    >>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3])
    Traceback (most recent call last):
      ...
    ValueError: The elements inside the sequence must contains only (0, 1, 2) values
    >>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1])
    Traceback (most recent call last):
      ...
    ValueError: The elements inside the sequence must contains only (0, 1, 2) values
    >>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1])
    Traceback (most recent call last):
      ...
    ValueError: The elements inside the sequence must contains only (0, 1, 2) values
    """"""
    if not sequence:
        return []
    if len(sequence) == 1:
        return list(sequence)
    low = 0
    high = len(sequence) - 1
    mid = 0
    while mid <= high:
        if sequence[mid] == colors[0]:
            sequence[low], sequence[mid] = sequence[mid], sequence[low]
            low += 1
            mid += 1
        elif sequence[mid] == colors[1]:
            mid += 1
        elif sequence[mid] == colors[2]:
            sequence[mid], sequence[high] = sequence[high], sequence[mid]
            high -= 1
        else:
            msg = f""The elements inside the sequence must contains only {colors} values""
            raise ValueError(msg)
    return sequence",data\repos\Python\sorts\dutch_national_flag_sort.py,dutch_national_flag_sort,670
1989,exchange_sort.py::exchange_sort::1,"def exchange_sort(numbers: list[int]) -> list[int]:
    """"""
    Uses exchange sort to sort a list of numbers.
    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort
    >>> exchange_sort([5, 4, 3, 2, 1])
    [1, 2, 3, 4, 5]
    >>> exchange_sort([-1, -2, -3])
    [-3, -2, -1]
    >>> exchange_sort([1, 2, 3, 4, 5])
    [1, 2, 3, 4, 5]
    >>> exchange_sort([0, 10, -2, 5, 3])
    [-2, 0, 3, 5, 10]
    >>> exchange_sort([])
    []
    """"""
    numbers_length = len(numbers)
    for i in range(numbers_length):
        for j in range(i + 1, numbers_length):
            if numbers[j] < numbers[i]:
                numbers[i], numbers[j] = numbers[j], numbers[i]
    return numbers",data\repos\Python\sorts\exchange_sort.py,exchange_sort,232
1990,external_sort.py::parse_memory::128,"def parse_memory(string):
    if string[-1].lower() == ""k"":
        return int(string[:-1]) * 1024
    elif string[-1].lower() == ""m"":
        return int(string[:-1]) * 1024 * 1024
    elif string[-1].lower() == ""g"":
        return int(string[:-1]) * 1024 * 1024 * 1024
    else:
        return int(string)",data\repos\Python\sorts\external_sort.py,parse_memory,97
1991,external_sort.py::main::139,"def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        ""-m"", ""--mem"", help=""amount of memory to use for sorting"", default=""100M""
    )
    parser.add_argument(
        ""filename"", metavar=""<filename>"", nargs=1, help=""name of file to sort""
    )
    args = parser.parse_args()

    sorter = ExternalSort(parse_memory(args.mem))
    sorter.sort(args.filename[0])",data\repos\Python\sorts\external_sort.py,main,90
1992,external_sort.py::write_block::17,"    def write_block(self, data, block_number):
        filename = self.BLOCK_FILENAME_FORMAT.format(block_number)
        with open(filename, ""w"") as file:
            file.write(data)
        self.block_filenames.append(filename)",data\repos\Python\sorts\external_sort.py,write_block,46
1993,external_sort.py::split::26,"    def split(self, block_size, sort_key=None):
        i = 0
        with open(self.filename) as file:
            while True:
                lines = file.readlines(block_size)

                if lines == []:
                    break

                if sort_key is None:
                    lines.sort()
                else:
                    lines.sort(key=sort_key)

                self.write_block("""".join(lines), i)
                i += 1",data\repos\Python\sorts\external_sort.py,split,85
1994,external_sort.py::select::48,"    def select(self, choices):
        min_index = -1
        min_str = None

        for i in range(len(choices)):
            if min_str is None or choices[i] < min_str:
                min_index = i

        return min_index",data\repos\Python\sorts\external_sort.py,select,52
1995,external_sort.py::get_dict::66,"    def get_dict(self):
        return {
            i: self.buffers[i] for i in range(self.num_buffers) if i not in self.empty
        }",data\repos\Python\sorts\external_sort.py,get_dict,34
1996,external_sort.py::refresh::71,"    def refresh(self):
        for i in range(self.num_buffers):
            if self.buffers[i] is None and i not in self.empty:
                self.buffers[i] = self.files[i].readline()

                if self.buffers[i] == """":
                    self.empty.add(i)
                    self.files[i].close()

        return len(self.empty) != self.num_buffers",data\repos\Python\sorts\external_sort.py,refresh,76
1997,external_sort.py::merge::93,"    def merge(self, filenames, outfilename, buffer_size):
        buffers = FilesArray(self.get_file_handles(filenames, buffer_size))
        with open(outfilename, ""w"", buffer_size) as outfile:
            while buffers.refresh():
                min_index = self.merge_strategy.select(buffers.get_dict())
                outfile.write(buffers.unshift(min_index))",data\repos\Python\sorts\external_sort.py,merge,70
1998,external_sort.py::get_file_handles::100,"    def get_file_handles(self, filenames, buffer_size):
        files = {}

        for i in range(len(filenames)):
            files[i] = open(filenames[i], ""r"", buffer_size)  # noqa: UP015

        return files",data\repos\Python\sorts\external_sort.py,get_file_handles,51
1999,external_sort.py::sort::113,"    def sort(self, filename, sort_key=None):
        num_blocks = self.get_number_blocks(filename, self.block_size)
        splitter = FileSplitter(filename)
        splitter.split(self.block_size, sort_key)

        merger = FileMerger(NWayMerge())
        buffer_size = self.block_size / (num_blocks + 1)
        merger.merge(splitter.get_block_filenames(), filename + "".out"", buffer_size)

        splitter.cleanup()",data\repos\Python\sorts\external_sort.py,sort,89
2000,gnome_sort.py::gnome_sort::16,"def gnome_sort(lst: list) -> list:
    """"""
    Pure implementation of the gnome sort algorithm in Python

    Take some mutable ordered collection with heterogeneous comparable items inside as
    arguments, return the same collection ordered by ascending.

    Examples:
    >>> gnome_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> gnome_sort([])
    []

    >>> gnome_sort([-2, -5, -45])
    [-45, -5, -2]

    >>> """".join(gnome_sort(list(set(""Gnomes are stupid!""))))
    ' !Gadeimnoprstu'
    """"""
    if len(lst) <= 1:
        return lst

    i = 1

    while i < len(lst):
        if lst[i - 1] <= lst[i]:
            i += 1
        else:
            lst[i - 1], lst[i] = lst[i], lst[i - 1]
            i -= 1
            if i == 0:
                i = 1

    return lst",data\repos\Python\sorts\gnome_sort.py,gnome_sort,233
2001,heap_sort.py::heapify::6,"def heapify(unsorted: list[int], index: int, heap_size: int) -> None:
    """"""
    :param unsorted: unsorted list containing integers numbers
    :param index: index
    :param heap_size: size of the heap
    :return: None
    >>> unsorted = [1, 4, 3, 5, 2]
    >>> heapify(unsorted, 0, len(unsorted))
    >>> unsorted
    [4, 5, 3, 1, 2]
    >>> heapify(unsorted, 0, len(unsorted))
    >>> unsorted
    [5, 4, 3, 1, 2]
    """"""
    largest = index
    left_index = 2 * index + 1
    right_index = 2 * index + 2
    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:
        largest = left_index

    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:
        largest = right_index

    if largest != index:
        unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])
        heapify(unsorted, largest, heap_size)",data\repos\Python\sorts\heap_sort.py,heapify,269
2002,heap_sort.py::heap_sort::34,"def heap_sort(unsorted: list[int]) -> list[int]:
    """"""
    A pure Python implementation of the heap sort algorithm

    :param collection: a mutable ordered collection of heterogeneous comparable items
    :return: the same collection ordered by ascending

    Examples:
    >>> heap_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> heap_sort([])
    []
    >>> heap_sort([-2, -5, -45])
    [-45, -5, -2]
    >>> heap_sort([3, 7, 9, 28, 123, -5, 8, -30, -200, 0, 4])
    [-200, -30, -5, 0, 3, 4, 7, 8, 9, 28, 123]
    """"""
    n = len(unsorted)
    for i in range(n // 2 - 1, -1, -1):
        heapify(unsorted, i, n)
    for i in range(n - 1, 0, -1):
        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]
        heapify(unsorted, 0, i)
    return unsorted",data\repos\Python\sorts\heap_sort.py,heap_sort,279
2003,insertion_sort.py::insertion_sort::27,"def insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:
    """"""A pure Python implementation of the insertion sort algorithm

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> insertion_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> insertion_sort([]) == sorted([])
    True
    >>> insertion_sort([-2, -5, -45]) == sorted([-2, -5, -45])
    True
    >>> insertion_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c'])
    True
    >>> import random
    >>> collection = random.sample(range(-50, 50), 100)
    >>> insertion_sort(collection) == sorted(collection)
    True
    >>> import string
    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)
    >>> insertion_sort(collection) == sorted(collection)
    True
    """"""

    for insert_index in range(1, len(collection)):
        insert_value = collection[insert_index]
        while insert_index > 0 and insert_value < collection[insert_index - 1]:
            collection[insert_index] = collection[insert_index - 1]
            insert_index -= 1
        collection[insert_index] = insert_value
    return collection",data\repos\Python\sorts\insertion_sort.py,insertion_sort,321
2004,intro_sort.py::insertion_sort::10,"def insertion_sort(array: list, start: int = 0, end: int = 0) -> list:
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
    >>> insertion_sort(array, 0, len(array))
    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
    >>> array = [21, 15, 11, 45, -2, -11, 46]
    >>> insertion_sort(array, 0, len(array))
    [-11, -2, 11, 15, 21, 45, 46]
    >>> array = [-2, 0, 89, 11, 48, 79, 12]
    >>> insertion_sort(array, 0, len(array))
    [-2, 0, 11, 12, 48, 79, 89]
    >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']
    >>> insertion_sort(array, 0, len(array))
    ['a', 'd', 'l', 'o', 'o', 'p', 'v', 'z']
    >>> array = [73.568, 73.56, -45.03, 1.7, 0, 89.45]
    >>> insertion_sort(array, 0, len(array))
    [-45.03, 0, 1.7, 73.56, 73.568, 89.45]
    """"""
    end = end or len(array)
    for i in range(start, end):
        temp_index = i
        temp_index_value = array[i]
        while temp_index != start and temp_index_value < array[temp_index - 1]:
            array[temp_index] = array[temp_index - 1]
            temp_index -= 1
        array[temp_index] = temp_index_value
    return array",data\repos\Python\sorts\intro_sort.py,insertion_sort,479
2005,intro_sort.py::heapify::39,"def heapify(array: list, index: int, heap_size: int) -> None:  # Max Heap
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
    >>> heapify(array, len(array) // 2, len(array))
    """"""
    largest = index
    left_index = 2 * index + 1  # Left Node
    right_index = 2 * index + 2  # Right Node

    if left_index < heap_size and array[largest] < array[left_index]:
        largest = left_index

    if right_index < heap_size and array[largest] < array[right_index]:
        largest = right_index

    if largest != index:
        array[index], array[largest] = array[largest], array[index]
        heapify(array, largest, heap_size)",data\repos\Python\sorts\intro_sort.py,heapify,211
2006,intro_sort.py::heap_sort::59,"def heap_sort(array: list) -> list:
    """"""
    >>> heap_sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])
    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
    >>> heap_sort([-2, -11, 0, 0, 0, 87, 45, -69, 78, 12, 10, 103, 89, 52])
    [-69, -11, -2, 0, 0, 0, 10, 12, 45, 52, 78, 87, 89, 103]
    >>> heap_sort(['b', 'd', 'e', 'f', 'g', 'p', 'x', 'z', 'b', 's', 'e', 'u', 'v'])
    ['b', 'b', 'd', 'e', 'e', 'f', 'g', 'p', 's', 'u', 'v', 'x', 'z']
    >>> heap_sort([6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7])
    [-457.0, -45.54, 0, 1, 1.7, 2.879, 6.2, 11.7, 758.56, 8465.2]
    """"""
    n = len(array)

    for i in range(n // 2, -1, -1):
        heapify(array, i, n)

    for i in range(n - 1, 0, -1):
        array[i], array[0] = array[0], array[i]
        heapify(array, 0, i)

    return array",data\repos\Python\sorts\intro_sort.py,heap_sort,462
2007,intro_sort.py::median_of_3::82,"def median_of_3(
    array: list, first_index: int, middle_index: int, last_index: int
) -> int:
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)
    12
    >>> array = [13, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)
    13
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 15, 14, 27, 79, 23, 45, 14, 16]
    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)
    14
    """"""
    if (array[first_index] > array[middle_index]) != (
        array[first_index] > array[last_index]
    ):
        return array[first_index]
    elif (array[middle_index] > array[first_index]) != (
        array[middle_index] > array[last_index]
    ):
        return array[middle_index]
    else:
        return array[last_index]",data\repos\Python\sorts\intro_sort.py,median_of_3,381
2008,intro_sort.py::partition::108,"def partition(array: list, low: int, high: int, pivot: int) -> int:
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
    >>> partition(array, 0, len(array), 12)
    8
    >>> array = [21, 15, 11, 45, -2, -11, 46]
    >>> partition(array, 0, len(array), 15)
    3
    >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']
    >>> partition(array, 0, len(array), 'p')
    5
    >>> array = [6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7]
    >>> partition(array, 0, len(array), 2.879)
    6
    """"""
    i = low
    j = high
    while True:
        while array[i] < pivot:
            i += 1
        j -= 1
        while pivot < array[j]:
            j -= 1
        if i >= j:
            return i
        array[i], array[j] = array[j], array[i]
        i += 1",data\repos\Python\sorts\intro_sort.py,partition,331
2009,intro_sort.py::sort::137,"def sort(array: list) -> list:
    """"""
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])
    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
    >>> sort([-1, -5, -3, -13, -44])
    [-44, -13, -5, -3, -1]
    >>> sort([])
    []
    >>> sort([5])
    [5]
    >>> sort([-3, 0, -7, 6, 23, -34])
    [-34, -7, -3, 0, 6, 23]
    >>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ])
    [0.3, 1.0, 1.7, 2.1, 3.3]
    >>> sort(['d', 'a', 'b', 'e', 'c'])
    ['a', 'b', 'c', 'd', 'e']
    """"""
    if len(array) == 0:
        return array
    max_depth = 2 * math.ceil(math.log2(len(array)))
    size_threshold = 16
    return intro_sort(array, 0, len(array), size_threshold, max_depth)",data\repos\Python\sorts\intro_sort.py,sort,375
2010,intro_sort.py::intro_sort::166,"def intro_sort(
    array: list, start: int, end: int, size_threshold: int, max_depth: int
) -> list:
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
    >>> max_depth = 2 * math.ceil(math.log2(len(array)))
    >>> intro_sort(array, 0, len(array), 16, max_depth)
    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
    """"""
    while end - start > size_threshold:
        if max_depth == 0:
            return heap_sort(array)
        max_depth -= 1
        pivot = median_of_3(array, start, start + ((end - start) // 2) + 1, end - 1)
        p = partition(array, start, end, pivot)
        intro_sort(array, p, end, size_threshold, max_depth)
        end = p
    return insertion_sort(array, start, end)",data\repos\Python\sorts\intro_sort.py,intro_sort,273
2011,iterative_merge_sort.py::merge::15,"def merge(input_list: list, low: int, mid: int, high: int) -> list:
    """"""
    sorting left-half and right-half individually
    then merging them into result
    """"""
    result = []
    left, right = input_list[low:mid], input_list[mid : high + 1]
    while left and right:
        result.append((left if left[0] <= right[0] else right).pop(0))
    input_list[low : high + 1] = result + left + right
    return input_list",data\repos\Python\sorts\iterative_merge_sort.py,merge,117
2012,iterative_merge_sort.py::iter_merge_sort::29,"def iter_merge_sort(input_list: list) -> list:
    """"""
    Return a sorted copy of the input list

    >>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7])
    [1, 2, 5, 7, 7, 8, 9]
    >>> iter_merge_sort([1])
    [1]
    >>> iter_merge_sort([2, 1])
    [1, 2]
    >>> iter_merge_sort([2, 1, 3])
    [1, 2, 3]
    >>> iter_merge_sort([4, 3, 2, 1])
    [1, 2, 3, 4]
    >>> iter_merge_sort([5, 4, 3, 2, 1])
    [1, 2, 3, 4, 5]
    >>> iter_merge_sort(['c', 'b', 'a'])
    ['a', 'b', 'c']
    >>> iter_merge_sort([0.3, 0.2, 0.1])
    [0.1, 0.2, 0.3]
    >>> iter_merge_sort(['dep', 'dang', 'trai'])
    ['dang', 'dep', 'trai']
    >>> iter_merge_sort([6])
    [6]
    >>> iter_merge_sort([])
    []
    >>> iter_merge_sort([-2, -9, -1, -4])
    [-9, -4, -2, -1]
    >>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1])
    [-1.1, -1, 0.0, 1, 1.1]
    >>> iter_merge_sort(['c', 'b', 'a'])
    ['a', 'b', 'c']
    >>> iter_merge_sort('cba')
    ['a', 'b', 'c']
    """"""
    if len(input_list) <= 1:
        return input_list
    input_list = list(input_list)

    # iteration for two-way merging
    p = 2
    while p <= len(input_list):
        # getting low, high and middle value for merge-sort of single list
        for i in range(0, len(input_list), p):
            low = i
            high = i + p - 1
            mid = (low + high + 1) // 2
            input_list = merge(input_list, low, mid, high)
        # final merge of last two parts
        if p * 2 >= len(input_list):
            mid = i
            input_list = merge(input_list, 0, mid, len(input_list) - 1)
            break
        p *= 2

    return input_list",data\repos\Python\sorts\iterative_merge_sort.py,iter_merge_sort,600
2013,merge_insertion_sort.py::binary_search_insertion::17,"def binary_search_insertion(sorted_list, item):
    """"""
    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)
    [1, 2, 4, 7, 9, 10]
    """"""
    left = 0
    right = len(sorted_list) - 1
    while left <= right:
        middle = (left + right) // 2
        if left == right:
            if sorted_list[middle] < item:
                left = middle + 1
            break
        elif sorted_list[middle] < item:
            left = middle + 1
        else:
            right = middle - 1
    sorted_list.insert(left, item)
    return sorted_list",data\repos\Python\sorts\merge_insertion_sort.py,binary_search_insertion,160
2014,merge_insertion_sort.py::merge::38,"def merge(left, right):
    """"""
    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])
    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]
    """"""
    result = []
    while left and right:
        if left[0][0] < right[0][0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    return result + left + right",data\repos\Python\sorts\merge_insertion_sort.py,merge,125
2015,merge_insertion_sort.py::sortlist_2d::52,"def sortlist_2d(list_2d):
    """"""
    >>> sortlist_2d([[9, 10], [1, 6], [7, 8], [2, 3], [4, 5]])
    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]
    """"""
    length = len(list_2d)
    if length <= 1:
        return list_2d
    middle = length // 2
    return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))",data\repos\Python\sorts\merge_insertion_sort.py,sortlist_2d,142
2016,merge_insertion_sort.py::merge_insertion_sort::64,"def merge_insertion_sort(collection: list[int]) -> list[int]:
    """"""Pure implementation of merge-insertion sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> merge_insertion_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> merge_insertion_sort([99])
    [99]

    >>> merge_insertion_sort([-2, -5, -45])
    [-45, -5, -2]

    Testing with all permutations on range(0,5):
    >>> import itertools
    >>> permutations = list(itertools.permutations([0, 1, 2, 3, 4]))
    >>> all(merge_insertion_sort(p) == [0, 1, 2, 3, 4] for p in permutations)
    True
    """"""

    if len(collection) <= 1:
        return collection

    """"""
    Group the items into two pairs, and leave one element if there is a last odd item.

    Example: [999, 100, 75, 40, 10000]
                -> [999, 100], [75, 40]. Leave 10000.
    """"""
    two_paired_list = []
    has_last_odd_item = False
    for i in range(0, len(collection), 2):
        if i == len(collection) - 1:
            has_last_odd_item = True
        else:
            """"""
            Sort two-pairs in each groups.

            Example: [999, 100], [75, 40]
                        -> [100, 999], [40, 75]
            """"""
            if collection[i] < collection[i + 1]:
                two_paired_list.append([collection[i], collection[i + 1]])
            else:
                two_paired_list.append([collection[i + 1], collection[i]])

    """"""
    Sort two_paired_list.

    Example: [100, 999], [40, 75]
                -> [40, 75], [100, 999]
    """"""
    sorted_list_2d = sortlist_2d(two_paired_list)

    """"""
    40 < 100 is sure because it has already been sorted.
    Generate the sorted_list of them so that you can avoid unnecessary comparison.

    Example:
           group0 group1
           40     100
           75     999
        ->
           group0 group1
           [40,   100]
           75     999
    """"""
    result = [i[0] for i in sorted_list_2d]

    """"""
    100 < 999 is sure because it has already been sorted.
    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.

    Example:
           group0 group1
           [40,   100]
           75     999
        ->
           group0 group1
           [40,   100,   999]
           75
    """"""
    result.append(sorted_list_2d[-1][1])

    """"""
    Insert the last odd item left if there is.

    Example:
           group0 group1
           [40,   100,   999]
           75
        ->
           group0 group1
           [40,   100,   999,   10000]
           75
    """"""
    if has_last_odd_item:
        pivot = collection[-1]
        result = binary_search_insertion(result, pivot)

    """"""
    Insert the remaining items.
    In this case, 40 < 75 is sure because it has already been sorted.
    Therefore, you only need to insert 75 into [100, 999, 10000],
    so that you can avoid unnecessary comparison.

    Example:
           group0 group1
           [40,   100,   999,   10000]
            ^ You don't need to compare with this as 40 < 75 is already sure.
           75
        ->
           [40,   75,    100,   999,   10000]
    """"""
    is_last_odd_item_inserted_before_this_index = False
    for i in range(len(sorted_list_2d) - 1):
        if result[i] == collection[-1] and has_last_odd_item:
            is_last_odd_item_inserted_before_this_index = True
        pivot = sorted_list_2d[i][1]
        # If last_odd_item is inserted before the item's index,
        # you should forward index one more.
        if is_last_odd_item_inserted_before_this_index:
            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)
        else:
            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)

    return result",data\repos\Python\sorts\merge_insertion_sort.py,merge_insertion_sort,1061
2017,merge_sort.py::merge_sort::13,"def merge_sort(collection: list) -> list:
    """"""
    Sorts a list using the merge sort algorithm.

    :param collection: A mutable ordered collection with comparable items.
    :return: The same collection ordered in ascending order.

    Time Complexity: O(n log n)
    Space Complexity: O(n)

    Examples:
    >>> merge_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> merge_sort([])
    []
    >>> merge_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""

    def merge(left: list, right: list) -> list:
        """"""
        Merge two sorted lists into a single sorted list.

        :param left: Left collection
        :param right: Right collection
        :return: Merged result
        """"""
        result = []
        while left and right:
            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))
        result.extend(left)
        result.extend(right)
        return result

    if len(collection) <= 1:
        return collection
    mid_index = len(collection) // 2
    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))",data\repos\Python\sorts\merge_sort.py,merge_sort,277
2018,merge_sort.py::merge::32,"    def merge(left: list, right: list) -> list:
        """"""
        Merge two sorted lists into a single sorted list.

        :param left: Left collection
        :param right: Right collection
        :return: Merged result
        """"""
        result = []
        while left and right:
            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))
        result.extend(left)
        result.extend(right)
        return result",data\repos\Python\sorts\merge_sort.py,merge,100
2019,msd_radix_sort.py::msd_radix_sort::11,"def msd_radix_sort(list_of_ints: list[int]) -> list[int]:
    """"""
    Implementation of the MSD radix sort algorithm. Only works
    with positive integers
    :param list_of_ints: A list of integers
    :return: Returns the sorted list
    >>> msd_radix_sort([40, 12, 1, 100, 4])
    [1, 4, 12, 40, 100]
    >>> msd_radix_sort([])
    []
    >>> msd_radix_sort([123, 345, 123, 80])
    [80, 123, 123, 345]
    >>> msd_radix_sort([1209, 834598, 1, 540402, 45])
    [1, 45, 1209, 540402, 834598]
    >>> msd_radix_sort([-1, 34, 45])
    Traceback (most recent call last):
        ...
    ValueError: All numbers must be positive
    """"""
    if not list_of_ints:
        return []

    if min(list_of_ints) < 0:
        raise ValueError(""All numbers must be positive"")

    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)
    return _msd_radix_sort(list_of_ints, most_bits)",data\repos\Python\sorts\msd_radix_sort.py,msd_radix_sort,289
2020,msd_radix_sort.py::msd_radix_sort_inplace::78,"def msd_radix_sort_inplace(list_of_ints: list[int]):
    """"""
    Inplace implementation of the MSD radix sort algorithm.
    Sorts based on the binary representation of the integers.
    >>> lst = [1, 345, 23, 89, 0, 3]
    >>> msd_radix_sort_inplace(lst)
    >>> lst == sorted(lst)
    True
    >>> lst = [1, 43, 0, 0, 0, 24, 3, 3]
    >>> msd_radix_sort_inplace(lst)
    >>> lst == sorted(lst)
    True
    >>> lst = []
    >>> msd_radix_sort_inplace(lst)
    >>> lst == []
    True
    >>> lst = [-1, 34, 23, 4, -42]
    >>> msd_radix_sort_inplace(lst)
    Traceback (most recent call last):
        ...
    ValueError: All numbers must be positive
    """"""

    length = len(list_of_ints)
    if not list_of_ints or length == 1:
        return

    if min(list_of_ints) < 0:
        raise ValueError(""All numbers must be positive"")

    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)
    _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)",data\repos\Python\sorts\msd_radix_sort.py,msd_radix_sort_inplace,297
2021,natural_sort.py::natural_sort::6,"def natural_sort(input_list: list[str]) -> list[str]:
    """"""
    Sort the given list of strings in the way that humans expect.

    The normal Python sort algorithm sorts lexicographically,
    so you might not get the results that you expect...

    >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']
    >>> sorted(example1)
    ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']
    >>> # The natural sort algorithm sort based on meaning and not computer code point.
    >>> natural_sort(example1)
    ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']

    >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
    >>> sorted(example2)
    ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
    >>> natural_sort(example2)
    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
    """"""

    def alphanum_key(key):
        return [int(s) if s.isdigit() else s.lower() for s in re.split(""([0-9]+)"", key)]

    return sorted(input_list, key=alphanum_key)",data\repos\Python\sorts\natural_sort.py,natural_sort,370
2022,natural_sort.py::alphanum_key::27,"    def alphanum_key(key):
        return [int(s) if s.isdigit() else s.lower() for s in re.split(""([0-9]+)"", key)]",data\repos\Python\sorts\natural_sort.py,alphanum_key,36
2023,odd_even_sort.py::odd_even_sort::8,"def odd_even_sort(input_list: list) -> list:
    """"""
    Sort input with odd even sort.

    This algorithm uses the same idea of bubblesort,
    but by first dividing in two phase (odd and even).
    Originally developed for use on parallel processors
    with local interconnections.
    :param collection: mutable ordered sequence of elements
    :return: same collection in ascending order
    Examples:
    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])
    [1, 2, 3, 4, 5]
    >>> odd_even_sort([])
    []
    >>> odd_even_sort([-10 ,-1 ,10 ,2])
    [-10, -1, 2, 10]
    >>> odd_even_sort([1 ,2 ,3 ,4])
    [1, 2, 3, 4]
    """"""
    is_sorted = False
    while is_sorted is False:  # Until all the indices are traversed keep looping
        is_sorted = True
        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices
            if input_list[i] > input_list[i + 1]:
                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]
                # swapping if elements not in order
                is_sorted = False

        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices
            if input_list[i] > input_list[i + 1]:
                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]
                # swapping if elements not in order
                is_sorted = False
    return input_list",data\repos\Python\sorts\odd_even_sort.py,odd_even_sort,377
2024,odd_even_transposition_parallel.py::oe_process::32,"def oe_process(
    position,
    value,
    l_send,
    r_send,
    lr_cv,
    rr_cv,
    result_pipe,
    multiprocessing_context,
):
    process_lock = multiprocessing_context.Lock()

    # we perform n swaps since after n swaps we know we are sorted
    # we *could* stop early if we are sorted already, but it takes as long to
    # find out we are sorted as it does to sort the list with this algorithm
    for i in range(10):
        if (i + position) % 2 == 0 and r_send is not None:
            # send your value to your right neighbor
            with process_lock:
                r_send[1].send(value)

            # receive your right neighbor's value
            with process_lock:
                temp = rr_cv[0].recv()

            # take the lower value since you are on the left
            value = min(value, temp)
        elif (i + position) % 2 != 0 and l_send is not None:
            # send your value to your left neighbor
            with process_lock:
                l_send[1].send(value)

            # receive your left neighbor's value
            with process_lock:
                temp = lr_cv[0].recv()

            # take the higher value since you are on the right
            value = max(value, temp)
    # after all swaps are performed, send the values back to main
    result_pipe[1].send(value)",data\repos\Python\sorts\odd_even_transposition_parallel.py,oe_process,308
2025,odd_even_transposition_parallel.py::odd_even_transposition::81,"def odd_even_transposition(arr):
    """"""
    >>> odd_even_transposition(list(range(10)[::-1])) == sorted(list(range(10)[::-1]))
    True
    >>> odd_even_transposition([""a"", ""x"", ""c""]) == sorted([""x"", ""a"", ""c""])
    True
    >>> odd_even_transposition([1.9, 42.0, 2.8]) == sorted([1.9, 42.0, 2.8])
    True
    >>> odd_even_transposition([False, True, False]) == sorted([False, False, True])
    True
    >>> odd_even_transposition([1, 32.0, 9]) == sorted([False, False, True])
    False
    >>> odd_even_transposition([1, 32.0, 9]) == sorted([1.0, 32, 9.0])
    True
    >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]
    >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list)
    True
    >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]
    >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list + [1])
    False
    """"""
    # spawn method is considered safer than fork
    multiprocessing_context = mp.get_context(""spawn"")

    process_array_ = []
    result_pipe = []
    # initialize the list of pipes where the values will be retrieved
    for _ in arr:
        result_pipe.append(multiprocessing_context.Pipe())
    # creates the processes
    # the first and last process only have one neighbor so they are made outside
    # of the loop
    temp_rs = multiprocessing_context.Pipe()
    temp_rr = multiprocessing_context.Pipe()
    process_array_.append(
        multiprocessing_context.Process(
            target=oe_process,
            args=(
                0,
                arr[0],
                None,
                temp_rs,
                None,
                temp_rr,
                result_pipe[0],
                multiprocessing_context,
            ),
        )
    )
    temp_lr = temp_rs
    temp_ls = temp_rr

    for i in range(1, len(arr) - 1):
        temp_rs = multiprocessing_context.Pipe()
        temp_rr = multiprocessing_context.Pipe()
        process_array_.append(
            multiprocessing_context.Process(
                target=oe_process,
                args=(
                    i,
                    arr[i],
                    temp_ls,
                    temp_rs,
                    temp_lr,
                    temp_rr,
                    result_pipe[i],
                    multiprocessing_context,
                ),
            )
        )
        temp_lr = temp_rs
        temp_ls = temp_rr

    process_array_.append(
        multiprocessing_context.Process(
            target=oe_process,
            args=(
                len(arr) - 1,
                arr[len(arr) - 1],
                temp_ls,
                None,
                temp_lr,
                None,
                result_pipe[len(arr) - 1],
                multiprocessing_context,
            ),
        )
    )

    # start the processes
    for p in process_array_:
        p.start()

    # wait for the processes to end and write their values to the list
    for p in range(len(result_pipe)):
        arr[p] = result_pipe[p][0].recv()
        process_array_[p].join()
    return arr",data\repos\Python\sorts\odd_even_transposition_parallel.py,odd_even_transposition,735
2026,odd_even_transposition_parallel.py::main::182,"def main():
    arr = list(range(10, 0, -1))
    print(""Initial List"")
    print(*arr)
    arr = odd_even_transposition(arr)
    print(""Sorted List\n"")
    print(*arr)",data\repos\Python\sorts\odd_even_transposition_parallel.py,main,49
2027,odd_even_transposition_single_threaded.py::odd_even_transposition::11,"def odd_even_transposition(arr: list) -> list:
    """"""
    >>> odd_even_transposition([5, 4, 3, 2, 1])
    [1, 2, 3, 4, 5]

    >>> odd_even_transposition([13, 11, 18, 0, -1])
    [-1, 0, 11, 13, 18]

    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])
    [-2.9, -0.1, 0.1, 1.1]
    """"""
    arr_size = len(arr)
    for _ in range(arr_size):
        for i in range(_ % 2, arr_size - 1, 2):
            if arr[i + 1] < arr[i]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]

    return arr",data\repos\Python\sorts\odd_even_transposition_single_threaded.py,odd_even_transposition,203
2028,pancake_sort.py::pancake_sort::12,"def pancake_sort(arr):
    """"""Sort Array with Pancake Sort.
    :param arr: Collection containing comparable items
    :return: Collection ordered in ascending order of items
    Examples:
    >>> pancake_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> pancake_sort([])
    []
    >>> pancake_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    cur = len(arr)
    while cur > 1:
        # Find the maximum number in arr
        mi = arr.index(max(arr[0:cur]))
        # Reverse from 0 to mi
        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]
        # Reverse whole list
        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]
        cur -= 1
    return arr",data\repos\Python\sorts\pancake_sort.py,pancake_sort,207
2029,patience_sort.py::patience_sort::31,"def patience_sort(collection: list) -> list:
    """"""A pure implementation of patience sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> patience_sort([1, 9, 5, 21, 17, 6])
    [1, 5, 6, 9, 17, 21]

    >>> patience_sort([])
    []

    >>> patience_sort([-3, -17, -48])
    [-48, -17, -3]
    """"""
    stacks: list[Stack] = []
    # sort into stacks
    for element in collection:
        new_stacks = Stack([element])
        i = bisect_left(stacks, new_stacks)
        if i != len(stacks):
            stacks[i].append(element)
        else:
            stacks.append(new_stacks)

    # use a heap-based merge to merge stack efficiently
    collection[:] = merge(*(reversed(stack) for stack in stacks))
    return collection",data\repos\Python\sorts\patience_sort.py,patience_sort,224
2030,pigeonhole_sort.py::pigeonhole_sort::6,"def pigeonhole_sort(a):
    """"""
    >>> a = [8, 3, 2, 7, 4, 6, 8]
    >>> b = sorted(a)  # a nondestructive sort
    >>> pigeonhole_sort(a)  # a destructive sort
    >>> a == b
    True
    """"""
    # size of range of values in the list (ie, number of pigeonholes we need)

    min_val = min(a)  # min() finds the minimum value
    max_val = max(a)  # max() finds the maximum value

    size = max_val - min_val + 1  # size is difference of max and min values plus one

    # list of pigeonholes of size equal to the variable size
    holes = [0] * size

    # Populate the pigeonholes.
    for x in a:
        assert isinstance(x, int), ""integers only please""
        holes[x - min_val] += 1

    # Putting the elements back into the array in an order.
    i = 0
    for count in range(size):
        while holes[count] > 0:
            holes[count] -= 1
            a[i] = count + min_val
            i += 1",data\repos\Python\sorts\pigeonhole_sort.py,pigeonhole_sort,266
2031,pigeonhole_sort.py::main::38,"def main():
    a = [8, 3, 2, 7, 4, 6, 8]
    pigeonhole_sort(a)
    print(""Sorted order is:"", "" "".join(a))",data\repos\Python\sorts\pigeonhole_sort.py,main,45
2032,pigeon_sort.py::pigeon_sort::16,"def pigeon_sort(array: list[int]) -> list[int]:
    """"""
    Implementation of pigeon hole sort algorithm
    :param array: Collection of comparable items
    :return: Collection sorted in ascending order
    >>> pigeon_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> pigeon_sort([])
    []
    >>> pigeon_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    if len(array) == 0:
        return array

    _min, _max = min(array), max(array)

    # Compute the variables
    holes_range = _max - _min + 1
    holes, holes_repeat = [0] * holes_range, [0] * holes_range

    # Make the sorting.
    for i in array:
        index = i - _min
        holes[index] = i
        holes_repeat[index] += 1

    # Makes the array back by replacing the numbers.
    index = 0
    for i in range(holes_range):
        while holes_repeat[i] > 0:
            array[index] = holes[i]
            index += 1
            holes_repeat[i] -= 1

    # Returns the sorted array.
    return array",data\repos\Python\sorts\pigeon_sort.py,pigeon_sort,279
2033,quick_sort.py::quick_sort::16,"def quick_sort(collection: list) -> list:
    """"""A pure Python implementation of quicksort algorithm.

    :param collection: a mutable collection of comparable items
    :return: the same collection ordered in ascending order

    Examples:
    >>> quick_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> quick_sort([])
    []
    >>> quick_sort([-2, 5, 0, -45])
    [-45, -2, 0, 5]
    """"""
    # Base case: if the collection has 0 or 1 elements, it is already sorted
    if len(collection) < 2:
        return collection

    # Randomly select a pivot index and remove the pivot element from the collection
    pivot_index = randrange(len(collection))
    pivot = collection.pop(pivot_index)

    # Partition the remaining elements into two groups: lesser or equal, and greater
    lesser = [item for item in collection if item <= pivot]
    greater = [item for item in collection if item > pivot]

    # Recursively sort the lesser and greater groups, and combine with the pivot
    return [*quick_sort(lesser), pivot, *quick_sort(greater)]",data\repos\Python\sorts\quick_sort.py,quick_sort,269
2034,quick_sort_3_partition.py::quick_sort_3partition::1,"def quick_sort_3partition(sorting: list, left: int, right: int) -> None:
    """""" ""
    Python implementation of quick sort algorithm with 3-way partition.
    The idea of 3-way quick sort is based on ""Dutch National Flag algorithm"".

    :param sorting: sort list
    :param left: left endpoint of sorting
    :param right: right endpoint of sorting
    :return: None

    Examples:
    >>> array1 = [5, -1, -1, 5, 5, 24, 0]
    >>> quick_sort_3partition(array1, 0, 6)
    >>> array1
    [-1, -1, 0, 5, 5, 5, 24]
    >>> array2 = [9, 0, 2, 6]
    >>> quick_sort_3partition(array2, 0, 3)
    >>> array2
    [0, 2, 6, 9]
    >>> array3 = []
    >>> quick_sort_3partition(array3, 0, 0)
    >>> array3
    []
    """"""
    if right <= left:
        return
    a = i = left
    b = right
    pivot = sorting[left]
    while i <= b:
        if sorting[i] < pivot:
            sorting[a], sorting[i] = sorting[i], sorting[a]
            a += 1
            i += 1
        elif sorting[i] > pivot:
            sorting[b], sorting[i] = sorting[i], sorting[b]
            b -= 1
        else:
            i += 1
    quick_sort_3partition(sorting, left, a - 1)
    quick_sort_3partition(sorting, b + 1, right)",data\repos\Python\sorts\quick_sort_3_partition.py,quick_sort_3partition,381
2035,quick_sort_3_partition.py::quick_sort_lomuto_partition::44,"def quick_sort_lomuto_partition(sorting: list, left: int, right: int) -> None:
    """"""
    A pure Python implementation of quick sort algorithm(in-place)
    with Lomuto partition scheme:
    https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme

    :param sorting: sort list
    :param left: left endpoint of sorting
    :param right: right endpoint of sorting
    :return: None

    Examples:
    >>> nums1 = [0, 5, 3, 1, 2]
    >>> quick_sort_lomuto_partition(nums1, 0, 4)
    >>> nums1
    [0, 1, 2, 3, 5]
    >>> nums2 = []
    >>> quick_sort_lomuto_partition(nums2, 0, 0)
    >>> nums2
    []
    >>> nums3 = [-2, 5, 0, -4]
    >>> quick_sort_lomuto_partition(nums3, 0, 3)
    >>> nums3
    [-4, -2, 0, 5]
    """"""
    if left < right:
        pivot_index = lomuto_partition(sorting, left, right)
        quick_sort_lomuto_partition(sorting, left, pivot_index - 1)
        quick_sort_lomuto_partition(sorting, pivot_index + 1, right)",data\repos\Python\sorts\quick_sort_3_partition.py,quick_sort_lomuto_partition,299
2036,quick_sort_3_partition.py::lomuto_partition::75,"def lomuto_partition(sorting: list, left: int, right: int) -> int:
    """"""
    Example:
    >>> lomuto_partition([1,5,7,6], 0, 3)
    2
    """"""
    pivot = sorting[right]
    store_index = left
    for i in range(left, right):
        if sorting[i] < pivot:
            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]
            store_index += 1
    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]
    return store_index",data\repos\Python\sorts\quick_sort_3_partition.py,lomuto_partition,129
2037,quick_sort_3_partition.py::three_way_radix_quicksort::91,"def three_way_radix_quicksort(sorting: list) -> list:
    """"""
    Three-way radix quicksort:
    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort
    First divide the list into three parts.
    Then recursively sort the ""less than"" and ""greater than"" partitions.

    >>> three_way_radix_quicksort([])
    []
    >>> three_way_radix_quicksort([1])
    [1]
    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])
    [-5, -2, -2, 0, 1, 1]
    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])
    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]
    """"""
    if len(sorting) <= 1:
        return sorting
    return (
        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])
        + [i for i in sorting if i == sorting[0]]
        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])
    )",data\repos\Python\sorts\quick_sort_3_partition.py,three_way_radix_quicksort,293
2038,radix_sort.py::radix_sort::12,"def radix_sort(list_of_ints: list[int]) -> list[int]:
    """"""
    Examples:
    >>> radix_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> radix_sort(list(range(15))) == sorted(range(15))
    True
    >>> radix_sort(list(range(14,-1,-1))) == sorted(range(15))
    True
    >>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000])
    True
    """"""
    placement = 1
    max_digit = max(list_of_ints)
    while placement <= max_digit:
        # declare and initialize empty buckets
        buckets: list[list] = [[] for _ in range(RADIX)]
        # split list_of_ints between the buckets
        for i in list_of_ints:
            tmp = int((i / placement) % RADIX)
            buckets[tmp].append(i)
        # put each buckets' contents into list_of_ints
        a = 0
        for b in range(RADIX):
            for i in buckets[b]:
                list_of_ints[a] = i
                a += 1
        # move to next
        placement *= RADIX
    return list_of_ints",data\repos\Python\sorts\radix_sort.py,radix_sort,282
2039,recursive_insertion_sort.py::rec_insertion_sort::8,"def rec_insertion_sort(collection: list, n: int):
    """"""
    Given a collection of numbers and its length, sorts the collections
    in ascending order

    :param collection: A mutable collection of comparable elements
    :param n: The length of collections

    >>> col = [1, 2, 1]
    >>> rec_insertion_sort(col, len(col))
    >>> col
    [1, 1, 2]

    >>> col = [2, 1, 0, -1, -2]
    >>> rec_insertion_sort(col, len(col))
    >>> col
    [-2, -1, 0, 1, 2]

    >>> col = [1]
    >>> rec_insertion_sort(col, len(col))
    >>> col
    [1]
    """"""
    # Checks if the entire collection has been sorted
    if len(collection) <= 1 or n <= 1:
        return

    insert_next(collection, n - 1)
    rec_insertion_sort(collection, n - 1)",data\repos\Python\sorts\recursive_insertion_sort.py,rec_insertion_sort,222
2040,recursive_insertion_sort.py::insert_next::39,"def insert_next(collection: list, index: int):
    """"""
    Inserts the '(index-1)th' element into place

    >>> col = [3, 2, 4, 2]
    >>> insert_next(col, 1)
    >>> col
    [2, 3, 4, 2]

    >>> col = [3, 2, 3]
    >>> insert_next(col, 2)
    >>> col
    [3, 2, 3]

    >>> col = []
    >>> insert_next(col, 1)
    >>> col
    []
    """"""
    # Checks order between adjacent elements
    if index >= len(collection) or collection[index - 1] <= collection[index]:
        return

    # Swaps adjacent elements since they are not in ascending order
    collection[index - 1], collection[index] = (
        collection[index],
        collection[index - 1],
    )

    insert_next(collection, index + 1)",data\repos\Python\sorts\recursive_insertion_sort.py,insert_next,205
2041,recursive_mergesort_array.py::merge::8,"def merge(arr: list[int]) -> list[int]:
    """"""Return a sorted array.
    >>> merge([10,9,8,7,6,5,4,3,2,1])
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> merge([1,2,3,4,5,6,7,8,9,10])
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> merge([10,22,1,2,3,9,15,23])
    [1, 2, 3, 9, 10, 15, 22, 23]
    >>> merge([100])
    [100]
    >>> merge([])
    []
    """"""
    if len(arr) > 1:
        middle_length = len(arr) // 2  # Finds the middle of the array
        left_array = arr[
            :middle_length
        ]  # Creates an array of the elements in the first half.
        right_array = arr[
            middle_length:
        ]  # Creates an array of the elements in the second half.
        left_size = len(left_array)
        right_size = len(right_array)
        merge(left_array)  # Starts sorting the left.
        merge(right_array)  # Starts sorting the right
        left_index = 0  # Left Counter
        right_index = 0  # Right Counter
        index = 0  # Position Counter
        while (
            left_index < left_size and right_index < right_size
        ):  # Runs until the lowers size of the left and right are sorted.
            if left_array[left_index] < right_array[right_index]:
                arr[index] = left_array[left_index]
                left_index += 1
            else:
                arr[index] = right_array[right_index]
                right_index += 1
            index += 1
        while (
            left_index < left_size
        ):  # Adds the left over elements in the left half of the array
            arr[index] = left_array[left_index]
            left_index += 1
            index += 1
        while (
            right_index < right_size
        ):  # Adds the left over elements in the right half of the array
            arr[index] = right_array[right_index]
            right_index += 1
            index += 1
    return arr",data\repos\Python\sorts\recursive_mergesort_array.py,merge,534
2042,recursive_quick_sort.py::quick_sort::1,"def quick_sort(data: list) -> list:
    """"""
    >>> for data in ([2, 1, 0], [2.2, 1.1, 0], ""quick_sort""):
    ...     quick_sort(data) == sorted(data)
    True
    True
    True
    """"""
    if len(data) <= 1:
        return data
    else:
        return [
            *quick_sort([e for e in data[1:] if e <= data[0]]),
            data[0],
            *quick_sort([e for e in data[1:] if e > data[0]]),
        ]",data\repos\Python\sorts\recursive_quick_sort.py,quick_sort,133
2043,selection_sort.py::selection_sort::1,"def selection_sort(collection: list[int]) -> list[int]:
    """"""
    Sorts a list in ascending order using the selection sort algorithm.

    :param collection: A list of integers to be sorted.
    :return: The sorted list.

    Examples:
    >>> selection_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> selection_sort([])
    []

    >>> selection_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""

    length = len(collection)
    for i in range(length - 1):
        min_index = i
        for k in range(i + 1, length):
            if collection[k] < collection[min_index]:
                min_index = k
        if min_index != i:
            collection[i], collection[min_index] = collection[min_index], collection[i]
    return collection",data\repos\Python\sorts\selection_sort.py,selection_sort,195
2044,shell_sort.py::shell_sort::6,"def shell_sort(collection: list[int]) -> list[int]:
    """"""Pure implementation of shell sort algorithm in Python
    :param collection:  Some mutable ordered collection with heterogeneous
    comparable items inside
    :return:  the same collection ordered by ascending

    >>> shell_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> shell_sort([])
    []
    >>> shell_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    # Marcin Ciura's gap sequence

    gaps = [701, 301, 132, 57, 23, 10, 4, 1]
    for gap in gaps:
        for i in range(gap, len(collection)):
            insert_value = collection[i]
            j = i
            while j >= gap and collection[j - gap] > insert_value:
                collection[j] = collection[j - gap]
                j -= gap
            if j != i:
                collection[j] = insert_value
    return collection",data\repos\Python\sorts\shell_sort.py,shell_sort,233
2045,shrink_shell_sort.py::shell_sort::24,"def shell_sort(collection: list) -> list:
    """"""Implementation of shell sort algorithm in Python
    :param collection:  Some mutable ordered collection with heterogeneous
    comparable items inside
    :return:  the same collection ordered by ascending

    >>> shell_sort([3, 2, 1])
    [1, 2, 3]
    >>> shell_sort([])
    []
    >>> shell_sort([1])
    [1]
    """"""

    # Choose an initial gap value
    gap = len(collection)

    # Set the gap value to be decreased by a factor of 1.3
    # after each iteration
    shrink = 1.3

    # Continue sorting until the gap is 1
    while gap > 1:
        # Decrease the gap value
        gap = int(gap / shrink)

        # Sort the elements using insertion sort
        for i in range(gap, len(collection)):
            temp = collection[i]
            j = i
            while j >= gap and collection[j - gap] > temp:
                collection[j] = collection[j - gap]
                j -= gap
            collection[j] = temp

    return collection",data\repos\Python\sorts\shrink_shell_sort.py,shell_sort,244
2046,slowsort.py::slowsort::15,"def slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:
    """"""
    Sorts sequence[start..end] (both inclusive) in-place.
    start defaults to 0 if not given.
    end defaults to len(sequence) - 1 if not given.
    It returns None.
    >>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq
    [1, 2, 3, 4, 4, 5, 5, 6]
    >>> seq = []; slowsort(seq); seq
    []
    >>> seq = [2]; slowsort(seq); seq
    [2]
    >>> seq = [1, 2, 3, 4]; slowsort(seq); seq
    [1, 2, 3, 4]
    >>> seq = [4, 3, 2, 1]; slowsort(seq); seq
    [1, 2, 3, 4]
    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq
    [9, 8, 2, 3, 4, 5, 6, 7, 1, 0]
    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq
    [5, 6, 7, 8, 9, 4, 3, 2, 1, 0]
    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq
    [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
    """"""
    if start is None:
        start = 0

    if end is None:
        end = len(sequence) - 1

    if start >= end:
        return

    mid = (start + end) // 2

    slowsort(sequence, start, mid)
    slowsort(sequence, mid + 1, end)

    if sequence[end] < sequence[mid]:
        sequence[end], sequence[mid] = sequence[mid], sequence[end]

    slowsort(sequence, start, end - 1)",data\repos\Python\sorts\slowsort.py,slowsort,567
2047,stalin_sort.py::stalin_sort::8,"def stalin_sort(sequence: list[int]) -> list[int]:
    """"""
    Sorts a list using the Stalin sort algorithm.

    >>> stalin_sort([4, 3, 5, 2, 1, 7])
    [4, 5, 7]

    >>> stalin_sort([1, 2, 3, 4])
    [1, 2, 3, 4]

    >>> stalin_sort([4, 5, 5, 2, 3])
    [4, 5, 5]

    >>> stalin_sort([6, 11, 12, 4, 1, 5])
    [6, 11, 12]

    >>> stalin_sort([5, 0, 4, 3])
    [5]

    >>> stalin_sort([5, 4, 3, 2, 1])
    [5]

    >>> stalin_sort([1, 2, 3, 4, 5])
    [1, 2, 3, 4, 5]

    >>> stalin_sort([1, 2, 8, 7, 6])
    [1, 2, 8]
    """"""
    result = [sequence[0]]
    for element in sequence[1:]:
        if element >= result[-1]:
            result.append(element)

    return result",data\repos\Python\sorts\stalin_sort.py,stalin_sort,297
2048,stooge_sort.py::stooge_sort::1,"def stooge_sort(arr: list[int]) -> list[int]:
    """"""
    Examples:
    >>> stooge_sort([18.1, 0, -7.1, -1, 2, 2])
    [-7.1, -1, 0, 2, 2, 18.1]

    >>> stooge_sort([])
    []
    """"""
    stooge(arr, 0, len(arr) - 1)
    return arr",data\repos\Python\sorts\stooge_sort.py,stooge_sort,96
2049,stooge_sort.py::stooge::14,"def stooge(arr: list[int], i: int, h: int) -> None:
    if i >= h:
        return

    # If first element is smaller than the last then swap them
    if arr[i] > arr[h]:
        arr[i], arr[h] = arr[h], arr[i]

    # If there are more than 2 elements in the array
    if h - i + 1 > 2:
        t = (int)((h - i + 1) / 3)

        # Recursively sort first 2/3 elements
        stooge(arr, i, (h - t))

        # Recursively sort last 2/3 elements
        stooge(arr, i + t, (h))

        # Recursively sort first 2/3 elements
        stooge(arr, i, (h - t))",data\repos\Python\sorts\stooge_sort.py,stooge,180
2050,strand_sort.py::strand_sort::4,"def strand_sort(arr: list, reverse: bool = False, solution: list | None = None) -> list:
    """"""
    Strand sort implementation
    source: https://en.wikipedia.org/wiki/Strand_sort

    :param arr: Unordered input list
    :param reverse: Descent ordering flag
    :param solution: Ordered items container

    Examples:
    >>> strand_sort([4, 2, 5, 3, 0, 1])
    [0, 1, 2, 3, 4, 5]

    >>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True)
    [5, 4, 3, 2, 1, 0]
    """"""
    _operator = operator.lt if reverse else operator.gt
    solution = solution or []

    if not arr:
        return solution

    sublist = [arr.pop(0)]
    for i, item in enumerate(arr):
        if _operator(item, sublist[-1]):
            sublist.append(item)
            arr.pop(i)

    #  merging sublist into solution list
    if not solution:
        solution.extend(sublist)
    else:
        while sublist:
            item = sublist.pop(0)
            for i, xx in enumerate(solution):
                if not _operator(item, xx):
                    solution.insert(i, item)
                    break
            else:
                solution.append(item)

    strand_sort(arr, reverse, solution)
    return solution",data\repos\Python\sorts\strand_sort.py,strand_sort,312
2051,tim_sort.py::binary_search::1,"def binary_search(lst, item, start, end):
    if start == end:
        return start if lst[start] > item else start + 1
    if start > end:
        return start

    mid = (start + end) // 2
    if lst[mid] < item:
        return binary_search(lst, item, mid + 1, end)
    elif lst[mid] > item:
        return binary_search(lst, item, start, mid - 1)
    else:
        return mid",data\repos\Python\sorts\tim_sort.py,binary_search,106
2052,tim_sort.py::insertion_sort::16,"def insertion_sort(lst):
    length = len(lst)

    for index in range(1, length):
        value = lst[index]
        pos = binary_search(lst, value, 0, index - 1)
        lst = [*lst[:pos], value, *lst[pos:index], *lst[index + 1 :]]

    return lst",data\repos\Python\sorts\tim_sort.py,insertion_sort,70
2053,tim_sort.py::merge::27,"def merge(left, right):
    if not left:
        return right

    if not right:
        return left

    if left[0] < right[0]:
        return [left[0], *merge(left[1:], right)]

    return [right[0], *merge(left, right[1:])]",data\repos\Python\sorts\tim_sort.py,merge,66
2054,tim_sort.py::tim_sort::40,"def tim_sort(lst):
    """"""
    >>> tim_sort(""Python"")
    ['P', 'h', 'n', 'o', 't', 'y']
    >>> tim_sort((1.1, 1, 0, -1, -1.1))
    [-1.1, -1, 0, 1, 1.1]
    >>> tim_sort(list(reversed(list(range(7)))))
    [0, 1, 2, 3, 4, 5, 6]
    >>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])
    True
    >>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])
    True
    """"""
    length = len(lst)
    runs, sorted_runs = [], []
    new_run = [lst[0]]
    sorted_array = []
    i = 1
    while i < length:
        if lst[i] < lst[i - 1]:
            runs.append(new_run)
            new_run = [lst[i]]
        else:
            new_run.append(lst[i])
        i += 1
    runs.append(new_run)

    for run in runs:
        sorted_runs.append(insertion_sort(run))
    for run in sorted_runs:
        sorted_array = merge(sorted_array, run)

    return sorted_array",data\repos\Python\sorts\tim_sort.py,tim_sort,291
2055,tim_sort.py::main::75,"def main():
    lst = [5, 9, 10, 3, -4, 5, 178, 92, 46, -18, 0, 7]
    sorted_lst = tim_sort(lst)
    print(sorted_lst)",data\repos\Python\sorts\tim_sort.py,main,55
2056,topological_sort.py::topological_sort::18,"def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:
    """"""Perform topological sort on a directed acyclic graph.""""""
    current = start
    # add current to visited
    visited.append(current)
    neighbors = edges[current]
    for neighbor in neighbors:
        # if neighbor not in visited, visit
        if neighbor not in visited:
            sort = topological_sort(neighbor, visited, sort)
    # if all neighbors visited add current to sort
    sort.append(current)
    # if all vertices haven't been visited select a new one to visit
    if len(visited) != len(vertices):
        for vertice in vertices:
            if vertice not in visited:
                sort = topological_sort(vertice, visited, sort)
    # return sort
    return sort",data\repos\Python\sorts\topological_sort.py,topological_sort,173
2057,tree_sort.py::tree_sort::42,"def tree_sort(arr: list[int]) -> tuple[int, ...]:
    """"""
    >>> tree_sort([])
    ()
    >>> tree_sort((1,))
    (1,)
    >>> tree_sort((1, 2))
    (1, 2)
    >>> tree_sort([5, 2, 7])
    (2, 5, 7)
    >>> tree_sort((5, -4, 9, 2, 7))
    (-4, 2, 5, 7, 9)
    >>> tree_sort([5, 6, 1, -1, 4, 37, 2, 7])
    (-1, 1, 2, 4, 5, 6, 7, 37)

    # >>> tree_sort(range(10, -10, -1)) == tuple(sorted(range(10, -10, -1)))
    # True
    """"""
    if len(arr) == 0:
        return tuple(arr)
    root = Node(arr[0])
    for item in arr[1:]:
        root.insert(item)
    return tuple(root)",data\repos\Python\sorts\tree_sort.py,tree_sort,236
2058,tree_sort.py::insert::29,"    def insert(self, val: int) -> None:
        if val < self.val:
            if self.left is None:
                self.left = Node(val)
            else:
                self.left.insert(val)
        elif val > self.val:
            if self.right is None:
                self.right = Node(val)
            else:
                self.right.insert(val)",data\repos\Python\sorts\tree_sort.py,insert,72
2059,unknown_sort.py::merge_sort::9,"def merge_sort(collection):
    """"""Pure implementation of the fastest merge sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: a collection ordered by ascending

    Examples:
    >>> merge_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> merge_sort([])
    []

    >>> merge_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    start, end = [], []
    while len(collection) > 1:
        min_one, max_one = min(collection), max(collection)
        start.append(min_one)
        end.append(max_one)
        collection.remove(min_one)
        collection.remove(max_one)
    end.reverse()
    return start + collection + end",data\repos\Python\sorts\unknown_sort.py,merge_sort,179
2060,wiggle_sort.py::wiggle_sort::12,"def wiggle_sort(nums: list) -> list:
    """"""
    Python implementation of wiggle.
    Example:
    >>> wiggle_sort([0, 5, 3, 2, 2])
    [0, 5, 2, 3, 2]
    >>> wiggle_sort([])
    []
    >>> wiggle_sort([-2, -5, -45])
    [-45, -2, -5]
    >>> wiggle_sort([-2.1, -5.68, -45.11])
    [-45.11, -2.1, -5.68]
    """"""
    for i, _ in enumerate(nums):
        if (i % 2 == 1) == (nums[i - 1] > nums[i]):
            nums[i - 1], nums[i] = nums[i], nums[i - 1]

    return nums",data\repos\Python\sorts\wiggle_sort.py,wiggle_sort,184
2061,aho_corasick.py::find_next_state::17,"    def find_next_state(self, current_state: int, char: str) -> int | None:
        for state in self.adlist[current_state][""next_states""]:
            if char == self.adlist[state][""value""]:
                return state
        return None",data\repos\Python\strings\aho_corasick.py,find_next_state,52
2062,aho_corasick.py::add_keyword::23,"    def add_keyword(self, keyword: str) -> None:
        current_state = 0
        for character in keyword:
            next_state = self.find_next_state(current_state, character)
            if next_state is None:
                self.adlist.append(
                    {
                        ""value"": character,
                        ""next_states"": [],
                        ""fail_state"": 0,
                        ""output"": [],
                    }
                )
                self.adlist[current_state][""next_states""].append(len(self.adlist) - 1)
                current_state = len(self.adlist) - 1
            else:
                current_state = next_state
        self.adlist[current_state][""output""].append(keyword)",data\repos\Python\strings\aho_corasick.py,add_keyword,138
2063,aho_corasick.py::set_fail_transitions::42,"    def set_fail_transitions(self) -> None:
        q: deque = deque()
        for node in self.adlist[0][""next_states""]:
            q.append(node)
            self.adlist[node][""fail_state""] = 0
        while q:
            r = q.popleft()
            for child in self.adlist[r][""next_states""]:
                q.append(child)
                state = self.adlist[r][""fail_state""]
                while (
                    self.find_next_state(state, self.adlist[child][""value""]) is None
                    and state != 0
                ):
                    state = self.adlist[state][""fail_state""]
                self.adlist[child][""fail_state""] = self.find_next_state(
                    state, self.adlist[child][""value""]
                )
                if self.adlist[child][""fail_state""] is None:
                    self.adlist[child][""fail_state""] = 0
                self.adlist[child][""output""] = (
                    self.adlist[child][""output""]
                    + self.adlist[self.adlist[child][""fail_state""]][""output""]
                )",data\repos\Python\strings\aho_corasick.py,set_fail_transitions,217
2064,aho_corasick.py::search_in::67,"    def search_in(self, string: str) -> dict[str, list[int]]:
        """"""
        >>> A = Automaton([""what"", ""hat"", ""ver"", ""er""])
        >>> A.search_in(""whatever, err ... , wherever"")
        {'what': [0], 'hat': [1], 'ver': [5, 25], 'er': [6, 10, 22, 26]}
        """"""
        result: dict = {}  # returns a dict with keywords and list of its occurrences
        current_state = 0
        for i in range(len(string)):
            while (
                self.find_next_state(current_state, string[i]) is None
                and current_state != 0
            ):
                current_state = self.adlist[current_state][""fail_state""]
            next_state = self.find_next_state(current_state, string[i])
            if next_state is None:
                current_state = 0
            else:
                current_state = next_state
                for key in self.adlist[current_state][""output""]:
                    if key not in result:
                        result[key] = []
                    result[key].append(i - len(key) + 1)
        return result",data\repos\Python\strings\aho_corasick.py,search_in,243
2065,alternative_string_arrange.py::alternative_string_arrange::1,"def alternative_string_arrange(first_str: str, second_str: str) -> str:
    """"""
    Return the alternative arrangements of the two strings.
    :param first_str:
    :param second_str:
    :return: String
    >>> alternative_string_arrange(""ABCD"", ""XY"")
    'AXBYCD'
    >>> alternative_string_arrange(""XY"", ""ABCD"")
    'XAYBCD'
    >>> alternative_string_arrange(""AB"", ""XYZ"")
    'AXBYZ'
    >>> alternative_string_arrange(""ABC"", """")
    'ABC'
    """"""
    first_str_length: int = len(first_str)
    second_str_length: int = len(second_str)
    abs_length: int = (
        first_str_length if first_str_length > second_str_length else second_str_length
    )
    output_list: list = []
    for char_count in range(abs_length):
        if char_count < first_str_length:
            output_list.append(first_str[char_count])
        if char_count < second_str_length:
            output_list.append(second_str[char_count])
    return """".join(output_list)",data\repos\Python\strings\alternative_string_arrange.py,alternative_string_arrange,228
2066,anagrams.py::signature::8,"def signature(word: str) -> str:
    """"""
    Return a word's frequency-based signature.

    >>> signature(""test"")
    'e1s1t2'
    >>> signature(""this is a test"")
    ' 3a1e1h1i2s3t3'
    >>> signature(""finaltest"")
    'a1e1f1i1l1n1s1t2'
    """"""
    frequencies = collections.Counter(word)
    return """".join(
        f""{char}{frequency}"" for char, frequency in sorted(frequencies.items())
    )",data\repos\Python\strings\anagrams.py,signature,120
2067,anagrams.py::anagram::25,"def anagram(my_word: str) -> list[str]:
    """"""
    Return every anagram of the given word from the dictionary.

    >>> anagram('test')
    ['sett', 'stet', 'test']
    >>> anagram('this is a test')
    []
    >>> anagram('final')
    ['final']
    """"""
    return word_by_signature[signature(my_word)]",data\repos\Python\strings\anagrams.py,anagram,80
2068,autocomplete_using_trie.py::autocomplete_using_trie::41,"def autocomplete_using_trie(string: str) -> tuple:
    """"""
    >>> trie = Trie()
    >>> for word in words:
    ...     trie.insert_word(word)
    ...
    >>> matches = autocomplete_using_trie(""de"")
    >>> ""detergent "" in matches
    True
    >>> ""dog "" in matches
    False
    """"""
    suffixes = trie.find_word(string)
    return tuple(string + word for word in suffixes)",data\repos\Python\strings\autocomplete_using_trie.py,autocomplete_using_trie,95
2069,autocomplete_using_trie.py::insert_word::10,"    def insert_word(self, text: str) -> None:
        trie = self._trie
        for char in text:
            if char not in trie:
                trie[char] = {}
            trie = trie[char]
        trie[END] = True",data\repos\Python\strings\autocomplete_using_trie.py,insert_word,52
2070,autocomplete_using_trie.py::find_word::18,"    def find_word(self, prefix: str) -> tuple | list:
        trie = self._trie
        for char in prefix:
            if char in trie:
                trie = trie[char]
            else:
                return []
        return self._elements(trie)",data\repos\Python\strings\autocomplete_using_trie.py,find_word,54
2071,barcode_validator.py::get_check_digit::6,"def get_check_digit(barcode: int) -> int:
    """"""
    Returns the last digit of barcode by excluding the last digit first
    and then computing to reach the actual last digit from the remaining
    12 digits.

    >>> get_check_digit(8718452538119)
    9
    >>> get_check_digit(87184523)
    5
    >>> get_check_digit(87193425381086)
    9
    >>> [get_check_digit(x) for x in range(0, 100, 10)]
    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]
    """"""
    barcode //= 10  # exclude the last digit
    checker = False
    s = 0

    # extract and check each digit
    while barcode != 0:
        mult = 1 if checker else 3
        s += mult * (barcode % 10)
        barcode //= 10
        checker = not checker

    return (10 - (s % 10)) % 10",data\repos\Python\strings\barcode_validator.py,get_check_digit,233
2072,barcode_validator.py::is_valid::35,"def is_valid(barcode: int) -> bool:
    """"""
    Checks for length of barcode and last-digit
    Returns boolean value of validity of barcode

    >>> is_valid(8718452538119)
    True
    >>> is_valid(87184525)
    False
    >>> is_valid(87193425381089)
    False
    >>> is_valid(0)
    False
    >>> is_valid(dwefgiweuf)
    Traceback (most recent call last):
        ...
    NameError: name 'dwefgiweuf' is not defined
    """"""
    return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10",data\repos\Python\strings\barcode_validator.py,is_valid,143
2073,barcode_validator.py::get_barcode::56,"def get_barcode(barcode: str) -> int:
    """"""
    Returns the barcode as an integer

    >>> get_barcode(""8718452538119"")
    8718452538119
    >>> get_barcode(""dwefgiweuf"")
    Traceback (most recent call last):
        ...
    ValueError: Barcode 'dwefgiweuf' has alphabetic characters.
    """"""
    if str(barcode).isalpha():
        msg = f""Barcode '{barcode}' has alphabetic characters.""
        raise ValueError(msg)
    elif int(barcode) < 0:
        raise ValueError(""The entered barcode has a negative value. Try again."")
    else:
        return int(barcode)",data\repos\Python\strings\barcode_validator.py,get_barcode,145
2074,bitap_string_match.py::bitap_string_match::17,"def bitap_string_match(text: str, pattern: str) -> int:
    """"""
    Retrieves the index of the first occurrence of pattern in text.

    Args:
        text: A string consisting only of lowercase alphabetical characters.
        pattern: A string consisting only of lowercase alphabetical characters.

    Returns:
        int: The index where pattern first occurs. Return -1  if not found.

    >>> bitap_string_match('abdabababc', 'ababc')
    5
    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')
    0
    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')
    0
    >>> bitap_string_match('abdabababc', '')
    0
    >>> bitap_string_match('abdabababc', 'c')
    9
    >>> bitap_string_match('abdabababc', 'fofosdfo')
    -1
    >>> bitap_string_match('abdab', 'fofosdfo')
    -1
    """"""
    if not pattern:
        return 0
    m = len(pattern)
    if m > len(text):
        return -1

    # Initial state of bit string 1110
    state = ~1
    # Bit = 0 if character appears at index, and 1 otherwise
    pattern_mask: list[int] = [~0] * 27  # 1111

    for i, char in enumerate(pattern):
        # For the pattern mask for this character, set the bit to 0 for each i
        # the character appears.
        pattern_index: int = ord(char) - ord(""a"")
        pattern_mask[pattern_index] &= ~(1 << i)

    for i, char in enumerate(text):
        text_index = ord(char) - ord(""a"")
        # If this character does not appear in pattern, it's pattern mask is 1111.
        # Performing a bitwise OR between state and 1111 will reset the state to 1111
        # and start searching the start of pattern again.
        state |= pattern_mask[text_index]
        state <<= 1

        # If the mth bit (counting right to left) of the state is 0, then we have
        # found pattern in text
        if (state & (1 << m)) == 0:
            return i - m + 1

    return -1",data\repos\Python\strings\bitap_string_match.py,bitap_string_match,520
2075,boyer_moore_search.py::match_in_pattern::36,"    def match_in_pattern(self, char: str) -> int:
        """"""
        Finds the index of char in pattern in reverse order.

        Parameters :
            char (chr): character to be searched

        Returns :
            i (int): index of char from last in pattern
            -1 (int): if char is not found in pattern

        >>> bms = BoyerMooreSearch(text=""ABAABA"", pattern=""AB"")
        >>> bms.match_in_pattern(""B"")
        1
        """"""

        for i in range(self.patLen - 1, -1, -1):
            if char == self.pattern[i]:
                return i
        return -1",data\repos\Python\strings\boyer_moore_search.py,match_in_pattern,140
2076,boyer_moore_search.py::mismatch_in_text::57,"    def mismatch_in_text(self, current_pos: int) -> int:
        """"""
        Find the index of mis-matched character in text when compared with pattern
        from last.

        Parameters :
            current_pos (int): current index position of text

        Returns :
            i (int): index of mismatched char from last in text
            -1 (int): if there is no mismatch between pattern and text block

        >>> bms = BoyerMooreSearch(text=""ABAABA"", pattern=""AB"")
        >>> bms.mismatch_in_text(2)
        3
        """"""

        for i in range(self.patLen - 1, -1, -1):
            if self.pattern[i] != self.text[current_pos + i]:
                return current_pos + i
        return -1",data\repos\Python\strings\boyer_moore_search.py,mismatch_in_text,166
2077,boyer_moore_search.py::bad_character_heuristic::79,"    def bad_character_heuristic(self) -> list[int]:
        """"""
        Finds the positions of the pattern location.

        >>> bms = BoyerMooreSearch(text=""ABAABA"", pattern=""AB"")
        >>> bms.bad_character_heuristic()
        [0, 3]
        """"""

        positions = []
        for i in range(self.textLen - self.patLen + 1):
            mismatch_index = self.mismatch_in_text(i)
            if mismatch_index == -1:
                positions.append(i)
            else:
                match_index = self.match_in_pattern(self.text[mismatch_index])
                i = (
                    mismatch_index - match_index
                )  # shifting index lgtm [py/multiple-definition]
        return positions",data\repos\Python\strings\boyer_moore_search.py,bad_character_heuristic,150
2078,camel_case_to_snake_case.py::camel_to_snake_case::1,"def camel_to_snake_case(input_str: str) -> str:
    """"""
    Transforms a camelCase (or PascalCase) string to snake_case

    >>> camel_to_snake_case(""someRandomString"")
    'some_random_string'

    >>> camel_to_snake_case(""SomeRandomStr#ng"")
    'some_random_str_ng'

    >>> camel_to_snake_case(""123someRandom123String123"")
    '123_some_random_123_string_123'

    >>> camel_to_snake_case(""123SomeRandom123String123"")
    '123_some_random_123_string_123'

    >>> camel_to_snake_case(123)
    Traceback (most recent call last):
        ...
    ValueError: Expected string as input, found <class 'int'>

    """"""

    # check for invalid input type
    if not isinstance(input_str, str):
        msg = f""Expected string as input, found {type(input_str)}""
        raise ValueError(msg)

    snake_str = """"

    for index, char in enumerate(input_str):
        if char.isupper():
            snake_str += ""_"" + char.lower()

        # if char is lowercase but proceeded by a digit:
        elif input_str[index - 1].isdigit() and char.islower():
            snake_str += ""_"" + char

        # if char is a digit proceeded by a letter:
        elif input_str[index - 1].isalpha() and char.isnumeric():
            snake_str += ""_"" + char.lower()

        # if char is not alphanumeric:
        elif not char.isalnum():
            snake_str += ""_""

        else:
            snake_str += char

    # remove leading underscore
    if snake_str[0] == ""_"":
        snake_str = snake_str[1:]

    return snake_str",data\repos\Python\strings\camel_case_to_snake_case.py,camel_to_snake_case,361
2079,can_string_be_rearranged_as_palindrome.py::can_string_be_rearranged_as_palindrome_counter::11,"def can_string_be_rearranged_as_palindrome_counter(
    input_str: str = """",
) -> bool:
    """"""
    A Palindrome is a String that reads the same forward as it does backwards.
    Examples of Palindromes mom, dad, malayalam
    >>> can_string_be_rearranged_as_palindrome_counter(""Momo"")
    True
    >>> can_string_be_rearranged_as_palindrome_counter(""Mother"")
    False
    >>> can_string_be_rearranged_as_palindrome_counter(""Father"")
    False
    >>> can_string_be_rearranged_as_palindrome_counter(""A man a plan a canal Panama"")
    True
    """"""
    return sum(c % 2 for c in Counter(input_str.replace("" "", """").lower()).values()) < 2",data\repos\Python\strings\can_string_be_rearranged_as_palindrome.py,can_string_be_rearranged_as_palindrome_counter,162
2080,can_string_be_rearranged_as_palindrome.py::can_string_be_rearranged_as_palindrome::29,"def can_string_be_rearranged_as_palindrome(input_str: str = """") -> bool:
    """"""
    A Palindrome is a String that reads the same forward as it does backwards.
    Examples of Palindromes mom, dad, malayalam
    >>> can_string_be_rearranged_as_palindrome(""Momo"")
    True
    >>> can_string_be_rearranged_as_palindrome(""Mother"")
    False
    >>> can_string_be_rearranged_as_palindrome(""Father"")
    False
    >>> can_string_be_rearranged_as_palindrome_counter(""A man a plan a canal Panama"")
    True
    """"""
    if len(input_str) == 0:
        return True
    lower_case_input_str = input_str.replace("" "", """").lower()
    # character_freq_dict: Stores the frequency of every character in the input string
    character_freq_dict: dict[str, int] = {}

    for character in lower_case_input_str:
        character_freq_dict[character] = character_freq_dict.get(character, 0) + 1
    """"""
    Above line of code is equivalent to:
    1) Getting the frequency of current character till previous index
    >>> character_freq =  character_freq_dict.get(character, 0)
    2) Incrementing the frequency of current character by 1
    >>> character_freq = character_freq + 1
    3) Updating the frequency of current character
    >>> character_freq_dict[character] = character_freq
    """"""
    """"""
    OBSERVATIONS:
    Even length palindrome
    -> Every character appears even no.of times.
    Odd length palindrome
    -> Every character appears even no.of times except for one character.
    LOGIC:
    Step 1: We'll count number of characters that appear odd number of times i.e oddChar
    Step 2:If we find more than 1 character that appears odd number of times,
    It is not possible to rearrange as a palindrome
    """"""
    odd_char = 0

    for character_count in character_freq_dict.values():
        if character_count % 2:
            odd_char += 1
    return not odd_char > 1",data\repos\Python\strings\can_string_be_rearranged_as_palindrome.py,can_string_be_rearranged_as_palindrome,450
2081,can_string_be_rearranged_as_palindrome.py::benchmark::78,"def benchmark(input_str: str = """") -> None:
    """"""
    Benchmark code for comparing above 2 functions
    """"""
    print(""\nFor string = "", input_str, "":"")
    print(
        ""> can_string_be_rearranged_as_palindrome_counter()"",
        ""\tans ="",
        can_string_be_rearranged_as_palindrome_counter(input_str),
        ""\ttime ="",
        timeit(
            ""z.can_string_be_rearranged_as_palindrome_counter(z.check_str)"",
            setup=""import __main__ as z"",
        ),
        ""seconds"",
    )
    print(
        ""> can_string_be_rearranged_as_palindrome()"",
        ""\tans ="",
        can_string_be_rearranged_as_palindrome(input_str),
        ""\ttime ="",
        timeit(
            ""z.can_string_be_rearranged_as_palindrome(z.check_str)"",
            setup=""import __main__ as z"",
        ),
        ""seconds"",
    )",data\repos\Python\strings\can_string_be_rearranged_as_palindrome.py,benchmark,199
2082,capitalize.py::capitalize::1,"def capitalize(sentence: str) -> str:
    """"""
    Capitalizes the first letter of a sentence or word.

    >>> capitalize(""hello world"")
    'Hello world'
    >>> capitalize(""123 hello world"")
    '123 hello world'
    >>> capitalize("" hello world"")
    ' hello world'
    >>> capitalize(""a"")
    'A'
    >>> capitalize("""")
    ''
    """"""
    if not sentence:
        return """"

    # Capitalize the first character if it's a lowercase letter
    # Concatenate the capitalized character with the rest of the string
    return sentence[0].upper() + sentence[1:]",data\repos\Python\strings\capitalize.py,capitalize,128
2083,check_anagrams.py::check_anagrams::8,"def check_anagrams(first_str: str, second_str: str) -> bool:
    """"""
    Two strings are anagrams if they are made up of the same letters but are
    arranged differently (ignoring the case).
    >>> check_anagrams('Silent', 'Listen')
    True
    >>> check_anagrams('This is a string', 'Is this a string')
    True
    >>> check_anagrams('This is    a      string', 'Is     this a string')
    True
    >>> check_anagrams('There', 'Their')
    False
    """"""
    first_str = first_str.lower().strip()
    second_str = second_str.lower().strip()

    # Remove whitespace
    first_str = first_str.replace("" "", """")
    second_str = second_str.replace("" "", """")

    # Strings of different lengths are not anagrams
    if len(first_str) != len(second_str):
        return False

    # Default values for count should be 0
    count: defaultdict[str, int] = defaultdict(int)

    # For each character in input strings,
    # increment count in the corresponding
    for i in range(len(first_str)):
        count[first_str[i]] += 1
        count[second_str[i]] -= 1

    return all(_count == 0 for _count in count.values())",data\repos\Python\strings\check_anagrams.py,check_anagrams,276
2084,count_vowels.py::count_vowels::1,"def count_vowels(s: str) -> int:
    """"""
    Count the number of vowels in a given string.

    :param s: Input string to count vowels in.
    :return: Number of vowels in the input string.

    Examples:
    >>> count_vowels(""hello world"")
    3
    >>> count_vowels(""HELLO WORLD"")
    3
    >>> count_vowels(""123 hello world"")
    3
    >>> count_vowels("""")
    0
    >>> count_vowels(""a quick brown fox"")
    5
    >>> count_vowels(""the quick BROWN fox"")
    5
    >>> count_vowels(""PYTHON"")
    1
    """"""
    if not isinstance(s, str):
        raise ValueError(""Input must be a string"")

    vowels = ""aeiouAEIOU""
    return sum(1 for char in s if char in vowels)",data\repos\Python\strings\count_vowels.py,count_vowels,197
2085,credit_card_validator.py::validate_initial_digits::8,"def validate_initial_digits(credit_card_number: str) -> bool:
    """"""
    Function to validate initial digits of a given credit card number.
    >>> valid = ""4111111111111111 41111111111111 34 35 37 412345 523456 634567""
    >>> all(validate_initial_digits(cc) for cc in valid.split())
    True
    >>> invalid = ""14 25 76 32323 36111111111111""
    >>> all(validate_initial_digits(cc) is False for cc in invalid.split())
    True
    """"""
    return credit_card_number.startswith((""34"", ""35"", ""37"", ""4"", ""5"", ""6""))",data\repos\Python\strings\credit_card_validator.py,validate_initial_digits,144
2086,credit_card_validator.py::luhn_validation::21,"def luhn_validation(credit_card_number: str) -> bool:
    """"""
    Function to luhn algorithm validation for a given credit card number.
    >>> luhn_validation('4111111111111111')
    True
    >>> luhn_validation('36111111111111')
    True
    >>> luhn_validation('41111111111111')
    False
    """"""
    cc_number = credit_card_number
    total = 0
    half_len = len(cc_number) - 2
    for i in range(half_len, -1, -2):
        #  double the value of every second digit
        digit = int(cc_number[i])
        digit *= 2
        # If doubling of a number results in a two digit number
        # i.e greater than 9(e.g., 6 x 2 = 12),
        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),
        # to get a single digit number.
        if digit > 9:
            digit %= 10
            digit += 1
        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]
        total += digit

    # Sum up the remaining digits
    for i in range(len(cc_number) - 1, -1, -2):
        total += int(cc_number[i])

    return total % 10 == 0",data\repos\Python\strings\credit_card_validator.py,luhn_validation,314
2087,credit_card_validator.py::validate_credit_card_number::55,"def validate_credit_card_number(credit_card_number: str) -> bool:
    """"""
    Function to validate the given credit card number.
    >>> validate_credit_card_number('4111111111111111')
    4111111111111111 is a valid credit card number.
    True
    >>> validate_credit_card_number('helloworld$')
    helloworld$ is an invalid credit card number because it has nonnumerical characters.
    False
    >>> validate_credit_card_number('32323')
    32323 is an invalid credit card number because of its length.
    False
    >>> validate_credit_card_number('32323323233232332323')
    32323323233232332323 is an invalid credit card number because of its length.
    False
    >>> validate_credit_card_number('36111111111111')
    36111111111111 is an invalid credit card number because of its first two digits.
    False
    >>> validate_credit_card_number('41111111111111')
    41111111111111 is an invalid credit card number because it fails the Luhn check.
    False
    """"""
    error_message = f""{credit_card_number} is an invalid credit card number because""
    if not credit_card_number.isdigit():
        print(f""{error_message} it has nonnumerical characters."")
        return False

    if not 13 <= len(credit_card_number) <= 16:
        print(f""{error_message} of its length."")
        return False

    if not validate_initial_digits(credit_card_number):
        print(f""{error_message} of its first two digits."")
        return False

    if not luhn_validation(credit_card_number):
        print(f""{error_message} it fails the Luhn check."")
        return False

    print(f""{credit_card_number} is a valid credit card number."")
    return True",data\repos\Python\strings\credit_card_validator.py,validate_credit_card_number,382
2088,damerau_levenshtein_distance.py::damerau_levenshtein_distance::11,"def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:
    """"""
    Implements the Damerau-Levenshtein distance algorithm that measures
    the edit distance between two strings.

    Parameters:
        first_string: The first string to compare
        second_string: The second string to compare

    Returns:
        distance: The edit distance between the first and second strings

    >>> damerau_levenshtein_distance(""cat"", ""cut"")
    1
    >>> damerau_levenshtein_distance(""kitten"", ""sitting"")
    3
    >>> damerau_levenshtein_distance(""hello"", ""world"")
    4
    >>> damerau_levenshtein_distance(""book"", ""back"")
    2
    >>> damerau_levenshtein_distance(""container"", ""containment"")
    3
    >>> damerau_levenshtein_distance(""container"", ""containment"")
    3
    """"""
    # Create a dynamic programming matrix to store the distances
    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]

    # Initialize the matrix
    for i in range(len(first_string) + 1):
        dp_matrix[i][0] = i
    for j in range(len(second_string) + 1):
        dp_matrix[0][j] = j

    # Fill the matrix
    for i, first_char in enumerate(first_string, start=1):
        for j, second_char in enumerate(second_string, start=1):
            cost = int(first_char != second_char)

            dp_matrix[i][j] = min(
                dp_matrix[i - 1][j] + 1,  # Deletion
                dp_matrix[i][j - 1] + 1,  # Insertion
                dp_matrix[i - 1][j - 1] + cost,  # Substitution
            )

            if (
                i > 1
                and j > 1
                and first_string[i - 1] == second_string[j - 2]
                and first_string[i - 2] == second_string[j - 1]
            ):
                # Transposition
                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)

    return dp_matrix[-1][-1]",data\repos\Python\strings\damerau_levenshtein_distance.py,damerau_levenshtein_distance,526
2089,detecting_english_programmatically.py::load_dictionary::7,"def load_dictionary() -> dict[str, None]:
    path = os.path.split(os.path.realpath(__file__))
    english_words: dict[str, None] = {}
    with open(path[0] + ""/dictionary.txt"") as dictionary_file:
        for word in dictionary_file.read().split(""\n""):
            english_words[word] = None
    return english_words",data\repos\Python\strings\detecting_english_programmatically.py,load_dictionary,73
2090,detecting_english_programmatically.py::get_english_count::19,"def get_english_count(message: str) -> float:
    message = message.upper()
    message = remove_non_letters(message)
    possible_words = message.split()
    matches = len([word for word in possible_words if word in ENGLISH_WORDS])
    return float(matches) / len(possible_words)",data\repos\Python\strings\detecting_english_programmatically.py,get_english_count,62
2091,detecting_english_programmatically.py::remove_non_letters::27,"def remove_non_letters(message: str) -> str:
    """"""
    >>> remove_non_letters(""Hi! how are you?"")
    'Hi how are you'
    >>> remove_non_letters(""P^y%t)h@o*n"")
    'Python'
    >>> remove_non_letters(""1+1=2"")
    ''
    >>> remove_non_letters(""www.google.com/"")
    'wwwgooglecom'
    >>> remove_non_letters("""")
    ''
    """"""
    return """".join(symbol for symbol in message if symbol in LETTERS_AND_SPACE)",data\repos\Python\strings\detecting_english_programmatically.py,remove_non_letters,110
2092,detecting_english_programmatically.py::is_english::43,"def is_english(
    message: str, word_percentage: int = 20, letter_percentage: int = 85
) -> bool:
    """"""
    >>> is_english('Hello World')
    True
    >>> is_english('llold HorWd')
    False
    """"""
    words_match = get_english_count(message) * 100 >= word_percentage
    num_letters = len(remove_non_letters(message))
    message_letters_percentage = (float(num_letters) / len(message)) * 100
    letters_match = message_letters_percentage >= letter_percentage
    return words_match and letters_match",data\repos\Python\strings\detecting_english_programmatically.py,is_english,124
2093,dna.py::dna::4,"def dna(dna: str) -> str:
    """"""
    https://en.wikipedia.org/wiki/DNA
    Returns the second side of a DNA strand

    >>> dna(""GCTA"")
    'CGAT'
    >>> dna(""ATGC"")
    'TACG'
    >>> dna(""CTGA"")
    'GACT'
    >>> dna(""GFGG"")
    Traceback (most recent call last):
        ...
    ValueError: Invalid Strand
    """"""

    if len(re.findall(""[ATCG]"", dna)) != len(dna):
        raise ValueError(""Invalid Strand"")

    return dna.translate(dna.maketrans(""ATCG"", ""TAGC""))",data\repos\Python\strings\dna.py,dna,138
2094,edit_distance.py::edit_distance::1,"def edit_distance(source: str, target: str) -> int:
    """"""
    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how
    dissimilar two strings are to one another. It is measured by counting the minimum
    number of operations required to transform one string into another.

    This implementation assumes that the cost of operations (insertion, deletion and
    substitution) is always 1

    Args:
    source: the initial string with respect to which we are calculating the edit
        distance for the target
    target: the target string, formed after performing n operations on the source string

    >>> edit_distance(""GATTIC"", ""GALTIC"")
    1
    >>> edit_distance(""NUM3"", ""HUM2"")
    2
    >>> edit_distance(""cap"", ""CAP"")
    3
    >>> edit_distance(""Cat"", """")
    3
    >>> edit_distance(""cat"", ""cat"")
    0
    >>> edit_distance("""", ""123456789"")
    9
    >>> edit_distance(""Be@uty"", ""Beautyyyy!"")
    5
    >>> edit_distance(""lstring"", ""lsstring"")
    1
    """"""
    if len(source) == 0:
        return len(target)
    elif len(target) == 0:
        return len(source)

    delta = int(source[-1] != target[-1])  # Substitution
    return min(
        edit_distance(source[:-1], target[:-1]) + delta,
        edit_distance(source, target[:-1]) + 1,
        edit_distance(source[:-1], target) + 1,
    )",data\repos\Python\strings\edit_distance.py,edit_distance,350
2095,frequency_finder.py::get_letter_count::38,"def get_letter_count(message: str) -> dict[str, int]:
    letter_count = dict.fromkeys(string.ascii_uppercase, 0)
    for letter in message.upper():
        if letter in LETTERS:
            letter_count[letter] += 1

    return letter_count",data\repos\Python\strings\frequency_finder.py,get_letter_count,57
2096,frequency_finder.py::get_frequency_order::51,"def get_frequency_order(message: str) -> str:
    """"""
    Get the frequency order of the letters in the given string
    >>> get_frequency_order('Hello World')
    'LOWDRHEZQXJKVBPYGFMUCSNIAT'
    >>> get_frequency_order('Hello@')
    'LHOEZQXJKVBPYGFWMUCDRSNIAT'
    >>> get_frequency_order('h')
    'HZQXJKVBPYGFWMUCLDRSNIOATE'
    """"""
    letter_to_freq = get_letter_count(message)
    freq_to_letter: dict[int, list[str]] = {
        freq: [] for letter, freq in letter_to_freq.items()
    }
    for letter in LETTERS:
        freq_to_letter[letter_to_freq[letter]].append(letter)

    freq_to_letter_str: dict[int, str] = {}

    for freq in freq_to_letter:  # noqa: PLC0206
        freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)
        freq_to_letter_str[freq] = """".join(freq_to_letter[freq])

    freq_pairs = list(freq_to_letter_str.items())
    freq_pairs.sort(key=get_item_at_index_zero, reverse=True)

    freq_order: list[str] = [freq_pair[1] for freq_pair in freq_pairs]

    return """".join(freq_order)",data\repos\Python\strings\frequency_finder.py,get_frequency_order,286
2097,frequency_finder.py::english_freq_match_score::82,"def english_freq_match_score(message: str) -> int:
    """"""
    >>> english_freq_match_score('Hello World')
    1
    """"""
    freq_order = get_frequency_order(message)
    match_score = 0
    for common_letter in ETAOIN[:6]:
        if common_letter in freq_order[:6]:
            match_score += 1

    for uncommon_letter in ETAOIN[-6:]:
        if uncommon_letter in freq_order[-6:]:
            match_score += 1

    return match_score",data\repos\Python\strings\frequency_finder.py,english_freq_match_score,106
2098,hamming_distance.py::hamming_distance::1,"def hamming_distance(string1: str, string2: str) -> int:
    """"""Calculate the Hamming distance between two equal length strings
    In information theory, the Hamming distance between two strings of equal
    length is the number of positions at which the corresponding symbols are
    different. https://en.wikipedia.org/wiki/Hamming_distance

    Args:
        string1 (str): Sequence 1
        string2 (str): Sequence 2

    Returns:
        int: Hamming distance

    >>> hamming_distance(""python"", ""python"")
    0
    >>> hamming_distance(""karolin"", ""kathrin"")
    3
    >>> hamming_distance(""00000"", ""11111"")
    5
    >>> hamming_distance(""karolin"", ""kath"")
    Traceback (most recent call last):
      ...
    ValueError: String lengths must match!
    """"""
    if len(string1) != len(string2):
        raise ValueError(""String lengths must match!"")

    count = 0

    for char1, char2 in zip(string1, string2):
        if char1 != char2:
            count += 1

    return count",data\repos\Python\strings\hamming_distance.py,hamming_distance,248
2099,indian_phone_validator.py::indian_phone_validator::4,"def indian_phone_validator(phone: str) -> bool:
    """"""
    Determine whether the string is a valid phone number or not
    :param phone:
    :return: Boolean
    >>> indian_phone_validator(""+91123456789"")
    False
    >>> indian_phone_validator(""+919876543210"")
    True
    >>> indian_phone_validator(""01234567896"")
    False
    >>> indian_phone_validator(""919876543218"")
    True
    >>> indian_phone_validator(""+91-1234567899"")
    False
    >>> indian_phone_validator(""+91-9876543218"")
    True
    """"""
    pat = re.compile(r""^(\+91[\-\s]?)?[0]?(91)?[789]\d{9}$"")
    if match := re.search(pat, phone):
        return match.string == phone
    return False",data\repos\Python\strings\indian_phone_validator.py,indian_phone_validator,176
2100,is_contains_unique_chars.py::is_contains_unique_chars::1,"def is_contains_unique_chars(input_str: str) -> bool:
    """"""
    Check if all characters in the string is unique or not.
    >>> is_contains_unique_chars(""I_love.py"")
    True
    >>> is_contains_unique_chars(""I don't love Python"")
    False

    Time complexity: O(n)
    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode
    """"""

    # Each bit will represent each unicode character
    # For example 65th bit representing 'A'
    # https://stackoverflow.com/a/12811293
    bitmap = 0
    for ch in input_str:
        ch_unicode = ord(ch)
        ch_bit_index_on = pow(2, ch_unicode)

        # If we already turned on bit for current character's unicode
        if bitmap >> ch_unicode & 1 == 1:
            return False
        bitmap |= ch_bit_index_on
    return True",data\repos\Python\strings\is_contains_unique_chars.py,is_contains_unique_chars,200
2101,is_isogram.py::is_isogram::6,"def is_isogram(string: str) -> bool:
    """"""
    An isogram is a word in which no letter is repeated.
    Examples of isograms are uncopyrightable and ambidextrously.
    >>> is_isogram('Uncopyrightable')
    True
    >>> is_isogram('allowance')
    False
    >>> is_isogram('copy1')
    Traceback (most recent call last):
     ...
    ValueError: String must only contain alphabetic characters.
    """"""
    if not all(x.isalpha() for x in string):
        raise ValueError(""String must only contain alphabetic characters."")

    letters = sorted(string.lower())
    return len(letters) == len(set(letters))",data\repos\Python\strings\is_isogram.py,is_isogram,144
2102,is_pangram.py::is_pangram::6,"def is_pangram(
    input_str: str = ""The quick brown fox jumps over the lazy dog"",
) -> bool:
    """"""
    A Pangram String contains all the alphabets at least once.
    >>> is_pangram(""The quick brown fox jumps over the lazy dog"")
    True
    >>> is_pangram(""Waltz, bad nymph, for quick jigs vex."")
    True
    >>> is_pangram(""Jived fox nymph grabs quick waltz."")
    True
    >>> is_pangram(""My name is Unknown"")
    False
    >>> is_pangram(""The quick brown fox jumps over the la_y dog"")
    False
    >>> is_pangram()
    True
    """"""
    # Declare frequency as a set to have unique occurrences of letters
    frequency = set()

    # Replace all the whitespace in our sentence
    input_str = input_str.replace("" "", """")
    for alpha in input_str:
        if ""a"" <= alpha.lower() <= ""z"":
            frequency.add(alpha.lower())
    return len(frequency) == 26",data\repos\Python\strings\is_pangram.py,is_pangram,229
2103,is_pangram.py::is_pangram_faster::35,"def is_pangram_faster(
    input_str: str = ""The quick brown fox jumps over the lazy dog"",
) -> bool:
    """"""
    >>> is_pangram_faster(""The quick brown fox jumps over the lazy dog"")
    True
    >>> is_pangram_faster(""Waltz, bad nymph, for quick jigs vex."")
    True
    >>> is_pangram_faster(""Jived fox nymph grabs quick waltz."")
    True
    >>> is_pangram_faster(""The quick brown fox jumps over the la_y dog"")
    False
    >>> is_pangram_faster()
    True
    """"""
    flag = [False] * 26
    for char in input_str:
        if char.islower():
            flag[ord(char) - 97] = True
        elif char.isupper():
            flag[ord(char) - 65] = True
    return all(flag)",data\repos\Python\strings\is_pangram.py,is_pangram_faster,197
2104,is_pangram.py::is_pangram_fastest::59,"def is_pangram_fastest(
    input_str: str = ""The quick brown fox jumps over the lazy dog"",
) -> bool:
    """"""
    >>> is_pangram_fastest(""The quick brown fox jumps over the lazy dog"")
    True
    >>> is_pangram_fastest(""Waltz, bad nymph, for quick jigs vex."")
    True
    >>> is_pangram_fastest(""Jived fox nymph grabs quick waltz."")
    True
    >>> is_pangram_fastest(""The quick brown fox jumps over the la_y dog"")
    False
    >>> is_pangram_fastest()
    True
    """"""
    return len({char for char in input_str.lower() if char.isalpha()}) == 26",data\repos\Python\strings\is_pangram.py,is_pangram_fastest,158
2105,is_pangram.py::benchmark::77,"def benchmark() -> None:
    """"""
    Benchmark code comparing different version.
    """"""
    from timeit import timeit

    setup = ""from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest""
    print(timeit(""is_pangram()"", setup=setup))
    print(timeit(""is_pangram_faster()"", setup=setup))
    print(timeit(""is_pangram_fastest()"", setup=setup))",data\repos\Python\strings\is_pangram.py,benchmark,99
2106,is_polish_national_id.py::is_polish_national_id::1,"def is_polish_national_id(input_str: str) -> bool:
    """"""
    Verification of the correctness of the PESEL number.
    www-gov-pl.translate.goog/web/gov/czym-jest-numer-pesel?_x_tr_sl=auto&_x_tr_tl=en

    PESEL can start with 0, that's why we take str as input,
    but convert it to int for some calculations.


    >>> is_polish_national_id(123)
    Traceback (most recent call last):
        ...
    ValueError: Expected str as input, found <class 'int'>

    >>> is_polish_national_id(""abc"")
    Traceback (most recent call last):
        ...
    ValueError: Expected number as input

    >>> is_polish_national_id(""02070803628"") # correct PESEL
    True

    >>> is_polish_national_id(""02150803629"") # wrong month
    False

    >>> is_polish_national_id(""02075503622"") # wrong day
    False

    >>> is_polish_national_id(""-99012212349"") # wrong range
    False

    >>> is_polish_national_id(""990122123499999"") # wrong range
    False

    >>> is_polish_national_id(""02070803621"") # wrong checksum
    False
    """"""

    # check for invalid input type
    if not isinstance(input_str, str):
        msg = f""Expected str as input, found {type(input_str)}""
        raise ValueError(msg)

    # check if input can be converted to int
    try:
        input_int = int(input_str)
    except ValueError:
        msg = ""Expected number as input""
        raise ValueError(msg)

    # check number range
    if not 10100000 <= input_int <= 99923199999:
        return False

    # check month correctness
    month = int(input_str[2:4])

    if (
        month not in range(1, 13)  # year 1900-1999
        and month not in range(21, 33)  # 2000-2099
        and month not in range(41, 53)  # 2100-2199
        and month not in range(61, 73)  # 2200-2299
        and month not in range(81, 93)  # 1800-1899
    ):
        return False

    # check day correctness
    day = int(input_str[4:6])

    if day not in range(1, 32):
        return False

    # check the checksum
    multipliers = [1, 3, 7, 9, 1, 3, 7, 9, 1, 3]
    subtotal = 0

    digits_to_check = str(input_str)[:-1]  # cut off the checksum

    for index, digit in enumerate(digits_to_check):
        # Multiply corresponding digits and multipliers.
        # In case of a double-digit result, add only the last digit.
        subtotal += (int(digit) * multipliers[index]) % 10

    checksum = 10 - subtotal % 10

    return checksum == input_int % 10",data\repos\Python\strings\is_polish_national_id.py,is_polish_national_id,692
2107,is_spain_national_id.py::is_spain_national_id::5,"def is_spain_national_id(spanish_id: str) -> bool:
    """"""
    Spain National Id is a string composed by 8 numbers plus a letter
    The letter in fact is not part of the ID, it acts as a validator,
    checking you didn't do a mistake when entering it on a system or
    are giving a fake one.

    https://en.wikipedia.org/wiki/Documento_Nacional_de_Identidad_(Spain)#Number

    >>> is_spain_national_id(""12345678Z"")
    True
    >>> is_spain_national_id(""12345678z"")  # It is case-insensitive
    True
    >>> is_spain_national_id(""12345678x"")
    False
    >>> is_spain_national_id(""12345678I"")
    False
    >>> is_spain_national_id(""12345678-Z"")  # Some systems add a dash
    True
    >>> is_spain_national_id(""12345678"")
    Traceback (most recent call last):
        ...
    ValueError: Input must be a string of 8 numbers plus letter
    >>> is_spain_national_id(""123456709"")
    Traceback (most recent call last):
        ...
    ValueError: Input must be a string of 8 numbers plus letter
    >>> is_spain_national_id(""1234567--Z"")
    Traceback (most recent call last):
        ...
    ValueError: Input must be a string of 8 numbers plus letter
    >>> is_spain_national_id(""1234Z"")
    Traceback (most recent call last):
        ...
    ValueError: Input must be a string of 8 numbers plus letter
    >>> is_spain_national_id(""1234ZzZZ"")
    Traceback (most recent call last):
        ...
    ValueError: Input must be a string of 8 numbers plus letter
    >>> is_spain_national_id(12345678)
    Traceback (most recent call last):
        ...
    TypeError: Expected string as input, found int
    """"""

    if not isinstance(spanish_id, str):
        msg = f""Expected string as input, found {type(spanish_id).__name__}""
        raise TypeError(msg)

    spanish_id_clean = spanish_id.replace(""-"", """").upper()
    if len(spanish_id_clean) != 9:
        raise ValueError(NUMBERS_PLUS_LETTER)

    try:
        number = int(spanish_id_clean[0:8])
        letter = spanish_id_clean[8]
    except ValueError as ex:
        raise ValueError(NUMBERS_PLUS_LETTER) from ex

    if letter.isdigit():
        raise ValueError(NUMBERS_PLUS_LETTER)

    return letter == LOOKUP_LETTERS[number % 23]",data\repos\Python\strings\is_spain_national_id.py,is_spain_national_id,574
2108,is_srilankan_phone_number.py::is_sri_lankan_phone_number::4,"def is_sri_lankan_phone_number(phone: str) -> bool:
    """"""
    Determine whether the string is a valid sri lankan mobile phone number or not
    References: https://aye.sh/blog/sri-lankan-phone-number-regex

    >>> is_sri_lankan_phone_number(""+94773283048"")
    True
    >>> is_sri_lankan_phone_number(""+9477-3283048"")
    True
    >>> is_sri_lankan_phone_number(""0718382399"")
    True
    >>> is_sri_lankan_phone_number(""0094702343221"")
    True
    >>> is_sri_lankan_phone_number(""075 3201568"")
    True
    >>> is_sri_lankan_phone_number(""07779209245"")
    False
    >>> is_sri_lankan_phone_number(""0957651234"")
    False
    """"""

    pattern = re.compile(r""^(?:0|94|\+94|0{2}94)7(0|1|2|4|5|6|7|8)(-| |)\d{7}$"")

    return bool(re.search(pattern, phone))",data\repos\Python\strings\is_srilankan_phone_number.py,is_sri_lankan_phone_number,242
2109,is_valid_email_address.py::is_valid_email_address::43,"def is_valid_email_address(email: str) -> bool:
    """"""
    Returns True if the passed email address is valid.

    The local part of the email precedes the singular @ symbol and
    is associated with a display-name. For example, ""john.smith""
    The domain is stricter than the local part and follows the @ symbol.

    Global email checks:
     1. There can only be one @ symbol in the email address. Technically if the
        @ symbol is quoted in the local-part, then it is valid, however this
        implementation ignores """" for now.
        (See https://en.wikipedia.org/wiki/Email_address#:~:text=If%20quoted,)
     2. The local-part and the domain are limited to a certain number of octets. With
        unicode storing a single character in one byte, each octet is equivalent to
        a character. Hence, we can just check the length of the string.
    Checks for the local-part:
     3. The local-part may contain: upper and lowercase latin letters, digits 0 to 9,
        and printable characters (!#$%&'*+-/=?^_`{|}~)
     4. The local-part may also contain a ""."" in any place that is not the first or
        last character, and may not have more than one ""."" consecutively.

    Checks for the domain:
     5. The domain may contain: upper and lowercase latin letters and digits 0 to 9
     6. Hyphen ""-"", provided that it is not the first or last character
     7. The domain may also contain a ""."" in any place that is not the first or
        last character, and may not have more than one ""."" consecutively.

    >>> for email, valid in email_tests:
    ...     assert is_valid_email_address(email) == valid
    """"""

    # (1.) Make sure that there is only one @ symbol in the email address
    if email.count(""@"") != 1:
        return False

    local_part, domain = email.split(""@"")
    # (2.) Check octet length of the local part and domain
    if len(local_part) > MAX_LOCAL_PART_OCTETS or len(domain) > MAX_DOMAIN_OCTETS:
        return False

    # (3.) Validate the characters in the local-part
    if any(
        char not in string.ascii_letters + string.digits + "".(!#$%&'*+-/=?^_`{|}~)""
        for char in local_part
    ):
        return False

    # (4.) Validate the placement of ""."" characters in the local-part
    if local_part.startswith(""."") or local_part.endswith(""."") or "".."" in local_part:
        return False

    # (5.) Validate the characters in the domain
    if any(char not in string.ascii_letters + string.digits + "".-"" for char in domain):
        return False

    # (6.) Validate the placement of ""-"" characters
    if domain.startswith(""-"") or domain.endswith("".""):
        return False

    # (7.) Validate the placement of ""."" characters
    return not (domain.startswith(""."") or domain.endswith(""."") or "".."" in domain)",data\repos\Python\strings\is_valid_email_address.py,is_valid_email_address,670
2110,jaro_winkler.py::jaro_winkler::4,"def jaro_winkler(str1: str, str2: str) -> float:
    """"""
    Jaro-Winkler distance is a string metric measuring an edit distance between two
    sequences.
    Output value is between 0.0 and 1.0.

    >>> jaro_winkler(""martha"", ""marhta"")
    0.9611111111111111
    >>> jaro_winkler(""CRATE"", ""TRACE"")
    0.7333333333333334
    >>> jaro_winkler(""test"", ""dbdbdbdb"")
    0.0
    >>> jaro_winkler(""test"", ""test"")
    1.0
    >>> jaro_winkler(""hello world"", ""HeLLo W0rlD"")
    0.6363636363636364
    >>> jaro_winkler(""test"", """")
    0.0
    >>> jaro_winkler(""hello"", ""world"")
    0.4666666666666666
    >>> jaro_winkler(""hell**o"", ""*world"")
    0.4365079365079365
    """"""

    def get_matched_characters(_str1: str, _str2: str) -> str:
        matched = []
        limit = min(len(_str1), len(_str2)) // 2
        for i, char in enumerate(_str1):
            left = int(max(0, i - limit))
            right = int(min(i + limit + 1, len(_str2)))
            if char in _str2[left:right]:
                matched.append(char)
                _str2 = (
                    f""{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}""
                )

        return """".join(matched)

    # matching characters
    matching_1 = get_matched_characters(str1, str2)
    matching_2 = get_matched_characters(str2, str1)
    match_count = len(matching_1)

    # transposition
    transpositions = (
        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2
    )

    if not match_count:
        jaro = 0.0
    else:
        jaro = (
            1
            / 3
            * (
                match_count / len(str1)
                + match_count / len(str2)
                + (match_count - transpositions) / match_count
            )
        )

    # common prefix up to 4 characters
    prefix_len = 0
    for c1, c2 in zip(str1[:4], str2[:4]):
        if c1 == c2:
            prefix_len += 1
        else:
            break

    return jaro + 0.1 * prefix_len * (1 - jaro)",data\repos\Python\strings\jaro_winkler.py,jaro_winkler,628
2111,jaro_winkler.py::get_matched_characters::28,"    def get_matched_characters(_str1: str, _str2: str) -> str:
        matched = []
        limit = min(len(_str1), len(_str2)) // 2
        for i, char in enumerate(_str1):
            left = int(max(0, i - limit))
            right = int(min(i + limit + 1, len(_str2)))
            if char in _str2[left:right]:
                matched.append(char)
                _str2 = (
                    f""{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}""
                )

        return """".join(matched)",data\repos\Python\strings\jaro_winkler.py,get_matched_characters,142
2112,join.py::join::6,"def join(separator: str, separated: list[str]) -> str:
    """"""
    Joins a list of strings using a separator
    and returns the result.

    :param separator: Separator to be used
                for joining the strings.
    :param separated: List of strings to be joined.

    :return: Joined string with the specified separator.

    Examples:

    >>> join("""", [""a"", ""b"", ""c"", ""d""])
    'abcd'
    >>> join(""#"", [""a"", ""b"", ""c"", ""d""])
    'a#b#c#d'
    >>> join(""#"", ""a"")
    'a'
    >>> join("" "", [""You"", ""are"", ""amazing!""])
    'You are amazing!'
    >>> join("","", ["""", """", """"])
    ',,'

    This example should raise an
    exception for non-string elements:
    >>> join(""#"", [""a"", ""b"", ""c"", 1])
    Traceback (most recent call last):
        ...
    Exception: join() accepts only strings

    Additional test case with a different separator:
    >>> join(""-"", [""apple"", ""banana"", ""cherry""])
    'apple-banana-cherry'
    """"""

    # Check that all elements are strings
    for word_or_phrase in separated:
        # If the element is not a string, raise an exception
        if not isinstance(word_or_phrase, str):
            raise Exception(""join() accepts only strings"")

    joined: str = """"
    """"""
    The last element of the list is not followed by the separator.
    So, we need to iterate through the list and join each element
    with the separator except the last element.
    """"""
    last_index: int = len(separated) - 1
    """"""
    Iterate through the list and join each element with the separator.
    Except the last element, all other elements are followed by the separator.
    """"""
    for word_or_phrase in separated[:last_index]:
        # join the element with the separator.
        joined += word_or_phrase + separator

    # If the list is not empty, join the last element.
    if separated != []:
        joined += separated[last_index]

    # Return the joined string.
    return joined",data\repos\Python\strings\join.py,join,463
2113,knuth_morris_pratt.py::knuth_morris_pratt::4,"def knuth_morris_pratt(text: str, pattern: str) -> int:
    """"""
    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text
    with complexity O(n + m)

    1) Preprocess pattern to identify any suffixes that are identical to prefixes

        This tells us where to continue from if we get a mismatch between a character
        in our pattern and the text.

    2) Step through the text one character at a time and compare it to a character in
        the pattern updating our location within the pattern if necessary

    >>> kmp = ""knuth_morris_pratt""
    >>> all(
    ...    knuth_morris_pratt(kmp, s) == kmp.find(s)
    ...    for s in (""kn"", ""h_m"", ""rr"", ""tt"", ""not there"")
    ... )
    True
    """"""

    # 1) Construct the failure array
    failure = get_failure_array(pattern)

    # 2) Step through text searching for pattern
    i, j = 0, 0  # index into text, pattern
    while i < len(text):
        if pattern[j] == text[i]:
            if j == (len(pattern) - 1):
                return i - j
            j += 1

        # if this is a prefix in our pattern
        # just go back far enough to continue
        elif j > 0:
            j = failure[j - 1]
            continue
        i += 1
    return -1",data\repos\Python\strings\knuth_morris_pratt.py,knuth_morris_pratt,330
2114,knuth_morris_pratt.py::get_failure_array::45,"def get_failure_array(pattern: str) -> list[int]:
    """"""
    Calculates the new index we should go to if we fail a comparison
    :param pattern:
    :return:
    """"""
    failure = [0]
    i = 0
    j = 1
    while j < len(pattern):
        if pattern[i] == pattern[j]:
            i += 1
        elif i > 0:
            i = failure[i - 1]
            continue
        j += 1
        failure.append(i)
    return failure",data\repos\Python\strings\knuth_morris_pratt.py,get_failure_array,113
2115,levenshtein_distance.py::levenshtein_distance::4,"def levenshtein_distance(first_word: str, second_word: str) -> int:
    """"""
    Implementation of the Levenshtein distance in Python.
    :param first_word: the first word to measure the difference.
    :param second_word: the second word to measure the difference.
    :return: the levenshtein distance between the two words.
    Examples:
    >>> levenshtein_distance(""planet"", ""planetary"")
    3
    >>> levenshtein_distance("""", ""test"")
    4
    >>> levenshtein_distance(""book"", ""back"")
    2
    >>> levenshtein_distance(""book"", ""book"")
    0
    >>> levenshtein_distance(""test"", """")
    4
    >>> levenshtein_distance("""", """")
    0
    >>> levenshtein_distance(""orchestration"", ""container"")
    10
    """"""
    # The longer word should come first
    if len(first_word) < len(second_word):
        return levenshtein_distance(second_word, first_word)

    if len(second_word) == 0:
        return len(first_word)

    previous_row = list(range(len(second_word) + 1))

    for i, c1 in enumerate(first_word):
        current_row = [i + 1]

        for j, c2 in enumerate(second_word):
            # Calculate insertions, deletions, and substitutions
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)

            # Get the minimum to append to the current row
            current_row.append(min(insertions, deletions, substitutions))

        # Store the previous row
        previous_row = current_row

    # Returns the last element (distance)
    return previous_row[-1]",data\repos\Python\strings\levenshtein_distance.py,levenshtein_distance,399
2116,levenshtein_distance.py::levenshtein_distance_optimized::54,"def levenshtein_distance_optimized(first_word: str, second_word: str) -> int:
    """"""
    Compute the Levenshtein distance between two words (strings).
    The function is optimized for efficiency by modifying rows in place.
    :param first_word: the first word to measure the difference.
    :param second_word: the second word to measure the difference.
    :return: the Levenshtein distance between the two words.
    Examples:
    >>> levenshtein_distance_optimized(""planet"", ""planetary"")
    3
    >>> levenshtein_distance_optimized("""", ""test"")
    4
    >>> levenshtein_distance_optimized(""book"", ""back"")
    2
    >>> levenshtein_distance_optimized(""book"", ""book"")
    0
    >>> levenshtein_distance_optimized(""test"", """")
    4
    >>> levenshtein_distance_optimized("""", """")
    0
    >>> levenshtein_distance_optimized(""orchestration"", ""container"")
    10
    """"""
    if len(first_word) < len(second_word):
        return levenshtein_distance_optimized(second_word, first_word)

    if len(second_word) == 0:
        return len(first_word)

    previous_row = list(range(len(second_word) + 1))

    for i, c1 in enumerate(first_word):
        current_row = [i + 1] + [0] * len(second_word)

        for j, c2 in enumerate(second_word):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row[j + 1] = min(insertions, deletions, substitutions)

        previous_row = current_row

    return previous_row[-1]",data\repos\Python\strings\levenshtein_distance.py,levenshtein_distance_optimized,397
2117,levenshtein_distance.py::benchmark_levenshtein_distance::99,"def benchmark_levenshtein_distance(func: Callable) -> None:
    """"""
    Benchmark the Levenshtein distance function.
    :param str: The name of the function being benchmarked.
    :param func: The function to be benchmarked.
    """"""
    from timeit import timeit

    stmt = f""{func.__name__}('sitting', 'kitten')""
    setup = f""from __main__ import {func.__name__}""
    number = 25_000
    result = timeit(stmt=stmt, setup=setup, number=number)
    print(f""{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds"")",data\repos\Python\strings\levenshtein_distance.py,benchmark_levenshtein_distance,148
2118,lower.py::lower::1,"def lower(word: str) -> str:
    """"""
    Will convert the entire string to lowercase letters

    >>> lower(""wow"")
    'wow'
    >>> lower(""HellZo"")
    'hellzo'
    >>> lower(""WHAT"")
    'what'
    >>> lower(""wh[]32"")
    'wh[]32'
    >>> lower(""whAT"")
    'what'
    """"""

    # Converting to ASCII value, obtaining the integer representation
    # and checking to see if the character is a capital letter.
    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.
    return """".join(chr(ord(char) + 32) if ""A"" <= char <= ""Z"" else char for char in word)",data\repos\Python\strings\lower.py,lower,159
2119,manacher.py::palindromic_string::1,"def palindromic_string(input_string: str) -> str:
    """"""
    >>> palindromic_string('abbbaba')
    'abbba'
    >>> palindromic_string('ababa')
    'ababa'

    Manacher's algorithm which finds Longest palindromic Substring in linear time.

    1. first this convert input_string(""xyx"") into new_string(""x|y|x"") where odd
        positions are actual input characters.
    2. for each character in new_string it find corresponding length and
        store the length and left,right to store previously calculated info.
        (please look the explanation for details)

    3. return corresponding output_string by removing all ""|""
    """"""
    max_length = 0

    # if input_string is ""aba"" than new_input_string become ""a|b|a""
    new_input_string = """"
    output_string = """"

    # append each character + ""|"" in new_string for range(0, length-1)
    for i in input_string[: len(input_string) - 1]:
        new_input_string += i + ""|""
    # append last character
    new_input_string += input_string[-1]

    # we will store the starting and ending of previous furthest ending palindromic
    # substring
    left, right = 0, 0

    # length[i] shows the length of palindromic substring with center i
    length = [1 for i in range(len(new_input_string))]

    # for each character in new_string find corresponding palindromic string
    start = 0
    for j in range(len(new_input_string)):
        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)
        while (
            j - k >= 0
            and j + k < len(new_input_string)
            and new_input_string[k + j] == new_input_string[j - k]
        ):
            k += 1

        length[j] = 2 * k - 1

        # does this string is ending after the previously explored end (that is right) ?
        # if yes the update the new right to the last index of this
        if j + k - 1 > right:
            left = j - k + 1
            right = j + k - 1

        # update max_length and start position
        if max_length < length[j]:
            max_length = length[j]
            start = j

    # create that string
    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]
    for i in s:
        if i != ""|"":
            output_string += i

    return output_string",data\repos\Python\strings\manacher.py,palindromic_string,586
2120,min_cost_string_conversion.py::compute_transform_tables::12,"def compute_transform_tables(
    source_string: str,
    destination_string: str,
    copy_cost: int,
    replace_cost: int,
    delete_cost: int,
    insert_cost: int,
) -> tuple[list[list[int]], list[list[str]]]:
    """"""
    Finds the most cost efficient sequence
    for converting one string into another.

    >>> costs, operations = compute_transform_tables(""cat"", ""cut"", 1, 2, 3, 3)
    >>> costs[0][:4]
    [0, 3, 6, 9]
    >>> costs[2][:4]
    [6, 4, 3, 6]
    >>> operations[0][:4]
    ['0', 'Ic', 'Iu', 'It']
    >>> operations[3][:4]
    ['Dt', 'Dt', 'Rtu', 'Ct']

    >>> compute_transform_tables("""", """", 1, 2, 3, 3)
    ([[0]], [['0']])
    """"""
    source_seq = list(source_string)
    destination_seq = list(destination_string)
    len_source_seq = len(source_seq)
    len_destination_seq = len(destination_seq)
    costs = [
        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)
    ]
    ops = [
        [""0"" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)
    ]

    for i in range(1, len_source_seq + 1):
        costs[i][0] = i * delete_cost
        ops[i][0] = f""D{source_seq[i - 1]}""

    for i in range(1, len_destination_seq + 1):
        costs[0][i] = i * insert_cost
        ops[0][i] = f""I{destination_seq[i - 1]}""

    for i in range(1, len_source_seq + 1):
        for j in range(1, len_destination_seq + 1):
            if source_seq[i - 1] == destination_seq[j - 1]:
                costs[i][j] = costs[i - 1][j - 1] + copy_cost
                ops[i][j] = f""C{source_seq[i - 1]}""
            else:
                costs[i][j] = costs[i - 1][j - 1] + replace_cost
                ops[i][j] = f""R{source_seq[i - 1]}"" + str(destination_seq[j - 1])

            if costs[i - 1][j] + delete_cost < costs[i][j]:
                costs[i][j] = costs[i - 1][j] + delete_cost
                ops[i][j] = f""D{source_seq[i - 1]}""

            if costs[i][j - 1] + insert_cost < costs[i][j]:
                costs[i][j] = costs[i][j - 1] + insert_cost
                ops[i][j] = f""I{destination_seq[j - 1]}""

    return costs, ops",data\repos\Python\strings\min_cost_string_conversion.py,compute_transform_tables,658
2121,min_cost_string_conversion.py::assemble_transformation::76,"def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:
    """"""
    Assembles the transformations based on the ops table.

    >>> ops = [['0', 'Ic', 'Iu', 'It'],
    ...        ['Dc', 'Cc', 'Iu', 'It'],
    ...        ['Da', 'Da', 'Rau', 'Rat'],
    ...        ['Dt', 'Dt', 'Rtu', 'Ct']]
    >>> x = len(ops) - 1
    >>> y = len(ops[0]) - 1
    >>> assemble_transformation(ops, x, y)
    ['Cc', 'Rau', 'Ct']

    >>> ops1 = [['0']]
    >>> x1 = len(ops1) - 1
    >>> y1 = len(ops1[0]) - 1
    >>> assemble_transformation(ops1, x1, y1)
    []

    >>> ops2 = [['0', 'I1', 'I2', 'I3'],
    ...         ['D1', 'C1', 'I2', 'I3'],
    ...         ['D2', 'D2', 'R23', 'R23']]
    >>> x2 = len(ops2) - 1
    >>> y2 = len(ops2[0]) - 1
    >>> assemble_transformation(ops2, x2, y2)
    ['C1', 'I2', 'R23']
    """"""
    if i == 0 and j == 0:
        return []
    elif ops[i][j][0] in {""C"", ""R""}:
        seq = assemble_transformation(ops, i - 1, j - 1)
        seq.append(ops[i][j])
        return seq
    elif ops[i][j][0] == ""D"":
        seq = assemble_transformation(ops, i - 1, j)
        seq.append(ops[i][j])
        return seq
    else:
        seq = assemble_transformation(ops, i, j - 1)
        seq.append(ops[i][j])
        return seq",data\repos\Python\strings\min_cost_string_conversion.py,assemble_transformation,465
2122,naive_string_search.py::naive_pattern_search::12,"def naive_pattern_search(s: str, pattern: str) -> list:
    """"""
    >>> naive_pattern_search(""ABAAABCDBBABCDDEBCABC"", ""ABC"")
    [4, 10, 18]
    >>> naive_pattern_search(""ABC"", ""ABAAABCDBBABCDDEBCABC"")
    []
    >>> naive_pattern_search("""", ""ABC"")
    []
    >>> naive_pattern_search(""TEST"", ""TEST"")
    [0]
    >>> naive_pattern_search(""ABCDEGFTEST"", ""TEST"")
    [7]
    """"""
    pat_len = len(pattern)
    position = []
    for i in range(len(s) - pat_len + 1):
        match_found = True
        for j in range(pat_len):
            if s[i + j] != pattern[j]:
                match_found = False
                break
        if match_found:
            position.append(i)
    return position",data\repos\Python\strings\naive_string_search.py,naive_pattern_search,185
2123,ngram.py::create_ngram::6,"def create_ngram(sentence: str, ngram_size: int) -> list[str]:
    """"""
    Create ngrams from a sentence

    >>> create_ngram(""I am a sentence"", 2)
    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']
    >>> create_ngram(""I am an NLPer"", 2)
    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']
    >>> create_ngram(""This is short"", 50)
    []
    """"""
    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]",data\repos\Python\strings\ngram.py,create_ngram,181
2124,palindrome.py::is_palindrome::21,"def is_palindrome(s: str) -> bool:
    """"""
    Return True if s is a palindrome otherwise return False.

    >>> all(is_palindrome(key) is value for key, value in test_data.items())
    True
    """"""

    start_i = 0
    end_i = len(s) - 1
    while start_i < end_i:
        if s[start_i] == s[end_i]:
            start_i += 1
            end_i -= 1
        else:
            return False
    return True",data\repos\Python\strings\palindrome.py,is_palindrome,110
2125,palindrome.py::is_palindrome_traversal::40,"def is_palindrome_traversal(s: str) -> bool:
    """"""
    Return True if s is a palindrome otherwise return False.

    >>> all(is_palindrome_traversal(key) is value for key, value in test_data.items())
    True
    """"""
    end = len(s) // 2
    n = len(s)

    # We need to traverse till half of the length of string
    # as we can get access of the i'th last element from
    # i'th index.
    # eg: [0,1,2,3,4,5] => 4th index can be accessed
    # with the help of 1st index (i==n-i-1)
    # where n is length of string
    return all(s[i] == s[n - i - 1] for i in range(end))",data\repos\Python\strings\palindrome.py,is_palindrome_traversal,180
2126,palindrome.py::is_palindrome_recursive::59,"def is_palindrome_recursive(s: str) -> bool:
    """"""
    Return True if s is a palindrome otherwise return False.

    >>> all(is_palindrome_recursive(key) is value for key, value in test_data.items())
    True
    """"""
    if len(s) <= 1:
        return True
    if s[0] == s[len(s) - 1]:
        return is_palindrome_recursive(s[1:-1])
    else:
        return False",data\repos\Python\strings\palindrome.py,is_palindrome_recursive,97
2127,palindrome.py::is_palindrome_slice::74,"def is_palindrome_slice(s: str) -> bool:
    """"""
    Return True if s is a palindrome otherwise return False.

    >>> all(is_palindrome_slice(key) is value for key, value in test_data.items())
    True
    """"""
    return s == s[::-1]",data\repos\Python\strings\palindrome.py,is_palindrome_slice,59
2128,palindrome.py::benchmark_function::84,"def benchmark_function(name: str) -> None:
    stmt = f""all({name}(key) is value for key, value in test_data.items())""
    setup = f""from __main__ import test_data, {name}""
    number = 500000
    result = timeit(stmt=stmt, setup=setup, number=number)
    print(f""{name:<35} finished {number:,} runs in {result:.5f} seconds"")",data\repos\Python\strings\palindrome.py,benchmark_function,96
2129,pig_latin.py::pig_latin::1,"def pig_latin(word: str) -> str:
    """"""Compute the piglatin of a given string.

    https://en.wikipedia.org/wiki/Pig_Latin

    Usage examples:
    >>> pig_latin(""pig"")
    'igpay'
    >>> pig_latin(""latin"")
    'atinlay'
    >>> pig_latin(""banana"")
    'ananabay'
    >>> pig_latin(""friends"")
    'iendsfray'
    >>> pig_latin(""smile"")
    'ilesmay'
    >>> pig_latin(""string"")
    'ingstray'
    >>> pig_latin(""eat"")
    'eatway'
    >>> pig_latin(""omelet"")
    'omeletway'
    >>> pig_latin(""are"")
    'areway'
    >>> pig_latin("" "")
    ''
    >>> pig_latin(None)
    ''
    """"""
    if not (word or """").strip():
        return """"
    word = word.lower()
    if word[0] in ""aeiou"":
        return f""{word}way""
    for i, char in enumerate(word):  # noqa: B007
        if char in ""aeiou"":
            break
    return f""{word[i:]}{word[:i]}ay""",data\repos\Python\strings\pig_latin.py,pig_latin,261
2130,prefix_function.py::prefix_function::14,"def prefix_function(input_string: str) -> list:
    """"""
    For the given string this function computes value for each index(i),
    which represents the longest coincidence of prefix and suffix
    for given substring (input_str[0...i])

    For the value of the first element the algorithm always returns 0

    >>> prefix_function(""aabcdaabc"")
    [0, 1, 0, 0, 0, 1, 2, 3, 4]
    >>> prefix_function(""asdasdad"")
    [0, 0, 0, 1, 2, 3, 4, 0]
    """"""

    # list for the result values
    prefix_result = [0] * len(input_string)

    for i in range(1, len(input_string)):
        # use last results for better performance - dynamic programming
        j = prefix_result[i - 1]
        while j > 0 and input_string[i] != input_string[j]:
            j = prefix_result[j - 1]

        if input_string[i] == input_string[j]:
            j += 1
        prefix_result[i] = j

    return prefix_result",data\repos\Python\strings\prefix_function.py,prefix_function,248
2131,prefix_function.py::longest_prefix::44,"def longest_prefix(input_str: str) -> int:
    """"""
    Prefix-function use case
    Finding longest prefix which is suffix as well

    >>> longest_prefix(""aabcdaabc"")
    4
    >>> longest_prefix(""asdasdad"")
    4
    >>> longest_prefix(""abcab"")
    2
    """"""

    # just returning maximum value of the array gives us answer
    return max(prefix_function(input_str))",data\repos\Python\strings\prefix_function.py,longest_prefix,91
2132,rabin_karp.py::rabin_karp::7,"def rabin_karp(pattern: str, text: str) -> bool:
    """"""
    The Rabin-Karp Algorithm for finding a pattern within a piece of text
    with complexity O(nm), most efficient when it is used with multiple patterns
    as it is able to check if any of a set of patterns match a section of text in o(1)
    given the precomputed hashes.

    This will be the simple version which only assumes one pattern is being searched
    for but it's not hard to modify

    1) Calculate pattern hash

    2) Step through the text one character at a time passing a window with the same
        length as the pattern
        calculating the hash of the text within the window compare it with the hash
        of the pattern. Only testing equality if the hashes match
    """"""
    p_len = len(pattern)
    t_len = len(text)
    if p_len > t_len:
        return False

    p_hash = 0
    text_hash = 0
    modulus_power = 1

    # Calculating the hash of pattern and substring of text
    for i in range(p_len):
        p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus
        text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus
        if i == p_len - 1:
            continue
        modulus_power = (modulus_power * alphabet_size) % modulus

    for i in range(t_len - p_len + 1):
        if text_hash == p_hash and text[i : i + p_len] == pattern:
            return True
        if i == t_len - p_len:
            continue
        # Calculate the https://en.wikipedia.org/wiki/Rolling_hash
        text_hash = (
            (text_hash - ord(text[i]) * modulus_power) * alphabet_size
            + ord(text[i + p_len])
        ) % modulus
    return False",data\repos\Python\strings\rabin_karp.py,rabin_karp,412
2133,rabin_karp.py::test_rabin_karp::54,"def test_rabin_karp() -> None:
    """"""
    >>> test_rabin_karp()
    Success.
    """"""
    # Test 1)
    pattern = ""abc1abc12""
    text1 = ""alskfjaldsabc1abc1abc12k23adsfabcabc""
    text2 = ""alskfjaldsk23adsfabcabc""
    assert rabin_karp(pattern, text1)
    assert not rabin_karp(pattern, text2)

    # Test 2)
    pattern = ""ABABX""
    text = ""ABABZABABYABABX""
    assert rabin_karp(pattern, text)

    # Test 3)
    pattern = ""AAAB""
    text = ""ABAAAAAB""
    assert rabin_karp(pattern, text)

    # Test 4)
    pattern = ""abcdabcy""
    text = ""abcxabcdabxabcdabcdabcy""
    assert rabin_karp(pattern, text)

    # Test 5)
    pattern = ""L""
    text = ""Lsai""
    assert rabin_karp(pattern, text)
    pattern = ""Lue""
    assert not rabin_karp(pattern, text)
    print(""Success."")",data\repos\Python\strings\rabin_karp.py,test_rabin_karp,264
2134,remove_duplicate.py::remove_duplicates::1,"def remove_duplicates(sentence: str) -> str:
    """"""
    Remove duplicates from sentence
    >>> remove_duplicates(""Python is great and Java is also great"")
    'Java Python also and great is'
    >>> remove_duplicates(""Python   is      great and Java is also great"")
    'Java Python also and great is'
    """"""
    return "" "".join(sorted(set(sentence.split())))",data\repos\Python\strings\remove_duplicate.py,remove_duplicates,78
2135,reverse_letters.py::reverse_letters::1,"def reverse_letters(sentence: str, length: int = 0) -> str:
    """"""
    Reverse all words that are longer than the given length of characters in a sentence.
    If unspecified, length is taken as 0

    >>> reverse_letters(""Hey wollef sroirraw"", 3)
    'Hey fellow warriors'
    >>> reverse_letters(""nohtyP is nohtyP"", 2)
    'Python is Python'
    >>> reverse_letters(""1 12 123 1234 54321 654321"", 0)
    '1 21 321 4321 12345 123456'
    >>> reverse_letters(""racecar"")
    'racecar'
    """"""
    return "" "".join(
        """".join(word[::-1]) if len(word) > length else word for word in sentence.split()
    )",data\repos\Python\strings\reverse_letters.py,reverse_letters,178
2136,reverse_words.py::reverse_words::1,"def reverse_words(input_str: str) -> str:
    """"""
    Reverses words in a given string
    >>> reverse_words(""I love Python"")
    'Python love I'
    >>> reverse_words(""I     Love          Python"")
    'Python Love I'
    """"""
    return "" "".join(input_str.split()[::-1])",data\repos\Python\strings\reverse_words.py,reverse_words,69
2137,snake_case_to_camel_pascal_case.py::snake_to_camel_case::1,"def snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:
    """"""
    Transforms a snake_case given string to camelCase (or PascalCase if indicated)
    (defaults to not use Pascal)

    >>> snake_to_camel_case(""some_random_string"")
    'someRandomString'

    >>> snake_to_camel_case(""some_random_string"", use_pascal=True)
    'SomeRandomString'

    >>> snake_to_camel_case(""some_random_string_with_numbers_123"")
    'someRandomStringWithNumbers123'

    >>> snake_to_camel_case(""some_random_string_with_numbers_123"", use_pascal=True)
    'SomeRandomStringWithNumbers123'

    >>> snake_to_camel_case(123)
    Traceback (most recent call last):
        ...
    ValueError: Expected string as input, found <class 'int'>

    >>> snake_to_camel_case(""some_string"", use_pascal=""True"")
    Traceback (most recent call last):
        ...
    ValueError: Expected boolean as use_pascal parameter, found <class 'str'>
    """"""

    if not isinstance(input_str, str):
        msg = f""Expected string as input, found {type(input_str)}""
        raise ValueError(msg)
    if not isinstance(use_pascal, bool):
        msg = f""Expected boolean as use_pascal parameter, found {type(use_pascal)}""
        raise ValueError(msg)

    words = input_str.split(""_"")

    start_index = 0 if use_pascal else 1

    words_to_capitalize = words[start_index:]

    capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]

    initial_word = """" if use_pascal else words[0]

    return """".join([initial_word, *capitalized_words])",data\repos\Python\strings\snake_case_to_camel_pascal_case.py,snake_to_camel_case,376
2138,split.py::split::1,"def split(string: str, separator: str = "" "") -> list:
    """"""
    Will split the string up into all the values separated by the separator
    (defaults to spaces)

    >>> split(""apple#banana#cherry#orange"",separator='#')
    ['apple', 'banana', 'cherry', 'orange']

    >>> split(""Hello there"")
    ['Hello', 'there']

    >>> split(""11/22/63"",separator = '/')
    ['11', '22', '63']

    >>> split(""12:43:39"",separator = "":"")
    ['12', '43', '39']

    >>> split("";abbb;;c;"", separator=';')
    ['', 'abbb', '', 'c', '']
    """"""

    split_words = []

    last_index = 0
    for index, char in enumerate(string):
        if char == separator:
            split_words.append(string[last_index:index])
            last_index = index + 1
        if index + 1 == len(string):
            split_words.append(string[last_index : index + 1])
    return split_words",data\repos\Python\strings\split.py,split,228
2139,string_switch_case.py::split_input::19,"def split_input(str_: str) -> list:
    """"""
    >>> split_input(""one two 31235three4four"")
    [['one', 'two', '31235three4four']]
    """"""
    return [char.split() for char in re.split(r""[^ a-z A-Z 0-9 \s]"", str_)]",data\repos\Python\strings\string_switch_case.py,split_input,70
2140,string_switch_case.py::to_simple_case::27,"def to_simple_case(str_: str) -> str:
    """"""
    >>> to_simple_case(""one two 31235three4four"")
    'OneTwo31235three4four'
    >>> to_simple_case(""This should be combined"")
    'ThisShouldBeCombined'
    >>> to_simple_case(""The first letters are capitalized, then string is merged"")
    'TheFirstLettersAreCapitalizedThenStringIsMerged'
    >>> to_simple_case(""special characters :, ', %, ^, $, are ignored"")
    'SpecialCharactersAreIgnored'
    """"""
    string_split = split_input(str_)
    return """".join(
        ["""".join([char.capitalize() for char in sub_str]) for sub_str in string_split]
    )",data\repos\Python\strings\string_switch_case.py,to_simple_case,152
2141,string_switch_case.py::to_complex_case::44,"def to_complex_case(text: str, upper: bool, separator: str) -> str:
    """"""
    Returns the string concatenated with the delimiter we provide.

    Parameters:
    @text: The string on which we want to perform operation
    @upper: Boolean value to determine whether we want capitalized result or not
    @separator: The delimiter with which we want to concatenate words

    Examples:
    >>> to_complex_case(""one two 31235three4four"", True, ""_"")
    'ONE_TWO_31235THREE4FOUR'
    >>> to_complex_case(""one two 31235three4four"", False, ""-"")
    'one-two-31235three4four'
    """"""
    try:
        string_split = split_input(text)
        if upper:
            res_str = """".join(
                [
                    separator.join([char.upper() for char in sub_str])
                    for sub_str in string_split
                ]
            )
        else:
            res_str = """".join(
                [
                    separator.join([char.lower() for char in sub_str])
                    for sub_str in string_split
                ]
            )
        return res_str
    except IndexError:
        return ""not valid string""",data\repos\Python\strings\string_switch_case.py,to_complex_case,248
2142,string_switch_case.py::to_pascal_case::81,"def to_pascal_case(text: str) -> str:
    """"""
    >>> to_pascal_case(""one two 31235three4four"")
    'OneTwo31235three4four'
    """"""
    return to_simple_case(text)",data\repos\Python\strings\string_switch_case.py,to_pascal_case,49
2143,string_switch_case.py::to_camel_case::89,"def to_camel_case(text: str) -> str:
    """"""
    >>> to_camel_case(""one two 31235three4four"")
    'oneTwo31235three4four'
    """"""
    try:
        res_str = to_simple_case(text)
        return res_str[0].lower() + res_str[1:]
    except IndexError:
        return ""not valid string""",data\repos\Python\strings\string_switch_case.py,to_camel_case,80
2144,string_switch_case.py::to_snake_case::101,"def to_snake_case(text: str, upper: bool) -> str:
    """"""
    >>> to_snake_case(""one two 31235three4four"", True)
    'ONE_TWO_31235THREE4FOUR'
    >>> to_snake_case(""one two 31235three4four"", False)
    'one_two_31235three4four'
    """"""
    return to_complex_case(text, upper, ""_"")",data\repos\Python\strings\string_switch_case.py,to_snake_case,91
2145,string_switch_case.py::to_kebab_case::111,"def to_kebab_case(text: str, upper: bool) -> str:
    """"""
    >>> to_kebab_case(""one two 31235three4four"", True)
    'ONE-TWO-31235THREE4FOUR'
    >>> to_kebab_case(""one two 31235three4four"", False)
    'one-two-31235three4four'
    """"""
    return to_complex_case(text, upper, ""-"")",data\repos\Python\strings\string_switch_case.py,to_kebab_case,92
2146,strip.py::strip::1,"def strip(user_string: str, characters: str = "" \t\n\r"") -> str:
    """"""
    Remove leading and trailing characters (whitespace by default) from a string.

    Args:
        user_string (str): The input string to be stripped.
        characters (str, optional): Optional characters to be removed
                (default is whitespace).

    Returns:
        str: The stripped string.

    Examples:
        >>> strip(""   hello   "")
        'hello'
        >>> strip(""...world..."", ""."")
        'world'
        >>> strip(""123hello123"", ""123"")
        'hello'
        >>> strip("""")
        ''
    """"""

    start = 0
    end = len(user_string)

    while start < end and user_string[start] in characters:
        start += 1

    while end > start and user_string[end - 1] in characters:
        end -= 1

    return user_string[start:end]",data\repos\Python\strings\strip.py,strip,195
2147,text_justification.py::text_justification::1,"def text_justification(word: str, max_width: int) -> list:
    """"""
    Will format the string such that each line has exactly
    (max_width) characters and is fully (left and right) justified,
    and return the list of justified text.

    example 1:
    string = ""This is an example of text justification.""
    max_width = 16

    output = ['This    is    an',
              'example  of text',
              'justification.  ']

    >>> text_justification(""This is an example of text justification."", 16)
    ['This    is    an', 'example  of text', 'justification.  ']

    example 2:
    string = ""Two roads diverged in a yellow wood""
    max_width = 16
    output = ['Two        roads',
              'diverged   in  a',
              'yellow wood     ']

    >>> text_justification(""Two roads diverged in a yellow wood"", 16)
    ['Two        roads', 'diverged   in  a', 'yellow wood     ']

    Time complexity: O(m*n)
    Space complexity: O(m*n)
    """"""

    # Converting string into list of strings split by a space
    words = word.split()

    def justify(line: list, width: int, max_width: int) -> str:
        overall_spaces_count = max_width - width
        words_count = len(line)
        if len(line) == 1:
            # if there is only word in line
            # just insert overall_spaces_count for the remainder of line
            return line[0] + "" "" * overall_spaces_count
        else:
            spaces_to_insert_between_words = words_count - 1
            # num_spaces_between_words_list[i] : tells you to insert
            # num_spaces_between_words_list[i] spaces
            # after word on line[i]
            num_spaces_between_words_list = spaces_to_insert_between_words * [
                overall_spaces_count // spaces_to_insert_between_words
            ]
            spaces_count_in_locations = (
                overall_spaces_count % spaces_to_insert_between_words
            )
            # distribute spaces via round robin to the left words
            for i in range(spaces_count_in_locations):
                num_spaces_between_words_list[i] += 1
            aligned_words_list = []
            for i in range(spaces_to_insert_between_words):
                # add the word
                aligned_words_list.append(line[i])
                # add the spaces to insert
                aligned_words_list.append(num_spaces_between_words_list[i] * "" "")
            # just add the last word to the sentence
            aligned_words_list.append(line[-1])
            # join the aligned words list to form a justified line
            return """".join(aligned_words_list)

    answer = []
    line: list[str] = []
    width = 0
    for inner_word in words:
        if width + len(inner_word) + len(line) <= max_width:
            # keep adding words until we can fill out max_width
            # width = sum of length of all words (without overall_spaces_count)
            # len(inner_word) = length of current inner_word
            # len(line) = number of overall_spaces_count to insert between words
            line.append(inner_word)
            width += len(inner_word)
        else:
            # justify the line and add it to result
            answer.append(justify(line, width, max_width))
            # reset new line and new width
            line, width = [inner_word], len(inner_word)
    remaining_spaces = max_width - width - len(line)
    answer.append("" "".join(line) + (remaining_spaces + 1) * "" "")
    return answer",data\repos\Python\strings\text_justification.py,text_justification,776
2148,text_justification.py::justify::35,"    def justify(line: list, width: int, max_width: int) -> str:
        overall_spaces_count = max_width - width
        words_count = len(line)
        if len(line) == 1:
            # if there is only word in line
            # just insert overall_spaces_count for the remainder of line
            return line[0] + "" "" * overall_spaces_count
        else:
            spaces_to_insert_between_words = words_count - 1
            # num_spaces_between_words_list[i] : tells you to insert
            # num_spaces_between_words_list[i] spaces
            # after word on line[i]
            num_spaces_between_words_list = spaces_to_insert_between_words * [
                overall_spaces_count // spaces_to_insert_between_words
            ]
            spaces_count_in_locations = (
                overall_spaces_count % spaces_to_insert_between_words
            )
            # distribute spaces via round robin to the left words
            for i in range(spaces_count_in_locations):
                num_spaces_between_words_list[i] += 1
            aligned_words_list = []
            for i in range(spaces_to_insert_between_words):
                # add the word
                aligned_words_list.append(line[i])
                # add the spaces to insert
                aligned_words_list.append(num_spaces_between_words_list[i] * "" "")
            # just add the last word to the sentence
            aligned_words_list.append(line[-1])
            # join the aligned words list to form a justified line
            return """".join(aligned_words_list)",data\repos\Python\strings\text_justification.py,justify,311
2149,title.py::to_title_case::1,"def to_title_case(word: str) -> str:
    """"""
    Converts a string to capitalized case, preserving the input as is

    >>> to_title_case(""Aakash"")
    'Aakash'

    >>> to_title_case(""aakash"")
    'Aakash'

    >>> to_title_case(""AAKASH"")
    'Aakash'

    >>> to_title_case(""aAkAsH"")
    'Aakash'
    """"""

    """"""
    Convert the first character to uppercase if it's lowercase
    """"""
    if ""a"" <= word[0] <= ""z"":
        word = chr(ord(word[0]) - 32) + word[1:]

    """"""
    Convert the remaining characters to lowercase if they are uppercase
    """"""
    for i in range(1, len(word)):
        if ""A"" <= word[i] <= ""Z"":
            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]

    return word",data\repos\Python\strings\title.py,to_title_case,204
2150,title.py::sentence_to_title_case::34,"def sentence_to_title_case(input_str: str) -> str:
    """"""
    Converts a string to title case, preserving the input as is

    >>> sentence_to_title_case(""Aakash Giri"")
    'Aakash Giri'

    >>> sentence_to_title_case(""aakash giri"")
    'Aakash Giri'

    >>> sentence_to_title_case(""AAKASH GIRI"")
    'Aakash Giri'

    >>> sentence_to_title_case(""aAkAsH gIrI"")
    'Aakash Giri'
    """"""

    return "" "".join(to_title_case(word) for word in input_str.split())",data\repos\Python\strings\title.py,sentence_to_title_case,128
2151,top_k_frequent_words.py::top_k_frequent_words::67,"def top_k_frequent_words(words: list[str], k_value: int) -> list[str]:
    """"""
    Returns the `k_value` most frequently occurring words,
    in non-increasing order of occurrence.
    In this context, a word is defined as an element in the provided list.

    In case `k_value` is greater than the number of distinct words, a value of k equal
    to the number of distinct words will be considered, instead.

    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 3)
    ['c', 'a', 'b']
    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 2)
    ['c', 'a']
    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 1)
    ['c']
    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 0)
    []
    >>> top_k_frequent_words([], 1)
    []
    >>> top_k_frequent_words(['a', 'a'], 2)
    ['a']
    """"""
    heap: Heap[WordCount] = Heap()
    count_by_word = Counter(words)
    heap.build_max_heap(
        [WordCount(word, count) for word, count in count_by_word.items()]
    )
    return [heap.extract_max().word for _ in range(min(k_value, len(count_by_word)))]",data\repos\Python\strings\top_k_frequent_words.py,top_k_frequent_words,332
2152,upper.py::upper::1,"def upper(word: str) -> str:
    """"""
    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII
    letters and subtracting 32 from their integer representation to get the uppercase
    letter.

    >>> upper(""wow"")
    'WOW'
    >>> upper(""Hello"")
    'HELLO'
    >>> upper(""WHAT"")
    'WHAT'
    >>> upper(""wh[]32"")
    'WH[]32'
    """"""
    return """".join(chr(ord(char) - 32) if ""a"" <= char <= ""z"" else char for char in word)",data\repos\Python\strings\upper.py,upper,122
2153,wave_string.py::wave::1,"def wave(txt: str) -> list:
    """"""
    Returns a so called 'wave' of a given string
    >>> wave('cat')
    ['Cat', 'cAt', 'caT']
    >>> wave('one')
    ['One', 'oNe', 'onE']
    >>> wave('book')
    ['Book', 'bOok', 'boOk', 'booK']
    """"""

    return [
        txt[:a] + txt[a].upper() + txt[a + 1 :]
        for a in range(len(txt))
        if txt[a].isalpha()
    ]",data\repos\Python\strings\wave_string.py,wave,124
2154,wildcard_pattern_matching.py::match_pattern::10,"def match_pattern(input_string: str, pattern: str) -> bool:
    """"""
    uses bottom-up dynamic programming solution for matching the input
    string with a given pattern.

    Runtime: O(len(input_string)*len(pattern))

    Arguments
    --------
    input_string: str, any string which should be compared with the pattern
    pattern: str, the string that represents a pattern and may contain
    '.' for single character matches and '*' for zero or more of preceding character
    matches

    Note
    ----
    the pattern cannot start with a '*',
    because there should be at least one character before *

    Returns
    -------
    A Boolean denoting whether the given string follows the pattern

    Examples
    -------
    >>> match_pattern(""aab"", ""c*a*b"")
    True
    >>> match_pattern(""dabc"", ""*abc"")
    False
    >>> match_pattern(""aaa"", ""aa"")
    False
    >>> match_pattern(""aaa"", ""a.a"")
    True
    >>> match_pattern(""aaab"", ""aa*"")
    False
    >>> match_pattern(""aaab"", "".*"")
    True
    >>> match_pattern(""a"", ""bbbb"")
    False
    >>> match_pattern("""", ""bbbb"")
    False
    >>> match_pattern(""a"", """")
    False
    >>> match_pattern("""", """")
    True
    """"""

    len_string = len(input_string) + 1
    len_pattern = len(pattern) + 1

    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of
    # length i of input_string matches with prefix string of length j of
    # given pattern.
    # ""dp"" stands for dynamic programming.
    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]

    # since string of zero length match pattern of zero length
    dp[0][0] = 1

    # since pattern of zero length will never match with string of non-zero length
    for i in range(1, len_string):
        dp[i][0] = 0

    # since string of zero length will match with pattern where there
    # is at least one * alternatively
    for j in range(1, len_pattern):
        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == ""*"" else 0

    # now using bottom-up approach to find for all remaining lengths
    for i in range(1, len_string):
        for j in range(1, len_pattern):
            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == ""."":
                dp[i][j] = dp[i - 1][j - 1]

            elif pattern[j - 1] == ""*"":
                if dp[i][j - 2] == 1:
                    dp[i][j] = 1
                elif pattern[j - 2] in (input_string[i - 1], "".""):
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = 0
            else:
                dp[i][j] = 0

    return bool(dp[-1][-1])",data\repos\Python\strings\wildcard_pattern_matching.py,match_pattern,686
2155,word_occurrence.py::word_occurrence::6,"def word_occurrence(sentence: str) -> dict:
    """"""
    >>> from collections import Counter
    >>> SENTENCE = ""a b A b c b d b d e f e g e h e i e j e 0""
    >>> occurence_dict = word_occurrence(SENTENCE)
    >>> all(occurence_dict[word] == count for word, count
    ...     in Counter(SENTENCE.split()).items())
    True
    >>> dict(word_occurrence(""Two  spaces""))
    {'Two': 1, 'spaces': 1}
    """"""
    occurrence: defaultdict[str, int] = defaultdict(int)
    # Creating a dictionary containing count of each word
    for word in sentence.split():
        occurrence[word] += 1
    return occurrence",data\repos\Python\strings\word_occurrence.py,word_occurrence,160
2156,word_patterns.py::get_word_pattern::1,"def get_word_pattern(word: str) -> str:
    """"""
    Returns numerical pattern of character appearances in given word
    >>> get_word_pattern("""")
    ''
    >>> get_word_pattern("" "")
    '0'
    >>> get_word_pattern(""pattern"")
    '0.1.2.2.3.4.5'
    >>> get_word_pattern(""word pattern"")
    '0.1.2.3.4.5.6.7.7.8.2.9'
    >>> get_word_pattern(""get word pattern"")
    '0.1.2.3.4.5.6.7.3.8.9.2.2.1.6.10'
    >>> get_word_pattern()
    Traceback (most recent call last):
    ...
    TypeError: get_word_pattern() missing 1 required positional argument: 'word'
    >>> get_word_pattern(1)
    Traceback (most recent call last):
    ...
    AttributeError: 'int' object has no attribute 'upper'
    >>> get_word_pattern(1.1)
    Traceback (most recent call last):
    ...
    AttributeError: 'float' object has no attribute 'upper'
    >>> get_word_pattern([])
    Traceback (most recent call last):
    ...
    AttributeError: 'list' object has no attribute 'upper'
    """"""
    word = word.upper()
    next_num = 0
    letter_nums = {}
    word_pattern = []

    for letter in word:
        if letter not in letter_nums:
            letter_nums[letter] = str(next_num)
            next_num += 1
        word_pattern.append(letter_nums[letter])
    return ""."".join(word_pattern)",data\repos\Python\strings\word_patterns.py,get_word_pattern,350
2157,z_function.py::z_function::13,"def z_function(input_str: str) -> list[int]:
    """"""
    For the given string this function computes value for each index,
    which represents the maximal length substring starting from the index
    and is the same as the prefix of the same size

    e.x.  for string 'abab' for second index value would be 2

    For the value of the first element the algorithm always returns 0

    >>> z_function(""abracadabra"")
    [0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]
    >>> z_function(""aaaa"")
    [0, 3, 2, 1]
    >>> z_function(""zxxzxxz"")
    [0, 0, 0, 4, 0, 0, 1]
    """"""
    z_result = [0 for i in range(len(input_str))]

    # initialize interval's left pointer and right pointer
    left_pointer, right_pointer = 0, 0

    for i in range(1, len(input_str)):
        # case when current index is inside the interval
        if i <= right_pointer:
            min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])
            z_result[i] = min_edge

        while go_next(i, z_result, input_str):
            z_result[i] += 1

        # if new index's result gives us more right interval,
        # we've to update left_pointer and right_pointer
        if i + z_result[i] - 1 > right_pointer:
            left_pointer, right_pointer = i, i + z_result[i] - 1

    return z_result",data\repos\Python\strings\z_function.py,z_function,368
2158,z_function.py::go_next::52,"def go_next(i: int, z_result: list[int], s: str) -> bool:
    """"""
    Check if we have to move forward to the next characters or not
    """"""
    return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]",data\repos\Python\strings\z_function.py,go_next,65
2159,z_function.py::find_pattern::59,"def find_pattern(pattern: str, input_str: str) -> int:
    """"""
    Example of using z-function for pattern occurrence
    Given function returns the number of times 'pattern'
    appears in 'input_str' as a substring

    >>> find_pattern(""abr"", ""abracadabra"")
    2
    >>> find_pattern(""a"", ""aaaa"")
    4
    >>> find_pattern(""xz"", ""zxxzxxz"")
    2
    """"""
    answer = 0
    # concatenate 'pattern' and 'input_str' and call z_function
    # with concatenated string
    z_result = z_function(pattern + input_str)

    for val in z_result:
        # if value is greater then length of the pattern string
        # that means this index is starting position of substring
        # which is equal to pattern string
        if val >= len(pattern):
            answer += 1

    return answer",data\repos\Python\strings\z_function.py,find_pattern,196
2160,co2_emission.py::fetch_last_half_hour::20,"def fetch_last_half_hour() -> str:
    last_half_hour = httpx.get(BASE_URL, timeout=10).json()[""data""][0]
    return last_half_hour[""intensity""][""actual""]",data\repos\Python\web_programming\co2_emission.py,fetch_last_half_hour,41
2161,co2_emission.py::fetch_from_to::26,"def fetch_from_to(start, end) -> list:
    return httpx.get(f""{BASE_URL}/{start}/{end}"", timeout=10).json()[""data""]",data\repos\Python\web_programming\co2_emission.py,fetch_from_to,33
2162,covid_stats_via_xpath.py::covid_stats::28,"def covid_stats(
    url: str = (
        ""https://web.archive.org/web/20250825095350/""
        ""https://www.worldometers.info/coronavirus/""
    ),
) -> CovidData:
    xpath_str = '//div[@class = ""maincounter-number""]/span/text()'
    try:
        response = httpx.get(url, timeout=10).raise_for_status()
    except httpx.TimeoutException:
        print(
            ""Request timed out. Please check your network connection ""
            ""or try again later.""
        )
        return CovidData(""N/A"", ""N/A"", ""N/A"")
    except httpx.HTTPStatusError as e:
        print(f""HTTP error occurred: {e}"")
        return CovidData(""N/A"", ""N/A"", ""N/A"")
    data = html.fromstring(response.content).xpath(xpath_str)
    if len(data) != 3:
        print(""Unexpected data format. The page structure may have changed."")
        data = ""N/A"", ""N/A"", ""N/A""
    return CovidData(*data)",data\repos\Python\web_programming\covid_stats_via_xpath.py,covid_stats,223
2163,crawl_google_scholar_citation.py::get_citation::18,"def get_citation(base_url: str, params: dict) -> str:
    """"""
    Return the citation number.
    """"""
    soup = BeautifulSoup(
        httpx.get(base_url, params=params, timeout=10).content, ""html.parser""
    )
    div = soup.find(""div"", attrs={""class"": ""gs_ri""})
    anchors = div.find(""div"", attrs={""class"": ""gs_fl""}).find_all(""a"")
    return anchors[2].get_text()",data\repos\Python\web_programming\crawl_google_scholar_citation.py,get_citation,101
2164,currency_converter.py::convert_currency::178,"def convert_currency(
    from_: str = ""USD"", to: str = ""INR"", amount: float = 1.0, api_key: str = """"
) -> str:
    """"""https://www.amdoren.com/currency-api/""""""
    # Instead of manually generating parameters
    params = locals()
    # from is a reserved keyword
    params[""from""] = params.pop(""from_"")
    res = httpx.get(URL_BASE, params=params, timeout=10).json()
    return str(res[""amount""]) if res[""error""] == 0 else res[""error_message""]",data\repos\Python\web_programming\currency_converter.py,convert_currency,125
2165,current_stock_price.py::stock_price::23,"def stock_price(symbol: str = ""AAPL"") -> str:
    """"""
    >>> stock_price(""EEEE"")
    'No <fin-streamer> tag with the specified data-testid attribute found.'
    >>> isinstance(float(stock_price(""GOOG"")),float)
    True
    """"""
    url = f""https://finance.yahoo.com/quote/{symbol}?p={symbol}""
    yahoo_finance_source = httpx.get(
        url, headers={""USER-AGENT"": ""Mozilla/5.0""}, timeout=10, follow_redirects=True
    ).text
    soup = BeautifulSoup(yahoo_finance_source, ""html.parser"")

    if specific_fin_streamer_tag := soup.find(""span"", {""data-testid"": ""qsp-price""}):
        return specific_fin_streamer_tag.get_text()
    return ""No <fin-streamer> tag with the specified data-testid attribute found.""",data\repos\Python\web_programming\current_stock_price.py,stock_price,179
2166,current_weather.py::current_weather::19,"def current_weather(location: str) -> list[dict]:
    """"""
    >>> current_weather(""location"")
    Traceback (most recent call last):
        ...
    ValueError: No API keys provided or no valid data returned.
    """"""
    weather_data = []
    if OPENWEATHERMAP_API_KEY:
        params_openweathermap = {""q"": location, ""appid"": OPENWEATHERMAP_API_KEY}
        response_openweathermap = httpx.get(
            OPENWEATHERMAP_URL_BASE, params=params_openweathermap, timeout=10
        )
        weather_data.append({""OpenWeatherMap"": response_openweathermap.json()})
    if WEATHERSTACK_API_KEY:
        params_weatherstack = {""query"": location, ""access_key"": WEATHERSTACK_API_KEY}
        response_weatherstack = httpx.get(
            WEATHERSTACK_URL_BASE, params=params_weatherstack, timeout=10
        )
        weather_data.append({""Weatherstack"": response_weatherstack.json()})
    if not weather_data:
        raise ValueError(""No API keys provided or no valid data returned."")
    return weather_data",data\repos\Python\web_programming\current_weather.py,current_weather,215
2167,daily_horoscope.py::horoscope::13,"def horoscope(zodiac_sign: int, day: str) -> str:
    url = (
        ""https://www.horoscope.com/us/horoscopes/general/""
        f""horoscope-general-daily-{day}.aspx?sign={zodiac_sign}""
    )
    soup = BeautifulSoup(httpx.get(url, timeout=10).content, ""html.parser"")
    return soup.find(""div"", class_=""main-horoscope"").p.text",data\repos\Python\web_programming\daily_horoscope.py,horoscope,94
2168,download_images_from_google_query.py::download_images_from_google_query::24,"def download_images_from_google_query(query: str = ""dhaka"", max_images: int = 5) -> int:
    """"""
    Searches google using the provided query term and downloads the images in a folder.

    Args:
         query : The image search term to be provided by the user. Defaults to
        ""dhaka"".
        image_numbers : [description]. Defaults to 5.

    Returns:
        The number of images successfully downloaded.

    # Comment out slow (4.20s call) doctests
    # >>> download_images_from_google_query()
    5
    # >>> download_images_from_google_query(""potato"")
    5
    """"""
    max_images = min(max_images, 50)  # Prevent abuse!
    params = {
        ""q"": query,
        ""tbm"": ""isch"",
        ""hl"": ""en"",
        ""ijn"": ""0"",
    }

    html = httpx.get(
        ""https://www.google.com/search"", params=params, headers=headers, timeout=10
    )
    soup = BeautifulSoup(html.text, ""html.parser"")
    matched_images_data = """".join(
        re.findall(r""AF_initDataCallback\(([^<]+)\);"", str(soup.select(""script"")))
    )

    matched_images_data_fix = json.dumps(matched_images_data)
    matched_images_data_json = json.loads(matched_images_data_fix)

    matched_google_image_data = re.findall(
        r""\[\""GRID_STATE0\"",null,\[\[1,\[0,\"".*?\"",(.*),\""All\"","",
        matched_images_data_json,
    )
    if not matched_google_image_data:
        return 0

    removed_matched_google_images_thumbnails = re.sub(
        r""\[\""(https\:\/\/encrypted-tbn0\.gstatic\.com\/images\?.*?)\"",\d+,\d+\]"",
        """",
        str(matched_google_image_data),
    )

    matched_google_full_resolution_images = re.findall(
        r""(?:'|,),\[\""(https:|http.*?)\"",\d+,\d+\]"",
        removed_matched_google_images_thumbnails,
    )
    for index, fixed_full_res_image in enumerate(matched_google_full_resolution_images):
        if index >= max_images:
            return index
        original_size_img_not_fixed = bytes(fixed_full_res_image, ""ascii"").decode(
            ""unicode-escape""
        )
        original_size_img = bytes(original_size_img_not_fixed, ""ascii"").decode(
            ""unicode-escape""
        )
        opener = urllib.request.build_opener()
        opener.addheaders = [
            (
                ""User-Agent"",
                ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36""
                "" (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.19582"",
            )
        ]
        urllib.request.install_opener(opener)
        path_name = f""query_{query.replace(' ', '_')}""
        if not os.path.exists(path_name):
            os.makedirs(path_name)
        urllib.request.urlretrieve(  # noqa: S310
            original_size_img, f""{path_name}/original_size_img_{index}.jpg""
        )
    return index",data\repos\Python\web_programming\download_images_from_google_query.py,download_images_from_google_query,679
2169,emails_from_url.py::get_domain_name::47,"def get_domain_name(url: str) -> str:
    """"""
    This function get the main domain name

    >>> get_domain_name(""https://a.b.c.d/e/f?g=h,i=j#k"")
    'c.d'
    >>> get_domain_name(""Not a URL!"")
    ''
    """"""
    return ""."".join(get_sub_domain_name(url).split(""."")[-2:])",data\repos\Python\web_programming\emails_from_url.py,get_domain_name,79
2170,emails_from_url.py::get_sub_domain_name::60,"def get_sub_domain_name(url: str) -> str:
    """"""
    >>> get_sub_domain_name(""https://a.b.c.d/e/f?g=h,i=j#k"")
    'a.b.c.d'
    >>> get_sub_domain_name(""Not a URL!"")
    ''
    """"""
    return parse.urlparse(url).netloc",data\repos\Python\web_programming\emails_from_url.py,get_sub_domain_name,68
2171,emails_from_url.py::emails_from_url::70,"def emails_from_url(url: str = ""https://github.com"") -> list[str]:
    """"""
    This function takes url and return all valid urls
    """"""
    # Get the base domain from the url
    domain = get_domain_name(url)

    # Initialize the parser
    parser = Parser(domain)

    try:
        # Open URL
        r = httpx.get(url, timeout=10, follow_redirects=True)

        # pass the raw HTML to the parser to get links
        parser.feed(r.text)

        # Get links and loop through
        valid_emails = set()
        for link in parser.urls:
            # open URL.
            # Check if the link is already absolute
            if not link.startswith(""http://"") and not link.startswith(""https://""):
                # Prepend protocol only if link starts with domain, normalize otherwise
                if link.startswith(domain):
                    link = f""https://{link}""
                else:
                    link = parse.urljoin(f""https://{domain}"", link)
            try:
                read = httpx.get(link, timeout=10, follow_redirects=True)
                # Get the valid email.
                emails = re.findall(""[a-zA-Z0-9]+@"" + domain, read.text)
                # If not in list then append it.
                for email in emails:
                    valid_emails.add(email)
            except ValueError:
                pass
    except ValueError:
        raise SystemExit(1)

    # Finally return a sorted list of email addresses with no duplicates.
    return sorted(valid_emails)",data\repos\Python\web_programming\emails_from_url.py,emails_from_url,312
2172,emails_from_url.py::handle_starttag::32,"    def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None:
        """"""
        This function parse html to take takes url from tags
        """"""
        # Only parse the 'anchor' tag.
        if tag == ""a"":
            # Check the list of defined attributes.
            for name, value in attrs:
                # If href is defined, not empty nor # print it and not already in urls.
                if name == ""href"" and value not in (*self.urls, """", ""#""):
                    url = parse.urljoin(self.domain, value)
                    self.urls.append(url)",data\repos\Python\web_programming\emails_from_url.py,handle_starttag,129
2173,fetch_anime_and_play.py::search_scraper::17,"def search_scraper(anime_name: str) -> list:
    """"""[summary]

    Take an url and
    return list of anime after scraping the site.

    >>> type(search_scraper(""demon_slayer""))
    <class 'list'>

    Args:
        anime_name (str): [Name of anime]

    Raises:
        e: [Raises exception on failure]

    Returns:
        [list]: [List of animes]
    """"""

    # concat the name to form the search url.
    search_url = f""{BASE_URL}/search?keyword={anime_name}""

    response = httpx.get(
        search_url, headers={""UserAgent"": UserAgent().chrome}, timeout=10
    )  # request the url.

    # Is the response ok?
    response.raise_for_status()

    # parse with soup.
    soup = BeautifulSoup(response.text, ""html.parser"")

    # get list of anime
    anime_ul = soup.find(""ul"", {""class"": ""items""})
    if anime_ul is None or isinstance(anime_ul, NavigableString):
        msg = f""Could not find and anime with name {anime_name}""
        raise ValueError(msg)
    anime_li = anime_ul.children

    # for each anime, insert to list. the name and url.
    anime_list = []
    for anime in anime_li:
        if isinstance(anime, Tag):
            anime_url = anime.find(""a"")
            if anime_url is None or isinstance(anime_url, NavigableString):
                continue
            anime_title = anime.find(""a"")
            if anime_title is None or isinstance(anime_title, NavigableString):
                continue

            anime_list.append({""title"": anime_title[""title""], ""url"": anime_url[""href""]})

    return anime_list",data\repos\Python\web_programming\fetch_anime_and_play.py,search_scraper,369
2174,fetch_anime_and_play.py::search_anime_episode_list::72,"def search_anime_episode_list(episode_endpoint: str) -> list:
    """"""[summary]

    Take an url and
    return list of episodes after scraping the site
    for an url.

    >>> type(search_anime_episode_list(""/anime/kimetsu-no-yaiba""))
    <class 'list'>

    Args:
        episode_endpoint (str): [Endpoint of episode]

    Raises:
        e: [description]

    Returns:
        [list]: [List of episodes]
    """"""

    request_url = f""{BASE_URL}{episode_endpoint}""

    response = httpx.get(
        url=request_url, headers={""UserAgent"": UserAgent().chrome}, timeout=10
    )
    response.raise_for_status()

    soup = BeautifulSoup(response.text, ""html.parser"")

    # With this id. get the episode list.
    episode_page_ul = soup.find(""ul"", {""id"": ""episode_related""})
    if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):
        msg = f""Could not find any anime eposiodes with name {anime_name}""
        raise ValueError(msg)
    episode_page_li = episode_page_ul.children

    episode_list = []
    for episode in episode_page_li:
        if isinstance(episode, Tag):
            url = episode.find(""a"")
            if url is None or isinstance(url, NavigableString):
                continue
            title = episode.find(""div"", {""class"": ""name""})
            if title is None or isinstance(title, NavigableString):
                continue

            episode_list.append(
                {""title"": title.text.replace("" "", """"), ""url"": url[""href""]}
            )

    return episode_list",data\repos\Python\web_programming\fetch_anime_and_play.py,search_anime_episode_list,347
2175,fetch_anime_and_play.py::get_anime_episode::125,"def get_anime_episode(episode_endpoint: str) -> list:
    """"""[summary]

    Get click url and download url from episode url

    >>> type(get_anime_episode(""/watch/kimetsu-no-yaiba/1""))
    <class 'list'>

    Args:
        episode_endpoint (str): [Endpoint of episode]

    Raises:
        e: [description]

    Returns:
        [list]: [List of download and watch url]
    """"""

    episode_page_url = f""{BASE_URL}{episode_endpoint}""

    response = httpx.get(
        url=episode_page_url, headers={""User-Agent"": UserAgent().chrome}, timeout=10
    )
    response.raise_for_status()

    soup = BeautifulSoup(response.text, ""html.parser"")

    url = soup.find(""iframe"", {""id"": ""playerframe""})
    if url is None or isinstance(url, NavigableString):
        msg = f""Could not find url and download url from {episode_endpoint}""
        raise RuntimeError(msg)

    episode_url = url[""src""]
    if not isinstance(episode_url, str):
        msg = f""Could not find url and download url from {episode_endpoint}""
        raise RuntimeError(msg)
    download_url = episode_url.replace(""/embed/"", ""/playlist/"") + "".m3u8""

    return [f""{BASE_URL}{episode_url}"", f""{BASE_URL}{download_url}""]",data\repos\Python\web_programming\fetch_anime_and_play.py,get_anime_episode,287
2176,fetch_bbc_news.py::fetch_bbc_news::15,"def fetch_bbc_news(bbc_news_api_key: str) -> None:
    # fetching a list of articles in json format
    bbc_news_page = httpx.get(_NEWS_API + bbc_news_api_key, timeout=10).json()
    # each article in the list is a dict
    for i, article in enumerate(bbc_news_page[""articles""], 1):
        print(f""{i}.) {article['title']}"")",data\repos\Python\web_programming\fetch_bbc_news.py,fetch_bbc_news,91
2177,fetch_github_info.py::fetch_github_info::44,"def fetch_github_info(auth_token: str) -> dict[Any, Any]:
    """"""
    Fetch GitHub info of a user using the httpx module
    """"""
    headers = {
        ""Authorization"": f""token {auth_token}"",
        ""Accept"": ""application/vnd.github.v3+json"",
    }
    return httpx.get(AUTHENTICATED_USER_ENDPOINT, headers=headers, timeout=10).json()",data\repos\Python\web_programming\fetch_github_info.py,fetch_github_info,84
2178,fetch_jobs.py::fetch_jobs::23,"def fetch_jobs(location: str = ""mumbai"") -> Generator[tuple[str, str]]:
    soup = BeautifulSoup(httpx.get(url + location, timeout=10).content, ""html.parser"")
    # This attribute finds out all the specifics listed in a job
    for job in soup.find_all(""div"", attrs={""data-tn-component"": ""organicJob""}):
        job_title = job.find(""a"", attrs={""data-tn-element"": ""jobTitle""}).text.strip()
        company_name = job.find(""span"", {""class"": ""company""}).text.strip()
        yield job_title, company_name",data\repos\Python\web_programming\fetch_jobs.py,fetch_jobs,126
2179,fetch_well_rx_price.py::fetch_pharmacy_and_price_list::14,"def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:
    """"""[summary]

    This function will take input of drug name and zipcode,
    then request to the BASE_URL site.
    Get the page data and scrape it to generate the
    list of the lowest prices for the prescription drug.

    Args:
        drug_name (str): [Drug name]
        zip_code(str): [Zip code]

    Returns:
        list: [List of pharmacy name and price]

    >>> print(fetch_pharmacy_and_price_list(None, None))
    None
    >>> print(fetch_pharmacy_and_price_list(None, 30303))
    None
    >>> print(fetch_pharmacy_and_price_list(""eliquis"", None))
    None
    """"""

    try:
        # Has user provided both inputs?
        if not drug_name or not zip_code:
            return None

        request_url = BASE_URL.format(drug_name, zip_code)
        response = httpx.get(request_url, timeout=10).raise_for_status()

        # Scrape the data using bs4
        soup = BeautifulSoup(response.text, ""html.parser"")

        # This list will store the name and price.
        pharmacy_price_list = []

        # Fetch all the grids that contain the items.
        grid_list = soup.find_all(""div"", {""class"": ""grid-x pharmCard""})
        if grid_list and len(grid_list) > 0:
            for grid in grid_list:
                # Get the pharmacy price.
                pharmacy_name = grid.find(""p"", {""class"": ""list-title""}).text

                # Get the price of the drug.
                price = grid.find(""span"", {""p"", ""price price-large""}).text

                pharmacy_price_list.append(
                    {
                        ""pharmacy_name"": pharmacy_name,
                        ""price"": price,
                    }
                )

        return pharmacy_price_list

    except (httpx.HTTPError, ValueError):
        return None",data\repos\Python\web_programming\fetch_well_rx_price.py,fetch_pharmacy_and_price_list,407
2180,get_amazon_product_data.py::get_amazon_product_data::23,"def get_amazon_product_data(product: str = ""laptop"") -> DataFrame:
    """"""
    Take a product name or category as input and return product information from Amazon
    including title, URL, price, ratings, and the discount available.
    """"""
    url = f""https://www.amazon.in/laptop/s?k={product}""
    header = {
        ""User-Agent"": (
            ""Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36""
            ""(KHTML, like Gecko)Chrome/44.0.2403.157 Safari/537.36""
        ),
        ""Accept-Language"": ""en-US, en;q=0.5"",
    }
    soup = BeautifulSoup(
        httpx.get(url, headers=header, timeout=10).text, features=""lxml""
    )
    # Initialize a Pandas dataframe with the column titles
    data_frame = DataFrame(
        columns=[
            ""Product Title"",
            ""Product Link"",
            ""Current Price of the product"",
            ""Product Rating"",
            ""MRP of the product"",
            ""Discount"",
        ]
    )
    # Loop through each entry and store them in the dataframe
    for item, _ in zip_longest(
        soup.find_all(
            ""div"",
            attrs={""class"": ""s-result-item"", ""data-component-type"": ""s-search-result""},
        ),
        soup.find_all(""div"", attrs={""class"": ""a-row a-size-base a-color-base""}),
    ):
        try:
            product_title = item.h2.text
            product_link = ""https://www.amazon.in/"" + item.h2.a[""href""]
            product_price = item.find(""span"", attrs={""class"": ""a-offscreen""}).text
            try:
                product_rating = item.find(""span"", attrs={""class"": ""a-icon-alt""}).text
            except AttributeError:
                product_rating = ""Not available""
            try:
                product_mrp = (
                    """"
                    + item.find(
                        ""span"", attrs={""class"": ""a-price a-text-price""}
                    ).text.split("""")[1]
                )
            except AttributeError:
                product_mrp = """"
            try:
                discount = float(
                    (
                        (
                            float(product_mrp.strip("""").replace("","", """"))
                            - float(product_price.strip("""").replace("","", """"))
                        )
                        / float(product_mrp.strip("""").replace("","", """"))
                    )
                    * 100
                )
            except ValueError:
                discount = float(""nan"")
        except AttributeError:
            continue
        data_frame.loc[str(len(data_frame.index))] = [
            product_title,
            product_link,
            product_price,
            product_rating,
            product_mrp,
            discount,
        ]
    data_frame.loc[
        data_frame[""Current Price of the product""] > data_frame[""MRP of the product""],
        ""MRP of the product"",
    ] = "" ""
    data_frame.loc[
        data_frame[""Current Price of the product""] > data_frame[""MRP of the product""],
        ""Discount"",
    ] = "" ""
    data_frame.index += 1
    return data_frame",data\repos\Python\web_programming\get_amazon_product_data.py,get_amazon_product_data,657
2181,get_imdb_top_250_movies_csv.py::get_imdb_top_250_movies::17,"def get_imdb_top_250_movies(url: str = """") -> dict[str, float]:
    url = url or ""https://www.imdb.com/chart/top/?ref_=nv_mv_250""
    soup = BeautifulSoup(httpx.get(url, timeout=10).text, ""html.parser"")
    titles = soup.find_all(""h3"", class_=""ipc-title__text"")
    ratings = soup.find_all(""span"", class_=""ipc-rating-star--rating"")
    return {
        title.a.text: float(rating.strong.text)
        for title, rating in zip(titles, ratings)
    }",data\repos\Python\web_programming\get_imdb_top_250_movies_csv.py,get_imdb_top_250_movies,125
2182,get_imdb_top_250_movies_csv.py::write_movies::28,"def write_movies(filename: str = ""IMDb_Top_250_Movies.csv"") -> None:
    movies = get_imdb_top_250_movies()
    with open(filename, ""w"", newline="""") as out_file:
        writer = csv.writer(out_file)
        writer.writerow([""Movie title"", ""IMDb rating""])
        for title, rating in movies.items():
            writer.writerow([title, rating])",data\repos\Python\web_programming\get_imdb_top_250_movies_csv.py,write_movies,83
2183,get_ip_geolocation.py::get_ip_geolocation::12,"def get_ip_geolocation(ip_address: str) -> str:
    try:
        # Construct the URL for the IP geolocation API
        url = f""https://ipinfo.io/{ip_address}/json""

        # Send a GET request to the API
        response = httpx.get(url, timeout=10)

        # Check if the HTTP request was successful
        response.raise_for_status()

        # Parse the response as JSON
        data = response.json()

        # Check if city, region, and country information is available
        if ""city"" in data and ""region"" in data and ""country"" in data:
            location = f""Location: {data['city']}, {data['region']}, {data['country']}""
        else:
            location = ""Location data not found.""

        return location
    except httpx.RequestError as e:
        # Handle network-related exceptions
        return f""Request error: {e}""
    except ValueError as e:
        # Handle JSON parsing errors
        return f""JSON parsing error: {e}""",data\repos\Python\web_programming\get_ip_geolocation.py,get_ip_geolocation,220
2184,get_top_billionaires.py::years_old::30,"def years_old(birth_timestamp: int, today: date | None = None) -> int:
    """"""
    Calculate the age in years based on the given birth date.  Only the year, month,
    and day are used in the calculation.  The time of day is ignored.

    Args:
        birth_timestamp: The date of birth.
        today: (useful for writing tests) or if None then datetime.date.today().

    Returns:
        int: The age in years.

    Examples:
    >>> today = date(2024, 1, 12)
    >>> years_old(birth_timestamp=datetime(1959, 11, 20).timestamp(), today=today)
    64
    >>> years_old(birth_timestamp=datetime(1970, 2, 13).timestamp(), today=today)
    53
    >>> all(
    ...     years_old(datetime(today.year - i, 1, 12).timestamp(), today=today) == i
    ...     for i in range(1, 111)
    ... )
    True
    """"""
    today = today or TODAY.date()
    birth_date = datetime.fromtimestamp(birth_timestamp, tz=UTC).date()
    return (today.year - birth_date.year) - (
        (today.month, today.day) < (birth_date.month, birth_date.day)
    )",data\repos\Python\web_programming\get_top_billionaires.py,years_old,283
2185,get_top_billionaires.py::get_forbes_real_time_billionaires::61,"def get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:
    """"""
    Get the top 10 real-time billionaires using Forbes API.

    Returns:
        List of top 10 realtime billionaires data.
    """"""
    response_json = httpx.get(API_URL, timeout=10).json()
    return [
        {
            ""Name"": person[""personName""],
            ""Source"": person[""source""],
            ""Country"": person[""countryOfCitizenship""],
            ""Gender"": person[""gender""],
            ""Worth ($)"": f""{person['finalWorth'] / 1000:.1f} Billion"",
            ""Age"": str(years_old(person[""birthDate""] / 1000)),
        }
        for person in response_json[""personList""][""personsLists""]
    ]",data\repos\Python\web_programming\get_top_billionaires.py,get_forbes_real_time_billionaires,167
2186,get_top_billionaires.py::display_billionaires::82,"def display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:
    """"""
    Display Forbes real-time billionaires in a rich table.

    Args:
        forbes_billionaires (list): Forbes top 10 real-time billionaires
    """"""

    table = rich_table.Table(
        title=f""Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}"",
        style=""green"",
        highlight=True,
        box=box.SQUARE,
    )
    for key in forbes_billionaires[0]:
        table.add_column(key)

    for billionaire in forbes_billionaires:
        table.add_row(*billionaire.values())

    rich_console.Console().print(table)",data\repos\Python\web_programming\get_top_billionaires.py,display_billionaires,158
2187,get_top_hn_posts.py::get_hackernews_story::13,"def get_hackernews_story(story_id: str) -> dict:
    url = f""https://hacker-news.firebaseio.com/v0/item/{story_id}.json?print=pretty""
    return httpx.get(url, timeout=10).json()",data\repos\Python\web_programming\get_top_hn_posts.py,get_hackernews_story,52
2188,get_top_hn_posts.py::hackernews_top_stories::18,"def hackernews_top_stories(max_stories: int = 10) -> list[dict]:
    """"""
    Get the top max_stories posts from HackerNews - https://news.ycombinator.com/
    """"""
    url = ""https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty""
    story_ids = httpx.get(url, timeout=10).json()[:max_stories]
    return [get_hackernews_story(story_id) for story_id in story_ids]",data\repos\Python\web_programming\get_top_hn_posts.py,hackernews_top_stories,105
2189,get_top_hn_posts.py::hackernews_top_stories_as_markdown::27,"def hackernews_top_stories_as_markdown(max_stories: int = 10) -> str:
    stories = hackernews_top_stories(max_stories)
    return ""\n"".join(""* [{title}]({url})"".format(**story) for story in stories)",data\repos\Python\web_programming\get_top_hn_posts.py,hackernews_top_stories_as_markdown,56
2190,giphy.py::get_gifs::16,"def get_gifs(query: str, api_key: str = giphy_api_key) -> list:
    """"""
    Get a list of URLs of GIFs based on a given query..
    """"""
    formatted_query = ""+"".join(query.split())
    url = f""https://api.giphy.com/v1/gifs/search?q={formatted_query}&api_key={api_key}""
    gifs = httpx.get(url, timeout=10).json()[""data""]
    return [gif[""url""] for gif in gifs]",data\repos\Python\web_programming\giphy.py,get_gifs,104
2191,instagram_crawler.py::extract_user_profile::23,"def extract_user_profile(script) -> dict:
    """"""
    May raise json.decoder.JSONDecodeError
    """"""
    data = script.contents[0]
    info = json.loads(data[data.find('{""config""') : -1])
    return info[""entry_data""][""ProfilePage""][0][""graphql""][""user""]",data\repos\Python\web_programming\instagram_crawler.py,extract_user_profile,63
2192,instagram_crawler.py::test_instagram_user::110,"def test_instagram_user(username: str = ""github"") -> None:
    """"""
    A self running doctest
    >>> test_instagram_user()
    """"""
    import os

    if os.environ.get(""CI""):
        return  # test failing on GitHub Actions
    instagram_user = InstagramUser(username)
    assert instagram_user.user_data
    assert isinstance(instagram_user.user_data, dict)
    assert instagram_user.username == username
    if username != ""github"":
        return
    assert instagram_user.fullname == ""GitHub""
    assert instagram_user.biography == ""Built for developers.""
    assert instagram_user.number_of_posts > 150
    assert instagram_user.number_of_followers > 120000
    assert instagram_user.number_of_followings > 15
    assert instagram_user.email == ""support@github.com""
    assert instagram_user.website == ""https://github.com/readme""
    assert instagram_user.profile_picture_url.startswith(""https://instagram."")
    assert instagram_user.is_verified is True
    assert instagram_user.is_private is False",data\repos\Python\web_programming\instagram_crawler.py,test_instagram_user,213
2193,instagram_crawler.py::get_json::48,"    def get_json(self) -> dict:
        """"""
        Return a dict of user information
        """"""
        html = httpx.get(self.url, headers=headers, timeout=10).text
        scripts = BeautifulSoup(html, ""html.parser"").find_all(""script"")
        try:
            return extract_user_profile(scripts[4])
        except (json.decoder.JSONDecodeError, KeyError):
            return extract_user_profile(scripts[3])",data\repos\Python\web_programming\instagram_crawler.py,get_json,88
2194,instagram_pic.py::download_image::15,"def download_image(url: str) -> str:
    """"""
    Download an image from a given URL by scraping the 'og:image' meta tag.

    Parameters:
        url: The URL to scrape.

    Returns:
        A message indicating the result of the operation.
    """"""
    try:
        response = httpx.get(url, timeout=10)
        response.raise_for_status()
    except httpx.RequestError as e:
        return f""An error occurred during the HTTP request to {url}: {e!r}""

    soup = BeautifulSoup(response.text, ""html.parser"")
    image_meta_tag = soup.find(""meta"", {""property"": ""og:image""})
    if not image_meta_tag:
        return ""No meta tag with property 'og:image' was found.""

    image_url = image_meta_tag.get(""content"")
    if not image_url:
        return f""Image URL not found in meta tag {image_meta_tag}.""

    try:
        image_data = httpx.get(image_url, timeout=10).content
    except httpx.RequestError as e:
        return f""An error occurred during the HTTP request to {image_url}: {e!r}""
    if not image_data:
        return f""Failed to download the image from {image_url}.""

    file_name = f""{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg""
    with open(file_name, ""wb"") as out_file:
        out_file.write(image_data)
    return f""Image downloaded and saved in the file {file_name}""",data\repos\Python\web_programming\instagram_pic.py,download_image,327
2195,instagram_video.py::download_video::13,"def download_video(url: str) -> bytes:
    base_url = ""https://downloadgram.net/wp-json/wppress/video-downloader/video?url=""
    video_url = httpx.get(base_url + url, timeout=10)
    return httpx.get(video_url, timeout=10).content",data\repos\Python\web_programming\instagram_video.py,download_video,60
2196,nasa_data.py::get_apod_data::11,"def get_apod_data(api_key: str) -> dict:
    """"""
    Get the APOD(Astronomical Picture of the day) data
    Get your API Key from: https://api.nasa.gov/
    """"""
    url = ""https://api.nasa.gov/planetary/apod""
    return httpx.get(url, params={""api_key"": api_key}, timeout=10).json()",data\repos\Python\web_programming\nasa_data.py,get_apod_data,83
2197,nasa_data.py::save_apod::20,"def save_apod(api_key: str, path: str = ""."") -> dict:
    apod_data = get_apod_data(api_key)
    img_url = apod_data[""url""]
    img_name = img_url.split(""/"")[-1]
    response = httpx.get(img_url, timeout=10)

    with open(f""{path}/{img_name}"", ""wb+"") as img_file:
        img_file.write(response.content)
    del response
    return apod_data",data\repos\Python\web_programming\nasa_data.py,save_apod,97
2198,nasa_data.py::get_archive_data::32,"def get_archive_data(query: str) -> dict:
    """"""
    Get the data of a particular query from NASA archives
    """"""
    url = ""https://images-api.nasa.gov/search""
    return httpx.get(url, params={""q"": query}, timeout=10).json()",data\repos\Python\web_programming\nasa_data.py,get_archive_data,58
2199,random_anime_character.py::save_image::20,"def save_image(image_url: str, image_title: str) -> None:
    """"""
    Saves the image of anime character
    """"""
    image = httpx.get(image_url, headers=headers, timeout=10)
    with open(image_title, ""wb"") as file:
        file.write(image.content)",data\repos\Python\web_programming\random_anime_character.py,save_image,62
2200,random_anime_character.py::random_anime_character::29,"def random_anime_character() -> tuple[str, str, str]:
    """"""
    Returns the Title, Description, and Image Title of a random anime character .
    """"""
    soup = BeautifulSoup(
        httpx.get(URL, headers=headers, timeout=10).text, ""html.parser""
    )
    title = soup.find(""meta"", attrs={""property"": ""og:title""}).attrs[""content""]
    image_url = soup.find(""meta"", attrs={""property"": ""og:image""}).attrs[""content""]
    description = soup.find(""p"", id=""description"").get_text()
    _, image_extension = os.path.splitext(os.path.basename(image_url))
    image_title = title.strip().replace("" "", ""_"")
    image_title = f""{image_title}{image_extension}""
    save_image(image_url, image_title)
    return (title, description, image_title)",data\repos\Python\web_programming\random_anime_character.py,random_anime_character,175
2201,recaptcha_verification.py::login_using_recaptcha::51,"def login_using_recaptcha(request):
    # Enter your recaptcha secret key here
    secret_key = ""secretKey""  # noqa: S105
    url = ""https://www.google.com/recaptcha/api/siteverify""

    # when method is not POST, direct user to login page
    if request.method != ""POST"":
        return render(request, ""login.html"")

    # from the frontend, get username, password, and client_key
    username = request.POST.get(""username"")
    password = request.POST.get(""password"")
    client_key = request.POST.get(""g-recaptcha-response"")

    # post recaptcha response to Google's recaptcha api
    response = httpx.post(
        url, data={""secret"": secret_key, ""response"": client_key}, timeout=10
    )
    # if the recaptcha api verified our keys
    if response.json().get(""success"", False):
        # authenticate the user
        user_in_database = authenticate(request, username=username, password=password)
        if user_in_database:
            login(request, user_in_database)
            return redirect(""/your-webpage"")
    return render(request, ""login.html"")",data\repos\Python\web_programming\recaptcha_verification.py,login_using_recaptcha,239
2202,reddit.py::get_subreddit_data::25,"def get_subreddit_data(
    subreddit: str, limit: int = 1, age: str = ""new"", wanted_data: list | None = None
) -> dict:
    """"""
    subreddit : Subreddit to query
    limit : Number of posts to fetch
    age : [""new"", ""top"", ""hot""]
    wanted_data : Get only the required data in the list
    """"""
    wanted_data = wanted_data or []
    if invalid_search_terms := "", "".join(sorted(set(wanted_data) - valid_terms)):
        msg = f""Invalid search term: {invalid_search_terms}""
        raise ValueError(msg)
    response = httpx.get(
        f""https://www.reddit.com/r/{subreddit}/{age}.json?limit={limit}"",
        headers={""User-agent"": ""A random string""},
        timeout=10,
    )
    response.raise_for_status()
    if response.status_code == 429:
        raise httpx.HTTPError(response=response)

    data = response.json()
    if not wanted_data:
        return {id_: data[""data""][""children""][id_] for id_ in range(limit)}

    data_dict = {}
    for id_ in range(limit):
        data_dict[id_] = {
            item: data[""data""][""children""][id_][""data""][item] for item in wanted_data
        }
    return data_dict",data\repos\Python\web_programming\reddit.py,get_subreddit_data,279
2203,search_books_by_isbn.py::get_openlibrary_data::19,"def get_openlibrary_data(olid: str = ""isbn/0140328726"") -> dict:
    """"""
    Given an 'isbn/0140328726', return book data from Open Library as a Python dict.
    Given an '/authors/OL34184A', return authors data as a Python dict.
    This code must work for olids with or without a leading slash ('/').

    # Comment out doctests if they take too long or have results that may change
    # >>> get_openlibrary_data(olid='isbn/0140328726')  # doctest: +ELLIPSIS
    {'publishers': ['Puffin'], 'number_of_pages': 96, 'isbn_10': ['0140328726'], ...
    # >>> get_openlibrary_data(olid='/authors/OL7353617A')  # doctest: +ELLIPSIS
    {'name': 'Adrian Brisku', 'created': {'type': '/type/datetime', ...
    """"""
    new_olid = olid.strip().strip(""/"")  # Remove leading/trailing whitespace & slashes
    if new_olid.count(""/"") != 1:
        msg = f""{olid} is not a valid Open Library olid""
        raise ValueError(msg)
    return httpx.get(
        f""https://openlibrary.org/{new_olid}.json"", timeout=10, follow_redirects=True
    ).json()",data\repos\Python\web_programming\search_books_by_isbn.py,get_openlibrary_data,296
2204,search_books_by_isbn.py::summarize_book::40,"def summarize_book(ol_book_data: dict) -> dict:
    """"""
    Given Open Library book data, return a summary as a Python dict.
    """"""
    desired_keys = {
        ""title"": ""Title"",
        ""publish_date"": ""Publish date"",
        ""authors"": ""Authors"",
        ""number_of_pages"": ""Number of pages"",
        ""isbn_10"": ""ISBN (10)"",
        ""isbn_13"": ""ISBN (13)"",
    }
    data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}
    data[""Authors""] = [
        get_openlibrary_data(author[""key""])[""name""] for author in data[""Authors""]
    ]
    for key, value in data.items():
        if isinstance(value, list):
            data[key] = "", "".join(value)
    return data",data\repos\Python\web_programming\search_books_by_isbn.py,summarize_book,174
2205,slack_message.py::send_slack_message::13,"def send_slack_message(message_body: str, slack_url: str) -> None:
    headers = {""Content-Type"": ""application/json""}
    response = httpx.post(
        slack_url, json={""text"": message_body}, headers=headers, timeout=10
    )
    if response.status_code != 200:
        msg = (
            ""Request to slack returned an error ""
            f""{response.status_code}, the response is:\n{response.text}""
        )
        raise ValueError(msg)",data\repos\Python\web_programming\slack_message.py,send_slack_message,101
2206,test_fetch_github_info.py::test_fetch_github_info::8,"def test_fetch_github_info(monkeypatch):
    class FakeResponse:
        def __init__(self, content) -> None:
            assert isinstance(content, (bytes, str))
            self.content = content

        def json(self):
            return json.loads(self.content)

    def mock_response(*args, **kwargs):
        assert args[0] == AUTHENTICATED_USER_ENDPOINT
        assert ""Authorization"" in kwargs[""headers""]
        assert kwargs[""headers""][""Authorization""].startswith(""token "")
        assert ""Accept"" in kwargs[""headers""]
        return FakeResponse(b'{""login"":""test"",""id"":1}')

    monkeypatch.setattr(httpx, ""get"", mock_response)
    result = fetch_github_info(""token"")
    assert result[""login""] == ""test""
    assert result[""id""] == 1",data\repos\Python\web_programming\test_fetch_github_info.py,test_fetch_github_info,168
2207,test_fetch_github_info.py::mock_response::17,"    def mock_response(*args, **kwargs):
        assert args[0] == AUTHENTICATED_USER_ENDPOINT
        assert ""Authorization"" in kwargs[""headers""]
        assert kwargs[""headers""][""Authorization""].startswith(""token "")
        assert ""Accept"" in kwargs[""headers""]
        return FakeResponse(b'{""login"":""test"",""id"":1}')",data\repos\Python\web_programming\test_fetch_github_info.py,mock_response,70
2208,world_covid19_stats.py::world_covid19_stats::20,"def world_covid19_stats(
    url: str = ""https://www.worldometers.info/coronavirus/"",
) -> dict:
    """"""
    Return a dict of current worldwide COVID-19 statistics
    """"""
    soup = BeautifulSoup(
        httpx.get(url, timeout=10, follow_redirects=True).text, ""html.parser""
    )
    keys = soup.find_all(""h1"")
    values = soup.find_all(""div"", {""class"": ""maincounter-number""})
    keys += soup.find_all(""span"", {""class"": ""panel-title""})
    values += soup.find_all(""div"", {""class"": ""number-table-main""})
    return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}",data\repos\Python\web_programming\world_covid19_stats.py,world_covid19_stats,152
2209,sol1.py::solution::13,"def solution(n: int = 1000) -> int:
    """"""
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    >>> solution(-7)
    0
    """"""

    return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)",data\repos\Python\project_euler\problem_001\sol1.py,solution,115
2210,sol2.py::solution::13,"def solution(n: int = 1000) -> int:
    """"""
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """"""

    total = 0
    terms = (n - 1) // 3
    total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.
    terms = (n - 1) // 5
    total += ((terms) * (10 + (terms - 1) * 5)) // 2
    terms = (n - 1) // 15
    total -= ((terms) * (30 + (terms - 1) * 15)) // 2
    return total",data\repos\Python\project_euler\problem_001\sol2.py,solution,202
2211,sol3.py::solution::13,"def solution(n: int = 1000) -> int:
    """"""
    This solution is based on the pattern that the successive numbers in the
    series follow: 0+3,+2,+1,+3,+1,+2,+3.
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """"""

    total = 0
    num = 0
    while 1:
        num += 3
        if num >= n:
            break
        total += num
        num += 2
        if num >= n:
            break
        total += num
        num += 1
        if num >= n:
            break
        total += num
        num += 3
        if num >= n:
            break
        total += num
        num += 1
        if num >= n:
            break
        total += num
        num += 2
        if num >= n:
            break
        total += num
        num += 3
        if num >= n:
            break
        total += num
    return total",data\repos\Python\project_euler\problem_001\sol3.py,solution,271
2212,sol4.py::solution::13,"def solution(n: int = 1000) -> int:
    """"""
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """"""

    xmulti = []
    zmulti = []
    z = 3
    x = 5
    temp = 1
    while True:
        result = z * temp
        if result < n:
            zmulti.append(result)
            temp += 1
        else:
            temp = 1
            break
    while True:
        result = x * temp
        if result < n:
            xmulti.append(result)
            temp += 1
        else:
            break
    collection = list(set(xmulti + zmulti))
    return sum(collection)",data\repos\Python\project_euler\problem_001\sol4.py,solution,195
2213,sol5.py::solution::13,"def solution(n: int = 1000) -> int:
    """"""
    Returns the sum of all the multiples of 3 or 5 below n.
    A straightforward pythonic solution using list comprehension.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """"""

    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)",data\repos\Python\project_euler\problem_001\sol5.py,solution,112
2214,sol6.py::solution::13,"def solution(n: int = 1000) -> int:
    """"""
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """"""

    a = 3
    result = 0
    while a < n:
        if a % 3 == 0 or a % 5 == 0:
            result += a
        elif a % 15 == 0:
            result -= a
        a += 1
    return result",data\repos\Python\project_euler\problem_001\sol6.py,solution,140
2215,sol7.py::solution::13,"def solution(n: int = 1000) -> int:
    """"""
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """"""

    result = 0
    for i in range(n):
        if i % 3 == 0 or i % 5 == 0:
            result += i
    return result",data\repos\Python\project_euler\problem_001\sol7.py,solution,114
2216,sol1.py::solution::19,"def solution(n: int = 4000000) -> int:
    """"""
    Returns the sum of all even fibonacci sequence elements that are lower
    or equal to n.

    >>> solution(10)
    10
    >>> solution(15)
    10
    >>> solution(2)
    2
    >>> solution(1)
    0
    >>> solution(34)
    44
    """"""

    i = 1
    j = 2
    total = 0
    while j <= n:
        if j % 2 == 0:
            total += j
        i, j = j, i + j

    return total",data\repos\Python\project_euler\problem_002\sol1.py,solution,141
2217,sol2.py::solution::19,"def solution(n: int = 4000000) -> int:
    """"""
    Returns the sum of all even fibonacci sequence elements that are lower
    or equal to n.

    >>> solution(10)
    10
    >>> solution(15)
    10
    >>> solution(2)
    2
    >>> solution(1)
    0
    >>> solution(34)
    44
    """"""

    even_fibs = []
    a, b = 0, 1
    while b <= n:
        if b % 2 == 0:
            even_fibs.append(b)
        a, b = b, a + b
    return sum(even_fibs)",data\repos\Python\project_euler\problem_002\sol2.py,solution,147
2218,sol3.py::solution::19,"def solution(n: int = 4000000) -> int:
    """"""
    Returns the sum of all even fibonacci sequence elements that are lower
    or equal to n.

    >>> solution(10)
    10
    >>> solution(15)
    10
    >>> solution(2)
    2
    >>> solution(1)
    0
    >>> solution(34)
    44
    """"""

    if n <= 1:
        return 0
    a = 0
    b = 2
    count = 0
    while 4 * b + a <= n:
        a, b = b, 4 * b + a
        count += a
    return count + b",data\repos\Python\project_euler\problem_002\sol3.py,solution,153
2219,sol4.py::solution::22,"def solution(n: int = 4000000) -> int:
    """"""
    Returns the sum of all even fibonacci sequence elements that are lower
    or equal to n.

    >>> solution(10)
    10
    >>> solution(15)
    10
    >>> solution(2)
    2
    >>> solution(1)
    0
    >>> solution(34)
    44
    >>> solution(3.4)
    2
    >>> solution(0)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution(-17)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution([])
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    >>> solution(""asd"")
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    """"""

    try:
        n = int(n)
    except (TypeError, ValueError):
        raise TypeError(""Parameter n must be int or castable to int."")
    if n <= 0:
        raise ValueError(""Parameter n must be greater than or equal to one."")
    getcontext().prec = 100
    phi = (Decimal(5) ** Decimal(""0.5"") + 1) / Decimal(2)

    index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2
    num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)
    total = num // 2
    return int(total)",data\repos\Python\project_euler\problem_002\sol4.py,solution,374
2220,sol5.py::solution::19,"def solution(n: int = 4000000) -> int:
    """"""
    Returns the sum of all even fibonacci sequence elements that are lower
    or equal to n.

    >>> solution(10)
    10
    >>> solution(15)
    10
    >>> solution(2)
    2
    >>> solution(1)
    0
    >>> solution(34)
    44
    """"""

    fib = [0, 1]
    i = 0
    while fib[i] <= n:
        fib.append(fib[i] + fib[i + 1])
        if fib[i + 2] > n:
            break
        i += 1
    total = 0
    for j in range(len(fib) - 1):
        if fib[j] % 2 == 0:
            total += fib[j]

    return total",data\repos\Python\project_euler\problem_002\sol5.py,solution,185
2221,sol1.py::is_prime::17,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).
    A number is prime if it has exactly two factors: 1 and itself.
    Returns boolean representing primality of given number (i.e., if the
    result is true, then the number is indeed prime else it is not).

    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(2999)
    True
    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_003\sol1.py,is_prime,277
2222,sol1.py::solution::51,"def solution(n: int = 600851475143) -> int:
    """"""
    Returns the largest prime factor of a given number n.

    >>> solution(13195)
    29
    >>> solution(10)
    5
    >>> solution(17)
    17
    >>> solution(3.4)
    3
    >>> solution(0)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution(-17)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution([])
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    >>> solution(""asd"")
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    """"""

    try:
        n = int(n)
    except (TypeError, ValueError):
        raise TypeError(""Parameter n must be int or castable to int."")
    if n <= 0:
        raise ValueError(""Parameter n must be greater than or equal to one."")
    max_number = 0
    if is_prime(n):
        return n
    while n % 2 == 0:
        n //= 2
    if is_prime(n):
        return n
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            if is_prime(n // i):
                max_number = n // i
                break
            elif is_prime(i):
                max_number = i
    return max_number",data\repos\Python\project_euler\problem_003\sol1.py,solution,356
2223,sol2.py::solution::15,"def solution(n: int = 600851475143) -> int:
    """"""
    Returns the largest prime factor of a given number n.

    >>> solution(13195)
    29
    >>> solution(10)
    5
    >>> solution(17)
    17
    >>> solution(3.4)
    3
    >>> solution(0)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution(-17)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution([])
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    >>> solution(""asd"")
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    """"""

    try:
        n = int(n)
    except (TypeError, ValueError):
        raise TypeError(""Parameter n must be int or castable to int."")
    if n <= 0:
        raise ValueError(""Parameter n must be greater than or equal to one."")
    prime = 1
    i = 2
    while i * i <= n:
        while n % i == 0:
            prime = i
            n //= i
        i += 1
    if n > 1:
        prime = n
    return int(prime)",data\repos\Python\project_euler\problem_003\sol2.py,solution,312
2224,sol3.py::solution::15,"def solution(n: int = 600851475143) -> int:
    """"""
    Returns the largest prime factor of a given number n.

    >>> solution(13195)
    29
    >>> solution(10)
    5
    >>> solution(17)
    17
    >>> solution(3.4)
    3
    >>> solution(0)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution(-17)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution([])
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    >>> solution(""asd"")
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    """"""

    try:
        n = int(n)
    except (TypeError, ValueError):
        raise TypeError(""Parameter n must be int or castable to int."")
    if n <= 0:
        raise ValueError(""Parameter n must be greater than or equal to one."")
    i = 2
    ans = 0
    if n == 2:
        return 2
    while n > 2:
        while n % i != 0:
            i += 1
        ans = i
        while n % i == 0:
            n = n // i
        i += 1
    return int(ans)",data\repos\Python\project_euler\problem_003\sol3.py,solution,327
2225,sol1.py::solution::16,"def solution(n: int = 998001) -> int:
    """"""
    Returns the largest palindrome made from the product of two 3-digit
    numbers which is less than n.

    >>> solution(20000)
    19591
    >>> solution(30000)
    29992
    >>> solution(40000)
    39893
    >>> solution(10000)
    Traceback (most recent call last):
        ...
    ValueError: That number is larger than our acceptable range.
    """"""

    # fetches the next number
    for number in range(n - 1, 9999, -1):
        str_number = str(number)

        # checks whether 'str_number' is a palindrome.
        if str_number == str_number[::-1]:
            divisor = 999

            # if 'number' is a product of two 3-digit numbers
            # then number is the answer otherwise fetch next number.
            while divisor != 99:
                if (number % divisor == 0) and (len(str(number // divisor)) == 3.0):
                    return number
                divisor -= 1
    raise ValueError(""That number is larger than our acceptable range."")",data\repos\Python\project_euler\problem_004\sol1.py,solution,248
2226,sol2.py::solution::16,"def solution(n: int = 998001) -> int:
    """"""
    Returns the largest palindrome made from the product of two 3-digit
    numbers which is less than n.

    >>> solution(20000)
    19591
    >>> solution(30000)
    29992
    >>> solution(40000)
    39893
    """"""

    answer = 0
    for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100
        for j in range(999, 99, -1):
            product_string = str(i * j)
            if product_string == product_string[::-1] and i * j < n:
                answer = max(answer, i * j)
    return answer",data\repos\Python\project_euler\problem_004\sol2.py,solution,164
2227,sol1.py::solution::17,"def solution(n: int = 20) -> int:
    """"""
    Returns the smallest positive number that is evenly divisible (divisible
    with no remainder) by all of the numbers from 1 to n.

    >>> solution(10)
    2520
    >>> solution(15)
    360360
    >>> solution(22)
    232792560
    >>> solution(3.4)
    6
    >>> solution(0)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution(-17)
    Traceback (most recent call last):
        ...
    ValueError: Parameter n must be greater than or equal to one.
    >>> solution([])
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    >>> solution(""asd"")
    Traceback (most recent call last):
        ...
    TypeError: Parameter n must be int or castable to int.
    """"""

    try:
        n = int(n)
    except (TypeError, ValueError):
        raise TypeError(""Parameter n must be int or castable to int."")
    if n <= 0:
        raise ValueError(""Parameter n must be greater than or equal to one."")
    i = 0
    while 1:
        i += n * (n - 1)
        nfound = 0
        for j in range(2, n):
            if i % j != 0:
                nfound = 1
                break
        if nfound == 0:
            if i == 0:
                i = 1
            return i
    return None",data\repos\Python\project_euler\problem_005\sol1.py,solution,353
2228,sol2.py::lcm::21,"def lcm(x: int, y: int) -> int:
    """"""
    Least Common Multiple.

    Using the property that lcm(a, b) * greatest_common_divisor(a, b) = a*b

    >>> lcm(3, 15)
    15
    >>> lcm(1, 27)
    27
    >>> lcm(13, 27)
    351
    >>> lcm(64, 48)
    192
    """"""

    return (x * y) // greatest_common_divisor(x, y)",data\repos\Python\project_euler\problem_005\sol2.py,lcm,113
2229,sol2.py::solution::40,"def solution(n: int = 20) -> int:
    """"""
    Returns the smallest positive number that is evenly divisible (divisible
    with no remainder) by all of the numbers from 1 to n.

    >>> solution(10)
    2520
    >>> solution(15)
    360360
    >>> solution(22)
    232792560
    """"""

    g = 1
    for i in range(1, n + 1):
        g = lcm(g, i)
    return g",data\repos\Python\project_euler\problem_005\sol2.py,solution,110
2230,sol1.py::solution::20,"def solution(n: int = 100) -> int:
    """"""
    Returns the difference between the sum of the squares of the first n
    natural numbers and the square of the sum.

    >>> solution(10)
    2640
    >>> solution(15)
    13160
    >>> solution(20)
    41230
    >>> solution(50)
    1582700
    """"""

    sum_of_squares = 0
    sum_of_ints = 0
    for i in range(1, n + 1):
        sum_of_squares += i**2
        sum_of_ints += i
    return sum_of_ints**2 - sum_of_squares",data\repos\Python\project_euler\problem_006\sol1.py,solution,148
2231,sol2.py::solution::20,"def solution(n: int = 100) -> int:
    """"""
    Returns the difference between the sum of the squares of the first n
    natural numbers and the square of the sum.

    >>> solution(10)
    2640
    >>> solution(15)
    13160
    >>> solution(20)
    41230
    >>> solution(50)
    1582700
    """"""

    sum_cubes = (n * (n + 1) // 2) ** 2
    sum_squares = n * (n + 1) * (2 * n + 1) // 6
    return sum_cubes - sum_squares",data\repos\Python\project_euler\problem_006\sol2.py,solution,143
2232,sol3.py::solution::22,"def solution(n: int = 100) -> int:
    """"""
    Returns the difference between the sum of the squares of the first n
    natural numbers and the square of the sum.

    >>> solution(10)
    2640
    >>> solution(15)
    13160
    >>> solution(20)
    41230
    >>> solution(50)
    1582700
    """"""

    sum_of_squares = sum(i * i for i in range(1, n + 1))
    square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))
    return square_of_sum - sum_of_squares",data\repos\Python\project_euler\problem_006\sol3.py,solution,139
2233,sol4.py::solution::20,"def solution(n: int = 100) -> int:
    """"""
    Returns the difference between the sum of the squares of the first n
    natural numbers and the square of the sum.

    >>> solution(10)
    2640
    >>> solution(15)
    13160
    >>> solution(20)
    41230
    >>> solution(50)
    1582700
    """"""

    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6
    square_of_sum = (n * (n + 1) / 2) ** 2
    return int(square_of_sum - sum_of_squares)",data\repos\Python\project_euler\problem_006\sol4.py,solution,147
2234,sol1.py::is_prime::18,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).
    A number is prime if it has exactly two factors: 1 and itself.
    Returns boolean representing primality of given number (i.e., if the
    result is true, then the number is indeed prime else it is not).

    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(2999)
    True
    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_007\sol1.py,is_prime,276
2235,sol1.py::solution::52,"def solution(nth: int = 10001) -> int:
    """"""
    Returns the n-th prime number.

    >>> solution(6)
    13
    >>> solution(1)
    2
    >>> solution(3)
    5
    >>> solution(20)
    71
    >>> solution(50)
    229
    >>> solution(100)
    541
    """"""

    count = 0
    number = 1
    while count != nth and number < 3:
        number += 1
        if is_prime(number):
            count += 1
    while count != nth:
        number += 2
        if is_prime(number):
            count += 1
    return number",data\repos\Python\project_euler\problem_007\sol1.py,solution,154
2236,sol2.py::is_prime::18,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).
    A number is prime if it has exactly two factors: 1 and itself.
    Returns boolean representing primality of given number (i.e., if the
    result is true, then the number is indeed prime else it is not).

    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(2999)
    True
    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_007\sol2.py,is_prime,277
2237,sol2.py::solution::52,"def solution(nth: int = 10001) -> int:
    """"""
    Returns the n-th prime number.

    >>> solution(6)
    13
    >>> solution(1)
    2
    >>> solution(3)
    5
    >>> solution(20)
    71
    >>> solution(50)
    229
    >>> solution(100)
    541
    >>> solution(3.4)
    5
    >>> solution(0)
    Traceback (most recent call last):
        ...
    ValueError: Parameter nth must be greater than or equal to one.
    >>> solution(-17)
    Traceback (most recent call last):
        ...
    ValueError: Parameter nth must be greater than or equal to one.
    >>> solution([])
    Traceback (most recent call last):
        ...
    TypeError: Parameter nth must be int or castable to int.
    >>> solution(""asd"")
    Traceback (most recent call last):
        ...
    TypeError: Parameter nth must be int or castable to int.
    """"""

    try:
        nth = int(nth)
    except (TypeError, ValueError):
        raise TypeError(""Parameter nth must be int or castable to int."") from None
    if nth <= 0:
        raise ValueError(""Parameter nth must be greater than or equal to one."")
    primes: list[int] = []
    num = 2
    while len(primes) < nth:
        if is_prime(num):
            primes.append(num)
            num += 1
        else:
            num += 1
    return primes[len(primes) - 1]",data\repos\Python\project_euler\problem_007\sol2.py,solution,337
2238,sol3.py::is_prime::19,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).
    A number is prime if it has exactly two factors: 1 and itself.
    Returns boolean representing primality of given number (i.e., if the
    result is true, then the number is indeed prime else it is not).

    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(2999)
    True
    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_007\sol3.py,is_prime,277
2239,sol3.py::prime_generator::53,"def prime_generator():
    """"""
    Generate a sequence of prime numbers
    """"""

    num = 2
    while True:
        if is_prime(num):
            yield num
        num += 1",data\repos\Python\project_euler\problem_007\sol3.py,prime_generator,41
2240,sol3.py::solution::65,"def solution(nth: int = 10001) -> int:
    """"""
    Returns the n-th prime number.

    >>> solution(6)
    13
    >>> solution(1)
    2
    >>> solution(3)
    5
    >>> solution(20)
    71
    >>> solution(50)
    229
    >>> solution(100)
    541
    """"""
    return next(itertools.islice(prime_generator(), nth - 1, nth))",data\repos\Python\project_euler\problem_007\sol3.py,solution,104
2241,sol1.py::solution::60,"def solution(n: str = N) -> int:
    """"""
    Find the thirteen adjacent digits in the 1000-digit number n that have
    the greatest product and returns it.

    >>> solution(""13978431290823798458352374"")
    609638400
    >>> solution(""13978431295823798458352374"")
    2612736000
    >>> solution(""1397843129582379841238352374"")
    209018880
    """"""

    largest_product = -sys.maxsize - 1
    for i in range(len(n) - 12):
        product = 1
        for j in range(13):
            product *= int(n[i + j])
        largest_product = max(largest_product, product)
    return largest_product",data\repos\Python\project_euler\problem_008\sol1.py,solution,164
2242,sol2.py::solution::60,"def solution(n: str = N) -> int:
    """"""
    Find the thirteen adjacent digits in the 1000-digit number n that have
    the greatest product and returns it.

    >>> solution(""13978431290823798458352374"")
    609638400
    >>> solution(""13978431295823798458352374"")
    2612736000
    >>> solution(""1397843129582379841238352374"")
    209018880
    """"""

    return max(
        # mypy cannot properly interpret reduce
        int(reduce(lambda x, y: str(int(x) * int(y)), n[i : i + 13]))
        for i in range(len(n) - 12)
    )",data\repos\Python\project_euler\problem_008\sol2.py,solution,154
2243,sol3.py::str_eval::60,"def str_eval(s: str) -> int:
    """"""
    Returns product of digits in given string n

    >>> str_eval(""987654321"")
    362880
    >>> str_eval(""22222222"")
    256
    """"""

    product = 1
    for digit in s:
        product *= int(digit)
    return product",data\repos\Python\project_euler\problem_008\sol3.py,str_eval,73
2244,sol3.py::solution::76,"def solution(n: str = N) -> int:
    """"""
    Find the thirteen adjacent digits in the 1000-digit number n that have
    the greatest product and returns it.
    """"""

    largest_product = -sys.maxsize - 1
    substr = n[:13]
    cur_index = 13
    while cur_index < len(n) - 13:
        if int(n[cur_index]) >= int(substr[0]):
            substr = substr[1:] + n[cur_index]
            cur_index += 1
        else:
            largest_product = max(largest_product, str_eval(substr))
            substr = n[cur_index : cur_index + 13]
            cur_index += 13
    return largest_product",data\repos\Python\project_euler\problem_008\sol3.py,solution,150
2245,sol1.py::solution::20,"def solution() -> int:
    """"""
    Returns the product of a,b,c which are Pythagorean Triplet that satisfies
    the following:
      1. a < b < c
      2. a**2 + b**2 = c**2
      3. a + b + c = 1000

    >>> solution()
    31875000
    """"""

    for a in range(300):
        for b in range(a + 1, 400):
            for c in range(b + 1, 500):
                if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):
                    return a * b * c

    return -1",data\repos\Python\project_euler\problem_009\sol1.py,solution,159
2246,sol1.py::solution_fast::41,"def solution_fast() -> int:
    """"""
    Returns the product of a,b,c which are Pythagorean Triplet that satisfies
    the following:
      1. a < b < c
      2. a**2 + b**2 = c**2
      3. a + b + c = 1000

    >>> solution_fast()
    31875000
    """"""

    for a in range(300):
        for b in range(400):
            c = 1000 - a - b
            if a < b < c and (a**2) + (b**2) == (c**2):
                return a * b * c

    return -1",data\repos\Python\project_euler\problem_009\sol1.py,solution_fast,148
2247,sol1.py::benchmark::62,"def benchmark() -> None:
    """"""
    Benchmark code comparing two different version function.
    """"""
    import timeit

    print(
        timeit.timeit(""solution()"", setup=""from __main__ import solution"", number=1000)
    )
    print(
        timeit.timeit(
            ""solution_fast()"", setup=""from __main__ import solution_fast"", number=1000
        )
    )",data\repos\Python\project_euler\problem_009\sol1.py,benchmark,84
2248,sol2.py::solution::20,"def solution(n: int = 1000) -> int:
    """"""
    Return the product of a,b,c which are Pythagorean Triplet that satisfies
    the following:
      1. a < b < c
      2. a**2 + b**2 = c**2
      3. a + b + c = n

    >>> solution(36)
    1620
    >>> solution(126)
    66780
    """"""

    product = -1
    candidate = 0
    for a in range(1, n // 3):
        # Solving the two equations a**2+b**2=c**2 and a+b+c=N eliminating c
        b = (n * n - 2 * a * n) // (2 * n - 2 * a)
        c = n - a - b
        if c * c == (a * a + b * b):
            candidate = a * b * c
            product = max(product, candidate)
    return product",data\repos\Python\project_euler\problem_009\sol2.py,solution,218
2249,sol3.py::solution::20,"def solution() -> int:
    """"""
    Returns the product of a,b,c which are Pythagorean Triplet that satisfies
    the following:
      1. a**2 + b**2 = c**2
      2. a + b + c = 1000

    >>> solution()
    31875000
    """"""

    return next(
        iter(
            [
                a * b * (1000 - a - b)
                for a in range(1, 999)
                for b in range(a, 999)
                if (a * a + b * b == (1000 - a - b) ** 2)
            ]
        )
    )",data\repos\Python\project_euler\problem_009\sol3.py,solution,144
2250,sol4.py::get_squares::20,"def get_squares(n: int) -> list[int]:
    """"""
    >>> get_squares(0)
    []
    >>> get_squares(1)
    [0]
    >>> get_squares(2)
    [0, 1]
    >>> get_squares(3)
    [0, 1, 4]
    >>> get_squares(4)
    [0, 1, 4, 9]
    """"""
    return [number * number for number in range(n)]",data\repos\Python\project_euler\problem_009\sol4.py,get_squares,104
2251,sol4.py::solution::36,"def solution(n: int = 1000) -> int:
    """"""
    Precomputing squares and checking if a^2 + b^2 is the square by set look-up.

    >>> solution(12)
    60
    >>> solution(36)
    1620
    """"""

    squares = get_squares(n)
    squares_set = set(squares)
    for a in range(1, n // 3):
        for b in range(a + 1, (n - a) // 2 + 1):
            if (
                squares[a] + squares[b] in squares_set
                and squares[n - a - b] == squares[a] + squares[b]
            ):
                return a * b * (n - a - b)

    return -1",data\repos\Python\project_euler\problem_009\sol4.py,solution,163
2252,sol1.py::is_prime::17,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).
    A number is prime if it has exactly two factors: 1 and itself.
    Returns boolean representing primality of given number num (i.e., if the
    result is true, then the number is indeed prime else it is not).

    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(2999)
    True
    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_010\sol1.py,is_prime,278
2253,sol1.py::solution::51,"def solution(n: int = 2000000) -> int:
    """"""
    Returns the sum of all the primes below n.

    >>> solution(1000)
    76127
    >>> solution(5000)
    1548136
    >>> solution(10000)
    5736396
    >>> solution(7)
    10
    """"""

    return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0",data\repos\Python\project_euler\problem_010\sol1.py,solution,109
2254,sol2.py::is_prime::19,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).
    A number is prime if it has exactly two factors: 1 and itself.
    Returns boolean representing primality of given number num (i.e., if the
    result is true, then the number is indeed prime else it is not).

    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(2999)
    True
    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_010\sol2.py,is_prime,278
2255,sol2.py::prime_generator::53,"def prime_generator() -> Iterator[int]:
    """"""
    Generate a list sequence of prime numbers
    """"""

    num = 2
    while True:
        if is_prime(num):
            yield num
        num += 1",data\repos\Python\project_euler\problem_010\sol2.py,prime_generator,46
2256,sol2.py::solution::65,"def solution(n: int = 2000000) -> int:
    """"""
    Returns the sum of all the primes below n.

    >>> solution(1000)
    76127
    >>> solution(5000)
    1548136
    >>> solution(10000)
    5736396
    >>> solution(7)
    10
    """"""

    return sum(takewhile(lambda x: x < n, prime_generator()))",data\repos\Python\project_euler\problem_010\sol2.py,solution,95
2257,sol3.py::solution::16,"def solution(n: int = 2000000) -> int:
    """"""
    Returns the sum of all the primes below n using Sieve of Eratosthenes:

    The sieve of Eratosthenes is one of the most efficient ways to find all primes
    smaller than n when n is smaller than 10 million.  Only for positive numbers.

    >>> solution(1000)
    76127
    >>> solution(5000)
    1548136
    >>> solution(10000)
    5736396
    >>> solution(7)
    10
    >>> solution(7.1)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> solution(-7)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    IndexError: list assignment index out of range
    >>> solution(""seven"")  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: can only concatenate str (not ""int"") to str
    """"""

    primality_list = [0 for i in range(n + 1)]
    primality_list[0] = 1
    primality_list[1] = 1

    for i in range(2, int(n**0.5) + 1):
        if primality_list[i] == 0:
            for j in range(i * i, n + 1, i):
                primality_list[j] = 1
    sum_of_primes = 0
    for i in range(n):
        if primality_list[i] == 0:
            sum_of_primes += i
    return sum_of_primes",data\repos\Python\project_euler\problem_010\sol3.py,solution,383
2258,sol1.py::largest_product::30,"def largest_product(grid):
    n_columns = len(grid[0])
    n_rows = len(grid)

    largest = 0
    lr_diag_product = 0
    rl_diag_product = 0

    # Check vertically, horizontally, diagonally at the same time (only works
    # for nxn grid)
    for i in range(n_columns):
        for j in range(n_rows - 3):
            vert_product = grid[j][i] * grid[j + 1][i] * grid[j + 2][i] * grid[j + 3][i]
            horz_product = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]

            # Left-to-right diagonal (\) product
            if i < n_columns - 3:
                lr_diag_product = (
                    grid[i][j]
                    * grid[i + 1][j + 1]
                    * grid[i + 2][j + 2]
                    * grid[i + 3][j + 3]
                )

            # Right-to-left diagonal(/) product
            if i > 2:
                rl_diag_product = (
                    grid[i][j]
                    * grid[i - 1][j + 1]
                    * grid[i - 2][j + 2]
                    * grid[i - 3][j + 3]
                )

            max_product = max(
                vert_product, horz_product, lr_diag_product, rl_diag_product
            )
            largest = max(largest, max_product)

    return largest",data\repos\Python\project_euler\problem_011\sol1.py,largest_product,339
2259,sol1.py::solution::71,"def solution():
    """"""Returns the greatest product of four adjacent numbers (horizontally,
    vertically, or diagonally).

    >>> solution()
    70600674
    """"""
    grid = []
    with open(os.path.dirname(__file__) + ""/grid.txt"") as file:
        for line in file:
            grid.append(line.strip(""\n"").split("" ""))

    grid = [[int(i) for i in grid[j]] for j in range(len(grid))]

    return largest_product(grid)",data\repos\Python\project_euler\problem_011\sol1.py,solution,102
2260,sol2.py::solution::30,"def solution():
    """"""Returns the greatest product of four adjacent numbers (horizontally,
    vertically, or diagonally).

    >>> solution()
    70600674
    """"""
    with open(os.path.dirname(__file__) + ""/grid.txt"") as f:
        grid = []
        for _ in range(20):
            grid.append([int(x) for x in f.readline().split()])

        maximum = 0

        # right
        for i in range(20):
            for j in range(17):
                temp = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]
                maximum = max(maximum, temp)

        # down
        for i in range(17):
            for j in range(20):
                temp = grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j]
                maximum = max(maximum, temp)

        # diagonal 1
        for i in range(17):
            for j in range(17):
                temp = (
                    grid[i][j]
                    * grid[i + 1][j + 1]
                    * grid[i + 2][j + 2]
                    * grid[i + 3][j + 3]
                )
                maximum = max(maximum, temp)

        # diagonal 2
        for i in range(17):
            for j in range(3, 20):
                temp = (
                    grid[i][j]
                    * grid[i + 1][j - 1]
                    * grid[i + 2][j - 2]
                    * grid[i + 3][j - 3]
                )
                maximum = max(maximum, temp)
        return maximum",data\repos\Python\project_euler\problem_011\sol2.py,solution,385
2261,sol1.py::count_divisors::26,"def count_divisors(n):
    n_divisors = 1
    i = 2
    while i * i <= n:
        multiplicity = 0
        while n % i == 0:
            n //= i
            multiplicity += 1
        n_divisors *= multiplicity + 1
        i += 1
    if n > 1:
        n_divisors *= 2
    return n_divisors",data\repos\Python\project_euler\problem_012\sol1.py,count_divisors,93
2262,sol1.py::solution::41,"def solution():
    """"""Returns the value of the first triangle number to have over five hundred
    divisors.

    >>> solution()
    76576500
    """"""
    t_num = 1
    i = 1

    while True:
        i += 1
        t_num += i

        if count_divisors(t_num) > 500:
            break

    return t_num",data\repos\Python\project_euler\problem_012\sol1.py,solution,83
2263,sol2.py::triangle_number_generator::26,"def triangle_number_generator():
    for n in range(1, 1000000):
        yield n * (n + 1) // 2",data\repos\Python\project_euler\problem_012\sol2.py,triangle_number_generator,31
2264,sol2.py::count_divisors::31,"def count_divisors(n):
    divisors_count = 1
    i = 2
    while i * i <= n:
        multiplicity = 0
        while n % i == 0:
            n //= i
            multiplicity += 1
        divisors_count *= multiplicity + 1
        i += 1
    if n > 1:
        divisors_count *= 2
    return divisors_count",data\repos\Python\project_euler\problem_012\sol2.py,count_divisors,93
2265,sol2.py::solution::46,"def solution():
    """"""Returns the value of the first triangle number to have over five hundred
    divisors.

    >>> solution()
    76576500
    """"""
    return next(i for i in triangle_number_generator() if count_divisors(i) > 500)",data\repos\Python\project_euler\problem_012\sol2.py,solution,56
2266,sol1.py::solution::12,"def solution():
    """"""
    Returns the first ten digits of the sum of the array elements
    from the file num.txt

    >>> solution()
    '5537376230'
    """"""
    file_path = os.path.join(os.path.dirname(__file__), ""num.txt"")
    with open(file_path) as file_hand:
        return str(sum(int(line) for line in file_hand))[:10]",data\repos\Python\project_euler\problem_013\sol1.py,solution,82
2267,sol1.py::solution::22,"def solution(n: int = 1000000) -> int:
    """"""Returns the number under n that generates the longest sequence using the
    formula:
    n  n/2 (n is even)
    n  3n + 1 (n is odd)

    >>> solution(1000000)
    837799
    >>> solution(200)
    171
    >>> solution(5000)
    3711
    >>> solution(15000)
    13255
    """"""
    largest_number = 1
    pre_counter = 1
    counters = {1: 1}

    for input1 in range(2, n):
        counter = 0
        number = input1

        while True:
            if number in counters:
                counter += counters[number]
                break
            if number % 2 == 0:
                number //= 2
                counter += 1
            else:
                number = (3 * number) + 1
                counter += 1

        if input1 not in counters:
            counters[input1] = counter

        if counter > pre_counter:
            largest_number = input1
            pre_counter = counter
    return largest_number",data\repos\Python\project_euler\problem_014\sol1.py,solution,254
2268,sol2.py::collatz_sequence_length::34,"def collatz_sequence_length(n: int) -> int:
    """"""Returns the Collatz sequence length for n.""""""
    if n in COLLATZ_SEQUENCE_LENGTHS:
        return COLLATZ_SEQUENCE_LENGTHS[n]
    next_n = n // 2 if n % 2 == 0 else 3 * n + 1
    sequence_length = collatz_sequence_length(next_n) + 1
    COLLATZ_SEQUENCE_LENGTHS[n] = sequence_length
    return sequence_length",data\repos\Python\project_euler\problem_014\sol2.py,collatz_sequence_length,101
2269,sol2.py::solution::44,"def solution(n: int = 1000000) -> int:
    """"""Returns the number under n that generates the longest Collatz sequence.

    >>> solution(1000000)
    837799
    >>> solution(200)
    171
    >>> solution(5000)
    3711
    >>> solution(15000)
    13255
    """"""

    result = max((collatz_sequence_length(i), i) for i in range(1, n))
    return result[1]",data\repos\Python\project_euler\problem_014\sol2.py,solution,106
2270,sol1.py::solution::12,"def solution(n: int = 20) -> int:
    """"""
    Returns the number of paths possible in a n x n grid starting at top left
    corner going to bottom right corner and being able to move right and down
    only.
    >>> solution(25)
    126410606437752
    >>> solution(23)
    8233430727600
    >>> solution(20)
    137846528820
    >>> solution(15)
    155117520
    >>> solution(1)
    2
    """"""
    n = 2 * n  # middle entry of odd rows starting at row 3 is the solution for n = 1,
    # 2, 3,...
    k = n // 2

    return int(factorial(n) / (factorial(k) * factorial(n - k)))",data\repos\Python\project_euler\problem_015\sol1.py,solution,179
2271,sol1.py::solution::10,"def solution(power: int = 1000) -> int:
    """"""Returns the sum of the digits of the number 2^power.
    >>> solution(1000)
    1366
    >>> solution(50)
    76
    >>> solution(20)
    31
    >>> solution(15)
    26
    """"""
    num = 2**power
    string_num = str(num)
    list_num = list(string_num)
    sum_of_num = 0

    for i in list_num:
        sum_of_num += int(i)

    return sum_of_num",data\repos\Python\project_euler\problem_016\sol1.py,solution,124
2272,sol2.py::solution::10,"def solution(power: int = 1000) -> int:
    """"""Returns the sum of the digits of the number 2^power.

    >>> solution(1000)
    1366
    >>> solution(50)
    76
    >>> solution(20)
    31
    >>> solution(15)
    26
    """"""
    n = 2**power
    r = 0
    while n:
        r, n = r + n % 10, n // 10
    return r",data\repos\Python\project_euler\problem_016\sol2.py,solution,111
2273,sol1.py::solution::19,"def solution(n: int = 1000) -> int:
    """"""Returns the number of letters used to write all numbers from 1 to n.
    where n is lower or equals to 1000.
    >>> solution(1000)
    21124
    >>> solution(5)
    19
    """"""
    # number of letters in zero, one, two, ..., nineteen (0 for zero since it's
    # never said aloud)
    ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8]
    # number of letters in twenty, thirty, ..., ninety (0 for numbers less than
    # 20 due to inconsistency in teens)
    tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6]

    count = 0

    for i in range(1, n + 1):
        if i < 1000:
            if i >= 100:
                # add number of letters for ""n hundred""
                count += ones_counts[i // 100] + 7

                if i % 100 != 0:
                    # add number of letters for ""and"" if number is not multiple
                    # of 100
                    count += 3

            if 0 < i % 100 < 20:
                # add number of letters for one, two, three, ..., nineteen
                # (could be combined with below if not for inconsistency in
                # teens)
                count += ones_counts[i % 100]
            else:
                # add number of letters for twenty, twenty one, ..., ninety
                # nine
                count += ones_counts[i % 10]
                count += tens_counts[(i % 100 - i % 10) // 10]
        else:
            count += ones_counts[i // 1000] + 8
    return count",data\repos\Python\project_euler\problem_017\sol1.py,solution,449
2274,solution.py::solution::34,"def solution():
    """"""
    Finds the maximum total in a triangle as described by the problem statement
    above.

    >>> solution()
    1074
    """"""
    script_dir = os.path.dirname(os.path.realpath(__file__))
    triangle = os.path.join(script_dir, ""triangle.txt"")

    with open(triangle) as f:
        triangle = f.readlines()

    a = [[int(y) for y in x.rstrip(""\r\n"").split("" "")] for x in triangle]

    for i in range(1, len(a)):
        for j in range(len(a[i])):
            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0
            number2 = a[i - 1][j - 1] if j > 0 else 0
            a[i][j] += max(number1, number2)
    return max(a[-1])",data\repos\Python\project_euler\problem_018\solution.py,solution,191
2275,sol1.py::solution::24,"def solution():
    """"""Returns the number of mondays that fall on the first of the month during
    the twentieth century (1 Jan 1901 to 31 Dec 2000)?

    >>> solution()
    171
    """"""
    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    day = 6
    month = 1
    year = 1901

    sundays = 0

    while year < 2001:
        day += 7

        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            if day > days_per_month[month - 1] and month != 2:
                month += 1
                day = day - days_per_month[month - 2]
            elif day > 29 and month == 2:
                month += 1
                day = day - 29
        elif day > days_per_month[month - 1]:
            month += 1
            day = day - days_per_month[month - 2]

        if month > 12:
            year += 1
            month = 1

        if year < 2001 and day == 1:
            sundays += 1
    return sundays",data\repos\Python\project_euler\problem_019\sol1.py,solution,300
2276,sol1.py::factorial::13,"def factorial(num: int) -> int:
    """"""Find the factorial of a given number n""""""
    fact = 1
    for i in range(1, num + 1):
        fact *= i
    return fact",data\repos\Python\project_euler\problem_020\sol1.py,factorial,47
2277,sol1.py::split_and_add::21,"def split_and_add(number: int) -> int:
    """"""Split number digits and add them.""""""
    sum_of_digits = 0
    while number > 0:
        last_digit = number % 10
        sum_of_digits += last_digit
        number = number // 10  # Removing the last_digit from the given number
    return sum_of_digits",data\repos\Python\project_euler\problem_020\sol1.py,split_and_add,75
2278,sol1.py::solution::31,"def solution(num: int = 100) -> int:
    """"""Returns the sum of the digits in the factorial of num
    >>> solution(100)
    648
    >>> solution(50)
    216
    >>> solution(10)
    27
    >>> solution(5)
    3
    >>> solution(3)
    6
    >>> solution(2)
    2
    >>> solution(1)
    1
    """"""
    nfact = factorial(num)
    result = split_and_add(nfact)
    return result",data\repos\Python\project_euler\problem_020\sol1.py,solution,117
2279,sol2.py::solution::15,"def solution(num: int = 100) -> int:
    """"""Returns the sum of the digits in the factorial of num
    >>> solution(100)
    648
    >>> solution(50)
    216
    >>> solution(10)
    27
    >>> solution(5)
    3
    >>> solution(3)
    6
    >>> solution(2)
    2
    >>> solution(1)
    1
    """"""
    return sum(int(x) for x in str(factorial(num)))",data\repos\Python\project_euler\problem_020\sol2.py,solution,112
2280,sol3.py::solution::15,"def solution(num: int = 100) -> int:
    """"""Returns the sum of the digits in the factorial of num
    >>> solution(1000)
    10539
    >>> solution(200)
    1404
    >>> solution(100)
    648
    >>> solution(50)
    216
    >>> solution(10)
    27
    >>> solution(5)
    3
    >>> solution(3)
    6
    >>> solution(2)
    2
    >>> solution(1)
    1
    >>> solution(0)
    1
    """"""
    return sum(map(int, str(factorial(num))))",data\repos\Python\project_euler\problem_020\sol3.py,solution,142
2281,sol4.py::solution::13,"def solution(num: int = 100) -> int:
    """"""Returns the sum of the digits in the factorial of num
    >>> solution(100)
    648
    >>> solution(50)
    216
    >>> solution(10)
    27
    >>> solution(5)
    3
    >>> solution(3)
    6
    >>> solution(2)
    2
    >>> solution(1)
    1
    """"""
    fact = 1
    result = 0
    for i in range(1, num + 1):
        fact *= i

    for j in str(fact):
        result += int(j)

    return result",data\repos\Python\project_euler\problem_020\sol4.py,solution,145
2282,sol1.py::sum_of_divisors::20,"def sum_of_divisors(n: int) -> int:
    total = 0
    for i in range(1, int(sqrt(n) + 1)):
        if n % i == 0 and i != sqrt(n):
            total += i + n // i
        elif i == sqrt(n):
            total += i
    return total - n",data\repos\Python\project_euler\problem_021\sol1.py,sum_of_divisors,74
2283,sol1.py::solution::30,"def solution(n: int = 10000) -> int:
    """"""Returns the sum of all the amicable numbers under n.

    >>> solution(10000)
    31626
    >>> solution(5000)
    8442
    >>> solution(1000)
    504
    >>> solution(100)
    0
    >>> solution(50)
    0
    """"""
    total = sum(
        i
        for i in range(1, n)
        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i
    )
    return total",data\repos\Python\project_euler\problem_021\sol1.py,solution,131
2284,sol1.py::solution::21,"def solution():
    """"""Returns the total of all the name scores in the file.

    >>> solution()
    871198282
    """"""
    with open(os.path.dirname(__file__) + ""/p022_names.txt"") as file:
        names = str(file.readlines()[0])
        names = names.replace('""', """").split("","")

    names.sort()

    name_score = 0
    total_score = 0

    for i, name in enumerate(names):
        for letter in name:
            name_score += ord(letter) - 64

        total_score += (i + 1) * name_score
        name_score = 0
    return total_score",data\repos\Python\project_euler\problem_022\sol1.py,solution,137
2285,sol2.py::solution::21,"def solution():
    """"""Returns the total of all the name scores in the file.

    >>> solution()
    871198282
    """"""
    total_sum = 0
    temp_sum = 0
    with open(os.path.dirname(__file__) + ""/p022_names.txt"") as file:
        name = str(file.readlines()[0])
        name = name.replace('""', """").split("","")

    name.sort()
    for i in range(len(name)):
        for j in name[i]:
            temp_sum += ord(j) - ord(""A"") + 1
        total_sum += (i + 1) * temp_sum
        temp_sum = 0
    return total_sum",data\repos\Python\project_euler\problem_022\sol2.py,solution,142
2286,sol1.py::solution::22,"def solution(limit=28123):
    """"""
    Finds the sum of all the positive integers which cannot be written as
    the sum of two abundant numbers
    as described by the statement above.

    >>> solution()
    4179871
    """"""
    sum_divs = [1] * (limit + 1)

    for i in range(2, int(limit**0.5) + 1):
        sum_divs[i * i] += i
        for k in range(i + 1, limit // i + 1):
            sum_divs[k * i] += k + i

    abundants = set()
    res = 0

    for n in range(1, limit + 1):
        if sum_divs[n] > n:
            abundants.add(n)

        if not any((n - a in abundants) for a in abundants):
            res += n

    return res",data\repos\Python\project_euler\problem_023\sol1.py,solution,194
2287,sol1.py::solution::16,"def solution():
    """"""Returns the millionth lexicographic permutation of the digits 0, 1, 2,
    3, 4, 5, 6, 7, 8 and 9.

    >>> solution()
    '2783915460'
    """"""
    result = list(map("""".join, permutations(""0123456789"")))
    return result[999999]",data\repos\Python\project_euler\problem_024\sol1.py,solution,83
2288,sol1.py::fibonacci::28,"def fibonacci(n: int) -> int:
    """"""
    Computes the Fibonacci number for input n by iterating through n numbers
    and creating an array of ints using the Fibonacci formula.
    Returns the nth element of the array.

    >>> fibonacci(2)
    1
    >>> fibonacci(3)
    2
    >>> fibonacci(5)
    5
    >>> fibonacci(10)
    55
    >>> fibonacci(12)
    144

    """"""
    if n == 1 or not isinstance(n, int):
        return 0
    elif n == 2:
        return 1
    else:
        sequence = [0, 1]
        for i in range(2, n + 1):
            sequence.append(sequence[i - 1] + sequence[i - 2])

        return sequence[n]",data\repos\Python\project_euler\problem_025\sol1.py,fibonacci,174
2289,sol1.py::fibonacci_digits_index::58,"def fibonacci_digits_index(n: int) -> int:
    """"""
    Computes incrementing Fibonacci numbers starting from 3 until the length
    of the resulting Fibonacci result is the input value n. Returns the term
    of the Fibonacci sequence where this occurs.

    >>> fibonacci_digits_index(1000)
    4782
    >>> fibonacci_digits_index(100)
    476
    >>> fibonacci_digits_index(50)
    237
    >>> fibonacci_digits_index(3)
    12
    """"""
    digits = 0
    index = 2

    while digits < n:
        index += 1
        digits = len(str(fibonacci(index)))

    return index",data\repos\Python\project_euler\problem_025\sol1.py,fibonacci_digits_index,141
2290,sol1.py::solution::83,"def solution(n: int = 1000) -> int:
    """"""
    Returns the index of the first term in the Fibonacci sequence to contain
    n digits.

    >>> solution(1000)
    4782
    >>> solution(100)
    476
    >>> solution(50)
    237
    >>> solution(3)
    12
    """"""
    return fibonacci_digits_index(n)",data\repos\Python\project_euler\problem_025\sol1.py,solution,85
2291,sol2.py::fibonacci_generator::30,"def fibonacci_generator() -> Generator[int]:
    """"""
    A generator that produces numbers in the Fibonacci sequence

    >>> generator = fibonacci_generator()
    >>> next(generator)
    1
    >>> next(generator)
    2
    >>> next(generator)
    3
    >>> next(generator)
    5
    >>> next(generator)
    8
    """"""
    a, b = 0, 1
    while True:
        a, b = b, a + b
        yield b",data\repos\Python\project_euler\problem_025\sol2.py,fibonacci_generator,104
2292,sol2.py::solution::52,"def solution(n: int = 1000) -> int:
    """"""Returns the index of the first term in the Fibonacci sequence to contain
    n digits.

    >>> solution(1000)
    4782
    >>> solution(100)
    476
    >>> solution(50)
    237
    >>> solution(3)
    12
    """"""
    answer = 1
    gen = fibonacci_generator()
    while len(str(next(gen))) < n:
        answer += 1
    return answer + 1",data\repos\Python\project_euler\problem_025\sol2.py,solution,111
2293,sol3.py::solution::28,"def solution(n: int = 1000) -> int:
    """"""Returns the index of the first term in the Fibonacci sequence to contain
    n digits.

    >>> solution(1000)
    4782
    >>> solution(100)
    476
    >>> solution(50)
    237
    >>> solution(3)
    12
    """"""
    f1, f2 = 1, 1
    index = 2
    while True:
        i = 0
        f = f1 + f2
        f1, f2 = f2, f
        index += 1
        for _ in str(f):
            i += 1
        if i == n:
            break
    return index",data\repos\Python\project_euler\problem_025\sol3.py,solution,158
2294,sol1.py::solution::27,"def solution(numerator: int = 1, digit: int = 1000) -> int:
    """"""
    Considering any range can be provided,
    because as per the problem, the digit d < 1000
    >>> solution(1, 10)
    7
    >>> solution(10, 100)
    97
    >>> solution(10, 1000)
    983
    """"""
    the_digit = 1
    longest_list_length = 0

    for divide_by_number in range(numerator, digit + 1):
        has_been_divided: list[int] = []
        now_divide = numerator
        for _ in range(1, digit + 1):
            if now_divide in has_been_divided:
                if longest_list_length < len(has_been_divided):
                    longest_list_length = len(has_been_divided)
                    the_digit = divide_by_number
            else:
                has_been_divided.append(now_divide)
                now_divide = now_divide * 10 % divide_by_number

    return the_digit",data\repos\Python\project_euler\problem_026\sol1.py,solution,229
2295,sol1.py::is_prime::26,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).
    A number is prime if it has exactly two factors: 1 and itself.
    Returns boolean representing primality of given number num (i.e., if the
    result is true, then the number is indeed prime else it is not).

    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(2999)
    True
    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(-10)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_027\sol1.py,is_prime,288
2296,sol1.py::solution::62,"def solution(a_limit: int = 1000, b_limit: int = 1000) -> int:
    """"""
    >>> solution(1000, 1000)
    -59231
    >>> solution(200, 1000)
    -59231
    >>> solution(200, 200)
    -4925
    >>> solution(-1000, 1000)
    0
    >>> solution(-1000, -1000)
    0
    """"""
    longest = [0, 0, 0]  # length, a, b
    for a in range((a_limit * -1) + 1, a_limit):
        for b in range(2, b_limit):
            if is_prime(b):
                count = 0
                n = 0
                while is_prime((n**2) + (a * n) + b):
                    count += 1
                    n += 1
                if count > longest[0]:
                    longest = [count, a, b]
    ans = longest[1] * longest[2]
    return ans",data\repos\Python\project_euler\problem_027\sol1.py,solution,233
2297,sol1.py::solution::23,"def solution(n: int = 1001) -> int:
    """"""Returns the sum of the numbers on the diagonals in a n by n spiral
    formed in the same way.

    >>> solution(1001)
    669171001
    >>> solution(500)
    82959497
    >>> solution(100)
    651897
    >>> solution(50)
    79697
    >>> solution(10)
    537
    """"""
    total = 1

    for i in range(1, ceil(n / 2.0)):
        odd = 2 * i + 1
        even = 2 * i
        total = total + 4 * odd**2 - 6 * even

    return total",data\repos\Python\project_euler\problem_028\sol1.py,solution,159
2298,sol1.py::solution::19,"def solution(n: int = 100) -> int:
    """"""Returns the number of distinct terms in the sequence generated by a^b
    for 2 <= a <= 100 and 2 <= b <= 100.

    >>> solution(100)
    9183
    >>> solution(50)
    2184
    >>> solution(20)
    324
    >>> solution(5)
    15
    >>> solution(2)
    1
    >>> solution(1)
    0
    """"""
    collect_powers = set()

    current_pow = 0

    n = n + 1  # maximum limit

    for a in range(2, n):
        for b in range(2, n):
            current_pow = a**b  # calculates the current power
            collect_powers.add(current_pow)  # adds the result to the set
    return len(collect_powers)",data\repos\Python\project_euler\problem_029\sol1.py,solution,196
2299,sol1.py::digits_fifth_powers_sum::27,"def digits_fifth_powers_sum(number: int) -> int:
    """"""
    >>> digits_fifth_powers_sum(1234)
    1300
    """"""
    return sum(DIGITS_FIFTH_POWER[digit] for digit in str(number))",data\repos\Python\project_euler\problem_030\sol1.py,digits_fifth_powers_sum,54
2300,sol1.py::solution::35,"def solution() -> int:
    return sum(
        number
        for number in range(1000, 1000000)
        if number == digits_fifth_powers_sum(number)
    )",data\repos\Python\project_euler\problem_030\sol1.py,solution,41
2301,sol1.py::two_pence::20,"def two_pence(x: int) -> int:
    return 0 if x < 0 else two_pence(x - 2) + one_pence()",data\repos\Python\project_euler\problem_031\sol1.py,two_pence,34
2302,sol1.py::five_pence::24,"def five_pence(x: int) -> int:
    return 0 if x < 0 else five_pence(x - 5) + two_pence(x)",data\repos\Python\project_euler\problem_031\sol1.py,five_pence,35
2303,sol1.py::ten_pence::28,"def ten_pence(x: int) -> int:
    return 0 if x < 0 else ten_pence(x - 10) + five_pence(x)",data\repos\Python\project_euler\problem_031\sol1.py,ten_pence,35
2304,sol1.py::twenty_pence::32,"def twenty_pence(x: int) -> int:
    return 0 if x < 0 else twenty_pence(x - 20) + ten_pence(x)",data\repos\Python\project_euler\problem_031\sol1.py,twenty_pence,35
2305,sol1.py::fifty_pence::36,"def fifty_pence(x: int) -> int:
    return 0 if x < 0 else fifty_pence(x - 50) + twenty_pence(x)",data\repos\Python\project_euler\problem_031\sol1.py,fifty_pence,35
2306,sol1.py::one_pound::40,"def one_pound(x: int) -> int:
    return 0 if x < 0 else one_pound(x - 100) + fifty_pence(x)",data\repos\Python\project_euler\problem_031\sol1.py,one_pound,35
2307,sol1.py::two_pound::44,"def two_pound(x: int) -> int:
    return 0 if x < 0 else two_pound(x - 200) + one_pound(x)",data\repos\Python\project_euler\problem_031\sol1.py,two_pound,35
2308,sol1.py::solution::48,"def solution(n: int = 200) -> int:
    """"""Returns the number of different ways can n pence be made using any number of
    coins?

    >>> solution(500)
    6295434
    >>> solution(200)
    73682
    >>> solution(50)
    451
    >>> solution(10)
    11
    """"""
    return two_pound(n)",data\repos\Python\project_euler\problem_031\sol1.py,solution,86
2309,sol2.py::solution::35,"def solution(pence: int = 200) -> int:
    """"""Returns the number of different ways to make X pence using any number of coins.
    The solution is based on dynamic programming paradigm in a bottom-up fashion.

    >>> solution(500)
    6295434
    >>> solution(200)
    73682
    >>> solution(50)
    451
    >>> solution(10)
    11
    """"""
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    number_of_ways = [0] * (pence + 1)
    number_of_ways[0] = 1  # base case: 1 way to make 0 pence

    for coin in coins:
        for i in range(coin, pence + 1, 1):
            number_of_ways[i] += number_of_ways[i - coin]
    return number_of_ways[pence]",data\repos\Python\project_euler\problem_031\sol2.py,solution,210
2310,sol32.py::is_combination_valid::19,"def is_combination_valid(combination):
    """"""
    Checks if a combination (a tuple of 9 digits)
    is a valid product equation.

    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))
    True

    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))
    False

    """"""
    return (
        int("""".join(combination[0:2])) * int("""".join(combination[2:5]))
        == int("""".join(combination[5:9]))
    ) or (
        int("""".join(combination[0])) * int("""".join(combination[1:5]))
        == int("""".join(combination[5:9]))
    )",data\repos\Python\project_euler\problem_032\sol32.py,is_combination_valid,185
2311,sol32.py::solution::40,"def solution():
    """"""
    Finds the sum of all products whose multiplicand/multiplier/product identity
    can be written as a 1 through 9 pandigital

    >>> solution()
    45228
    """"""

    return sum(
        {
            int("""".join(pandigital[5:9]))
            for pandigital in itertools.permutations(""123456789"")
            if is_combination_valid(pandigital)
        }
    )",data\repos\Python\project_euler\problem_032\sol32.py,solution,92
2312,sol1.py::is_digit_cancelling::23,"def is_digit_cancelling(num: int, den: int) -> bool:
    return (
        num != den and num % 10 == den // 10 and (num // 10) / (den % 10) == num / den
    )",data\repos\Python\project_euler\problem_033\sol1.py,is_digit_cancelling,55
2313,sol1.py::fraction_list::29,"def fraction_list(digit_len: int) -> list[str]:
    """"""
    >>> fraction_list(2)
    ['16/64', '19/95', '26/65', '49/98']
    >>> fraction_list(3)
    ['16/64', '19/95', '26/65', '49/98']
    >>> fraction_list(4)
    ['16/64', '19/95', '26/65', '49/98']
    >>> fraction_list(0)
    []
    >>> fraction_list(5)
    ['16/64', '19/95', '26/65', '49/98']
    """"""
    solutions = []
    den = 11
    last_digit = int(""1"" + ""0"" * digit_len)
    for num in range(den, last_digit):
        while den <= 99:
            if (
                (num != den)
                and (num % 10 == den // 10)
                and (den % 10 != 0)
                and is_digit_cancelling(num, den)
            ):
                solutions.append(f""{num}/{den}"")
            den += 1
        num += 1
        den = 10
    return solutions",data\repos\Python\project_euler\problem_033\sol1.py,fraction_list,258
2314,sol1.py::solution::60,"def solution(n: int = 2) -> int:
    """"""
    Return the solution to the problem
    """"""
    result = 1.0
    for fraction in fraction_list(n):
        frac = Fraction(fraction)
        result *= frac.denominator / frac.numerator
    return int(result)",data\repos\Python\project_euler\problem_033\sol1.py,solution,63
2315,sol1.py::sum_of_digit_factorial::14,"def sum_of_digit_factorial(n: int) -> int:
    """"""
    Returns the sum of the factorial of digits in n
    >>> sum_of_digit_factorial(15)
    121
    >>> sum_of_digit_factorial(0)
    1
    """"""
    return sum(DIGIT_FACTORIAL[d] for d in str(n))",data\repos\Python\project_euler\problem_034\sol1.py,sum_of_digit_factorial,73
2316,sol1.py::solution::25,"def solution() -> int:
    """"""
    Returns the sum of all numbers whose
    sum of the factorials of all digits
    add up to the number itself.
    >>> solution()
    40730
    """"""
    limit = 7 * factorial(9) + 1
    return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)",data\repos\Python\project_euler\problem_034\sol1.py,solution,84
2317,sol1.py::is_prime::30,"def is_prime(n: int) -> bool:
    """"""
    For 2 <= n <= 1000000, return True if n is prime.
    >>> is_prime(87)
    False
    >>> is_prime(23)
    True
    >>> is_prime(25363)
    False
    """"""
    return sieve[n]",data\repos\Python\project_euler\problem_035\sol1.py,is_prime,69
2318,sol1.py::contains_an_even_digit::43,"def contains_an_even_digit(n: int) -> bool:
    """"""
    Return True if n contains an even digit.
    >>> contains_an_even_digit(0)
    True
    >>> contains_an_even_digit(975317933)
    False
    >>> contains_an_even_digit(-245679)
    True
    """"""
    return any(digit in ""02468"" for digit in str(n))",data\repos\Python\project_euler\problem_035\sol1.py,contains_an_even_digit,81
2319,sol1.py::find_circular_primes::56,"def find_circular_primes(limit: int = 1000000) -> list[int]:
    """"""
    Return circular primes below limit.
    >>> len(find_circular_primes(100))
    13
    >>> len(find_circular_primes(1000000))
    55
    """"""
    result = [2]  # result already includes the number 2.
    for num in range(3, limit + 1, 2):
        if is_prime(num) and not contains_an_even_digit(num):
            str_num = str(num)
            list_nums = [int(str_num[j:] + str_num[:j]) for j in range(len(str_num))]
            if all(is_prime(i) for i in list_nums):
                result.append(num)
    return result",data\repos\Python\project_euler\problem_035\sol1.py,find_circular_primes,160
2320,sol1.py::is_palindrome::21,"def is_palindrome(n: int | str) -> bool:
    """"""
    Return true if the input n is a palindrome.
    Otherwise return false. n can be an integer or a string.

    >>> is_palindrome(909)
    True
    >>> is_palindrome(908)
    False
    >>> is_palindrome('10101')
    True
    >>> is_palindrome('10111')
    False
    """"""
    n = str(n)
    return n == n[::-1]",data\repos\Python\project_euler\problem_036\sol1.py,is_palindrome,102
2321,sol1.py::solution::39,"def solution(n: int = 1000000):
    """"""Return the sum of all numbers, less than n , which are palindromic in
    base 10 and base 2.

    >>> solution(1000000)
    872187
    >>> solution(500000)
    286602
    >>> solution(100000)
    286602
    >>> solution(1000)
    1772
    >>> solution(100)
    157
    >>> solution(10)
    25
    >>> solution(2)
    1
    >>> solution(1)
    0
    """"""
    total = 0

    for i in range(1, n):
        if is_palindrome(i) and is_palindrome(bin(i).split(""b"")[1]):
            total += i
    return total",data\repos\Python\project_euler\problem_036\sol1.py,solution,176
2322,sol1.py::is_prime::20,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).

    A number is prime if it has exactly two factors: 1 and itself.

    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(87)
    False
    >>> is_prime(563)
    True
    >>> is_prime(2999)
    True
    >>> is_prime(67483)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_037\sol1.py,is_prime,277
2323,sol1.py::list_truncated_nums::59,"def list_truncated_nums(n: int) -> list[int]:
    """"""
    Returns a list of all left and right truncated numbers of n
    >>> list_truncated_nums(927628)
    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]
    >>> list_truncated_nums(467)
    [467, 67, 46, 7, 4]
    >>> list_truncated_nums(58)
    [58, 8, 5]
    """"""
    str_num = str(n)
    list_nums = [n]
    for i in range(1, len(str_num)):
        list_nums.append(int(str_num[i:]))
        list_nums.append(int(str_num[:-i]))
    return list_nums",data\repos\Python\project_euler\problem_037\sol1.py,list_truncated_nums,174
2324,sol1.py::validate::77,"def validate(n: int) -> bool:
    """"""
    To optimize the approach, we will rule out the numbers above 1000,
    whose first or last three digits are not prime
    >>> validate(74679)
    False
    >>> validate(235693)
    False
    >>> validate(3797)
    True
    """"""
    return not (
        len(str(n)) > 3
        and (not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])))
    )",data\repos\Python\project_euler\problem_037\sol1.py,validate,109
2325,sol1.py::compute_truncated_primes::94,"def compute_truncated_primes(count: int = 11) -> list[int]:
    """"""
    Returns the list of truncated primes
    >>> compute_truncated_primes(11)
    [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 739397]
    """"""
    list_truncated_primes: list[int] = []
    num = 13
    while len(list_truncated_primes) != count:
        if validate(num):
            list_nums = list_truncated_nums(num)
            if all(is_prime(i) for i in list_nums):
                list_truncated_primes.append(num)
        num += 2
    return list_truncated_primes",data\repos\Python\project_euler\problem_037\sol1.py,compute_truncated_primes,156
2326,sol1.py::solution::111,"def solution() -> int:
    """"""
    Returns the sum of truncated primes
    """"""
    return sum(compute_truncated_primes(11))",data\repos\Python\project_euler\problem_037\sol1.py,solution,30
2327,sol1.py::is_9_pandigital::44,"def is_9_pandigital(n: int) -> bool:
    """"""
    Checks whether n is a 9-digit 1 to 9 pandigital number.
    >>> is_9_pandigital(12345)
    False
    >>> is_9_pandigital(156284973)
    True
    >>> is_9_pandigital(1562849733)
    False
    """"""
    s = str(n)
    return len(s) == 9 and set(s) == set(""123456789"")",data\repos\Python\project_euler\problem_038\sol1.py,is_9_pandigital,109
2328,sol1.py::solution::58,"def solution() -> int | None:
    """"""
    Return the largest 1 to 9 pandigital 9-digital number that can be formed as the
    concatenated product of an integer with (1,2,...,n) where n > 1.
    """"""
    for base_num in range(9999, 4999, -1):
        candidate = 100002 * base_num
        if is_9_pandigital(candidate):
            return candidate

    for base_num in range(333, 99, -1):
        candidate = 1002003 * base_num
        if is_9_pandigital(candidate):
            return candidate

    return None",data\repos\Python\project_euler\problem_038\sol1.py,solution,140
2329,sol1.py::pythagorean_triple::17,"def pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:
    """"""
    Returns a dictionary with keys as the perimeter of a right angled triangle
    and value as the number of corresponding triplets.
    >>> pythagorean_triple(15)
    Counter({12: 1})
    >>> pythagorean_triple(40)
    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1})
    >>> pythagorean_triple(50)
    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})
    """"""
    triplets: typing.Counter[int] = Counter()
    for base in range(1, max_perimeter + 1):
        for perpendicular in range(base, max_perimeter + 1):
            hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5
            if hypotenuse == int(hypotenuse):
                perimeter = int(base + perpendicular + hypotenuse)
                if perimeter > max_perimeter:
                    continue
                triplets[perimeter] += 1
    return triplets",data\repos\Python\project_euler\problem_039\sol1.py,pythagorean_triple,265
2330,sol1.py::solution::40,"def solution(n: int = 1000) -> int:
    """"""
    Returns perimeter with maximum solutions.
    >>> solution(100)
    90
    >>> solution(200)
    180
    >>> solution(1000)
    840
    """"""
    triplets = pythagorean_triple(n)
    return triplets.most_common(1)[0][0]",data\repos\Python\project_euler\problem_039\sol1.py,solution,80
2331,sol1.py::solution::18,"def solution():
    """"""Returns

    >>> solution()
    210
    """"""
    constant = []
    i = 1

    while len(constant) < 1e6:
        constant.append(str(i))
        i += 1

    constant = """".join(constant)

    return (
        int(constant[0])
        * int(constant[9])
        * int(constant[99])
        * int(constant[999])
        * int(constant[9999])
        * int(constant[99999])
        * int(constant[999999])
    )",data\repos\Python\project_euler\problem_040\sol1.py,solution,122
2332,sol1.py::is_prime::20,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).

    A number is prime if it has exactly two factors: 1 and itself.

    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(87)
    False
    >>> is_prime(563)
    True
    >>> is_prime(2999)
    True
    >>> is_prime(67483)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_041\sol1.py,is_prime,277
2333,sol1.py::solution::59,"def solution(n: int = 7) -> int:
    """"""
    Returns the maximum pandigital prime number of length n.
    If there are none, then it will return 0.
    >>> solution(2)
    0
    >>> solution(4)
    4231
    >>> solution(7)
    7652413
    """"""
    pandigital_str = """".join(str(i) for i in range(1, n + 1))
    perm_list = [int("""".join(i)) for i in permutations(pandigital_str, n)]
    pandigitals = [num for num in perm_list if is_prime(num)]
    return max(pandigitals) if pandigitals else 0",data\repos\Python\project_euler\problem_041\sol1.py,solution,150
2334,solution42.py::solution::23,"def solution():
    """"""
    Finds the amount of triangular words in the words file.

    >>> solution()
    162
    """"""
    script_dir = os.path.dirname(os.path.realpath(__file__))
    words_file_path = os.path.join(script_dir, ""words.txt"")

    words = """"
    with open(words_file_path) as f:
        words = f.readline()

    words = [word.strip('""') for word in words.strip(""\r\n"").split("","")]
    words = [
        word
        for word in [sum(ord(x) - 64 for x in word) for word in words]
        if word in TRIANGULAR_NUMBERS
    ]
    return len(words)",data\repos\Python\project_euler\problem_042\solution42.py,solution,141
2335,sol1.py::is_substring_divisible::24,"def is_substring_divisible(num: tuple) -> bool:
    """"""
    Returns True if the pandigital number passes
    all the divisibility tests.
    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))
    False
    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))
    False
    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))
    True
    """"""
    if num[3] % 2 != 0:
        return False

    if (num[2] + num[3] + num[4]) % 3 != 0:
        return False

    if num[5] % 5 != 0:
        return False

    tests = [7, 11, 13, 17]
    for i, test in enumerate(tests):
        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:
            return False
    return True",data\repos\Python\project_euler\problem_043\sol1.py,is_substring_divisible,283
2336,sol1.py::solution::51,"def solution(n: int = 10) -> int:
    """"""
    Returns the sum of all pandigital numbers which pass the
    divisibility tests.
    >>> solution(10)
    16695334890
    """"""
    return sum(
        int("""".join(map(str, num)))
        for num in permutations(range(n))
        if is_substring_divisible(num)
    )",data\repos\Python\project_euler\problem_043\sol1.py,solution,80
2337,sol1.py::is_pentagonal::15,"def is_pentagonal(n: int) -> bool:
    """"""
    Returns True if n is pentagonal, False otherwise.
    >>> is_pentagonal(330)
    True
    >>> is_pentagonal(7683)
    False
    >>> is_pentagonal(2380)
    True
    """"""
    root = (1 + 24 * n) ** 0.5
    return ((1 + root) / 6) % 1 == 0",data\repos\Python\project_euler\problem_044\sol1.py,is_pentagonal,100
2338,sol1.py::solution::29,"def solution(limit: int = 5000) -> int:
    """"""
    Returns the minimum difference of two pentagonal numbers P1 and P2 such that
    P1 + P2 is pentagonal and P2 - P1 is pentagonal.
    >>> solution(5000)
    5482660
    """"""
    pentagonal_nums = [(i * (3 * i - 1)) // 2 for i in range(1, limit)]
    for i, pentagonal_i in enumerate(pentagonal_nums):
        for j in range(i, len(pentagonal_nums)):
            pentagonal_j = pentagonal_nums[j]
            a = pentagonal_i + pentagonal_j
            b = pentagonal_j - pentagonal_i
            if is_pentagonal(a) and is_pentagonal(b):
                return b

    return -1",data\repos\Python\project_euler\problem_044\sol1.py,solution,177
2339,sol1.py::hexagonal_num::17,"def hexagonal_num(n: int) -> int:
    """"""
    Returns nth hexagonal number
    >>> hexagonal_num(143)
    40755
    >>> hexagonal_num(21)
    861
    >>> hexagonal_num(10)
    190
    """"""
    return n * (2 * n - 1)",data\repos\Python\project_euler\problem_045\sol1.py,hexagonal_num,71
2340,sol1.py::is_pentagonal::30,"def is_pentagonal(n: int) -> bool:
    """"""
    Returns True if n is pentagonal, False otherwise.
    >>> is_pentagonal(330)
    True
    >>> is_pentagonal(7683)
    False
    >>> is_pentagonal(2380)
    True
    """"""
    root = (1 + 24 * n) ** 0.5
    return ((1 + root) / 6) % 1 == 0",data\repos\Python\project_euler\problem_045\sol1.py,is_pentagonal,100
2341,sol1.py::solution::44,"def solution(start: int = 144) -> int:
    """"""
    Returns the next number which is triangular, pentagonal and hexagonal.
    >>> solution(144)
    1533776805
    """"""
    n = start
    num = hexagonal_num(n)
    while not is_pentagonal(num):
        n += 1
        num = hexagonal_num(n)
    return num",data\repos\Python\project_euler\problem_045\sol1.py,solution,83
2342,sol1.py::is_prime::25,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).

    A number is prime if it has exactly two factors: 1 and itself.

    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(87)
    False
    >>> is_prime(563)
    True
    >>> is_prime(2999)
    True
    >>> is_prime(67483)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_046\sol1.py,is_prime,277
2343,sol1.py::compute_nums::67,"def compute_nums(n: int) -> list[int]:
    """"""
    Returns a list of first n odd composite numbers which do
    not follow the conjecture.
    >>> compute_nums(1)
    [5777]
    >>> compute_nums(2)
    [5777, 5993]
    >>> compute_nums(0)
    Traceback (most recent call last):
        ...
    ValueError: n must be >= 0
    >>> compute_nums(""a"")
    Traceback (most recent call last):
        ...
    ValueError: n must be an integer
    >>> compute_nums(1.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be an integer

    """"""
    if not isinstance(n, int):
        raise ValueError(""n must be an integer"")
    if n <= 0:
        raise ValueError(""n must be >= 0"")

    list_nums = []
    for num in range(len(odd_composites)):
        i = 0
        while 2 * i * i <= odd_composites[num]:
            rem = odd_composites[num] - 2 * i * i
            if is_prime(rem):
                break
            i += 1
        else:
            list_nums.append(odd_composites[num])
            if len(list_nums) == n:
                return list_nums

    return []",data\repos\Python\project_euler\problem_046\sol1.py,compute_nums,281
2344,sol1.py::unique_prime_factors::24,"def unique_prime_factors(n: int) -> set:
    """"""
    Find unique prime factors of an integer.
    Tests include sorting because only the set matters,
    not the order in which it is produced.
    >>> sorted(set(unique_prime_factors(14)))
    [2, 7]
    >>> sorted(set(unique_prime_factors(644)))
    [2, 7, 23]
    >>> sorted(set(unique_prime_factors(646)))
    [2, 17, 19]
    """"""
    i = 2
    factors = set()
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.add(i)
    if n > 1:
        factors.add(n)
    return factors",data\repos\Python\project_euler\problem_047\sol1.py,unique_prime_factors,160
2345,sol1.py::upf_len::50,"def upf_len(num: int) -> int:
    """"""
    Memoize upf() length results for a given value.
    >>> upf_len(14)
    2
    """"""
    return len(unique_prime_factors(num))",data\repos\Python\project_euler\problem_047\sol1.py,upf_len,48
2346,sol1.py::equality::59,"def equality(iterable: list) -> bool:
    """"""
    Check the equality of ALL elements in an iterable
    >>> equality([1, 2, 3, 4])
    False
    >>> equality([2, 2, 2, 2])
    True
    >>> equality([1, 2, 3, 2, 1])
    False
    """"""
    return len(set(iterable)) in (0, 1)",data\repos\Python\project_euler\problem_047\sol1.py,equality,96
2347,sol1.py::run::72,"def run(n: int) -> list[int]:
    """"""
    Runs core process to find problem solution.
    >>> run(3)
    [644, 645, 646]
    """"""

    # Incrementor variable for our group list comprehension.
    # This is the first number in each list of values
    # to test.
    base = 2

    while True:
        # Increment each value of a generated range
        group = [base + i for i in range(n)]

        # Run elements through the unique_prime_factors function
        # Append our target number to the end.
        checker = [upf_len(x) for x in group]
        checker.append(n)

        # If all numbers in the list are equal, return the group variable.
        if equality(checker):
            return group

        # Increment our base variable by 1
        base += 1",data\repos\Python\project_euler\problem_047\sol1.py,run,182
2348,sol1.py::solution::101,"def solution(n: int = 4) -> int | None:
    """"""Return the first value of the first four consecutive integers to have four
    distinct prime factors each.
    >>> solution()
    134043
    """"""
    results = run(n)
    return results[0] if len(results) else None",data\repos\Python\project_euler\problem_047\sol1.py,solution,65
2349,sol1.py::solution::11,"def solution():
    """"""
    Returns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.

    >>> solution()
    '9110846700'
    """"""
    total = 0
    for i in range(1, 1001):
        total += i**i
    return str(total)[-10:]",data\repos\Python\project_euler\problem_048\sol1.py,solution,85
2350,sol1.py::is_prime::32,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).

    A number is prime if it has exactly two factors: 1 and itself.

    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(87)
    False
    >>> is_prime(563)
    True
    >>> is_prime(2999)
    True
    >>> is_prime(67483)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_049\sol1.py,is_prime,277
2351,sol1.py::search::71,"def search(target: int, prime_list: list) -> bool:
    """"""
    function to search a number in a list using Binary Search.
    >>> search(3, [1, 2, 3])
    True
    >>> search(4, [1, 2, 3])
    False
    >>> search(101, list(range(-100, 100)))
    False
    """"""

    left, right = 0, len(prime_list) - 1
    while left <= right:
        middle = (left + right) // 2
        if prime_list[middle] == target:
            return True
        elif prime_list[middle] < target:
            left = middle + 1
        else:
            right = middle - 1

    return False",data\repos\Python\project_euler\problem_049\sol1.py,search,165
2352,sol1.py::solution::95,"def solution():
    """"""
    Return the solution of the problem.
    >>> solution()
    296962999629
    """"""
    prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]
    candidates = []

    for number in prime_list:
        tmp_numbers = []

        for prime_member in permutations(list(str(number))):
            prime = int("""".join(prime_member))

            if prime % 2 == 0:
                continue

            if search(prime, prime_list):
                tmp_numbers.append(prime)

        tmp_numbers.sort()
        if len(tmp_numbers) >= 3:
            candidates.append(tmp_numbers)

    passed = []
    for candidate in candidates:
        length = len(candidate)
        found = False

        for i in range(length):
            for j in range(i + 1, length):
                for k in range(j + 1, length):
                    if (
                        abs(candidate[i] - candidate[j])
                        == abs(candidate[j] - candidate[k])
                        and len({candidate[i], candidate[j], candidate[k]}) == 3
                    ):
                        passed.append(
                            sorted([candidate[i], candidate[j], candidate[k]])
                        )
                        found = True

                    if found:
                        break
                if found:
                    break
            if found:
                break

    answer = set()
    for seq in passed:
        answer.add("""".join([str(i) for i in seq]))

    return max(int(x) for x in answer)",data\repos\Python\project_euler\problem_049\sol1.py,solution,314
2353,sol1.py::prime_sieve::22,"def prime_sieve(limit: int) -> list[int]:
    """"""
    Sieve of Erotosthenes
    Function to return all the prime numbers up to a number 'limit'
    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

    >>> prime_sieve(3)
    [2]

    >>> prime_sieve(50)
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    """"""
    is_prime = [True] * limit
    is_prime[0] = False
    is_prime[1] = False
    is_prime[2] = True

    for i in range(3, int(limit**0.5 + 1), 2):
        index = i * 2
        while index < limit:
            is_prime[index] = False
            index = index + i

    primes = [2]

    for i in range(3, limit, 2):
        if is_prime[i]:
            primes.append(i)

    return primes",data\repos\Python\project_euler\problem_050\sol1.py,prime_sieve,242
2354,sol1.py::solution::54,"def solution(ceiling: int = 1_000_000) -> int:
    """"""
    Returns the biggest prime, below the celing, that can be written as the sum
    of consecutive the most consecutive primes.

    >>> solution(500)
    499

    >>> solution(1_000)
    953

    >>> solution(10_000)
    9521
    """"""
    primes = prime_sieve(ceiling)
    length = 0
    largest = 0

    for i in range(len(primes)):
        for j in range(i + length, len(primes)):
            sol = sum(primes[i:j])
            if sol >= ceiling:
                break

            if sol in primes:
                length = j - i
                largest = sol

    return largest",data\repos\Python\project_euler\problem_050\sol1.py,solution,167
2355,sol1.py::prime_sieve::24,"def prime_sieve(n: int) -> list[int]:
    """"""
    Sieve of Erotosthenes
    Function to return all the prime numbers up to a certain number
    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

    >>> prime_sieve(3)
    [2]

    >>> prime_sieve(50)
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    """"""
    is_prime = [True] * n
    is_prime[0] = False
    is_prime[1] = False
    is_prime[2] = True

    for i in range(3, int(n**0.5 + 1), 2):
        index = i * 2
        while index < n:
            is_prime[index] = False
            index = index + i

    primes = [2]

    for i in range(3, n, 2):
        if is_prime[i]:
            primes.append(i)

    return primes",data\repos\Python\project_euler\problem_051\sol1.py,prime_sieve,241
2356,sol1.py::digit_replacements::56,"def digit_replacements(number: int) -> list[list[int]]:
    """"""
    Returns all the possible families of digit replacements in a number which
    contains at least one repeating digit

    >>> digit_replacements(544)
    [[500, 511, 522, 533, 544, 555, 566, 577, 588, 599]]

    >>> digit_replacements(3112)
    [[3002, 3112, 3222, 3332, 3442, 3552, 3662, 3772, 3882, 3992]]
    """"""
    number_str = str(number)
    replacements = []
    digits = [""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""]

    for duplicate in Counter(number_str) - Counter(set(number_str)):
        family = [int(number_str.replace(duplicate, digit)) for digit in digits]
        replacements.append(family)

    return replacements",data\repos\Python\project_euler\problem_051\sol1.py,digit_replacements,213
2357,sol1.py::solution::78,"def solution(family_length: int = 8) -> int:
    """"""
    Returns the solution of the problem

    >>> solution(2)
    229399

    >>> solution(3)
    221311
    """"""
    numbers_checked = set()

    # Filter primes with less than 3 replaceable digits
    primes = {
        x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3
    }

    for prime in primes:
        if prime in numbers_checked:
            continue

        replacements = digit_replacements(prime)

        for family in replacements:
            numbers_checked.update(family)
            primes_in_family = primes.intersection(family)

            if len(primes_in_family) != family_length:
                continue

            return min(primes_in_family)

    return -1",data\repos\Python\project_euler\problem_051\sol1.py,solution,180
2358,sol1.py::solution::13,"def solution():
    """"""Returns the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and
    6x, contain the same digits.

    >>> solution()
    142857
    """"""
    i = 1

    while True:
        if (
            sorted(str(i))
            == sorted(str(2 * i))
            == sorted(str(3 * i))
            == sorted(str(4 * i))
            == sorted(str(5 * i))
            == sorted(str(6 * i))
        ):
            return i

        i += 1",data\repos\Python\project_euler\problem_052\sol1.py,solution,128
2359,sol1.py::solution::27,"def solution():
    """"""Returns the number of values of nCr, for 1  n  100, are greater than
    one-million

    >>> solution()
    4075
    """"""
    total = 0

    for i in range(1, 101):
        for j in range(1, i + 1):
            if combinations(i, j) > 1e6:
                total += 1
    return total",data\repos\Python\project_euler\problem_053\sol1.py,solution,94
2360,sol1.py::solution::366,"def solution() -> int:
    # Solution for problem number 54 from Project Euler
    # Input from poker_hands.txt file
    answer = 0
    script_dir = os.path.abspath(os.path.dirname(__file__))
    poker_hands = os.path.join(script_dir, ""poker_hands.txt"")
    with open(poker_hands) as file_hand:
        for line in file_hand:
            player_hand = line[:14].strip()
            opponent_hand = line[15:].strip()
            player, opponent = PokerHand(player_hand), PokerHand(opponent_hand)
            output = player.compare_with(opponent)
            if output == ""Win"":
                answer += 1
    return answer",data\repos\Python\project_euler\problem_054\sol1.py,solution,145
2361,sol1.py::compare_with::141,"    def compare_with(self, other: PokerHand) -> str:
        """"""
        Determines the outcome of comparing self hand with other hand.
        Returns the output as 'Win', 'Loss', 'Tie' according to the rules of
        Texas Hold'em.

        Here are some examples:
        >>> player = PokerHand(""2H 3H 4H 5H 6H"")  # Stright flush
        >>> opponent = PokerHand(""KS AS TS QS JS"")  # Royal flush
        >>> player.compare_with(opponent)
        'Loss'

        >>> player = PokerHand(""2S AH 2H AS AC"")  # Full house
        >>> opponent = PokerHand(""2H 3H 5H 6H 7H"")  # Flush
        >>> player.compare_with(opponent)
        'Win'

        >>> player = PokerHand(""2S AH 4H 5S 6C"")  # High card
        >>> opponent = PokerHand(""AD 4C 5H 6H 2C"")  # High card
        >>> player.compare_with(opponent)
        'Tie'
        """"""
        # Breaking the tie works on the following order of precedence:
        # 1. First pair (default 0)
        # 2. Second pair (default 0)
        # 3. Compare all cards in reverse order because they are sorted.

        # First pair and second pair will only be a non-zero value if the card
        # type is either from the following:
        # 21: Four of a kind
        # 20: Full house
        # 17: Three of a kind
        # 16: Two pairs
        # 15: One pair
        if self._hand_type > other._hand_type:
            return ""Win""
        elif self._hand_type < other._hand_type:
            return ""Loss""
        elif self._first_pair == other._first_pair:
            if self._second_pair == other._second_pair:
                return self._compare_cards(other)
            else:
                return ""Win"" if self._second_pair > other._second_pair else ""Loss""
        return ""Win"" if self._first_pair > other._first_pair else ""Loss""",data\repos\Python\project_euler\problem_054\sol1.py,compare_with,474
2362,sol1.py::hand_name::187,"    def hand_name(self) -> str:
        """"""
        Return the name of the hand in the following format:
        'hand name, high card'

        Here are some examples:
        >>> PokerHand(""KS AS TS QS JS"").hand_name()
        'Royal flush'

        >>> PokerHand(""2D 6D 3D 4D 5D"").hand_name()
        'Straight flush, Six-high'

        >>> PokerHand(""JC 6H JS JD JH"").hand_name()
        'Four of a kind, Jacks'

        >>> PokerHand(""3D 2H 3H 2C 2D"").hand_name()
        'Full house, Twos over Threes'

        >>> PokerHand(""2H 4D 3C AS 5S"").hand_name()  # Low ace
        'Straight, Five-high'

        Source: https://en.wikipedia.org/wiki/List_of_poker_hands
        """"""
        name = PokerHand._HAND_NAME[self._hand_type - 14]
        high = PokerHand._CARD_NAME[self._high_card]
        pair1 = PokerHand._CARD_NAME[self._first_pair]
        pair2 = PokerHand._CARD_NAME[self._second_pair]
        if self._hand_type in [22, 19, 18]:
            return name + f"", {high}-high""
        elif self._hand_type in [21, 17, 15]:
            return name + f"", {pair1}s""
        elif self._hand_type in [20, 16]:
            join = ""over"" if self._hand_type == 20 else ""and""
            return name + f"", {pair1}s {join} {pair2}s""
        elif self._hand_type == 23:
            return name
        else:
            return name + f"", {high}""",data\repos\Python\project_euler\problem_054\sol1.py,hand_name,385
2363,test_poker_hand.py::generate_random_hand::139,"def generate_random_hand():
    play, oppo = randrange(len(SORTED_HANDS)), randrange(len(SORTED_HANDS))
    expected = [""Loss"", ""Tie"", ""Win""][(play >= oppo) + (play > oppo)]
    hand, other = SORTED_HANDS[play], SORTED_HANDS[oppo]
    return hand, other, expected",data\repos\Python\project_euler\problem_054\test_poker_hand.py,generate_random_hand,82
2364,test_poker_hand.py::generate_random_hands::146,"def generate_random_hands(number_of_hands: int = 100):
    return (generate_random_hand() for _ in range(number_of_hands))",data\repos\Python\project_euler\problem_054\test_poker_hand.py,generate_random_hands,31
2365,test_poker_hand.py::test_hand_is_five_high_straight::161,"def test_hand_is_five_high_straight(hand, expected, card_values):
    player = PokerHand(hand)
    assert player._is_five_high_straight() == expected
    assert player._card_values == card_values",data\repos\Python\project_euler\problem_054\test_poker_hand.py,test_hand_is_five_high_straight,44
2366,test_poker_hand.py::test_hand_sorted::187,"def test_hand_sorted():
    poker_hands = [PokerHand(hand) for hand in SORTED_HANDS]
    list_copy = poker_hands.copy()
    shuffle(list_copy)
    user_sorted = chain(sorted(list_copy))
    for index, hand in enumerate(user_sorted):
        assert hand == poker_hands[index]",data\repos\Python\project_euler\problem_054\test_poker_hand.py,test_hand_sorted,66
2367,test_poker_hand.py::test_custom_sort_five_high_straight::196,"def test_custom_sort_five_high_straight():
    # Test that five high straights are compared correctly.
    pokerhands = [PokerHand(""2D AC 3H 4H 5S""), PokerHand(""2S 3H 4H 5S 6C"")]
    pokerhands.sort(reverse=True)
    assert pokerhands[0].__str__() == ""2S 3H 4H 5S 6C""",data\repos\Python\project_euler\problem_054\test_poker_hand.py,test_custom_sort_five_high_straight,96
2368,test_poker_hand.py::test_multiple_calls_five_high_straight::203,"def test_multiple_calls_five_high_straight():
    # Multiple calls to five_high_straight function should still return True
    # and shouldn't mutate the list in every call other than the first.
    pokerhand = PokerHand(""2C 4S AS 3D 5C"")
    expected = True
    expected_card_values = [5, 4, 3, 2, 14]
    for _ in range(10):
        assert pokerhand._is_five_high_straight() == expected
        assert pokerhand._card_values == expected_card_values",data\repos\Python\project_euler\problem_054\test_poker_hand.py,test_multiple_calls_five_high_straight,118
2369,test_poker_hand.py::test_euler_project::214,"def test_euler_project():
    # Problem number 54 from Project Euler
    # Testing from poker_hands.txt file
    answer = 0
    script_dir = os.path.abspath(os.path.dirname(__file__))
    poker_hands = os.path.join(script_dir, ""poker_hands.txt"")
    with open(poker_hands) as file_hand:
        for line in file_hand:
            player_hand = line[:14].strip()
            opponent_hand = line[15:].strip()
            player, opponent = PokerHand(player_hand), PokerHand(opponent_hand)
            output = player.compare_with(opponent)
            if output == ""Win"":
                answer += 1
    assert answer == 376",data\repos\Python\project_euler\problem_054\test_poker_hand.py,test_euler_project,146
2370,sol1.py::is_palindrome::30,"def is_palindrome(n: int) -> bool:
    """"""
    Returns True if a number is palindrome.
    >>> is_palindrome(12567321)
    False
    >>> is_palindrome(1221)
    True
    >>> is_palindrome(9876789)
    True
    """"""
    return str(n) == str(n)[::-1]",data\repos\Python\project_euler\problem_055\sol1.py,is_palindrome,74
2371,sol1.py::sum_reverse::43,"def sum_reverse(n: int) -> int:
    """"""
    Returns the sum of n and reverse of n.
    >>> sum_reverse(123)
    444
    >>> sum_reverse(3478)
    12221
    >>> sum_reverse(12)
    33
    """"""
    return int(n) + int(str(n)[::-1])",data\repos\Python\project_euler\problem_055\sol1.py,sum_reverse,73
2372,sol1.py::solution::56,"def solution(limit: int = 10000) -> int:
    """"""
    Returns the count of all lychrel numbers below limit.
    >>> solution(10000)
    249
    >>> solution(5000)
    76
    >>> solution(1000)
    13
    """"""
    lychrel_nums = []
    for num in range(1, limit):
        iterations = 0
        a = num
        while iterations < 50:
            num = sum_reverse(num)
            iterations += 1
            if is_palindrome(num):
                break
        else:
            lychrel_nums.append(a)
    return len(lychrel_nums)",data\repos\Python\project_euler\problem_055\sol1.py,solution,141
2373,sol1.py::solution::13,"def solution(a: int = 100, b: int = 100) -> int:
    """"""
    Considering natural numbers of the form, a**b, where a, b < 100,
    what is the maximum digital sum?
    :param a:
    :param b:
    :return:
    >>> solution(10,10)
    45

    >>> solution(100,100)
    972

    >>> solution(100,200)
    1872
    """"""

    # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of
    # BASE raised to the POWER
    return max(
        sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)
    )",data\repos\Python\project_euler\problem_056\sol1.py,solution,163
2374,sol1.py::solution::23,"def solution(n: int = 1000) -> int:
    """"""
    returns number of fractions containing a numerator with more digits than
    the denominator in the first n expansions.
    >>> solution(14)
    2
    >>> solution(100)
    15
    >>> solution(10000)
    1508
    """"""
    prev_numerator, prev_denominator = 1, 1
    result = []
    for i in range(1, n + 1):
        numerator = prev_numerator + 2 * prev_denominator
        denominator = prev_numerator + prev_denominator
        if len(str(numerator)) > len(str(denominator)):
            result.append(i)
        prev_numerator = numerator
        prev_denominator = denominator

    return len(result)",data\repos\Python\project_euler\problem_057\sol1.py,solution,166
2375,sol1.py::is_prime::40,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).

    A number is prime if it has exactly two factors: 1 and itself.

    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(87)
    False
    >>> is_prime(563)
    True
    >>> is_prime(2999)
    True
    >>> is_prime(67483)
    False
    """"""

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or number % 2 == 0 or number % 3 == 0:
        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes
        return False

    # All primes number are in format of 6k +/- 1
    for i in range(5, int(math.sqrt(number) + 1), 6):
        if number % i == 0 or number % (i + 2) == 0:
            return False
    return True",data\repos\Python\project_euler\problem_058\sol1.py,is_prime,277
2376,sol1.py::solution::79,"def solution(ratio: float = 0.1) -> int:
    """"""
    Returns the side length of the square spiral of odd length greater
    than 1 for which the ratio of primes along both diagonals
    first falls below the given ratio.
    >>> solution(.5)
    11
    >>> solution(.2)
    309
    >>> solution(.111)
    11317
    """"""

    j = 3
    primes = 3

    while primes / (2 * j - 1) >= ratio:
        for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):
            primes += is_prime(i)
        j += 2
    return j",data\repos\Python\project_euler\problem_058\sol1.py,solution,162
2377,sol1.py::try_key::44,"def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:
    """"""
    Given an encrypted message and a possible 3-character key, decrypt the message.
    If the decrypted message contains a invalid character, i.e. not an ASCII letter,
    a digit, punctuation or whitespace, then we know the key is incorrect, so return
    None.
    >>> try_key([0, 17, 20, 4, 27], (104, 116, 120))
    'hello'
    >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None
    True
    """"""
    decoded: str = """"
    keychar: int
    cipherchar: int
    decodedchar: int

    for keychar, cipherchar in zip(cycle(key), ciphertext):
        decodedchar = cipherchar ^ keychar
        if decodedchar not in VALID_INTS:
            return None
        decoded += chr(decodedchar)

    return decoded",data\repos\Python\project_euler\problem_059\sol1.py,try_key,221
2378,sol1.py::filter_valid_chars::69,"def filter_valid_chars(ciphertext: list[int]) -> list[str]:
    """"""
    Given an encrypted message, test all 3-character strings to try and find the
    key. Return a list of the possible decrypted messages.
    >>> from itertools import cycle
    >>> text = ""The enemy's gate is down""
    >>> key = ""end""
    >>> encoded = [ord(k) ^ ord(c) for k,c in zip(cycle(key), text)]
    >>> text in filter_valid_chars(encoded)
    True
    """"""
    possibles: list[str] = []
    for key in product(LOWERCASE_INTS, repeat=3):
        encoded = try_key(ciphertext, key)
        if encoded is not None:
            possibles.append(encoded)
    return possibles",data\repos\Python\project_euler\problem_059\sol1.py,filter_valid_chars,161
2379,sol1.py::filter_common_word::88,"def filter_common_word(possibles: list[str], common_word: str) -> list[str]:
    """"""
    Given a list of possible decoded messages, narrow down the possibilities
    for checking for the presence of a specified common word. Only decoded messages
    containing common_word will be returned.
    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')
    ['I am here']
    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')
    ['athla amf', 'I am here']
    """"""
    return [possible for possible in possibles if common_word in possible.lower()]",data\repos\Python\project_euler\problem_059\sol1.py,filter_common_word,149
2380,sol1.py::solution::101,"def solution(filename: str = ""p059_cipher.txt"") -> int:
    """"""
    Test the ciphertext against all possible 3-character keys, then narrow down the
    possibilities by filtering using common words until there's only one possible
    decoded message.
    >>> solution(""test_cipher.txt"")
    3000
    """"""
    ciphertext: list[int]
    possibles: list[str]
    common_word: str
    decoded_text: str
    data: str = Path(__file__).parent.joinpath(filename).read_text(encoding=""utf-8"")

    ciphertext = [int(number) for number in data.strip().split("","")]

    possibles = filter_valid_chars(ciphertext)
    for common_word in COMMON_WORDS:
        possibles = filter_common_word(possibles, common_word)
        if len(possibles) == 1:
            break

    decoded_text = possibles[0]
    return sum(ord(char) for char in decoded_text)",data\repos\Python\project_euler\problem_059\sol1.py,solution,197
2381,sol1.py::solution::16,"def solution(max_base: int = 5) -> int:
    """"""
    Iterate through every possible cube and sort the cube's digits in
    ascending order. Sorting maintains an ordering of the digits that allows
    you to compare permutations. Store each sorted sequence of digits in a
    dictionary, whose key is the sequence of digits and value is a list of
    numbers that are the base of the cube.

    Once you find 5 numbers that produce the same sequence of digits, return
    the smallest one, which is at index 0 since we insert each base number in
    ascending order.

    >>> solution(2)
    125
    >>> solution(3)
    41063625
    """"""
    freqs = defaultdict(list)
    num = 0

    while True:
        digits = get_digits(num)
        freqs[digits].append(num)

        if len(freqs[digits]) == max_base:
            base = freqs[digits][0] ** 3
            return base

        num += 1",data\repos\Python\project_euler\problem_062\sol1.py,solution,217
2382,sol1.py::get_digits::47,"def get_digits(num: int) -> str:
    """"""
    Computes the sorted sequence of digits of the cube of num.

    >>> get_digits(3)
    '27'
    >>> get_digits(99)
    '027999'
    >>> get_digits(123)
    '0166788'
    """"""
    return """".join(sorted(str(num**3)))",data\repos\Python\project_euler\problem_062\sol1.py,get_digits,73
2383,sol1.py::solution::14,"def solution(max_base: int = 10, max_power: int = 22) -> int:
    """"""
    Returns the count of all n-digit numbers which are nth power
    >>> solution(10, 22)
    49
    >>> solution(0, 0)
    0
    >>> solution(1, 1)
    0
    >>> solution(-1, -1)
    0
    """"""
    bases = range(1, max_base)
    powers = range(1, max_power)
    return sum(
        1 for power in powers for base in bases if len(str(base**power)) == power
    )",data\repos\Python\project_euler\problem_063\sol1.py,solution,138
2384,sol1.py::continuous_fraction_period::19,"def continuous_fraction_period(n: int) -> int:
    """"""
    Returns the continued fraction period of a number n.

    >>> continuous_fraction_period(2)
    1
    >>> continuous_fraction_period(5)
    1
    >>> continuous_fraction_period(7)
    4
    >>> continuous_fraction_period(11)
    2
    >>> continuous_fraction_period(13)
    5
    """"""
    numerator = 0.0
    denominator = 1.0
    root = int(sqrt(n))
    integer_part = root
    period = 0
    while integer_part != 2 * root:
        numerator = denominator * integer_part - numerator
        denominator = (n - numerator**2) / denominator
        integer_part = int((root + numerator) / denominator)
        period += 1
    return period",data\repos\Python\project_euler\problem_064\sol1.py,continuous_fraction_period,176
2385,sol1.py::solution::47,"def solution(n: int = 10000) -> int:
    """"""
    Returns the count of numbers <= 10000 with odd periods.
    This function calls continuous_fraction_period for numbers which are
    not perfect squares.
    This is checked in if sr - floor(sr) != 0 statement.
    If an odd period is returned by continuous_fraction_period,
    count_odd_periods is increased by 1.

    >>> solution(2)
    1
    >>> solution(5)
    2
    >>> solution(7)
    2
    >>> solution(11)
    3
    >>> solution(13)
    4
    """"""
    count_odd_periods = 0
    for i in range(2, n + 1):
        sr = sqrt(i)
        if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:
            count_odd_periods += 1
    return count_odd_periods",data\repos\Python\project_euler\problem_064\sol1.py,solution,199
2386,sol1.py::sum_digits::56,"def sum_digits(num: int) -> int:
    """"""
    Returns the sum of every digit in num.

    >>> sum_digits(1)
    1
    >>> sum_digits(12345)
    15
    >>> sum_digits(999001)
    28
    """"""
    digit_sum = 0
    while num > 0:
        digit_sum += num % 10
        num //= 10
    return digit_sum",data\repos\Python\project_euler\problem_065\sol1.py,sum_digits,92
2387,sol1.py::solution::74,"def solution(max_n: int = 100) -> int:
    """"""
    Returns the sum of the digits in the numerator of the max-th convergent of
    the continued fraction for e.

    >>> solution(9)
    13
    >>> solution(10)
    17
    >>> solution(50)
    91
    """"""
    pre_numerator = 1
    cur_numerator = 2

    for i in range(2, max_n + 1):
        temp = pre_numerator
        e_cont = 2 * i // 3 if i % 3 == 0 else 1
        pre_numerator = cur_numerator
        cur_numerator = e_cont * pre_numerator + temp

    return sum_digits(cur_numerator)",data\repos\Python\project_euler\problem_065\sol1.py,solution,163
2388,sol1.py::solution::18,"def solution():
    """"""
    Finds the maximum total in a triangle as described by the problem statement
    above.

    >>> solution()
    7273
    """"""
    script_dir = os.path.dirname(os.path.realpath(__file__))
    triangle = os.path.join(script_dir, ""triangle.txt"")

    with open(triangle) as f:
        triangle = f.readlines()

    a = []
    for line in triangle:
        numbers_from_line = []
        for number in line.strip().split("" ""):
            numbers_from_line.append(int(number))
        a.append(numbers_from_line)

    for i in range(1, len(a)):
        for j in range(len(a[i])):
            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0
            number2 = a[i - 1][j - 1] if j > 0 else 0
            a[i][j] += max(number1, number2)
    return max(a[-1])",data\repos\Python\project_euler\problem_067\sol1.py,solution,208
2389,sol2.py::solution::18,"def solution() -> int:
    """"""
    Finds the maximum total in a triangle as described by the problem statement
    above.
    >>> solution()
    7273
    """"""
    script_dir = os.path.dirname(os.path.realpath(__file__))
    triangle_path = os.path.join(script_dir, ""triangle.txt"")

    with open(triangle_path) as in_file:
        triangle = [[int(i) for i in line.split()] for line in in_file]

    while len(triangle) != 1:
        last_row = triangle.pop()
        curr_row = triangle[-1]
        for j in range(len(last_row) - 1):
            curr_row[j] += max(last_row[j], last_row[j + 1])
    return triangle[0][0]",data\repos\Python\project_euler\problem_067\sol2.py,solution,158
2390,sol1.py::solution::46,"def solution(gon_side: int = 5) -> int:
    """"""
    Find the maximum number for a ""magic"" gon_side-gon ring

    The gon_side parameter should be in the range [3, 5],
    other side numbers aren't tested

    >>> solution(3)
    432621513
    >>> solution(4)
    426561813732
    >>> solution()
    6531031914842725
    >>> solution(6)
    Traceback (most recent call last):
    ValueError: gon_side must be in the range [3, 5]
    """"""
    if gon_side < 3 or gon_side > 5:
        raise ValueError(""gon_side must be in the range [3, 5]"")

    # Since it's 16, we know 10 is on the outer ring
    # Put the big numbers at the end so that they are never the first number
    small_numbers = list(range(gon_side + 1, 0, -1))
    big_numbers = list(range(gon_side + 2, gon_side * 2 + 1))

    for perm in permutations(small_numbers + big_numbers):
        numbers = generate_gon_ring(gon_side, list(perm))
        if is_magic_gon(numbers):
            return int("""".join(str(n) for n in numbers))

    msg = f""Magic {gon_side}-gon ring is impossible""
    raise ValueError(msg)",data\repos\Python\project_euler\problem_068\sol1.py,solution,305
2391,sol1.py::generate_gon_ring::80,"def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:
    """"""
    Generate a gon_side-gon ring from a permutation state
    The permutation state is the ring, but every duplicate is removed

    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])
    [4, 2, 3, 5, 3, 1, 6, 1, 2]
    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])
    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]
    """"""
    result = [0] * (gon_side * 3)
    result[0:3] = perm[0:3]
    perm.append(perm[1])

    magic_number = 1 if gon_side < 5 else 2

    for i in range(1, len(perm) // 3 + magic_number):
        result[3 * i] = perm[2 * i + 1]
        result[3 * i + 1] = result[3 * i - 1]
        result[3 * i + 2] = perm[2 * i + 2]

    return result",data\repos\Python\project_euler\problem_068\sol1.py,generate_gon_ring,322
2392,sol1.py::is_magic_gon::104,"def is_magic_gon(numbers: list[int]) -> bool:
    """"""
    Check if the solution set is a magic n-gon ring
    Check that the first number is the smallest number on the outer ring
    Take a list, and check if the sum of each 3 numbers chunk is equal to the same total

    >>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2])
    True
    >>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3])
    True
    >>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3])
    True
    >>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9])
    False
    >>> is_magic_gon([1])
    Traceback (most recent call last):
    ValueError: a gon ring should have a length that is a multiple of 3
    """"""
    if len(numbers) % 3 != 0:
        raise ValueError(""a gon ring should have a length that is a multiple of 3"")

    if min(numbers[::3]) != numbers[0]:
        return False

    total = sum(numbers[:3])

    return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))",data\repos\Python\project_euler\problem_068\sol1.py,is_magic_gon,332
2393,sol1.py::solution::27,"def solution(n: int = 10**6) -> int:
    """"""
    Returns solution to problem.
    Algorithm:
    1. Precompute (k) for all natural k, k <= n using product formula (wikilink below)
    https://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler's_product_formula

    2. Find k/(k) for all k  n and return the k that attains maximum

    >>> solution(10)
    6

    >>> solution(100)
    30

    >>> solution(9973)
    2310

    """"""

    if n <= 0:
        raise ValueError(""Please enter an integer greater than 0"")

    phi = list(range(n + 1))
    for number in range(2, n + 1):
        if phi[number] == number:
            phi[number] -= 1
            for multiple in range(number * 2, n + 1, number):
                phi[multiple] = (phi[multiple] // number) * (number - 1)

    answer = 1
    for number in range(1, n + 1):
        if (answer / phi[answer]) < (number / phi[number]):
            answer = number

    return answer",data\repos\Python\project_euler\problem_069\sol1.py,solution,271
2394,sol1.py::get_totients::37,"def get_totients(max_one: int) -> list[int]:
    """"""
    Calculates a list of totients from 0 to max_one exclusive, using the
    definition of Euler's product formula.

    >>> get_totients(5)
    [0, 1, 1, 2, 2]

    >>> get_totients(10)
    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]
    """"""
    totients = np.arange(max_one)

    for i in range(2, max_one):
        if totients[i] == i:
            x = np.arange(i, max_one, i)  # array of indexes to select
            totients[x] -= totients[x] // i

    return totients.tolist()",data\repos\Python\project_euler\problem_070\sol1.py,get_totients,174
2395,sol1.py::has_same_digits::58,"def has_same_digits(num1: int, num2: int) -> bool:
    """"""
    Return True if num1 and num2 have the same frequency of every digit, False
    otherwise.

    >>> has_same_digits(123456789, 987654321)
    True

    >>> has_same_digits(123, 23)
    False

    >>> has_same_digits(1234566, 123456)
    False
    """"""
    return sorted(str(num1)) == sorted(str(num2))",data\repos\Python\project_euler\problem_070\sol1.py,has_same_digits,105
2396,sol1.py::solution::75,"def solution(max_n: int = 10000000) -> int:
    """"""
    Finds the value of n from 1 to max such that n/(n) produces a minimum.

    >>> solution(100)
    21

    >>> solution(10000)
    4435
    """"""

    min_numerator = 1  # i
    min_denominator = 0  # (i)
    totients = get_totients(max_n + 1)

    for i in range(2, max_n + 1):
        t = totients[i]

        if i * min_denominator < min_numerator * t and has_same_digits(i, t):
            min_numerator = i
            min_denominator = t

    return min_numerator",data\repos\Python\project_euler\problem_070\sol1.py,solution,160
2397,sol1.py::solution::22,"def solution(numerator: int = 3, denominator: int = 7, limit: int = 1000000) -> int:
    """"""
    Returns the closest numerator of the fraction immediately to the
    left of given fraction (numerator/denominator) from a list of reduced
    proper fractions.
    >>> solution()
    428570
    >>> solution(3, 7, 8)
    2
    >>> solution(6, 7, 60)
    47
    """"""
    max_numerator = 0
    max_denominator = 1

    for current_denominator in range(1, limit + 1):
        current_numerator = current_denominator * numerator // denominator
        if current_denominator % denominator == 0:
            current_numerator -= 1
        if current_numerator * max_denominator > current_denominator * max_numerator:
            max_numerator = current_numerator
            max_denominator = current_denominator
    return max_numerator",data\repos\Python\project_euler\problem_071\sol1.py,solution,212
2398,sol1.py::solution::27,"def solution(limit: int = 1_000_000) -> int:
    """"""
    Returns an integer, the solution to the problem
    >>> solution(10)
    31
    >>> solution(100)
    3043
    >>> solution(1_000)
    304191
    """"""

    # generating an array from -1 to limit
    phi = np.arange(-1, limit)

    for i in range(2, limit + 1):
        if phi[i] == i - 1:
            ind = np.arange(2 * i, limit + 1, i)  # indexes for selection
            phi[ind] -= phi[ind] // i

    return int(np.sum(phi[2 : limit + 1]))",data\repos\Python\project_euler\problem_072\sol1.py,solution,158
2399,sol2.py::solution::20,"def solution(limit: int = 1000000) -> int:
    """"""
    Return the number of reduced proper fractions with denominator less than limit.
    >>> solution(8)
    21
    >>> solution(1000)
    304191
    """"""
    primes = set(range(3, limit, 2))
    primes.add(2)
    for p in range(3, limit, 2):
        if p not in primes:
            continue
        primes.difference_update(set(range(p * p, limit, p)))

    phi = [float(n) for n in range(limit + 1)]

    for p in primes:
        for n in range(p, limit + 1, p):
            phi[n] *= 1 - 1 / p

    return int(sum(phi[2:]))",data\repos\Python\project_euler\problem_072\sol2.py,solution,169
2400,sol1.py::solution::22,"def solution(max_d: int = 12_000) -> int:
    """"""
    Returns number of fractions lie between 1/3 and 1/2 in the sorted set
    of reduced proper fractions for d  max_d

    >>> solution(4)
    0

    >>> solution(5)
    1

    >>> solution(8)
    3
    """"""

    fractions_number = 0
    for d in range(max_d + 1):
        n_start = d // 3 + 1
        n_step = 1
        if d % 2 == 0:
            n_start += 1 - n_start % 2
            n_step = 2
        for n in range(n_start, (d + 1) // 2, n_step):
            if gcd(n, d) == 1:
                fractions_number += 1
    return fractions_number",data\repos\Python\project_euler\problem_073\sol1.py,solution,191
2401,sol1.py::sum_digit_factorials::56,"def sum_digit_factorials(n: int) -> int:
    """"""
    Return the sum of the factorial of the digits of n.
    >>> sum_digit_factorials(145)
    145
    >>> sum_digit_factorials(45361)
    871
    >>> sum_digit_factorials(540)
    145
    """"""
    if n in CACHE_SUM_DIGIT_FACTORIALS:
        return CACHE_SUM_DIGIT_FACTORIALS[n]
    ret = sum(DIGIT_FACTORIALS[let] for let in str(n))
    CACHE_SUM_DIGIT_FACTORIALS[n] = ret
    return ret",data\repos\Python\project_euler\problem_074\sol1.py,sum_digit_factorials,127
2402,sol1.py::chain_length::73,"def chain_length(n: int, previous: set | None = None) -> int:
    """"""
    Calculate the length of the chain of non-repeating terms starting with n.
    Previous is a set containing the previous member of the chain.
    >>> chain_length(10101)
    11
    >>> chain_length(555)
    20
    >>> chain_length(178924)
    39
    """"""
    previous = previous or set()
    if n in CHAIN_LENGTH_CACHE:
        return CHAIN_LENGTH_CACHE[n]
    next_number = sum_digit_factorials(n)
    if next_number in previous:
        CHAIN_LENGTH_CACHE[n] = 0
        return 0
    else:
        previous.add(n)
        ret = 1 + chain_length(next_number, previous)
        CHAIN_LENGTH_CACHE[n] = ret
        return ret",data\repos\Python\project_euler\problem_074\sol1.py,chain_length,177
2403,sol1.py::solution::98,"def solution(num_terms: int = 60, max_start: int = 1000000) -> int:
    """"""
    Return the number of chains with a starting number below one million which
    contain exactly n non-repeating terms.
    >>> solution(10,1000)
    28
    """"""
    return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)",data\repos\Python\project_euler\problem_074\sol1.py,solution,88
2404,sol2.py::digit_factorial_sum::42,"def digit_factorial_sum(number: int) -> int:
    """"""
    Function to perform the sum of the factorial of all the digits in number

    >>> digit_factorial_sum(69.0)
    Traceback (most recent call last):
        ...
    TypeError: Parameter number must be int

    >>> digit_factorial_sum(-1)
    Traceback (most recent call last):
        ...
    ValueError: Parameter number must be greater than or equal to 0

    >>> digit_factorial_sum(0)
    1

    >>> digit_factorial_sum(69)
    363600
    """"""
    if not isinstance(number, int):
        raise TypeError(""Parameter number must be int"")

    if number < 0:
        raise ValueError(""Parameter number must be greater than or equal to 0"")

    # Converts number in string to iterate on its digits and adds its factorial.
    return sum(DIGIT_FACTORIAL[digit] for digit in str(number))",data\repos\Python\project_euler\problem_074\sol2.py,digit_factorial_sum,199
2405,sol2.py::solution::72,"def solution(chain_length: int = 60, number_limit: int = 1000000) -> int:
    """"""
    Returns the number of numbers below number_limit that produce chains with exactly
    chain_length non repeating elements.

    >>> solution(10.0, 1000)
    Traceback (most recent call last):
        ...
    TypeError: Parameters chain_length and number_limit must be int

    >>> solution(10, 1000.0)
    Traceback (most recent call last):
        ...
    TypeError: Parameters chain_length and number_limit must be int

    >>> solution(0, 1000)
    Traceback (most recent call last):
        ...
    ValueError: Parameters chain_length and number_limit must be greater than 0

    >>> solution(10, 0)
    Traceback (most recent call last):
        ...
    ValueError: Parameters chain_length and number_limit must be greater than 0

    >>> solution(10, 1000)
    26
    """"""

    if not isinstance(chain_length, int) or not isinstance(number_limit, int):
        raise TypeError(""Parameters chain_length and number_limit must be int"")

    if chain_length <= 0 or number_limit <= 0:
        raise ValueError(
            ""Parameters chain_length and number_limit must be greater than 0""
        )

    # the counter for the chains with the exact desired length
    chains_counter = 0
    # the cached sizes of the previous chains
    chain_sets_lengths: dict[int, int] = {}

    for start_chain_element in range(1, number_limit):
        # The temporary set will contain the elements of the chain
        chain_set = set()
        chain_set_length = 0

        # Stop computing the chain when you find a cached size, a repeating item or the
        # length is greater then the desired one.
        chain_element = start_chain_element
        while (
            chain_element not in chain_sets_lengths
            and chain_element not in chain_set
            and chain_set_length <= chain_length
        ):
            chain_set.add(chain_element)
            chain_set_length += 1
            chain_element = digit_factorial_sum(chain_element)

        if chain_element in chain_sets_lengths:
            chain_set_length += chain_sets_lengths[chain_element]

        chain_sets_lengths[start_chain_element] = chain_set_length

        # If chain contains the exact amount of elements increase the counter
        if chain_set_length == chain_length:
            chains_counter += 1

    return chains_counter",data\repos\Python\project_euler\problem_074\sol2.py,solution,519
2406,sol1.py::solution::34,"def solution(limit: int = 1500000) -> int:
    """"""
    Return the number of values of L <= limit such that a wire of length L can be
    formmed into an integer sided right angle triangle in exactly one way.
    >>> solution(50)
    6
    >>> solution(1000)
    112
    >>> solution(50000)
    5502
    """"""
    frequencies: defaultdict = defaultdict(int)
    euclid_m = 2
    while 2 * euclid_m * (euclid_m + 1) <= limit:
        for euclid_n in range((euclid_m % 2) + 1, euclid_m, 2):
            if gcd(euclid_m, euclid_n) > 1:
                continue
            primitive_perimeter = 2 * euclid_m * (euclid_m + euclid_n)
            for perimeter in range(primitive_perimeter, limit + 1, primitive_perimeter):
                frequencies[perimeter] += 1
        euclid_m += 1
    return sum(1 for frequency in frequencies.values() if frequency == 1)",data\repos\Python\project_euler\problem_075\sol1.py,solution,242
2407,sol1.py::solution::19,"def solution(m: int = 100) -> int:
    """"""
    Returns the number of different ways the number m can be written as a
    sum of at least two positive integers.

    >>> solution(100)
    190569291
    >>> solution(50)
    204225
    >>> solution(30)
    5603
    >>> solution(10)
    41
    >>> solution(5)
    6
    >>> solution(3)
    2
    >>> solution(2)
    1
    >>> solution(1)
    0
    """"""
    memo = [[0 for _ in range(m)] for _ in range(m + 1)]
    for i in range(m + 1):
        memo[i][0] = 1

    for n in range(m + 1):
        for k in range(1, m):
            memo[n][k] += memo[n][k - 1]
            if n > k:
                memo[n][k] += memo[n - k - 1][k]

    return memo[m][m - 1] - 1",data\repos\Python\project_euler\problem_076\sol1.py,solution,236
2408,sol1.py::partition::34,"def partition(number_to_partition: int) -> set[int]:
    """"""
    Return a set of integers corresponding to unique prime partitions of n.
    The unique prime partitions can be represented as unique prime decompositions,
    e.g. (7+3) <-> 7*3 = 12, (3+3+2+2) = 3*3*2*2 = 36
    >>> partition(10)
    {32, 36, 21, 25, 30}
    >>> partition(15)
    {192, 160, 105, 44, 112, 243, 180, 150, 216, 26, 125, 126}
    >>> len(partition(20))
    26
    """"""
    if number_to_partition < 0:
        return set()
    elif number_to_partition == 0:
        return {1}

    ret: set[int] = set()
    prime: int
    sub: int

    for prime in primes:
        if prime > number_to_partition:
            continue
        for sub in partition(number_to_partition - prime):
            ret.add(sub * prime)

    return ret",data\repos\Python\project_euler\problem_077\sol1.py,partition,245
2409,sol1.py::solution::64,"def solution(number_unique_partitions: int = 5000) -> int | None:
    """"""
    Return the smallest integer that can be written as the sum of primes in over
    m unique ways.
    >>> solution(4)
    10
    >>> solution(500)
    45
    >>> solution(1000)
    53
    """"""
    for number_to_partition in range(1, NUM_PRIMES):
        if len(partition(number_to_partition)) > number_unique_partitions:
            return number_to_partition
    return None",data\repos\Python\project_euler\problem_077\sol1.py,solution,112
2410,sol1.py::solution::22,"def solution(number: int = 1000000) -> int:
    """"""
    >>> solution(1)
    1

    >>> solution(9)
    14

    >>> solution()
    55374
    """"""
    partitions = [1]

    for i in itertools.count(len(partitions)):
        item = 0
        for j in itertools.count(1):
            sign = -1 if j % 2 == 0 else +1
            index = (j * j * 3 - j) // 2
            if index > i:
                break
            item += partitions[i - index] * sign
            item %= number
            index += j
            if index > i:
                break
            item += partitions[i - index] * sign
            item %= number

        if item == 0:
            return i
        partitions.append(item)

    return 0",data\repos\Python\project_euler\problem_078\sol1.py,solution,187
2411,sol1.py::find_secret_passcode::21,"def find_secret_passcode(logins: list[str]) -> int:
    """"""
    Returns the shortest possible secret passcode of unknown length.

    >>> find_secret_passcode([""135"", ""259"", ""235"", ""189"", ""690"", ""168"", ""120"",
    ...     ""136"", ""289"", ""589"", ""160"", ""165"", ""580"", ""369"", ""250"", ""280""])
    12365890

    >>> find_secret_passcode([""426"", ""281"", ""061"", ""819"" ""268"", ""406"", ""420"",
    ...     ""428"", ""209"", ""689"", ""019"", ""421"", ""469"", ""261"", ""681"", ""201""])
    4206819
    """"""

    # Split each login by character e.g. '319' -> ('3', '1', '9')
    split_logins = [tuple(login) for login in logins]

    unique_chars = {char for login in split_logins for char in login}

    for permutation in itertools.permutations(unique_chars):
        satisfied = True
        for login in logins:
            if not (
                permutation.index(login[0])
                < permutation.index(login[1])
                < permutation.index(login[2])
            ):
                satisfied = False
                break

        if satisfied:
            return int("""".join(permutation))

    raise Exception(""Unable to find the secret passcode"")",data\repos\Python\project_euler\problem_079\sol1.py,find_secret_passcode,295
2412,sol1.py::solution::56,"def solution(input_file: str = ""keylog.txt"") -> int:
    """"""
    Returns the shortest possible secret passcode of unknown length
    for successful login attempts given by `input_file` text file.

    >>> solution(""keylog_test.txt"")
    6312980
    """"""
    logins = Path(__file__).parent.joinpath(input_file).read_text().splitlines()

    return find_secret_passcode(logins)",data\repos\Python\project_euler\problem_079\sol1.py,solution,89
2413,sol1.py::solution::13,"def solution() -> int:
    """"""
    To evaluate the sum, Used decimal python module to calculate the decimal
    places up to 100, the most important thing would be take calculate
    a few extra places for decimal otherwise there will be rounding
    error.

    >>> solution()
    40886
    """"""
    answer = 0
    decimal_context = decimal.Context(prec=105)
    for i in range(2, 100):
        number = decimal.Decimal(i)
        sqrt_number = number.sqrt(decimal_context)
        if len(str(sqrt_number)) > 1:
            answer += int(str(sqrt_number)[0])
            sqrt_number_str = str(sqrt_number)[2:101]
            answer += sum(int(x) for x in sqrt_number_str)
    return answer",data\repos\Python\project_euler\problem_080\sol1.py,solution,161
2414,sol1.py::solution::20,"def solution(filename: str = ""matrix.txt"") -> int:
    """"""
    Returns the minimal path sum from the top left to the bottom right of the matrix.
    >>> solution()
    427337
    """"""
    with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:
        data = in_file.read()

    grid = [[int(cell) for cell in row.split("","")] for row in data.strip().splitlines()]
    dp = [[0 for cell in row] for row in grid]
    n = len(grid[0])

    dp = [[0 for i in range(n)] for j in range(n)]
    dp[0][0] = grid[0][0]
    for i in range(1, n):
        dp[0][i] = grid[0][i] + dp[0][i - 1]
    for i in range(1, n):
        dp[i][0] = grid[i][0] + dp[i - 1][0]

    for i in range(1, n):
        for j in range(1, n):
            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])

    return dp[-1][-1]",data\repos\Python\project_euler\problem_081\sol1.py,solution,269
2415,sol1.py::solution::24,"def solution(filename: str = ""input.txt"") -> int:
    """"""
    Returns the minimal path sum in the matrix from the file, by starting in any cell
    in the left column and finishing in any cell in the right column,
    and only moving up, down, and right

    >>> solution(""test_matrix.txt"")
    994
    """"""

    with open(os.path.join(os.path.dirname(__file__), filename)) as input_file:
        matrix = [
            [int(element) for element in line.split("","")]
            for line in input_file.readlines()
        ]

    rows = len(matrix)
    cols = len(matrix[0])

    minimal_path_sums = [[-1 for _ in range(cols)] for _ in range(rows)]
    for i in range(rows):
        minimal_path_sums[i][0] = matrix[i][0]

    for j in range(1, cols):
        for i in range(rows):
            minimal_path_sums[i][j] = minimal_path_sums[i][j - 1] + matrix[i][j]

        for i in range(1, rows):
            minimal_path_sums[i][j] = min(
                minimal_path_sums[i][j], minimal_path_sums[i - 1][j] + matrix[i][j]
            )

        for i in range(rows - 2, -1, -1):
            minimal_path_sums[i][j] = min(
                minimal_path_sums[i][j], minimal_path_sums[i + 1][j] + matrix[i][j]
            )

    return min(minimal_path_sums_row[-1] for minimal_path_sums_row in minimal_path_sums)",data\repos\Python\project_euler\problem_082\sol1.py,solution,349
2416,sol1.py::solution::53,"def solution(target: int = 2000000) -> int:
    """"""
    Find the area of the grid which contains as close to two million rectangles
    as possible.
    >>> solution(20)
    6
    >>> solution(2000)
    72
    >>> solution(2000000000)
    86595
    """"""
    triangle_numbers: list[int] = [0]
    idx: int

    for idx in range(1, ceil(sqrt(target * 2) * 1.1)):
        triangle_numbers.append(triangle_numbers[-1] + idx)

    # we want this to be as close as possible to target
    best_product: int = 0
    # the area corresponding to the grid that gives the product closest to target
    area: int = 0
    # an estimate of b, using the quadratic formula
    b_estimate: float
    # the largest integer less than b_estimate
    b_floor: int
    # the largest integer less than b_estimate
    b_ceil: int
    # the triangle number corresponding to b_floor
    triangle_b_first_guess: int
    # the triangle number corresponding to b_ceil
    triangle_b_second_guess: int

    for idx_a, triangle_a in enumerate(triangle_numbers[1:], 1):
        b_estimate = (-1 + sqrt(1 + 8 * target / triangle_a)) / 2
        b_floor = floor(b_estimate)
        b_ceil = ceil(b_estimate)
        triangle_b_first_guess = triangle_numbers[b_floor]
        triangle_b_second_guess = triangle_numbers[b_ceil]

        if abs(target - triangle_b_first_guess * triangle_a) < abs(
            target - best_product
        ):
            best_product = triangle_b_first_guess * triangle_a
            area = idx_a * b_floor

        if abs(target - triangle_b_second_guess * triangle_a) < abs(
            target - best_product
        ):
            best_product = triangle_b_second_guess * triangle_a
            area = idx_a * b_ceil

    return area",data\repos\Python\project_euler\problem_085\sol1.py,solution,433
2417,sol1.py::solution::72,"def solution(limit: int = 1000000) -> int:
    """"""
    Return the least value of M such that there are more than one million cuboids
    of side lengths 1 <= a,b,c <= M such that the shortest distance between two
    opposite vertices of the cuboid is integral.
    >>> solution(100)
    24
    >>> solution(1000)
    72
    >>> solution(2000)
    100
    >>> solution(20000)
    288
    """"""
    num_cuboids: int = 0
    max_cuboid_size: int = 0
    sum_shortest_sides: int

    while num_cuboids <= limit:
        max_cuboid_size += 1
        for sum_shortest_sides in range(2, 2 * max_cuboid_size + 1):
            if sqrt(sum_shortest_sides**2 + max_cuboid_size**2).is_integer():
                num_cuboids += (
                    min(max_cuboid_size, sum_shortest_sides // 2)
                    - max(1, sum_shortest_sides - max_cuboid_size)
                    + 1
                )

    return max_cuboid_size",data\repos\Python\project_euler\problem_086\sol1.py,solution,262
2418,sol1.py::solution::18,"def solution(limit: int = 50000000) -> int:
    """"""
    Return the number of integers less than limit which can be expressed as the sum
    of a prime square, prime cube, and prime fourth power.
    >>> solution(50)
    4
    """"""
    ret = set()
    prime_square_limit = int((limit - 24) ** (1 / 2))

    primes = set(range(3, prime_square_limit + 1, 2))
    primes.add(2)
    for p in range(3, prime_square_limit + 1, 2):
        if p not in primes:
            continue
        primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))

    for prime1 in primes:
        square = prime1 * prime1
        for prime2 in primes:
            cube = prime2 * prime2 * prime2
            if square + cube >= limit - 16:
                break
            for prime3 in primes:
                tetr = prime3 * prime3 * prime3 * prime3
                total = square + cube + tetr
                if total >= limit:
                    break
                ret.add(total)

    return len(ret)",data\repos\Python\project_euler\problem_087\sol1.py,solution,256
2419,sol1.py::parse_roman_numerals::36,"def parse_roman_numerals(numerals: str) -> int:
    """"""
    Converts a string of roman numerals to an integer.
    e.g.
    >>> parse_roman_numerals(""LXXXIX"")
    89
    >>> parse_roman_numerals(""IIII"")
    4
    """"""

    total_value = 0

    index = 0
    while index < len(numerals) - 1:
        current_value = SYMBOLS[numerals[index]]
        next_value = SYMBOLS[numerals[index + 1]]
        if current_value < next_value:
            total_value -= current_value
        else:
            total_value += current_value
        index += 1
    total_value += SYMBOLS[numerals[index]]

    return total_value",data\repos\Python\project_euler\problem_089\sol1.py,parse_roman_numerals,160
2420,sol1.py::generate_roman_numerals::62,"def generate_roman_numerals(num: int) -> str:
    """"""
    Generates a string of roman numerals for a given integer.
    e.g.
    >>> generate_roman_numerals(89)
    'LXXXIX'
    >>> generate_roman_numerals(4)
    'IV'
    """"""

    numerals = """"

    m_count = num // 1000
    numerals += m_count * ""M""
    num %= 1000

    c_count = num // 100
    if c_count == 9:
        numerals += ""CM""
        c_count -= 9
    elif c_count == 4:
        numerals += ""CD""
        c_count -= 4
    if c_count >= 5:
        numerals += ""D""
        c_count -= 5
    numerals += c_count * ""C""
    num %= 100

    x_count = num // 10
    if x_count == 9:
        numerals += ""XC""
        x_count -= 9
    elif x_count == 4:
        numerals += ""XL""
        x_count -= 4
    if x_count >= 5:
        numerals += ""L""
        x_count -= 5
    numerals += x_count * ""X""
    num %= 10

    if num == 9:
        numerals += ""IX""
        num -= 9
    elif num == 4:
        numerals += ""IV""
        num -= 4
    if num >= 5:
        numerals += ""V""
        num -= 5
    numerals += num * ""I""

    return numerals",data\repos\Python\project_euler\problem_089\sol1.py,generate_roman_numerals,351
2421,sol1.py::solution::118,"def solution(roman_numerals_filename: str = ""/p089_roman.txt"") -> int:
    """"""
    Calculates and returns the answer to project euler problem 89.

    >>> solution(""/numeralcleanup_test.txt"")
    16
    """"""

    savings = 0

    with open(os.path.dirname(__file__) + roman_numerals_filename) as file1:
        lines = file1.readlines()

    for line in lines:
        original = line.strip()
        num = parse_roman_numerals(original)
        shortened = generate_roman_numerals(num)
        savings += len(original) - len(shortened)

    return savings",data\repos\Python\project_euler\problem_089\sol1.py,solution,129
2422,sol1.py::is_right::17,"def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:
    """"""
    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.
    Note: this doesn't check if P and Q are equal, but that's handled by the use of
    itertools.combinations in the solution function.

    >>> is_right(0, 1, 2, 0)
    True
    >>> is_right(1, 0, 2, 2)
    False
    """"""
    if x1 == y1 == 0 or x2 == y2 == 0:
        return False
    a_square = x1 * x1 + y1 * y1
    b_square = x2 * x2 + y2 * y2
    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
    return (
        a_square + b_square == c_square
        or a_square + c_square == b_square
        or b_square + c_square == a_square
    )",data\repos\Python\project_euler\problem_091\sol1.py,is_right,259
2423,sol1.py::solution::40,"def solution(limit: int = 50) -> int:
    """"""
    Return the number of right triangles OPQ that can be formed by two points P, Q
    which have both x- and y- coordinates between 0 and limit inclusive.

    >>> solution(2)
    14
    >>> solution(10)
    448
    """"""
    return sum(
        1
        for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)
        if is_right(*pt1, *pt2)
    )",data\repos\Python\project_euler\problem_091\sol1.py,solution,118
2424,sol1.py::next_number::17,"def next_number(number: int) -> int:
    """"""
    Returns the next number of the chain by adding the square of each digit
    to form a new number.
    For example, if number = 12, next_number() will return 1^2 + 2^2 = 5.
    Therefore, 5 is the next number of the chain.
    >>> next_number(44)
    32
    >>> next_number(10)
    1
    >>> next_number(32)
    13
    """"""

    sum_of_digits_squared = 0
    while number:
        # Increased Speed Slightly by checking every 5 digits together.
        sum_of_digits_squared += DIGITS_SQUARED[number % 100000]
        number //= 100000

    return sum_of_digits_squared",data\repos\Python\project_euler\problem_092\sol1.py,next_number,168
2425,sol1.py::chain::54,"def chain(number: int) -> bool:
    """"""
    The function generates the chain of numbers until the next number is 1 or 89.
    For example, if starting number is 44, then the function generates the
    following chain of numbers:
    44  32  13  10  1  1.
    Once the next number generated is 1 or 89, the function returns whether
    or not the next number generated by next_number() is 1.
    >>> chain(10)
    True
    >>> chain(58)
    False
    >>> chain(1)
    True
    """"""

    if CHAINS[number - 1] is not None:
        return CHAINS[number - 1]  # type: ignore[return-value]

    number_chain = chain(next_number(number))
    CHAINS[number - 1] = number_chain

    while number < 10000000:
        CHAINS[number - 1] = number_chain
        number *= 10

    return number_chain",data\repos\Python\project_euler\problem_092\sol1.py,chain,217
2426,sol1.py::solution::83,"def solution(number: int = 10000000) -> int:
    """"""
    The function returns the number of integers that end up being 89 in each chain.
    The function accepts a range number and the function checks all the values
    under value number.

    >>> solution(100)
    80
    >>> solution(10000000)
    8581146
    """"""
    for i in range(1, number):
        if CHAINS[i] is None:
            chain(i + 1)

    return CHAINS[:number].count(False)",data\repos\Python\project_euler\problem_092\sol1.py,solution,116
2427,sol1.py::solution::16,"def solution(max_perimeter: int = 10**9) -> int:
    """"""
    Returns the sum of the perimeters of all almost equilateral triangles with integral
    side lengths and area and whose perimeters do not exceed max_perimeter

    >>> solution(20)
    16
    """"""

    prev_value = 1
    value = 2

    perimeters_sum = 0
    i = 0
    perimeter = 0
    while perimeter <= max_perimeter:
        perimeters_sum += perimeter

        prev_value += 2 * value
        value += prev_value

        perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2
        i += 1

    return perimeters_sum",data\repos\Python\project_euler\problem_094\sol1.py,solution,164
2428,sol1.py::generate_primes::34,"def generate_primes(max_num: int) -> list[int]:
    """"""
    Calculates the list of primes up to and including `max_num`.

    >>> generate_primes(6)
    [2, 3, 5]
    """"""
    are_primes = [True] * (max_num + 1)
    are_primes[0] = are_primes[1] = False
    for i in range(2, isqrt(max_num) + 1):
        if are_primes[i]:
            for j in range(i * i, max_num + 1, i):
                are_primes[j] = False

    return [prime for prime, is_prime in enumerate(are_primes) if is_prime]",data\repos\Python\project_euler\problem_095\sol1.py,generate_primes,152
2429,sol1.py::multiply::51,"def multiply(
    chain: list[int],
    primes: list[int],
    min_prime_idx: int,
    prev_num: int,
    max_num: int,
    prev_sum: int,
    primes_degrees: dict[int, int],
) -> None:
    """"""
    Run over all prime combinations to generate non-prime numbers.

    >>> chain = [0] * 3
    >>> primes_degrees = {}
    >>> multiply(
    ...     chain=chain,
    ...     primes=[2],
    ...     min_prime_idx=0,
    ...     prev_num=1,
    ...     max_num=2,
    ...     prev_sum=0,
    ...     primes_degrees=primes_degrees,
    ... )
    >>> chain
    [0, 0, 1]
    >>> primes_degrees
    {2: 1}
    """"""

    min_prime = primes[min_prime_idx]
    num = prev_num * min_prime

    min_prime_degree = primes_degrees.get(min_prime, 0)
    min_prime_degree += 1
    primes_degrees[min_prime] = min_prime_degree

    new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (
        min_prime**min_prime_degree - 1
    )
    chain[num] = new_sum

    for prime_idx in range(min_prime_idx, len(primes)):
        if primes[prime_idx] * num > max_num:
            break

        multiply(
            chain=chain,
            primes=primes,
            min_prime_idx=prime_idx,
            prev_num=num,
            max_num=max_num,
            prev_sum=new_sum,
            primes_degrees=primes_degrees.copy(),
        )",data\repos\Python\project_euler\problem_095\sol1.py,multiply,365
2430,sol1.py::find_longest_chain::107,"def find_longest_chain(chain: list[int], max_num: int) -> int:
    """"""
    Finds the smallest element of longest chain

    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)
    6
    """"""

    max_len = 0
    min_elem = 0
    for start in range(2, len(chain)):
        visited = {start}
        elem = chain[start]
        length = 1

        while elem > 1 and elem <= max_num and elem not in visited:
            visited.add(elem)
            elem = chain[elem]
            length += 1

        if elem == start and length > max_len:
            max_len = length
            min_elem = start

    return min_elem",data\repos\Python\project_euler\problem_095\sol1.py,find_longest_chain,173
2431,sol1.py::solution::134,"def solution(max_num: int = 1000000) -> int:
    """"""
    Runs the calculation for numbers <= `max_num`.

    >>> solution(10)
    6
    >>> solution(200000)
    12496
    """"""

    primes = generate_primes(max_num)
    chain = [0] * (max_num + 1)
    for prime_idx, prime in enumerate(primes):
        if prime**2 > max_num:
            break

        multiply(
            chain=chain,
            primes=primes,
            min_prime_idx=prime_idx,
            prev_num=1,
            max_num=max_num,
            prev_sum=0,
            primes_degrees={},
        )

    return find_longest_chain(chain=chain, max_num=max_num)",data\repos\Python\project_euler\problem_095\sol1.py,solution,161
2432,sol1.py::solution::13,"def solution(n: int = 10) -> str:
    """"""
    Returns the last n digits of NUMBER.
    >>> solution()
    '8739992577'
    >>> solution(8)
    '39992577'
    >>> solution(1)
    '7'
    >>> solution(-1)
    Traceback (most recent call last):
        ...
    ValueError: Invalid input
    >>> solution(8.3)
    Traceback (most recent call last):
        ...
    ValueError: Invalid input
    >>> solution(""a"")
    Traceback (most recent call last):
        ...
    ValueError: Invalid input
    """"""
    if not isinstance(n, int) or n < 0:
        raise ValueError(""Invalid input"")
    modulus = 10**n
    number = 28433 * (pow(2, 7830457, modulus)) + 1
    return str(number % modulus)",data\repos\Python\project_euler\problem_097\sol1.py,solution,188
2433,sol1.py::solution::20,"def solution(data_file: str = ""base_exp.txt"") -> int:
    """"""
    >>> solution()
    709
    """"""
    largest: float = 0
    result = 0
    for i, line in enumerate(open(os.path.join(os.path.dirname(__file__), data_file))):
        a, x = list(map(int, line.split("","")))
        if x * log10(a) > largest:
            largest = x * log10(a)
            result = i + 1
    return result",data\repos\Python\project_euler\problem_099\sol1.py,solution,105
2434,sol1.py::solution::16,"def solution(min_total: int = 10**12) -> int:
    """"""
    Returns the number of blue discs for the first arrangement to contain
    over min_total discs in total

    >>> solution(2)
    3

    >>> solution(4)
    15

    >>> solution(21)
    85
    """"""

    prev_numerator = 1
    prev_denominator = 0

    numerator = 1
    denominator = 1

    while numerator <= 2 * min_total - 1:
        prev_numerator += 2 * numerator
        numerator += 2 * prev_numerator

        prev_denominator += 2 * denominator
        denominator += 2 * prev_denominator

    return (denominator + 1) // 2",data\repos\Python\project_euler\problem_100\sol1.py,solution,164
2435,sol1.py::solve::52,"def solve(matrix: Matrix, vector: Matrix) -> Matrix:
    """"""
    Solve the linear system of equations Ax = b (A = ""matrix"", b = ""vector"")
    for x using Gaussian elimination and back substitution. We assume that A
    is an invertible square matrix and that b is a column vector of the
    same height.
    >>> solve([[1, 0], [0, 1]], [[1],[2]])
    [[1.0], [2.0]]
    >>> solve([[2, 1, -1],[-3, -1, 2],[-2, 1, 2]],[[8], [-11],[-3]])
    [[2.0], [3.0], [-1.0]]
    """"""
    size: int = len(matrix)
    augmented: Matrix = [[0 for _ in range(size + 1)] for _ in range(size)]
    row: int
    row2: int
    col: int
    col2: int
    pivot_row: int
    ratio: float

    for row in range(size):
        for col in range(size):
            augmented[row][col] = matrix[row][col]

        augmented[row][size] = vector[row][0]

    row = 0
    col = 0
    while row < size and col < size:
        # pivoting
        pivot_row = max((abs(augmented[row2][col]), row2) for row2 in range(col, size))[
            1
        ]
        if augmented[pivot_row][col] == 0:
            col += 1
            continue
        else:
            augmented[row], augmented[pivot_row] = augmented[pivot_row], augmented[row]

        for row2 in range(row + 1, size):
            ratio = augmented[row2][col] / augmented[row][col]
            augmented[row2][col] = 0
            for col2 in range(col + 1, size + 1):
                augmented[row2][col2] -= augmented[row][col2] * ratio

        row += 1
        col += 1

    # back substitution
    for col in range(1, size):
        for row in range(col):
            ratio = augmented[row][col] / augmented[col][col]
            for col2 in range(col, size + 1):
                augmented[row][col2] -= augmented[col][col2] * ratio

    # round to get rid of numbers like 2.000000000000004
    return [
        [round(augmented[row][size] / augmented[row][row], 10)] for row in range(size)
    ]",data\repos\Python\project_euler\problem_101\sol1.py,solve,562
2436,sol1.py::interpolate::113,"def interpolate(y_list: list[int]) -> Callable[[int], int]:
    """"""
    Given a list of data points (1,y0),(2,y1), ..., return a function that
    interpolates the data points. We find the coefficients of the interpolating
    polynomial by solving a system of linear equations corresponding to
    x = 1, 2, 3...

    >>> interpolate([1])(3)
    1
    >>> interpolate([1, 8])(3)
    15
    >>> interpolate([1, 8, 27])(4)
    58
    >>> interpolate([1, 8, 27, 64])(6)
    216
    """"""

    size: int = len(y_list)
    matrix: Matrix = [[0 for _ in range(size)] for _ in range(size)]
    vector: Matrix = [[0] for _ in range(size)]
    coeffs: Matrix
    x_val: int
    y_val: int
    col: int

    for x_val, y_val in enumerate(y_list):
        for col in range(size):
            matrix[x_val][col] = (x_val + 1) ** (size - col - 1)
        vector[x_val][0] = y_val

    coeffs = solve(matrix, vector)

    def interpolated_func(var: int) -> int:
        """"""
        >>> interpolate([1])(3)
        1
        >>> interpolate([1, 8])(3)
        15
        >>> interpolate([1, 8, 27])(4)
        58
        >>> interpolate([1, 8, 27, 64])(6)
        216
        """"""
        return sum(
            round(coeffs[x_val][0]) * (var ** (size - x_val - 1))
            for x_val in range(size)
        )

    return interpolated_func",data\repos\Python\project_euler\problem_101\sol1.py,interpolate,393
2437,sol1.py::question_function::164,"def question_function(variable: int) -> int:
    """"""
    The generating function u as specified in the question.
    >>> question_function(0)
    1
    >>> question_function(1)
    1
    >>> question_function(5)
    8138021
    >>> question_function(10)
    9090909091
    """"""
    return (
        1
        - variable
        + variable**2
        - variable**3
        + variable**4
        - variable**5
        + variable**6
        - variable**7
        + variable**8
        - variable**9
        + variable**10
    )",data\repos\Python\project_euler\problem_101\sol1.py,question_function,141
2438,sol1.py::solution::191,"def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:
    """"""
    Find the sum of the FITs of the BOPS. For each interpolating polynomial of order
    1, 2, ... , 10, find the first x such that the value of the polynomial at x does
    not equal u(x).
    >>> solution(lambda n: n ** 3, 3)
    74
    """"""
    data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]

    polynomials: list[Callable[[int], int]] = [
        interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)
    ]

    ret: int = 0
    poly: Callable[[int], int]
    x_val: int

    for poly in polynomials:
        x_val = 1
        while func(x_val) == poly(x_val):
            x_val += 1

        ret += poly(x_val)

    return ret",data\repos\Python\project_euler\problem_101\sol1.py,solution,228
2439,sol1.py::interpolated_func::145,"    def interpolated_func(var: int) -> int:
        """"""
        >>> interpolate([1])(3)
        1
        >>> interpolate([1, 8])(3)
        15
        >>> interpolate([1, 8, 27])(4)
        58
        >>> interpolate([1, 8, 27, 64])(6)
        216
        """"""
        return sum(
            round(coeffs[x_val][0]) * (var ** (size - x_val - 1))
            for x_val in range(size)
        )",data\repos\Python\project_euler\problem_101\sol1.py,interpolated_func,116
2440,sol1.py::vector_product::27,"def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:
    """"""
    Return the 2-d vector product of two vectors.
    >>> vector_product((1, 2), (-5, 0))
    10
    >>> vector_product((3, 1), (6, 10))
    24
    """"""
    return point1[0] * point2[1] - point1[1] * point2[0]",data\repos\Python\project_euler\problem_102\sol1.py,vector_product,103
2441,sol1.py::contains_origin::38,"def contains_origin(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> bool:
    """"""
    Check if the triangle given by the points A(x1, y1), B(x2, y2), C(x3, y3)
    contains the origin.
    >>> contains_origin(-340, 495, -153, -910, 835, -947)
    True
    >>> contains_origin(-175, 41, -421, -714, 574, -645)
    False
    """"""
    point_a: tuple[int, int] = (x1, y1)
    point_a_to_b: tuple[int, int] = (x2 - x1, y2 - y1)
    point_a_to_c: tuple[int, int] = (x3 - x1, y3 - y1)
    a: float = -vector_product(point_a, point_a_to_b) / vector_product(
        point_a_to_c, point_a_to_b
    )
    b: float = +vector_product(point_a, point_a_to_c) / vector_product(
        point_a_to_c, point_a_to_b
    )

    return a > 0 and b > 0 and a + b < 1",data\repos\Python\project_euler\problem_102\sol1.py,contains_origin,276
2442,sol1.py::solution::60,"def solution(filename: str = ""p102_triangles.txt"") -> int:
    """"""
    Find the number of triangles whose interior contains the origin.
    >>> solution(""test_triangles.txt"")
    1
    """"""
    data: str = Path(__file__).parent.joinpath(filename).read_text(encoding=""utf-8"")

    triangles: list[list[int]] = []
    for line in data.strip().split(""\n""):
        triangles.append([int(number) for number in line.split("","")])

    ret: int = 0
    triangle: list[int]

    for triangle in triangles:
        ret += contains_origin(*triangle)

    return ret",data\repos\Python\project_euler\problem_102\sol1.py,solution,133
2443,sol1.py::check::21,"def check(number: int) -> bool:
    """"""
    Takes a number and checks if it is pandigital both from start and end


    >>> check(123456789987654321)
    True

    >>> check(120000987654321)
    False

    >>> check(1234567895765677987654321)
    True

    """"""

    check_last = [0] * 11
    check_front = [0] * 11

    # mark last 9 numbers
    for _ in range(9):
        check_last[int(number % 10)] = 1
        number = number // 10
    # flag
    f = True

    # check last 9 numbers for pandigitality

    for x in range(9):
        if not check_last[x + 1]:
            f = False
    if not f:
        return f

    # mark first 9 numbers
    number = int(str(number)[:9])

    for _ in range(9):
        check_front[int(number % 10)] = 1
        number = number // 10

    # check first 9 numbers for pandigitality

    for x in range(9):
        if not check_front[x + 1]:
            f = False
    return f",data\repos\Python\project_euler\problem_104\sol1.py,check,270
2444,sol1.py::check1::70,"def check1(number: int) -> bool:
    """"""
    Takes a number and checks if it is pandigital from END

    >>> check1(123456789987654321)
    True

    >>> check1(120000987654321)
    True

    >>> check1(12345678957656779870004321)
    False

    """"""

    check_last = [0] * 11

    # mark last 9 numbers
    for _ in range(9):
        check_last[int(number % 10)] = 1
        number = number // 10
    # flag
    f = True

    # check last 9 numbers for pandigitality

    for x in range(9):
        if not check_last[x + 1]:
            f = False
    return f",data\repos\Python\project_euler\problem_104\sol1.py,check1,170
2445,sol1.py::solution::102,"def solution() -> int:
    """"""
    Outputs the answer is the least Fibonacci number pandigital from both sides.
    >>> solution()
    329468
    """"""

    a = 1
    b = 1
    c = 2
    # temporary Fibonacci numbers

    a1 = 1
    b1 = 1
    c1 = 2
    # temporary Fibonacci numbers mod 1e9

    # mod m=1e9, done for fast optimisation
    tocheck = [0] * 1000000
    m = 1000000000

    for x in range(1000000):
        c1 = (a1 + b1) % m
        a1 = b1 % m
        b1 = c1 % m
        if check1(b1):
            tocheck[x + 3] = 1

    for x in range(1000000):
        c = a + b
        a = b
        b = c
        # perform check only if in tocheck
        if tocheck[x + 3] and check(b):
            return x + 3  # first 2 already done
    return -1",data\repos\Python\project_euler\problem_104\sol1.py,solution,256
2446,sol1.py::solution::95,"def solution(filename: str = ""p107_network.txt"") -> int:
    """"""
    Find the maximum saving which can be achieved by removing redundant edges
    whilst ensuring that the network remains connected.
    >>> solution(""test_network.txt"")
    150
    """"""
    script_dir: str = os.path.abspath(os.path.dirname(__file__))
    network_file: str = os.path.join(script_dir, filename)
    edges: dict[EdgeT, int] = {}
    data: list[str]
    edge1: int
    edge2: int

    with open(network_file) as f:
        data = f.read().strip().split(""\n"")

    adjaceny_matrix = [line.split("","") for line in data]

    for edge1 in range(1, len(adjaceny_matrix)):
        for edge2 in range(edge1):
            if adjaceny_matrix[edge1][edge2] != ""-"":
                edges[(edge2, edge1)] = int(adjaceny_matrix[edge1][edge2])

    graph: Graph = Graph(set(range(len(adjaceny_matrix))), edges)

    subgraph: Graph = graph.prims_algorithm()

    initial_total: int = sum(graph.edges.values())
    optimal_total: int = sum(subgraph.edges.values())

    return initial_total - optimal_total",data\repos\Python\project_euler\problem_107\sol1.py,solution,267
2447,sol1.py::add_edge::50,"    def add_edge(self, edge: EdgeT, weight: int) -> None:
        """"""
        Add a new edge to the graph.
        >>> graph = Graph({1, 2}, {(2, 1): 4})
        >>> graph.add_edge((3, 1), 5)
        >>> sorted(graph.vertices)
        [1, 2, 3]
        >>> sorted([(v,k) for k,v in graph.edges.items()])
        [(4, (1, 2)), (5, (1, 3))]
        """"""
        self.vertices.add(edge[0])
        self.vertices.add(edge[1])
        self.edges[(min(edge), max(edge))] = weight",data\repos\Python\project_euler\problem_107\sol1.py,add_edge,143
2448,sol1.py::prims_algorithm::64,"    def prims_algorithm(self) -> Graph:
        """"""
        Run Prim's algorithm to find the minimum spanning tree.
        Reference: https://en.wikipedia.org/wiki/Prim%27s_algorithm
        >>> graph = Graph({1,2,3,4},{(1,2):5, (1,3):10, (1,4):20, (2,4):30, (3,4):1})
        >>> mst = graph.prims_algorithm()
        >>> sorted(mst.vertices)
        [1, 2, 3, 4]
        >>> sorted(mst.edges)
        [(1, 2), (1, 3), (3, 4)]
        """"""
        subgraph: Graph = Graph({min(self.vertices)}, {})
        min_edge: EdgeT
        min_weight: int
        edge: EdgeT
        weight: int

        while len(subgraph.vertices) < len(self.vertices):
            min_weight = max(self.edges.values()) + 1
            for edge, weight in self.edges.items():
                if (edge[0] in subgraph.vertices) ^ (
                    edge[1] in subgraph.vertices
                ) and weight < min_weight:
                    min_edge = edge
                    min_weight = weight

            subgraph.add_edge(min_edge, min_weight)

        return subgraph",data\repos\Python\project_euler\problem_107\sol1.py,prims_algorithm,278
2449,sol1.py::solution::59,"def solution(limit: int = 100) -> int:
    """"""
    Count the number of distinct ways a player can checkout with a score
    less than limit.
    >>> solution(171)
    42336
    >>> solution(50)
    12577
    """"""
    singles: list[int] = [*list(range(1, 21)), 25]
    doubles: list[int] = [2 * x for x in range(1, 21)] + [50]
    triples: list[int] = [3 * x for x in range(1, 21)]
    all_values: list[int] = singles + doubles + triples + [0]

    num_checkouts: int = 0
    double: int
    throw1: int
    throw2: int
    checkout_total: int

    for double in doubles:
        for throw1, throw2 in combinations_with_replacement(all_values, 2):
            checkout_total = double + throw1 + throw2
            if checkout_total < limit:
                num_checkouts += 1

    return num_checkouts",data\repos\Python\project_euler\problem_109\sol1.py,solution,229
2450,sol1.py::check_bouncy::20,"def check_bouncy(n: int) -> bool:
    """"""
    Returns True if number is bouncy, False otherwise
    >>> check_bouncy(6789)
    False
    >>> check_bouncy(-12345)
    False
    >>> check_bouncy(0)
    False
    >>> check_bouncy(6.74)
    Traceback (most recent call last):
        ...
    ValueError: check_bouncy() accepts only integer arguments
    >>> check_bouncy(132475)
    True
    >>> check_bouncy(34)
    False
    >>> check_bouncy(341)
    True
    >>> check_bouncy(47)
    False
    >>> check_bouncy(-12.54)
    Traceback (most recent call last):
        ...
    ValueError: check_bouncy() accepts only integer arguments
    >>> check_bouncy(-6548)
    True
    """"""
    if not isinstance(n, int):
        raise ValueError(""check_bouncy() accepts only integer arguments"")
    str_n = str(n)
    sorted_str_n = """".join(sorted(str_n))
    return str_n not in {sorted_str_n, sorted_str_n[::-1]}",data\repos\Python\project_euler\problem_112\sol1.py,check_bouncy,241
2451,sol1.py::solution::55,"def solution(percent: float = 99) -> int:
    """"""
    Returns the least number for which the proportion of bouncy numbers is
    exactly 'percent'
    >>> solution(50)
    538
    >>> solution(90)
    21780
    >>> solution(80)
    4770
    >>> solution(105)
    Traceback (most recent call last):
        ...
    ValueError: solution() only accepts values from 0 to 100
    >>> solution(100.011)
    Traceback (most recent call last):
        ...
    ValueError: solution() only accepts values from 0 to 100
    """"""
    if not 0 < percent < 100:
        raise ValueError(""solution() only accepts values from 0 to 100"")
    bouncy_num = 0
    num = 1

    while True:
        if check_bouncy(num):
            bouncy_num += 1
        if (bouncy_num / num) * 100 >= percent:
            return num
        num += 1",data\repos\Python\project_euler\problem_112\sol1.py,solution,218
2452,sol1.py::choose::21,"def choose(n: int, r: int) -> int:
    """"""
    Calculate the binomial coefficient c(n,r) using the multiplicative formula.
    >>> choose(4,2)
    6
    >>> choose(5,3)
    10
    >>> choose(20,6)
    38760
    """"""
    ret = 1.0
    for i in range(1, r + 1):
        ret *= (n + 1 - i) / i
    return round(ret)",data\repos\Python\project_euler\problem_113\sol1.py,choose,110
2453,sol1.py::non_bouncy_exact::37,"def non_bouncy_exact(n: int) -> int:
    """"""
    Calculate the number of non-bouncy numbers with at most n digits.
    >>> non_bouncy_exact(1)
    9
    >>> non_bouncy_exact(6)
    7998
    >>> non_bouncy_exact(10)
    136126
    """"""
    return choose(8 + n, n) + choose(9 + n, n) - 10",data\repos\Python\project_euler\problem_113\sol1.py,non_bouncy_exact,94
2454,sol1.py::non_bouncy_upto::50,"def non_bouncy_upto(n: int) -> int:
    """"""
    Calculate the number of non-bouncy numbers with at most n digits.
    >>> non_bouncy_upto(1)
    9
    >>> non_bouncy_upto(6)
    12951
    >>> non_bouncy_upto(10)
    277032
    """"""
    return sum(non_bouncy_exact(i) for i in range(1, n + 1))",data\repos\Python\project_euler\problem_113\sol1.py,non_bouncy_upto,97
2455,sol1.py::solution::63,"def solution(num_digits: int = 100) -> int:
    """"""
    Calculate the number of non-bouncy numbers less than a googol.
    >>> solution(6)
    12951
    >>> solution(10)
    277032
    """"""
    return non_bouncy_upto(num_digits)",data\repos\Python\project_euler\problem_113\sol1.py,solution,64
2456,sol1.py::solution::35,"def solution(length: int = 50) -> int:
    """"""
    Returns the number of ways a row of the given length can be filled

    >>> solution(7)
    17
    """"""

    ways_number = [1] * (length + 1)

    for row_length in range(3, length + 1):
        for block_length in range(3, row_length + 1):
            for block_start in range(row_length - block_length):
                ways_number[row_length] += ways_number[
                    row_length - block_start - block_length - 1
                ]

            ways_number[row_length] += 1

    return ways_number[length]",data\repos\Python\project_euler\problem_114\sol1.py,solution,138
2457,sol1.py::solution::30,"def solution(min_block_length: int = 50) -> int:
    """"""
    Returns for given minimum block length the least value of n
    for which the fill-count function first exceeds one million

    >>> solution(3)
    30

    >>> solution(10)
    57
    """"""

    fill_count_functions = [1] * min_block_length

    for n in count(min_block_length):
        fill_count_functions.append(1)

        for block_length in range(min_block_length, n + 1):
            for block_start in range(n - block_length):
                fill_count_functions[n] += fill_count_functions[
                    n - block_start - block_length - 1
                ]

            fill_count_functions[n] += 1

        if fill_count_functions[n] > 1_000_000:
            break

    return n",data\repos\Python\project_euler\problem_115\sol1.py,solution,175
2458,sol1.py::solution::38,"def solution(length: int = 50) -> int:
    """"""
    Returns the number of different ways can the grey tiles in a row
    of the given length be replaced if colours cannot be mixed
    and at least one coloured tile must be used

    >>> solution(5)
    12
    """"""

    different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]

    for row_length in range(length + 1):
        for tile_length in range(2, 5):
            for tile_start in range(row_length - tile_length + 1):
                different_colour_ways_number[row_length][tile_length - 2] += (
                    different_colour_ways_number[row_length - tile_start - tile_length][
                        tile_length - 2
                    ]
                    + 1
                )

    return sum(different_colour_ways_number[length])",data\repos\Python\project_euler\problem_116\sol1.py,solution,185
2459,sol1.py::solution::32,"def solution(length: int = 50) -> int:
    """"""
    Returns the number of ways can a row of the given length be tiled

    >>> solution(5)
    15
    """"""

    ways_number = [1] * (length + 1)

    for row_length in range(length + 1):
        for tile_length in range(2, 5):
            for tile_start in range(row_length - tile_length + 1):
                ways_number[row_length] += ways_number[
                    row_length - tile_start - tile_length
                ]

    return ways_number[length]",data\repos\Python\project_euler\problem_117\sol1.py,solution,122
2460,sol1.py::digit_sum::16,"def digit_sum(n: int) -> int:
    """"""
    Returns the sum of the digits of the number.
    >>> digit_sum(123)
    6
    >>> digit_sum(456)
    15
    >>> digit_sum(78910)
    25
    """"""
    return sum(int(digit) for digit in str(n))",data\repos\Python\project_euler\problem_119\sol1.py,digit_sum,72
2461,sol1.py::solution::29,"def solution(n: int = 30) -> int:
    """"""
    Returns the value of 30th digit power sum.
    >>> solution(2)
    512
    >>> solution(5)
    5832
    >>> solution(10)
    614656
    """"""
    digit_to_powers = []
    for digit in range(2, 100):
        for power in range(2, 100):
            number = int(math.pow(digit, power))
            if digit == digit_sum(number):
                digit_to_powers.append(number)

    digit_to_powers.sort()
    return digit_to_powers[n - 1]",data\repos\Python\project_euler\problem_119\sol1.py,solution,134
2462,sol1.py::solution::18,"def solution(n: int = 1000) -> int:
    """"""
    Returns  r_max for 3 <= a <= n as explained above
    >>> solution(10)
    300
    >>> solution(100)
    330750
    >>> solution(1000)
    333082500
    """"""
    return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))",data\repos\Python\project_euler\problem_120\sol1.py,solution,98
2463,sol1.py::solution::29,"def solution(num_turns: int = 15) -> int:
    """"""
    Find the maximum prize fund that should be allocated to a single game in which
    fifteen turns are played.
    >>> solution(4)
    10
    >>> solution(10)
    225
    """"""
    total_prob: float = 0.0
    prob: float
    num_blue: int
    num_red: int
    ind: int
    col: int
    series: tuple[int, ...]

    for series in product(range(2), repeat=num_turns):
        num_blue = series.count(1)
        num_red = num_turns - num_blue
        if num_red >= num_blue:
            continue
        prob = 1.0
        for ind, col in enumerate(series, 2):
            if col == 0:
                prob *= (ind - 1) / ind
            else:
                prob *= 1 / ind

        total_prob += prob

    return int(1 / total_prob)",data\repos\Python\project_euler\problem_121\sol1.py,solution,217
2464,sol1.py::solve::40,"def solve(nums: list[int], goal: int, depth: int) -> bool:
    """"""
    Checks if nums can have a sum equal to goal, given that length of nums does
    not exceed depth.

    >>> solve([1], 2, 2)
    True
    >>> solve([1], 2, 0)
    False
    """"""
    if len(nums) > depth:
        return False
    for el in nums:
        if el + nums[-1] == goal:
            return True
        nums.append(el + nums[-1])
        if solve(nums=nums, goal=goal, depth=depth):
            return True
        del nums[-1]
    return False",data\repos\Python\project_euler\problem_122\sol1.py,solve,146
2465,sol1.py::solution::62,"def solution(n: int = 200) -> int:
    """"""
    Calculates sum of smallest number of multiplactions for each number up to
    and including n.

    >>> solution(1)
    0
    >>> solution(2)
    1
    >>> solution(14)
    45
    >>> solution(15)
    50
    """"""
    total = 0
    for i in range(2, n + 1):
        max_length = 0
        while True:
            nums = [1]
            max_length += 1
            if solve(nums=nums, goal=i, depth=max_length):
                break
        total += max_length
    return total",data\repos\Python\project_euler\problem_122\sol1.py,solution,146
2466,sol1.py::sieve::46,"def sieve() -> Generator[int]:
    """"""
    Returns a prime number generator using sieve method.
    >>> type(sieve())
    <class 'generator'>
    >>> primes = sieve()
    >>> next(primes)
    2
    >>> next(primes)
    3
    >>> next(primes)
    5
    >>> next(primes)
    7
    >>> next(primes)
    11
    >>> next(primes)
    13
    """"""
    factor_map: dict[int, int] = {}
    prime = 2
    while True:
        factor = factor_map.pop(prime, None)
        if factor:
            x = factor + prime
            while x in factor_map:
                x += factor
            factor_map[x] = factor
        else:
            factor_map[prime * prime] = prime
            yield prime
        prime += 1",data\repos\Python\project_euler\problem_123\sol1.py,sieve,185
2467,sol1.py::solution::80,"def solution(limit: float = 1e10) -> int:
    """"""
    Returns the least value of n for which the remainder first exceeds 10^10.
    >>> solution(1e8)
    2371
    >>> solution(1e9)
    7037
    """"""
    primes = sieve()

    n = 1
    while True:
        prime = next(primes)
        if (2 * prime * n) > limit:
            return n
        # Ignore the next prime as the reminder will be 2.
        next(primes)
        n += 2",data\repos\Python\project_euler\problem_123\sol1.py,solution,124
2468,sol1.py::is_palindrome::19,"def is_palindrome(n: int) -> bool:
    """"""
    Check if an integer is palindromic.
    >>> is_palindrome(12521)
    True
    >>> is_palindrome(12522)
    False
    >>> is_palindrome(12210)
    False
    """"""
    if n % 10 == 0:
        return False
    s = str(n)
    return s == s[::-1]",data\repos\Python\project_euler\problem_125\sol1.py,is_palindrome,90
2469,sol1.py::solution::35,"def solution() -> int:
    """"""
    Returns the sum of all numbers less than 1e8 that are both palindromic and
    can be written as the sum of consecutive squares.
    """"""
    answer = set()
    first_square = 1
    sum_squares = 5
    while sum_squares < LIMIT:
        last_square = first_square + 1
        while sum_squares < LIMIT:
            if is_palindrome(sum_squares):
                answer.add(sum_squares)
            last_square += 1
            sum_squares += last_square**2
        first_square += 1
        sum_squares = first_square**2 + (first_square + 1) ** 2

    return sum(answer)",data\repos\Python\project_euler\problem_125\sol1.py,solution,155
2470,sol1.py::least_divisible_repunit::17,"def least_divisible_repunit(divisor: int) -> int:
    """"""
    Return the least value k such that the Repunit of length k is divisible by divisor.
    >>> least_divisible_repunit(7)
    6
    >>> least_divisible_repunit(41)
    5
    >>> least_divisible_repunit(1234567)
    34020
    """"""
    if divisor % 5 == 0 or divisor % 2 == 0:
        return 0
    repunit = 1
    repunit_index = 1
    while repunit:
        repunit = (10 * repunit + 1) % divisor
        repunit_index += 1
    return repunit_index",data\repos\Python\project_euler\problem_129\sol1.py,least_divisible_repunit,154
2471,sol1.py::solution::37,"def solution(limit: int = 1000000) -> int:
    """"""
    Return the least value of n for which least_divisible_repunit(n)
    first exceeds limit.
    >>> solution(10)
    17
    >>> solution(100)
    109
    >>> solution(1000)
    1017
    """"""
    divisor = limit - 1
    if divisor % 2 == 0:
        divisor += 1
    while least_divisible_repunit(divisor) <= limit:
        divisor += 2
    return divisor",data\repos\Python\project_euler\problem_129\sol1.py,solution,117
2472,sol1.py::is_prime::18,"def is_prime(number: int) -> bool:
    """"""
    Determines whether number is prime

    >>> is_prime(3)
    True

    >>> is_prime(4)
    False
    """"""

    return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))",data\repos\Python\project_euler\problem_131\sol1.py,is_prime,65
2473,sol1.py::solution::32,"def solution(max_prime: int = 10**6) -> int:
    """"""
    Returns number of primes below max_prime with the property

    >>> solution(100)
    4
    """"""

    primes_count = 0
    cube_index = 1
    prime_candidate = 7
    while prime_candidate < max_prime:
        primes_count += is_prime(prime_candidate)

        cube_index += 1
        prime_candidate += 6 * cube_index

    return primes_count",data\repos\Python\project_euler\problem_131\sol1.py,solution,101
2474,sol1.py::solution::23,"def solution(limit: int = 1000000) -> int:
    """"""
    returns the values of n less than or equal to the limit
    have exactly ten distinct solutions.
    >>> solution(100)
    0
    >>> solution(10000)
    45
    >>> solution(50050)
    292
    """"""
    limit = limit + 1
    frequency = [0] * limit
    for first_term in range(1, limit):
        for n in range(first_term, limit, first_term):
            common_difference = first_term + n / first_term
            if common_difference % 4:  # d must be divisible by 4
                continue
            else:
                common_difference /= 4
                if (
                    first_term > common_difference
                    and first_term < 4 * common_difference
                ):  # since x, y, z are positive integers
                    frequency[n] += 1  # so z > 0, a > d and 4d < a

    count = sum(1 for x in frequency[1:limit] if x == 10)

    return count",data\repos\Python\project_euler\problem_135\sol1.py,solution,239
2475,sol1.py::solution::31,"def solution(n_limit: int = 50 * 10**6) -> int:
    """"""
    Define n count list and loop over delta, y to get the counts, then check
    which n has count == 1.

    >>> solution(3)
    0
    >>> solution(10)
    3
    >>> solution(100)
    25
    >>> solution(110)
    27
    """"""
    n_sol = [0] * n_limit

    for delta in range(1, (n_limit + 1) // 4 + 1):
        for y in range(4 * delta - 1, delta, -1):
            n = y * (4 * delta - y)
            if n >= n_limit:
                break
            n_sol[n] += 1

    ans = 0
    for i in range(n_limit):
        if n_sol[i] == 1:
            ans += 1

    return ans",data\repos\Python\project_euler\problem_136\sol1.py,solution,205
2476,sol1.py::next_point::35,"def next_point(
    point_x: float, point_y: float, incoming_gradient: float
) -> tuple[float, float, float]:
    """"""
    Given that a laser beam hits the interior of the white cell at point
    (point_x, point_y) with gradient incoming_gradient, return a tuple (x,y,m1)
    where the next point of contact with the interior is (x,y) with gradient m1.
    >>> next_point(5.0, 0.0, 0.0)
    (-5.0, 0.0, 0.0)
    >>> next_point(5.0, 0.0, -2.0)
    (0.0, -10.0, 2.0)
    """"""
    # normal_gradient = gradient of line through which the beam is reflected
    # outgoing_gradient = gradient of reflected line
    normal_gradient = point_y / 4 / point_x
    s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)
    c2 = (1 - normal_gradient * normal_gradient) / (
        1 + normal_gradient * normal_gradient
    )
    outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)

    # to find the next point, solve the simultaeneous equations:
    # y^2 + 4x^2 = 100
    # y - b = m * (x - a)
    # ==> A x^2 + B x + C = 0
    quadratic_term = outgoing_gradient**2 + 4
    linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)
    constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100

    x_minus = (
        -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)
    ) / (2 * quadratic_term)
    x_plus = (
        -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)
    ) / (2 * quadratic_term)

    # two solutions, one of which is our input point
    next_x = x_minus if isclose(x_plus, point_x) else x_plus
    next_y = point_y + outgoing_gradient * (next_x - point_x)

    return next_x, next_y, outgoing_gradient",data\repos\Python\project_euler\problem_144\sol1.py,next_point,512
2477,sol1.py::solution::78,"def solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:
    """"""
    Return the number of times that the beam hits the interior wall of the
    cell before exiting.
    >>> solution(0.00001,-10)
    1
    >>> solution(5, 0)
    287
    """"""
    num_reflections: int = 0
    point_x: float = first_x_coord
    point_y: float = first_y_coord
    gradient: float = (10.1 - point_y) / (0.0 - point_x)

    while not (-0.01 <= point_x <= 0.01 and point_y > 0):
        point_x, point_y, gradient = next_point(point_x, point_y, gradient)
        num_reflections += 1

    return num_reflections",data\repos\Python\project_euler\problem_144\sol1.py,solution,186
2478,sol1.py::slow_reversible_numbers::21,"def slow_reversible_numbers(
    remaining_length: int, remainder: int, digits: list[int], length: int
) -> int:
    """"""
    Count the number of reversible numbers of given length.
    Iterate over possible digits considering parity of current sum remainder.
    >>> slow_reversible_numbers(1, 0, [0], 1)
    0
    >>> slow_reversible_numbers(2, 0, [0] * 2, 2)
    20
    >>> slow_reversible_numbers(3, 0, [0] * 3, 3)
    100
    """"""
    if remaining_length == 0:
        if digits[0] == 0 or digits[-1] == 0:
            return 0

        for i in range(length // 2 - 1, -1, -1):
            remainder += digits[i] + digits[length - i - 1]

            if remainder % 2 == 0:
                return 0

            remainder //= 10

        return 1

    if remaining_length == 1:
        if remainder % 2 == 0:
            return 0

        result = 0
        for digit in range(10):
            digits[length // 2] = digit
            result += slow_reversible_numbers(
                0, (remainder + 2 * digit) // 10, digits, length
            )
        return result

    result = 0
    for digit1 in range(10):
        digits[(length + remaining_length) // 2 - 1] = digit1

        if (remainder + digit1) % 2 == 0:
            other_parity_digits = ODD_DIGITS
        else:
            other_parity_digits = EVEN_DIGITS

        for digit2 in other_parity_digits:
            digits[(length - remaining_length) // 2] = digit2
            result += slow_reversible_numbers(
                remaining_length - 2,
                (remainder + digit1 + digit2) // 10,
                digits,
                length,
            )
    return result",data\repos\Python\project_euler\problem_145\sol1.py,slow_reversible_numbers,441
2479,sol1.py::slow_solution::80,"def slow_solution(max_power: int = 9) -> int:
    """"""
    To evaluate the solution, use solution()
    >>> slow_solution(3)
    120
    >>> slow_solution(6)
    18720
    >>> slow_solution(7)
    68720
    """"""
    result = 0
    for length in range(1, max_power + 1):
        result += slow_reversible_numbers(length, 0, [0] * length, length)
    return result",data\repos\Python\project_euler\problem_145\sol1.py,slow_solution,105
2480,sol1.py::reversible_numbers::96,"def reversible_numbers(
    remaining_length: int, remainder: int, digits: list[int], length: int
) -> int:
    """"""
    Count the number of reversible numbers of given length.
    Iterate over possible digits considering parity of current sum remainder.
    >>> reversible_numbers(1, 0, [0], 1)
    0
    >>> reversible_numbers(2, 0, [0] * 2, 2)
    20
    >>> reversible_numbers(3, 0, [0] * 3, 3)
    100
    """"""
    # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers
    if (length - 1) % 4 == 0:
        return 0

    return slow_reversible_numbers(remaining_length, remainder, digits, length)",data\repos\Python\project_euler\problem_145\sol1.py,reversible_numbers,187
2481,sol1.py::solution::116,"def solution(max_power: int = 9) -> int:
    """"""
    To evaluate the solution, use solution()
    >>> solution(3)
    120
    >>> solution(6)
    18720
    >>> solution(7)
    68720
    """"""
    result = 0
    for length in range(1, max_power + 1):
        result += reversible_numbers(length, 0, [0] * length, length)
    return result",data\repos\Python\project_euler\problem_145\sol1.py,solution,99
2482,sol1.py::benchmark::132,"def benchmark() -> None:
    """"""
    Benchmarks
    """"""
    # Running performance benchmarks...
    # slow_solution : 292.9300301000003
    # solution      : 54.90970860000016

    from timeit import timeit

    print(""Running performance benchmarks..."")

    print(f""slow_solution : {timeit('slow_solution()', globals=globals(), number=10)}"")
    print(f""solution      : {timeit('solution()', globals=globals(), number=10)}"")",data\repos\Python\project_euler\problem_145\sol1.py,benchmark,109
2483,sol1.py::solve::13,"def solve(
    digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int]
) -> int:
    """"""
    Solve for remaining 'digit' digits, with previous 'prev1' digit, and
    previous-previous 'prev2' digit, total sum of 'sum_max'.
    Pass around 'cache' to store/reuse intermediate results.

    >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=True, cache={})
    9
    >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=False, cache={})
    10
    """"""
    if digit == 0:
        return 1

    cache_str = f""{digit},{prev1},{prev2}""
    if cache_str in cache:
        return cache[cache_str]

    comb = 0
    for curr in range(sum_max - prev1 - prev2 + 1):
        if first and curr == 0:
            continue

        comb += solve(
            digit=digit - 1,
            prev1=curr,
            prev2=prev1,
            sum_max=sum_max,
            first=False,
            cache=cache,
        )

    cache[cache_str] = comb
    return comb",data\repos\Python\project_euler\problem_164\sol1.py,solve,287
2484,sol1.py::solution::51,"def solution(n_digits: int = 20) -> int:
    """"""
    Solves the problem for n_digits number of digits.

    >>> solution(2)
    45
    >>> solution(10)
    21838806
    """"""
    cache: dict[str, int] = {}
    return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)",data\repos\Python\project_euler\problem_164\sol1.py,solution,91
2485,sol1.py::solution::17,"def solution(limit: int = 1000000) -> int:
    """"""
    Return the number of different square laminae that can be formed using up to
    one million tiles.
    >>> solution(100)
    41
    """"""
    answer = 0

    for outer_width in range(3, (limit // 4) + 2):
        if outer_width**2 > limit:
            hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)
        else:
            hole_width_lower_bound = 1
        if (outer_width - hole_width_lower_bound) % 2:
            hole_width_lower_bound += 1

        answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1

    return answer",data\repos\Python\project_euler\problem_173\sol1.py,solution,167
2486,sol1.py::solution::24,"def solution(t_limit: int = 1000000, n_limit: int = 10) -> int:
    """"""
    Return the sum of N(n) for 1 <= n <= n_limit.

    >>> solution(1000,5)
    222
    >>> solution(1000,10)
    249
    >>> solution(10000,10)
    2383
    """"""
    count: defaultdict = defaultdict(int)

    for outer_width in range(3, (t_limit // 4) + 2):
        if outer_width * outer_width > t_limit:
            hole_width_lower_bound = max(
                ceil(sqrt(outer_width * outer_width - t_limit)), 1
            )
        else:
            hole_width_lower_bound = 1

        hole_width_lower_bound += (outer_width - hole_width_lower_bound) % 2

        for hole_width in range(hole_width_lower_bound, outer_width - 1, 2):
            count[outer_width * outer_width - hole_width * hole_width] += 1

    return sum(1 for n in count.values() if 1 <= n <= n_limit)",data\repos\Python\project_euler\problem_174\sol1.py,solution,240
2487,sol1.py::is_sq::54,"def is_sq(number: int) -> bool:
    """"""
    Check if number is a perfect square.

    >>> is_sq(1)
    True
    >>> is_sq(1000001)
    False
    >>> is_sq(1000000)
    True
    """"""
    sq: int = int(number**0.5)
    return number == sq * sq",data\repos\Python\project_euler\problem_180\sol1.py,is_sq,76
2488,sol1.py::add_three::69,"def add_three(
    x_num: int, x_den: int, y_num: int, y_den: int, z_num: int, z_den: int
) -> tuple[int, int]:
    """"""
    Given the numerators and denominators of three fractions, return the
    numerator and denominator of their sum in lowest form.
    >>> add_three(1, 3, 1, 3, 1, 3)
    (1, 1)
    >>> add_three(2, 5, 4, 11, 12, 3)
    (262, 55)
    """"""
    top: int = x_num * y_den * z_den + y_num * x_den * z_den + z_num * x_den * y_den
    bottom: int = x_den * y_den * z_den
    hcf: int = gcd(top, bottom)
    top //= hcf
    bottom //= hcf
    return top, bottom",data\repos\Python\project_euler\problem_180\sol1.py,add_three,204
2489,sol1.py::solution::88,"def solution(order: int = 35) -> int:
    """"""
    Find the sum of the numerator and denominator of the sum of all s(x,y,z) for
    golden triples (x,y,z) of the given order.

    >>> solution(5)
    296
    >>> solution(10)
    12519
    >>> solution(20)
    19408891927
    """"""
    unique_s: set = set()
    hcf: int
    total: Fraction = Fraction(0)
    fraction_sum: tuple[int, int]

    for x_num in range(1, order + 1):
        for x_den in range(x_num + 1, order + 1):
            for y_num in range(1, order + 1):
                for y_den in range(y_num + 1, order + 1):
                    # n=1
                    z_num = x_num * y_den + x_den * y_num
                    z_den = x_den * y_den
                    hcf = gcd(z_num, z_den)
                    z_num //= hcf
                    z_den //= hcf
                    if 0 < z_num < z_den <= order:
                        fraction_sum = add_three(
                            x_num, x_den, y_num, y_den, z_num, z_den
                        )
                        unique_s.add(fraction_sum)

                    # n=2
                    z_num = (
                        x_num * x_num * y_den * y_den + x_den * x_den * y_num * y_num
                    )
                    z_den = x_den * x_den * y_den * y_den
                    if is_sq(z_num) and is_sq(z_den):
                        z_num = int(sqrt(z_num))
                        z_den = int(sqrt(z_den))
                        hcf = gcd(z_num, z_den)
                        z_num //= hcf
                        z_den //= hcf
                        if 0 < z_num < z_den <= order:
                            fraction_sum = add_three(
                                x_num, x_den, y_num, y_den, z_num, z_den
                            )
                            unique_s.add(fraction_sum)

                    # n=-1
                    z_num = x_num * y_num
                    z_den = x_den * y_num + x_num * y_den
                    hcf = gcd(z_num, z_den)
                    z_num //= hcf
                    z_den //= hcf
                    if 0 < z_num < z_den <= order:
                        fraction_sum = add_three(
                            x_num, x_den, y_num, y_den, z_num, z_den
                        )
                        unique_s.add(fraction_sum)

                    # n=2
                    z_num = x_num * x_num * y_num * y_num
                    z_den = (
                        x_den * x_den * y_num * y_num + x_num * x_num * y_den * y_den
                    )
                    if is_sq(z_num) and is_sq(z_den):
                        z_num = int(sqrt(z_num))
                        z_den = int(sqrt(z_den))
                        hcf = gcd(z_num, z_den)
                        z_num //= hcf
                        z_den //= hcf
                        if 0 < z_num < z_den <= order:
                            fraction_sum = add_three(
                                x_num, x_den, y_num, y_den, z_num, z_den
                            )
                            unique_s.add(fraction_sum)

    for num, den in unique_s:
        total += Fraction(num, den)

    return total.denominator + total.numerator",data\repos\Python\project_euler\problem_180\sol1.py,solution,734
2490,sol1.py::slow_calculate_prime_numbers::17,"def slow_calculate_prime_numbers(max_number: int) -> list[int]:
    """"""
    Returns prime numbers below max_number.
    See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

    >>> slow_calculate_prime_numbers(10)
    [2, 3, 5, 7]

    >>> slow_calculate_prime_numbers(2)
    []
    """"""

    # List containing a bool value for every number below max_number/2
    is_prime = [True] * max_number

    for i in range(2, isqrt(max_number - 1) + 1):
        if is_prime[i]:
            # Mark all multiple of i as not prime
            for j in range(i**2, max_number, i):
                is_prime[j] = False

    return [i for i in range(2, max_number) if is_prime[i]]",data\repos\Python\project_euler\problem_187\sol1.py,slow_calculate_prime_numbers,185
2491,sol1.py::calculate_prime_numbers::41,"def calculate_prime_numbers(max_number: int) -> list[int]:
    """"""
    Returns prime numbers below max_number.
    See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

    >>> calculate_prime_numbers(10)
    [2, 3, 5, 7]

    >>> calculate_prime_numbers(2)
    []
    """"""

    if max_number <= 2:
        return []

    # List containing a bool value for every odd number below max_number/2
    is_prime = [True] * (max_number // 2)

    for i in range(3, isqrt(max_number - 1) + 1, 2):
        if is_prime[i // 2]:
            # Mark all multiple of i as not prime using list slicing
            is_prime[i**2 // 2 :: i] = [False] * (
                # Same as: (max_number - (i**2)) // (2 * i) + 1
                # but faster than len(is_prime[i**2 // 2 :: i])
                len(range(i**2 // 2, max_number // 2, i))
            )

    return [2] + [2 * i + 1 for i in range(1, max_number // 2) if is_prime[i]]",data\repos\Python\project_euler\problem_187\sol1.py,calculate_prime_numbers,273
2492,sol1.py::slow_solution::71,"def slow_solution(max_number: int = 10**8) -> int:
    """"""
    Returns the number of composite integers below max_number have precisely two,
    not necessarily distinct, prime factors.

    >>> slow_solution(30)
    10
    """"""

    prime_numbers = slow_calculate_prime_numbers(max_number // 2)

    semiprimes_count = 0
    left = 0
    right = len(prime_numbers) - 1
    while left <= right:
        while prime_numbers[left] * prime_numbers[right] >= max_number:
            right -= 1
        semiprimes_count += right - left + 1
        left += 1

    return semiprimes_count",data\repos\Python\project_euler\problem_187\sol1.py,slow_solution,150
2493,sol1.py::while_solution::94,"def while_solution(max_number: int = 10**8) -> int:
    """"""
    Returns the number of composite integers below max_number have precisely two,
    not necessarily distinct, prime factors.

    >>> while_solution(30)
    10
    """"""

    prime_numbers = calculate_prime_numbers(max_number // 2)

    semiprimes_count = 0
    left = 0
    right = len(prime_numbers) - 1
    while left <= right:
        while prime_numbers[left] * prime_numbers[right] >= max_number:
            right -= 1
        semiprimes_count += right - left + 1
        left += 1

    return semiprimes_count",data\repos\Python\project_euler\problem_187\sol1.py,while_solution,148
2494,sol1.py::solution::117,"def solution(max_number: int = 10**8) -> int:
    """"""
    Returns the number of composite integers below max_number have precisely two,
    not necessarily distinct, prime factors.

    >>> solution(30)
    10
    """"""

    prime_numbers = calculate_prime_numbers(max_number // 2)

    semiprimes_count = 0
    right = len(prime_numbers) - 1
    for left in range(len(prime_numbers)):
        if left > right:
            break
        for r in range(right, left - 2, -1):
            if prime_numbers[left] * prime_numbers[r] < max_number:
                break
        right = r
        semiprimes_count += right - left + 1

    return semiprimes_count",data\repos\Python\project_euler\problem_187\sol1.py,solution,164
2495,sol1.py::benchmark::142,"def benchmark() -> None:
    """"""
    Benchmarks
    """"""
    # Running performance benchmarks...
    # slow_solution : 108.50874730000032
    # while_sol     : 28.09581200000048
    # solution      : 25.063097400000515

    from timeit import timeit

    print(""Running performance benchmarks..."")

    print(f""slow_solution : {timeit('slow_solution()', globals=globals(), number=10)}"")
    print(f""while_sol     : {timeit('while_solution()', globals=globals(), number=10)}"")
    print(f""solution      : {timeit('solution()', globals=globals(), number=10)}"")",data\repos\Python\project_euler\problem_187\sol1.py,benchmark,148
2496,sol1.py::solution::45,"def solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:
    """"""
    Returns the last 8 digits of the hyperexponentiation of base by
    height, i.e. the number baseheight:

    >>> solution(base=3, height=2)
    27
    >>> solution(base=3, height=3)
    97484987
    >>> solution(base=123, height=456, digits=4)
    2547
    """"""

    # calculate baseheight by right-assiciative repeated modular
    # exponentiation
    result = base
    for _ in range(1, height):
        result = _modexpt(base, result, 10**digits)

    return result",data\repos\Python\project_euler\problem_188\sol1.py,solution,168
2497,sol1.py::solution::23,"def solution(n: int = 15) -> int:
    """"""
    Calculate sum of |_ P_m _| for m from 2 to n.

    >>> solution(2)
    1
    >>> solution(3)
    2
    >>> solution(4)
    4
    >>> solution(5)
    10
    """"""
    total = 0
    for m in range(2, n + 1):
        x1 = 2 / (m + 1)
        p = 1.0
        for i in range(1, m + 1):
            xi = i * x1
            p *= xi**i
        total += int(p)
    return total",data\repos\Python\project_euler\problem_190\sol1.py,solution,149
2498,sol1.py::solution::89,"def solution(days: int = 30) -> int:
    """"""
    Returns the number of possible prize strings for a particular number
    of days, using a simple recursive function with caching to speed it up.

    >>> solution()
    1918080160
    >>> solution(4)
    43
    """"""

    return _calculate(days, absent=0, late=0)",data\repos\Python\project_euler\problem_191\sol1.py,solution,80
2499,sol1.py::get_pascal_triangle_unique_coefficients::34,"def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:
    """"""
    Returns the unique coefficients of a Pascal's triangle of depth ""depth"".

    The coefficients of this triangle are symmetric. A further improvement to this
    method could be to calculate the coefficients once per level. Nonetheless,
    the current implementation is fast enough for the original problem.

    >>> get_pascal_triangle_unique_coefficients(1)
    {1}
    >>> get_pascal_triangle_unique_coefficients(2)
    {1}
    >>> get_pascal_triangle_unique_coefficients(3)
    {1, 2}
    >>> get_pascal_triangle_unique_coefficients(8)
    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}
    """"""
    coefficients = {1}
    previous_coefficients = [1]
    for _ in range(2, depth + 1):
        coefficients_begins_one = [*previous_coefficients, 0]
        coefficients_ends_one = [0, *previous_coefficients]
        previous_coefficients = []
        for x, y in zip(coefficients_begins_one, coefficients_ends_one):
            coefficients.add(x + y)
            previous_coefficients.append(x + y)
    return coefficients",data\repos\Python\project_euler\problem_203\sol1.py,get_pascal_triangle_unique_coefficients,272
2500,sol1.py::get_squarefrees::63,"def get_squarefrees(unique_coefficients: set[int]) -> set[int]:
    """"""
    Calculates the squarefree numbers inside unique_coefficients.

    Based on the definition of a non-squarefree number, then any non-squarefree
    n can be decomposed as n = p*p*r, where p is positive prime number and r
    is a positive integer.

    Under the previous formula, any coefficient that is lower than p*p is
    squarefree as r cannot be negative. On the contrary, if any r exists such
    that n = p*p*r, then the number is non-squarefree.

    >>> get_squarefrees({1})
    {1}
    >>> get_squarefrees({1, 2})
    {1, 2}
    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})
    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}
    """"""

    non_squarefrees = set()
    for number in unique_coefficients:
        divisor = 2
        copy_number = number
        while divisor**2 <= copy_number:
            multiplicity = 0
            while copy_number % divisor == 0:
                copy_number //= divisor
                multiplicity += 1
            if multiplicity >= 2:
                non_squarefrees.add(number)
                break
            divisor += 1

    return unique_coefficients.difference(non_squarefrees)",data\repos\Python\project_euler\problem_203\sol1.py,get_squarefrees,337
2501,sol1.py::solution::100,"def solution(n: int = 51) -> int:
    """"""
    Returns the sum of squarefrees for a given Pascal's Triangle of depth n.

    >>> solution(1)
    1
    >>> solution(8)
    105
    >>> solution(9)
    175
    """"""
    unique_coefficients = get_pascal_triangle_unique_coefficients(n)
    squarefrees = get_squarefrees(unique_coefficients)
    return sum(squarefrees)",data\repos\Python\project_euler\problem_203\sol1.py,solution,98
2502,sol1.py::total_frequency_distribution::17,"def total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:
    """"""
    Returns frequency distribution of total

    >>> total_frequency_distribution(sides_number=6, dice_number=1)
    [0, 1, 1, 1, 1, 1, 1]

    >>> total_frequency_distribution(sides_number=4, dice_number=2)
    [0, 0, 1, 2, 3, 4, 3, 2, 1]
    """"""

    max_face_number = sides_number
    max_total = max_face_number * dice_number
    totals_frequencies = [0] * (max_total + 1)

    min_face_number = 1
    faces_numbers = range(min_face_number, max_face_number + 1)
    for dice_numbers in product(faces_numbers, repeat=dice_number):
        total = sum(dice_numbers)
        totals_frequencies[total] += 1

    return totals_frequencies",data\repos\Python\project_euler\problem_205\sol1.py,total_frequency_distribution,210
2503,sol1.py::solution::41,"def solution() -> float:
    """"""
    Returns probability that Pyramidal Peter beats Cubic Colin
    rounded to seven decimal places in the form 0.abcdefg

    >>> solution()
    0.5731441
    """"""

    peter_totals_frequencies = total_frequency_distribution(
        sides_number=4, dice_number=9
    )
    colin_totals_frequencies = total_frequency_distribution(
        sides_number=6, dice_number=6
    )

    peter_wins_count = 0
    min_peter_total = 9
    max_peter_total = 4 * 9
    min_colin_total = 6
    for peter_total in range(min_peter_total, max_peter_total + 1):
        peter_wins_count += peter_totals_frequencies[peter_total] * sum(
            colin_totals_frequencies[min_colin_total:peter_total]
        )

    total_games_number = (4**9) * (6**6)
    peter_win_probability = peter_wins_count / total_games_number

    rounded_peter_win_probability = round(peter_win_probability, ndigits=7)

    return rounded_peter_win_probability",data\repos\Python\project_euler\problem_205\sol1.py,solution,243
2504,sol1.py::is_square_form::36,"def is_square_form(num: int) -> bool:
    """"""
    Determines if num is in the form 1_2_3_4_5_6_7_8_9

    >>> is_square_form(1)
    False
    >>> is_square_form(112233445566778899)
    True
    >>> is_square_form(123456789012345678)
    False
    """"""
    digit = 9

    while num > 0:
        if num % 10 != digit:
            return False
        num //= 100
        digit -= 1

    return True",data\repos\Python\project_euler\problem_206\sol1.py,is_square_form,126
2505,sol1.py::solution::58,"def solution() -> int:
    """"""
    Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0
    """"""
    num = 138902663

    while not is_square_form(num * num):
        if num % 10 == 3:
            num -= 6  # (3 - 6) % 10 = 7
        else:
            num -= 4  # (7 - 4) % 10 = 3

    return num * 10",data\repos\Python\project_euler\problem_206\sol1.py,solution,119
2506,sol1.py::check_partition_perfect::44,"def check_partition_perfect(positive_integer: int) -> bool:
    """"""

    Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a
    real number.

    >>> check_partition_perfect(2)
    True

    >>> check_partition_perfect(6)
    False

    """"""

    exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)

    return exponent == int(exponent)",data\repos\Python\project_euler\problem_207\sol1.py,check_partition_perfect,113
2507,sol1.py::solution::63,"def solution(max_proportion: float = 1 / 12345) -> int:
    """"""
    Find m for which the proportion of perfect partitions to total partitions is lower
    than max_proportion

    >>> solution(1) > 5
    True

    >>> solution(1/2) > 10
    True

    >>> solution(3 / 13) > 185
    True

    """"""

    total_partitions = 0
    perfect_partitions = 0

    integer = 3
    while True:
        partition_candidate = (integer**2 - 1) / 4
        # if candidate is an integer, then there is a partition for k
        if partition_candidate == int(partition_candidate):
            partition_candidate = int(partition_candidate)
            total_partitions += 1
            if check_partition_perfect(partition_candidate):
                perfect_partitions += 1
        if (
            perfect_partitions > 0
            and perfect_partitions / total_partitions < max_proportion
        ):
            return int(partition_candidate)
        integer += 1",data\repos\Python\project_euler\problem_207\sol1.py,solution,223
2508,sol1.py::prime_sieve::23,"def prime_sieve(n: int) -> list:
    """"""
    Sieve of Erotosthenes
    Function to return all the prime numbers up to a certain number
    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
    >>> prime_sieve(3)
    [2]
    >>> prime_sieve(50)
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    """"""
    is_prime = [True] * n
    is_prime[0] = False
    is_prime[1] = False
    is_prime[2] = True

    for i in range(3, int(n**0.5 + 1), 2):
        index = i * 2
        while index < n:
            is_prime[index] = False
            index = index + i

    primes = [2]

    for i in range(3, n, 2):
        if is_prime[i]:
            primes.append(i)

    return primes",data\repos\Python\project_euler\problem_234\sol1.py,prime_sieve,240
2509,sol1.py::solution::53,"def solution(limit: int = 999_966_663_333) -> int:
    """"""
    Computes the solution to the problem up to the specified limit
    >>> solution(1000)
    34825

    >>> solution(10_000)
    1134942

    >>> solution(100_000)
    36393008
    """"""
    primes_upper_bound = math.floor(math.sqrt(limit)) + 100
    primes = prime_sieve(primes_upper_bound)

    matches_sum = 0
    prime_index = 0
    last_prime = primes[prime_index]

    while (last_prime**2) <= limit:
        next_prime = primes[prime_index + 1]

        lower_bound = last_prime**2
        upper_bound = next_prime**2

        # Get numbers divisible by lps(current)
        current = lower_bound + last_prime
        while upper_bound > current <= limit:
            matches_sum += current
            current += last_prime

        # Reset the upper_bound
        while (upper_bound - next_prime) > limit:
            upper_bound -= next_prime

        # Add the numbers divisible by ups(current)
        current = upper_bound - next_prime
        while current > lower_bound:
            matches_sum += current
            current -= next_prime

        # Remove the numbers divisible by both ups and lps
        current = 0
        while upper_bound > current <= limit:
            if current <= lower_bound:
                # Increment the current number
                current += last_prime * next_prime
                continue

            if current > limit:
                break

            # Remove twice since it was added by both ups and lps
            matches_sum -= current * 2

            # Increment the current number
            current += last_prime * next_prime

        # Setup for next pair
        last_prime = next_prime
        prime_index += 1

    return matches_sum",data\repos\Python\project_euler\problem_234\sol1.py,solution,397
2510,sol1.py::solution::36,"def solution(exponent: int = 30) -> int:
    """"""
    For any given exponent x >= 0, 1 <= n <= 2^x.
    This function returns how many Nim games are lost given that
    each Nim game has three heaps of the form (n, 2*n, 3*n).
    >>> solution(0)
    1
    >>> solution(2)
    3
    >>> solution(10)
    144
    """"""
    # To find how many total games were lost for a given exponent x,
    # we need to find the Fibonacci number F(x+2).
    fibonacci_index = exponent + 2
    phi = (1 + 5**0.5) / 2
    fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5

    return int(fibonacci)",data\repos\Python\project_euler\problem_301\sol1.py,solution,192
2511,sol1.py::solve::67,"def solve(arr: NDArray, row: int, cols: set[int], cache: dict[str, int]) -> int:
    """"""
    Finds the max sum for array `arr` starting with row index `row`, and with columns
    included in `cols`. `cache` is used for caching intermediate results.

    >>> solve(arr=np.array([[1, 2], [3, 4]]), row=0, cols={0, 1}, cache={})
    5
    """"""

    cache_id = f""{row}, {sorted(cols)}""
    if cache_id in cache:
        return cache[cache_id]

    if row == len(arr):
        return 0

    max_sum = 0
    for col in cols:
        new_cols = cols - {col}
        max_sum = max(
            max_sum,
            int(arr[row, col])
            + solve(arr=arr, row=row + 1, cols=new_cols, cache=cache),
        )
    cache[cache_id] = max_sum
    return max_sum",data\repos\Python\project_euler\problem_345\sol1.py,solve,218
2512,sol1.py::solution::95,"def solution(matrix_str: list[str] = MATRIX_2) -> int:
    """"""
    Takes list of strings `matrix_str` to parse the matrix and calculates the max sum.

    >>> solution([""1 2"", ""3 4""])
    5
    >>> solution(MATRIX_1)
    3315
    """"""

    n = len(matrix_str)
    arr = np.empty(shape=(n, n), dtype=int)
    for row, matrix_row_str in enumerate(matrix_str):
        matrix_row_list_str = matrix_row_str.split()
        for col, elem_str in enumerate(matrix_row_list_str):
            arr[row, col] = int(elem_str)

    cache: dict[str, int] = {}
    return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)",data\repos\Python\project_euler\problem_345\sol1.py,solution,167
2513,sol1.py::solution::34,"def solution(num_picks: int = 20) -> str:
    """"""
    Calculates the expected number of distinct colours

    >>> solution(10)
    '5.669644129'

    >>> solution(30)
    '6.985042712'
    """"""
    total = math.comb(NUM_BALLS, num_picks)
    missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)

    result = NUM_COLOURS * (1 - missing_colour / total)

    return f""{result:.9f}""",data\repos\Python\project_euler\problem_493\sol1.py,solution,117
2514,sol1.py::next_term::20,"def next_term(a_i, k, i, n):
    """"""
    Calculates and updates a_i in-place to either the n-th term or the
    smallest term for which c > 10^k when the terms are written in the form:
            a(i) = b * 10^k + c

    For any a(i), if digitsum(b) and c have the same value, the difference
    between subsequent terms will be the same until c >= 10^k.  This difference
    is cached to greatly speed up the computation.

    Arguments:
    a_i -- array of digits starting from the one's place that represent
           the i-th term in the sequence
    k --  k when terms are written in the from a(i) = b*10^k + c.
          Term are calulcated until c > 10^k or the n-th term is reached.
    i -- position along the sequence
    n -- term to calculate up to if k is large enough

    Return: a tuple of difference between ending term and starting term, and
    the number of terms calculated. ex. if starting term is a_0=1, and
    ending term is a_10=62, then (61, 9) is returned.
    """"""
    # ds_b - digitsum(b)
    ds_b = sum(a_i[j] for j in range(k, len(a_i)))
    c = sum(a_i[j] * base[j] for j in range(min(len(a_i), k)))

    diff, dn = 0, 0
    max_dn = n - i

    sub_memo = memo.get(ds_b)

    if sub_memo is not None:
        jumps = sub_memo.get(c)

        if jumps is not None and len(jumps) > 0:
            # find and make the largest jump without going over
            max_jump = -1
            for _k in range(len(jumps) - 1, -1, -1):
                if jumps[_k][2] <= k and jumps[_k][1] <= max_dn:
                    max_jump = _k
                    break

            if max_jump >= 0:
                diff, dn, _kk = jumps[max_jump]
                # since the difference between jumps is cached, add c
                new_c = diff + c
                for j in range(min(k, len(a_i))):
                    new_c, a_i[j] = divmod(new_c, 10)
                if new_c > 0:
                    add(a_i, k, new_c)

        else:
            sub_memo[c] = []
    else:
        sub_memo = {c: []}
        memo[ds_b] = sub_memo

    if dn >= max_dn or c + diff >= base[k]:
        return diff, dn

    if k > ks[0]:
        while True:
            # keep doing smaller jumps
            _diff, terms_jumped = next_term(a_i, k - 1, i + dn, n)
            diff += _diff
            dn += terms_jumped

            if dn >= max_dn or c + diff >= base[k]:
                break
    else:
        # would be too small a jump, just compute sequential terms instead
        _diff, terms_jumped = compute(a_i, k, i + dn, n)
        diff += _diff
        dn += terms_jumped

    jumps = sub_memo[c]

    # keep jumps sorted by # of terms skipped
    j = 0
    while j < len(jumps):
        if jumps[j][1] > dn:
            break
        j += 1

    # cache the jump for this value digitsum(b) and c
    sub_memo[c].insert(j, (diff, dn, k))
    return (diff, dn)",data\repos\Python\project_euler\problem_551\sol1.py,next_term,811
2515,sol1.py::compute::109,"def compute(a_i, k, i, n):
    """"""
    same as next_term(a_i, k, i, n) but computes terms without memoizing results.
    """"""
    if i >= n:
        return 0, i
    if k > len(a_i):
        a_i.extend([0 for _ in range(k - len(a_i))])

    # note: a_i -> b * 10^k + c
    # ds_b -> digitsum(b)
    # ds_c -> digitsum(c)
    start_i = i
    ds_b, ds_c, diff = 0, 0, 0
    for j in range(len(a_i)):
        if j >= k:
            ds_b += a_i[j]
        else:
            ds_c += a_i[j]

    while i < n:
        i += 1
        addend = ds_c + ds_b
        diff += addend
        ds_c = 0
        for j in range(k):
            s = a_i[j] + addend
            addend, a_i[j] = divmod(s, 10)

            ds_c += a_i[j]

        if addend > 0:
            break

    if addend > 0:
        add(a_i, k, addend)
    return diff, i - start_i",data\repos\Python\project_euler\problem_551\sol1.py,compute,281
2516,sol1.py::add::148,"def add(digits, k, addend):
    """"""
    adds addend to digit array given in digits
    starting at index k
    """"""
    for j in range(k, len(digits)):
        s = digits[j] + addend
        if s >= 10:
            quotient, digits[j] = divmod(s, 10)
            addend = addend // 10 + quotient
        else:
            digits[j] = s
            addend = addend // 10

        if addend == 0:
            break

    while addend > 0:
        addend, digit = divmod(addend, 10)
        digits.append(digit)",data\repos\Python\project_euler\problem_551\sol1.py,add,142
2517,sol1.py::solution::170,"def solution(n: int = 10**15) -> int:
    """"""
    returns n-th term of sequence

    >>> solution(10)
    62

    >>> solution(10**6)
    31054319

    >>> solution(10**15)
    73597483551591773
    """"""

    digits = [1]
    i = 1
    dn = 0
    while True:
        _diff, terms_jumped = next_term(digits, 20, i + dn, n)
        dn += terms_jumped
        if dn == n - i:
            break

    a_n = 0
    for j in range(len(digits)):
        a_n += digits[j] * 10**j
    return a_n",data\repos\Python\project_euler\problem_551\sol1.py,solution,160
2518,sol1.py::circle_bottom_arc_integral::32,"def circle_bottom_arc_integral(point: float) -> float:
    """"""
    Returns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)

    >>> circle_bottom_arc_integral(0)
    0.39269908169872414

    >>> circle_bottom_arc_integral(1 / 2)
    0.44634954084936207

    >>> circle_bottom_arc_integral(1)
    0.5
    """"""

    return (
        (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))
    ) / 4",data\repos\Python\project_euler\problem_587\sol1.py,circle_bottom_arc_integral,148
2519,sol1.py::concave_triangle_area::51,"def concave_triangle_area(circles_number: int) -> float:
    """"""
    Returns area of concave triangle

    >>> concave_triangle_area(1)
    0.026825229575318944

    >>> concave_triangle_area(2)
    0.01956236140083944
    """"""

    intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (
        2 * (circles_number**2 + 1)
    )
    intersection_x = circles_number * intersection_y

    triangle_area = intersection_x * intersection_y / 2
    concave_region_area = circle_bottom_arc_integral(
        1 / 2
    ) - circle_bottom_arc_integral(intersection_x)

    return triangle_area + concave_region_area",data\repos\Python\project_euler\problem_587\sol1.py,concave_triangle_area,164
2520,sol1.py::solution::75,"def solution(fraction: float = 1 / 1000) -> int:
    """"""
    Returns least value of n
    for which the concave triangle occupies less than fraction of the L-section

    >>> solution(1 / 10)
    15
    """"""

    l_section_area = (1 - pi / 4) / 4

    for n in count(1):
        if concave_triangle_area(n) / l_section_area < fraction:
            return n

    return -1",data\repos\Python\project_euler\problem_587\sol1.py,solution,105
2521,sol1.py::log_difference::20,"def log_difference(number: int) -> float:
    """"""
    This function returns the decimal value of a number multiplied with log(2)
    Since the problem is on powers of two, finding the powers of two with
    large exponents is time consuming. Hence we use log to reduce compute time.

    We can find out that the first power of 2 with starting digits 123 is 90.
    Computing 2^90 is time consuming.
    Hence we find log(2^90) = 90*log(2) = 27.092699609758302
    But we require only the decimal part to determine whether the power starts with 123.
    So we just return the decimal part of the log product.
    Therefore we return 0.092699609758302

    >>> log_difference(90)
    0.092699609758302
    >>> log_difference(379)
    0.090368356648852

    """"""

    log_number = math.log(2, 10) * number
    difference = round((log_number - int(log_number)), 15)

    return difference",data\repos\Python\project_euler\problem_686\sol1.py,log_difference,233
2522,sol1.py::solution::46,"def solution(number: int = 678910) -> int:
    """"""
    This function calculates the power of two which is nth (n = number)
    smallest value of power of 2
    such that the starting digits of the 2^power is 123.

    For example the powers of 2 for which starting digits is 123 are:
    90, 379, 575, 864, 1060, 1545, 1741, 2030, 2226, 2515 and so on.
    90 is the first power of 2 whose starting digits are 123,
    379 is second power of 2 whose starting digits are 123,
    and so on.

    So if number = 10, then solution returns 2515 as we observe from above series.

    We will define a lowerbound and upperbound.
    lowerbound = log(1.23), upperbound = log(1.24)
    because we need to find the powers that yield 123 as starting digits.

    log(1.23) = 0.08990511143939792, log(1,24) = 0.09342168516223506.
    We use 1.23 and not 12.3 or 123, because log(1.23) yields only decimal value
    which is less than 1.
    log(12.3) will be same decimal value but 1 added to it
    which is log(12.3) = 1.093421685162235.
    We observe that decimal value remains same no matter 1.23 or 12.3
    Since we use the function log_difference(),
    which returns the value that is only decimal part, using 1.23 is logical.

    If we see, 90*log(2) = 27.092699609758302,
    decimal part = 0.092699609758302, which is inside the range of lowerbound
    and upperbound.

    If we compute the difference between all the powers which lead to 123
    starting digits is as follows:

    379 - 90 = 289
    575 - 379 = 196
    864 - 575 = 289
    1060 - 864 = 196

    We see a pattern here. The difference is either 196 or 289 = 196 + 93.

    Hence to optimize the algorithm we will increment by 196 or 93 depending upon the
    log_difference() value.

    Let's take for example 90.
    Since 90 is the first power leading to staring digits as 123,
    we will increment iterator by 196.
    Because the difference between any two powers leading to 123
    as staring digits is greater than or equal to 196.
    After incrementing by 196 we get 286.

    log_difference(286) = 0.09457875989861 which is greater than upperbound.
    The next power is 379, and we need to add 93 to get there.
    The iterator will now become 379,
    which is the next power leading to 123 as starting digits.

    Let's take 1060. We increment by 196, we get 1256.
    log_difference(1256) = 0.09367455396034,
    Which is greater than upperbound hence we increment by 93. Now iterator is 1349.
    log_difference(1349) = 0.08946415071057 which is less than lowerbound.
    The next power is 1545 and we need to add 196 to get 1545.

    Conditions are as follows:

    1) If we find a power whose log_difference() is in the range of
    lower and upperbound, we will increment by 196.
    which implies that the power is a number which will lead to 123 as starting digits.
    2) If we find a power, whose log_difference() is greater than or equal upperbound,
    we will increment by 93.
    3) if log_difference() < lowerbound, we increment by 196.

    Reference to the above logic:
    https://math.stackexchange.com/questions/4093970/powers-of-2-starting-with-123-does-a-pattern-exist

    >>> solution(1000)
    284168

    >>> solution(56000)
    15924915

    >>> solution(678910)
    193060223

    """"""

    power_iterator = 90
    position = 0

    lower_limit = math.log(1.23, 10)
    upper_limit = math.log(1.24, 10)
    previous_power = 0

    while position < number:
        difference = log_difference(power_iterator)

        if difference >= upper_limit:
            power_iterator += 93

        elif difference < lower_limit:
            power_iterator += 196

        else:
            previous_power = power_iterator
            power_iterator += 196
            position += 1

    return previous_power",data\repos\Python\project_euler\problem_686\sol1.py,solution,1072
2523,sol1.py::calculate_prime_numbers::16,"def calculate_prime_numbers(max_number: int) -> list[int]:
    """"""
    Returns prime numbers below max_number

    >>> calculate_prime_numbers(10)
    [2, 3, 5, 7]
    """"""

    is_prime = [True] * max_number
    for i in range(2, isqrt(max_number - 1) + 1):
        if is_prime[i]:
            for j in range(i**2, max_number, i):
                is_prime[j] = False

    return [i for i in range(2, max_number) if is_prime[i]]",data\repos\Python\project_euler\problem_800\sol1.py,calculate_prime_numbers,124
2524,sol1.py::solution::33,"def solution(base: int = 800800, degree: int = 800800) -> int:
    """"""
    Returns the number of hybrid-integers less than or equal to base^degree

    >>> solution(800, 1)
    2

    >>> solution(800, 800)
    10790
    """"""

    upper_bound = degree * log2(base)
    max_prime = int(upper_bound)
    prime_numbers = calculate_prime_numbers(max_prime)

    hybrid_integers_count = 0
    left = 0
    right = len(prime_numbers) - 1
    while left < right:
        while (
            prime_numbers[right] * log2(prime_numbers[left])
            + prime_numbers[left] * log2(prime_numbers[right])
            > upper_bound
        ):
            right -= 1
        hybrid_integers_count += right - left
        left += 1

    return hybrid_integers_count",data\repos\Python\project_euler\problem_800\sol1.py,solution,196
2525,binary_step.py::binary_step::14,"def binary_step(vector: np.ndarray) -> np.ndarray:
    """"""
    Implements the binary step function

    Parameters:
        vector (ndarray): A vector that consists of numeric values

    Returns:
        vector (ndarray): Input vector after applying binary step function

    >>> vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])
    >>> binary_step(vector)
    array([0, 1, 1, 1, 0, 1])
    """"""

    return np.where(vector >= 0, 1, 0)",data\repos\Python\neural_network\activation_functions\binary_step.py,binary_step,130
2526,exponential_linear_unit.py::exponential_linear_unit::14,"def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:
    """"""
         Implements the ELU activation function.
         Parameters:
             vector: the array containing input of elu activation
             alpha: hyper-parameter
         return:
         elu (np.array): The input numpy array after applying elu.

         Mathematically, f(x) = x, x>0 else (alpha * (e^x -1)), x<=0, alpha >=0

    Examples:
    >>> exponential_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)
    array([ 2.3       ,  0.6       , -0.25939942, -0.29328877])

    >>> exponential_linear_unit(vector=np.array([-9.2,-0.3,0.45,-4.56]), alpha=0.067)
    array([-0.06699323, -0.01736518,  0.45      , -0.06629904])


    """"""
    return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))",data\repos\Python\neural_network\activation_functions\exponential_linear_unit.py,exponential_linear_unit,248
2527,gaussian_error_linear_unit.py::sigmoid::16,"def sigmoid(vector: np.ndarray) -> np.ndarray:
    """"""
    Mathematical function sigmoid takes a vector x of K real numbers as input and
    returns 1/ (1 + e^-x).
    https://en.wikipedia.org/wiki/Sigmoid_function

    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))
    array([0.26894142, 0.73105858, 0.88079708])
    """"""
    return 1 / (1 + np.exp(-vector))",data\repos\Python\neural_network\activation_functions\gaussian_error_linear_unit.py,sigmoid,110
2528,gaussian_error_linear_unit.py::gaussian_error_linear_unit::28,"def gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:
    """"""
    Implements the Gaussian Error Linear Unit (GELU) function

    Parameters:
        vector (np.ndarray): A  numpy array of shape (1, n) consisting of real values

    Returns:
        gelu_vec (np.ndarray): The input numpy array, after applying gelu

    Examples:
    >>> gaussian_error_linear_unit(np.array([-1.0, 1.0, 2.0]))
    array([-0.15420423,  0.84579577,  1.93565862])

    >>> gaussian_error_linear_unit(np.array([-3]))
    array([-0.01807131])
    """"""
    return vector * sigmoid(1.702 * vector)",data\repos\Python\neural_network\activation_functions\gaussian_error_linear_unit.py,gaussian_error_linear_unit,161
2529,leaky_rectified_linear_unit.py::leaky_rectified_linear_unit::12,"def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:
    """"""
        Implements the LeakyReLU activation function.

        Parameters:
            vector (np.ndarray): The input array for LeakyReLU activation.
            alpha (float): The slope for negative values.

        Returns:
            np.ndarray: The input array after applying the LeakyReLU activation.

        Formula: f(x) = x if x > 0 else f(x) = alpha * x

    Examples:
    >>> leaky_rectified_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)
    array([ 2.3 ,  0.6 , -0.6 , -1.14])

    >>> leaky_rectified_linear_unit(np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.067)
    array([-0.6164 , -0.0201 ,  0.45   , -0.30552])

    """"""
    return np.where(vector > 0, vector, alpha * vector)",data\repos\Python\neural_network\activation_functions\leaky_rectified_linear_unit.py,leaky_rectified_linear_unit,239
2530,mish.py::mish::14,"def mish(vector: np.ndarray) -> np.ndarray:
    """"""
        Implements the Mish activation function.

        Parameters:
            vector (np.ndarray): The input array for Mish activation.

        Returns:
            np.ndarray: The input array after applying the Mish activation.

        Formula:
            f(x) = x * tanh(softplus(x)) = x * tanh(ln(1 + e^x))

    Examples:
    >>> mish(vector=np.array([2.3,0.6,-2,-3.8]))
    array([ 2.26211893,  0.46613649, -0.25250148, -0.08405831])

    >>> mish(np.array([-9.2, -0.3, 0.45, -4.56]))
    array([-0.00092952, -0.15113318,  0.33152014, -0.04745745])

    """"""
    return vector * np.tanh(softplus(vector))",data\repos\Python\neural_network\activation_functions\mish.py,mish,208
2531,rectified_linear_unit.py::relu::18,"def relu(vector: list[float]):
    """"""
    Implements the relu function

    Parameters:
        vector (np.array,list,tuple): A  numpy array of shape (1,n)
        consisting of real values or a similar list,tuple


    Returns:
        relu_vec (np.array): The input numpy array, after applying
        relu.

    >>> vec = np.array([-1, 0, 5])
    >>> relu(vec)
    array([0, 0, 5])
    """"""

    # compare two arrays and then return element-wise maxima.
    return np.maximum(0, vector)",data\repos\Python\neural_network\activation_functions\rectified_linear_unit.py,relu,125
2532,scaled_exponential_linear_unit.py::scaled_exponential_linear_unit::18,"def scaled_exponential_linear_unit(
    vector: np.ndarray, alpha: float = 1.6732, lambda_: float = 1.0507
) -> np.ndarray:
    """"""
    Applies the Scaled Exponential Linear Unit function to each element of the vector.
    Parameters :
        vector : np.ndarray
        alpha : float (default = 1.6732)
        lambda_ : float (default = 1.0507)

    Returns : np.ndarray
    Formula : f(x) = lambda_ * x if x > 0
                     lambda_ * alpha * (e**x - 1) if x <= 0
    Examples :
    >>> scaled_exponential_linear_unit(vector=np.array([1.3, 3.7, 2.4]))
    array([1.36591, 3.88759, 2.52168])

    >>> scaled_exponential_linear_unit(vector=np.array([1.3, 4.7, 8.2]))
    array([1.36591, 4.93829, 8.61574])
    """"""
    return lambda_ * np.where(vector > 0, vector, alpha * (np.exp(vector) - 1))",data\repos\Python\neural_network\activation_functions\scaled_exponential_linear_unit.py,scaled_exponential_linear_unit,256
2533,soboleva_modified_hyperbolic_tangent.py::soboleva_modified_hyperbolic_tangent::14,"def soboleva_modified_hyperbolic_tangent(
    vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float
) -> np.ndarray:
    """"""
    Implements the Soboleva Modified Hyperbolic Tangent function

    Parameters:
        vector (ndarray): A vector that consists of numeric values
        a_value (float): parameter a of the equation
        b_value (float): parameter b of the equation
        c_value (float): parameter c of the equation
        d_value (float): parameter d of the equation

    Returns:
        vector (ndarray): Input array after applying SMHT function

    >>> vector = np.array([5.4, -2.4, 6.3, -5.23, 3.27, 0.56])
    >>> soboleva_modified_hyperbolic_tangent(vector, 0.2, 0.4, 0.6, 0.8)
    array([ 0.11075085, -0.28236685,  0.07861169, -0.1180085 ,  0.22999056,
            0.1566043 ])
    """"""

    # Separate the numerator and denominator for simplicity
    # Calculate the numerator and denominator element-wise
    numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)
    denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)

    # Calculate and return the final result element-wise
    return numerator / denominator",data\repos\Python\neural_network\activation_functions\soboleva_modified_hyperbolic_tangent.py,soboleva_modified_hyperbolic_tangent,333
2534,softplus.py::softplus::12,"def softplus(vector: np.ndarray) -> np.ndarray:
    """"""
    Implements the Softplus activation function.

    Parameters:
        vector (np.ndarray): The input array for the Softplus activation.

    Returns:
        np.ndarray: The input array after applying the Softplus activation.

    Formula: f(x) = ln(1 + e^x)

    Examples:
    >>> softplus(np.array([2.3, 0.6, -2, -3.8]))
    array([2.39554546, 1.03748795, 0.12692801, 0.02212422])

    >>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))
    array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])
    """"""
    return np.log(1 + np.exp(vector))",data\repos\Python\neural_network\activation_functions\softplus.py,softplus,210
2535,squareplus.py::squareplus::12,"def squareplus(vector: np.ndarray, beta: float) -> np.ndarray:
    """"""
    Implements the SquarePlus activation function.

    Parameters:
        vector (np.ndarray): The input array for the SquarePlus activation.
        beta (float): size of the curved region

    Returns:
        np.ndarray: The input array after applying the SquarePlus activation.

    Formula: f(x) = ( x + sqrt(x^2 + b) ) / 2

    Examples:
    >>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2)
    array([2.5       , 1.06811457, 0.22474487, 0.12731349])

    >>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3)
    array([0.0808119 , 0.72891979, 1.11977651, 0.15893419])
    """"""
    return (vector + np.sqrt(vector**2 + beta)) / 2",data\repos\Python\neural_network\activation_functions\squareplus.py,squareplus,232
2536,swish.py::sigmoid::21,"def sigmoid(vector: np.ndarray) -> np.ndarray:
    """"""
    Mathematical function sigmoid takes a vector x of K real numbers as input and
    returns 1/ (1 + e^-x).
    https://en.wikipedia.org/wiki/Sigmoid_function

    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))
    array([0.26894142, 0.73105858, 0.88079708])
    """"""
    return 1 / (1 + np.exp(-vector))",data\repos\Python\neural_network\activation_functions\swish.py,sigmoid,110
2537,swish.py::sigmoid_linear_unit::33,"def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:
    """"""
    Implements the Sigmoid Linear Unit (SiLU) or swish function

    Parameters:
        vector (np.ndarray): A  numpy array consisting of real values

    Returns:
        swish_vec (np.ndarray): The input numpy array, after applying swish

    Examples:
    >>> sigmoid_linear_unit(np.array([-1.0, 1.0, 2.0]))
    array([-0.26894142,  0.73105858,  1.76159416])

    >>> sigmoid_linear_unit(np.array([-2]))
    array([-0.23840584])
    """"""
    return vector * sigmoid(vector)",data\repos\Python\neural_network\activation_functions\swish.py,sigmoid_linear_unit,148
2538,swish.py::swish::53,"def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:
    """"""
    Parameters:
        vector (np.ndarray): A  numpy array consisting of real values
        trainable_parameter: Use to implement various Swish Activation Functions

    Returns:
        swish_vec (np.ndarray): The input numpy array, after applying swish

    Examples:
    >>> swish(np.array([-1.0, 1.0, 2.0]), 2)
    array([-0.11920292,  0.88079708,  1.96402758])

    >>> swish(np.array([-2]), 1)
    array([-0.23840584])
    """"""
    return vector * sigmoid(trainable_parameter * vector)",data\repos\Python\neural_network\activation_functions\swish.py,swish,157
2539,test_matrix_operation.py::test_addition::38,"def test_addition(mat1, mat2):
    if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):
        logger.info(f""\n\t{test_addition.__name__} returned integer"")
        with pytest.raises(TypeError):
            matop.add(mat1, mat2)
    elif (np.array(mat1)).shape == (np.array(mat2)).shape:
        logger.info(f""\n\t{test_addition.__name__} with same matrix dims"")
        act = (np.array(mat1) + np.array(mat2)).tolist()
        theo = matop.add(mat1, mat2)
        assert theo == act
    else:
        logger.info(f""\n\t{test_addition.__name__} with different matrix dims"")
        with pytest.raises(ValueError):
            matop.add(mat1, mat2)",data\repos\Python\matrix\tests\test_matrix_operation.py,test_addition,189
2540,test_matrix_operation.py::test_subtraction::58,"def test_subtraction(mat1, mat2):
    if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):
        logger.info(f""\n\t{test_subtraction.__name__} returned integer"")
        with pytest.raises(TypeError):
            matop.subtract(mat1, mat2)
    elif (np.array(mat1)).shape == (np.array(mat2)).shape:
        logger.info(f""\n\t{test_subtraction.__name__} with same matrix dims"")
        act = (np.array(mat1) - np.array(mat2)).tolist()
        theo = matop.subtract(mat1, mat2)
        assert theo == act
    else:
        logger.info(f""\n\t{test_subtraction.__name__} with different matrix dims"")
        with pytest.raises(ValueError):
            assert matop.subtract(mat1, mat2)",data\repos\Python\matrix\tests\test_matrix_operation.py,test_subtraction,190
2541,test_matrix_operation.py::test_multiplication::78,"def test_multiplication(mat1, mat2):
    if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):
        logger.info(f""\n\t{test_multiplication.__name__} returned integer"")
        with pytest.raises(TypeError):
            matop.add(mat1, mat2)
    elif (np.array(mat1)).shape == (np.array(mat2)).shape:
        logger.info(f""\n\t{test_multiplication.__name__} meets dim requirements"")
        act = (np.matmul(mat1, mat2)).tolist()
        theo = matop.multiply(mat1, mat2)
        assert theo == act
    else:
        logger.info(
            f""\n\t{test_multiplication.__name__} does not meet dim requirements""
        )
        with pytest.raises(ValueError):
            assert matop.subtract(mat1, mat2)",data\repos\Python\matrix\tests\test_matrix_operation.py,test_multiplication,191
2542,test_matrix_operation.py::test_scalar_multiply::97,"def test_scalar_multiply():
    act = (3.5 * np.array(mat_a)).tolist()
    theo = matop.scalar_multiply(mat_a, 3.5)
    assert theo == act",data\repos\Python\matrix\tests\test_matrix_operation.py,test_scalar_multiply,42
2543,test_matrix_operation.py::test_identity::104,"def test_identity():
    act = (np.identity(5)).tolist()
    theo = matop.identity(5)
    assert theo == act",data\repos\Python\matrix\tests\test_matrix_operation.py,test_identity,31
2544,test_matrix_operation.py::test_transpose::112,"def test_transpose(mat):
    if (np.array(mat)).shape < (2, 2):
        logger.info(f""\n\t{test_transpose.__name__} returned integer"")
        with pytest.raises(TypeError):
            matop.transpose(mat)
    else:
        act = (np.transpose(mat)).tolist()
        theo = matop.transpose(mat, return_map=False)
        assert theo == act",data\repos\Python\matrix\tests\test_matrix_operation.py,test_transpose,83
2545,adams_bashforth.py::step_2::67,"    def step_2(self) -> np.ndarray:
        """"""
        >>> def f(x, y):
        ...     return x
        >>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_2()
        array([0.  , 0.  , 0.06, 0.16, 0.3 , 0.48])

        >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_2()
        Traceback (most recent call last):
            ...
        ValueError: Insufficient initial points information.
        """"""

        if len(self.x_initials) != 2 or len(self.y_initials) != 2:
            raise ValueError(""Insufficient initial points information."")

        x_0, x_1 = self.x_initials[:2]
        y_0, y_1 = self.y_initials[:2]

        n = int((self.x_final - x_1) / self.step_size)
        y = np.zeros(n + 2)
        y[0] = y_0
        y[1] = y_1

        for i in range(n):
            y[i + 2] = y[i + 1] + (self.step_size / 2) * (
                3 * self.func(x_1, y[i + 1]) - self.func(x_0, y[i])
            )
            x_0 = x_1
            x_1 += self.step_size

        return y",data\repos\Python\maths\numerical_analysis\adams_bashforth.py,step_2,352
2546,adams_bashforth.py::step_3::100,"    def step_3(self) -> np.ndarray:
        """"""
        >>> def f(x, y):
        ...     return x + y
        >>> y = AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_3()
        >>> float(y[3])
        0.15533333333333332

        >>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_3()
        Traceback (most recent call last):
            ...
        ValueError: Insufficient initial points information.
        """"""
        if len(self.x_initials) != 3 or len(self.y_initials) != 3:
            raise ValueError(""Insufficient initial points information."")

        x_0, x_1, x_2 = self.x_initials[:3]
        y_0, y_1, y_2 = self.y_initials[:3]

        n = int((self.x_final - x_2) / self.step_size)
        y = np.zeros(n + 4)
        y[0] = y_0
        y[1] = y_1
        y[2] = y_2

        for i in range(n + 1):
            y[i + 3] = y[i + 2] + (self.step_size / 12) * (
                23 * self.func(x_2, y[i + 2])
                - 16 * self.func(x_1, y[i + 1])
                + 5 * self.func(x_0, y[i])
            )
            x_0 = x_1
            x_1 = x_2
            x_2 += self.step_size

        return y",data\repos\Python\maths\numerical_analysis\adams_bashforth.py,step_3,393
2547,adams_bashforth.py::step_4::137,"    def step_4(self) -> np.ndarray:
        """"""
        >>> def f(x,y):
        ...     return x + y
        >>> y = AdamsBashforth(
        ...    f, [0, 0.2, 0.4, 0.6], [0, 0, 0.04, 0.128], 0.2, 1).step_4()
        >>> float(y[4])
        0.30699999999999994
        >>> float(y[5])
        0.5771083333333333

        >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_4()
        Traceback (most recent call last):
            ...
        ValueError: Insufficient initial points information.
        """"""

        if len(self.x_initials) != 4 or len(self.y_initials) != 4:
            raise ValueError(""Insufficient initial points information."")

        x_0, x_1, x_2, x_3 = self.x_initials[:4]
        y_0, y_1, y_2, y_3 = self.y_initials[:4]

        n = int((self.x_final - x_3) / self.step_size)
        y = np.zeros(n + 4)
        y[0] = y_0
        y[1] = y_1
        y[2] = y_2
        y[3] = y_3

        for i in range(n):
            y[i + 4] = y[i + 3] + (self.step_size / 24) * (
                55 * self.func(x_3, y[i + 3])
                - 59 * self.func(x_2, y[i + 2])
                + 37 * self.func(x_1, y[i + 1])
                - 9 * self.func(x_0, y[i])
            )
            x_0 = x_1
            x_1 = x_2
            x_2 = x_3
            x_3 += self.step_size

        return y",data\repos\Python\maths\numerical_analysis\adams_bashforth.py,step_4,475
2548,adams_bashforth.py::step_5::181,"    def step_5(self) -> np.ndarray:
        """"""
        >>> def f(x,y):
        ...     return x + y
        >>> y = AdamsBashforth(
        ...     f, [0, 0.2, 0.4, 0.6, 0.8], [0, 0.02140, 0.02140, 0.22211, 0.42536],
        ...     0.2, 1).step_5()
        >>> float(y[-1])
        0.05436839444444452

        >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_5()
        Traceback (most recent call last):
            ...
        ValueError: Insufficient initial points information.
        """"""

        if len(self.x_initials) != 5 or len(self.y_initials) != 5:
            raise ValueError(""Insufficient initial points information."")

        x_0, x_1, x_2, x_3, x_4 = self.x_initials[:5]
        y_0, y_1, y_2, y_3, y_4 = self.y_initials[:5]

        n = int((self.x_final - x_4) / self.step_size)
        y = np.zeros(n + 6)
        y[0] = y_0
        y[1] = y_1
        y[2] = y_2
        y[3] = y_3
        y[4] = y_4

        for i in range(n + 1):
            y[i + 5] = y[i + 4] + (self.step_size / 720) * (
                1901 * self.func(x_4, y[i + 4])
                - 2774 * self.func(x_3, y[i + 3])
                - 2616 * self.func(x_2, y[i + 2])
                - 1274 * self.func(x_1, y[i + 1])
                + 251 * self.func(x_0, y[i])
            )
            x_0 = x_1
            x_1 = x_2
            x_2 = x_3
            x_3 = x_4
            x_4 += self.step_size

        return y",data\repos\Python\maths\numerical_analysis\adams_bashforth.py,step_5,527
2549,bisection.py::bisection::4,"def bisection(function: Callable[[float], float], a: float, b: float) -> float:
    """"""
    finds where function becomes 0 in [a,b] using bolzano
    >>> bisection(lambda x: x ** 3 - 1, -5, 5)
    1.0000000149011612
    >>> bisection(lambda x: x ** 3 - 1, 2, 1000)
    Traceback (most recent call last):
        ...
    ValueError: could not find root in given interval.
    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)
    1.0
    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)
    3.0
    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)
    Traceback (most recent call last):
        ...
    ValueError: could not find root in given interval.
    """"""
    start: float = a
    end: float = b
    if function(a) == 0:  # one of the a or b is a root for the function
        return a
    elif function(b) == 0:
        return b
    elif (
        function(a) * function(b) > 0
    ):  # if none of these are root and they are both positive or negative,
        # then this algorithm can't find the root
        raise ValueError(""could not find root in given interval."")
    else:
        mid: float = start + (end - start) / 2.0
        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7
            if function(mid) == 0:
                return mid
            elif function(mid) * function(start) < 0:
                end = mid
            else:
                start = mid
            mid = start + (end - start) / 2.0
        return mid",data\repos\Python\maths\numerical_analysis\bisection.py,bisection,452
2550,bisection_2.py::equation::11,"def equation(x: float) -> float:
    """"""
    >>> equation(5)
    -15
    >>> equation(0)
    10
    >>> equation(-5)
    -15
    >>> equation(0.1)
    9.99
    >>> equation(-0.1)
    9.99
    """"""
    return 10 - x * x",data\repos\Python\maths\numerical_analysis\bisection_2.py,equation,79
2551,bisection_2.py::bisection::27,"def bisection(a: float, b: float) -> float:
    """"""
    >>> bisection(-2, 5)
    3.1611328125
    >>> bisection(0, 6)
    3.158203125
    >>> bisection(2, 3)
    Traceback (most recent call last):
        ...
    ValueError: Wrong space!
    """"""
    # Bolzano theory in order to find if there is a root between a and b
    if equation(a) * equation(b) >= 0:
        raise ValueError(""Wrong space!"")

    c = a
    while (b - a) >= 0.01:
        # Find middle point
        c = (a + b) / 2
        # Check if middle point is root
        if equation(c) == 0.0:
            break
        # Decide the side to repeat the steps
        if equation(c) * equation(a) < 0:
            b = c
        else:
            a = c
    return c",data\repos\Python\maths\numerical_analysis\bisection_2.py,bisection,223
2552,integration_by_simpson_approx.py::simpson_integration::37,"def simpson_integration(function, a: float, b: float, precision: int = 4) -> float:
    """"""
    Args:
        function : the function which's integration is desired
        a : the lower limit of integration
        b : upper limit of integration
        precision : precision of the result,error required default is 4

    Returns:
        result : the value of the approximated integration of function in range a to b

    Raises:
        AssertionError: function is not callable
        AssertionError: a is not float or integer
        AssertionError: function should return float or integer
        AssertionError: b is not float or integer
        AssertionError: precision is not positive integer

    >>> simpson_integration(lambda x : x*x,1,2,3)
    2.333

    >>> simpson_integration(lambda x : x*x,'wrong_input',2,3)
    Traceback (most recent call last):
        ...
    AssertionError: a should be float or integer your input : wrong_input

    >>> simpson_integration(lambda x : x*x,1,'wrong_input',3)
    Traceback (most recent call last):
        ...
    AssertionError: b should be float or integer your input : wrong_input

    >>> simpson_integration(lambda x : x*x,1,2,'wrong_input')
    Traceback (most recent call last):
        ...
    AssertionError: precision should be positive integer your input : wrong_input
    >>> simpson_integration('wrong_input',2,3,4)
    Traceback (most recent call last):
        ...
    AssertionError: the function(object) passed should be callable your input : ...

    >>> simpson_integration(lambda x : x*x,3.45,3.2,1)
    -2.8

    >>> simpson_integration(lambda x : x*x,3.45,3.2,0)
    Traceback (most recent call last):
        ...
    AssertionError: precision should be positive integer your input : 0

    >>> simpson_integration(lambda x : x*x,3.45,3.2,-1)
    Traceback (most recent call last):
        ...
    AssertionError: precision should be positive integer your input : -1

    """"""
    assert callable(function), (
        f""the function(object) passed should be callable your input : {function}""
    )
    assert isinstance(a, (float, int)), f""a should be float or integer your input : {a}""
    assert isinstance(function(a), (float, int)), (
        ""the function should return integer or float return type of your function, ""
        f""{type(a)}""
    )
    assert isinstance(b, (float, int)), f""b should be float or integer your input : {b}""
    assert isinstance(precision, int) and precision > 0, (
        f""precision should be positive integer your input : {precision}""
    )

    # just applying the formula of simpson for approximate integration written in
    # mentioned article in first comment of this file and above this function

    h = (b - a) / N_STEPS
    result = function(a) + function(b)

    for i in range(1, N_STEPS):
        a1 = a + h * i
        result += function(a1) * (4 if i % 2 else 2)

    result *= h / 3
    return round(result, precision)",data\repos\Python\maths\numerical_analysis\integration_by_simpson_approx.py,simpson_integration,706
2553,intersection.py::intersection::5,"def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:
    """"""
    function is the f we want to find its root
    x0 and x1 are two random starting points
    >>> intersection(lambda x: x ** 3 - 1, -5, 5)
    0.9999999999954654
    >>> intersection(lambda x: x ** 3 - 1, 5, 5)
    Traceback (most recent call last):
        ...
    ZeroDivisionError: float division by zero, could not find root
    >>> intersection(lambda x: x ** 3 - 1, 100, 200)
    1.0000000000003888
    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 0, 2)
    0.9999999998088019
    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 2, 4)
    2.9999999998088023
    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)
    3.0000000001786042
    >>> intersection(math.sin, -math.pi, math.pi)
    0.0
    >>> intersection(math.cos, -math.pi, math.pi)
    Traceback (most recent call last):
        ...
    ZeroDivisionError: float division by zero, could not find root
    """"""
    x_n: float = x0
    x_n1: float = x1
    while True:
        if x_n == x_n1 or function(x_n1) == function(x_n):
            raise ZeroDivisionError(""float division by zero, could not find root"")
        x_n2: float = x_n1 - (
            function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))
        )
        if abs(x_n2 - x_n1) < 10**-5:
            return x_n2
        x_n = x_n1
        x_n1 = x_n2",data\repos\Python\maths\numerical_analysis\intersection.py,intersection,465
2554,intersection.py::f::44,"def f(x: float) -> float:
    """"""
    function is f(x) = x^3 - 2x - 5
    >>> f(2)
    -1.0
    """"""
    return math.pow(x, 3) - (2 * x) - 5",data\repos\Python\maths\numerical_analysis\intersection.py,f,61
2555,nevilles_method.py::neville_interpolate::12,"def neville_interpolate(x_points: list, y_points: list, x0: int) -> list:
    """"""
       Interpolate and evaluate a polynomial using Neville's method.
       Arguments:
           x_points, y_points: Iterables of x and corresponding y points through
            which the polynomial passes.
           x0: The value of x to evaluate the polynomial for.
       Return Value: A list of the approximated value and the Neville iterations
           table respectively.
    >>> import pprint
    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0]
    10.0
    >>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1])
    [[0, 6, 0, 0, 0],
     [0, 7, 0, 0, 0],
     [0, 8, 104.0, 0, 0],
     [0, 9, 104.0, 104.0, 0],
     [0, 11, 104.0, 104.0, 104.0]]
    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0]
    104.0
    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '')
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for -: 'str' and 'int'
    """"""
    n = len(x_points)
    q = [[0] * n for i in range(n)]
    for i in range(n):
        q[i][1] = y_points[i]

    for i in range(2, n):
        for j in range(i, n):
            q[j][i] = (
                (x0 - x_points[j - i + 1]) * q[j][i - 1]
                - (x0 - x_points[j]) * q[j - 1][i - 1]
            ) / (x_points[j] - x_points[j - i + 1])

    return [q[n - 1][n - 1], q]",data\repos\Python\maths\numerical_analysis\nevilles_method.py,neville_interpolate,512
2556,newton_forward_interpolation.py::ucal::8,"def ucal(u: float, p: int) -> float:
    """"""
    >>> ucal(1, 2)
    0
    >>> ucal(1.1, 2)
    0.11000000000000011
    >>> ucal(1.2, 2)
    0.23999999999999994
    """"""
    temp = u
    for i in range(1, p):
        temp = temp * (u - i)
    return temp",data\repos\Python\maths\numerical_analysis\newton_forward_interpolation.py,ucal,106
2557,newton_forward_interpolation.py::main::23,"def main() -> None:
    n = int(input(""enter the numbers of values: ""))
    y: list[list[float]] = []
    for _ in range(n):
        y.append([])
    for i in range(n):
        for j in range(n):
            y[i].append(j)
            y[i][j] = 0

    print(""enter the values of parameters in a list: "")
    x = list(map(int, input().split()))

    print(""enter the values of corresponding parameters: "")
    for i in range(n):
        y[i][0] = float(input())

    value = int(input(""enter the value to interpolate: ""))
    u = (value - x[0]) / (x[1] - x[0])

    # for calculating forward difference table

    for i in range(1, n):
        for j in range(n - i):
            y[j][i] = y[j + 1][i - 1] - y[j][i - 1]

    summ = y[0][0]
    for i in range(1, n):
        summ += (ucal(u, i) * y[0][i]) / math.factorial(i)

    print(f""the value at {value} is {summ}"")",data\repos\Python\maths\numerical_analysis\newton_forward_interpolation.py,main,266
2558,newton_raphson.py::calc_derivative::18,"def calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:
    """"""
    Approximate the derivative of a function f(x) at a point x using the finite
    difference method

    >>> import math
    >>> tolerance = 1e-5
    >>> derivative = calc_derivative(lambda x: x**2, 2)
    >>> math.isclose(derivative, 4, abs_tol=tolerance)
    True
    >>> derivative = calc_derivative(math.sin, 0)
    >>> math.isclose(derivative, 1, abs_tol=tolerance)
    True
    """"""
    return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x",data\repos\Python\maths\numerical_analysis\newton_raphson.py,calc_derivative,165
2559,newton_raphson.py::newton_raphson::35,"def newton_raphson(
    f: RealFunc,
    x0: float = 0,
    max_iter: int = 100,
    step: float = 1e-6,
    max_error: float = 1e-6,
    log_steps: bool = False,
) -> tuple[float, float, list[float]]:
    """"""
    Find a root of the given function f using the Newton-Raphson method.

    :param f: A real-valued single-variable function
    :param x0: Initial guess
    :param max_iter: Maximum number of iterations
    :param step: Step size of x, used to approximate f'(x)
    :param max_error: Maximum approximation error
    :param log_steps: bool denoting whether to log intermediate steps

    :return: A tuple containing the approximation, the error, and the intermediate
        steps. If log_steps is False, then an empty list is returned for the third
        element of the tuple.

    :raises ZeroDivisionError: The derivative approaches 0.
    :raises ArithmeticError: No solution exists, or the solution isn't found before the
        iteration limit is reached.

    >>> import math
    >>> tolerance = 1e-15
    >>> root, *_ = newton_raphson(lambda x: x**2 - 5*x + 2, 0.4, max_error=tolerance)
    >>> math.isclose(root, (5 - math.sqrt(17)) / 2, abs_tol=tolerance)
    True
    >>> root, *_ = newton_raphson(lambda x: math.log(x) - 1, 2, max_error=tolerance)
    >>> math.isclose(root, math.e, abs_tol=tolerance)
    True
    >>> root, *_ = newton_raphson(math.sin, 1, max_error=tolerance)
    >>> math.isclose(root, 0, abs_tol=tolerance)
    True
    >>> newton_raphson(math.cos, 0)
    Traceback (most recent call last):
    ...
    ZeroDivisionError: No converging solution found, zero derivative
    >>> newton_raphson(lambda x: x**2 + 1, 2)
    Traceback (most recent call last):
    ...
    ArithmeticError: No converging solution found, iteration limit reached
    """"""

    def f_derivative(x: float) -> float:
        return calc_derivative(f, x, step)

    a = x0  # Set initial guess
    steps = []
    for _ in range(max_iter):
        if log_steps:  # Log intermediate steps
            steps.append(a)

        error = abs(f(a))
        if error < max_error:
            return a, error, steps

        if f_derivative(a) == 0:
            raise ZeroDivisionError(""No converging solution found, zero derivative"")
        a -= f(a) / f_derivative(a)  # Calculate next estimate
    raise ArithmeticError(""No converging solution found, iteration limit reached"")",data\repos\Python\maths\numerical_analysis\newton_raphson.py,newton_raphson,647
2560,numerical_integration.py::trapezoidal_area::10,"def trapezoidal_area(
    fnc: Callable[[float], float],
    x_start: float,
    x_end: float,
    steps: int = 100,
) -> float:
    """"""
    Treats curve as a collection of linear lines and sums the area of the
    trapezium shape they form
    :param fnc: a function which defines a curve
    :param x_start: left end point to indicate the start of line segment
    :param x_end: right end point to indicate end of line segment
    :param steps: an accuracy gauge; more steps increases the accuracy
    :return: a float representing the length of the curve

    >>> def f(x):
    ...    return 5
    >>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)
    '10.000'

    >>> def f(x):
    ...    return 9*x**2
    >>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)
    '192.0000'

    >>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)
    '384.0000'
    """"""
    x1 = x_start
    fx1 = fnc(x_start)
    area = 0.0

    for _ in range(steps):
        # Approximates small segments of curve as linear and solve
        # for trapezoidal area
        x2 = (x_end - x_start) / steps + x1
        fx2 = fnc(x2)
        area += abs(fx2 + fx1) * (x2 - x1) / 2

        # Increment step
        x1 = x2
        fx1 = fx2
    return area",data\repos\Python\maths\numerical_analysis\numerical_integration.py,trapezoidal_area,403
2561,proper_fractions.py::proper_fractions::4,"def proper_fractions(denominator: int) -> list[str]:
    """"""
    this algorithm returns a list of proper fractions, in the
    range between 0 and 1, which can be formed with the given denominator
    https://en.wikipedia.org/wiki/Fraction#Proper_and_improper_fractions

    >>> proper_fractions(10)
    ['1/10', '3/10', '7/10', '9/10']
    >>> proper_fractions(5)
    ['1/5', '2/5', '3/5', '4/5']
    >>> proper_fractions(-15)
    Traceback (most recent call last):
        ...
    ValueError: The Denominator Cannot be less than 0
    >>> proper_fractions(0)
    []
    >>> proper_fractions(1.2)
    Traceback (most recent call last):
        ...
    ValueError: The Denominator must be an integer
    """"""

    if denominator < 0:
        raise ValueError(""The Denominator Cannot be less than 0"")
    elif isinstance(denominator, float):
        raise ValueError(""The Denominator must be an integer"")
    return [
        f""{numerator}/{denominator}""
        for numerator in range(1, denominator)
        if gcd(numerator, denominator) == 1
    ]",data\repos\Python\maths\numerical_analysis\proper_fractions.py,proper_fractions,284
2562,runge_kutta.py::runge_kutta::4,"def runge_kutta(f, y0, x0, h, x_end):
    """"""
    Calculate the numeric solution at each step to the ODE f(x, y) using RK4

    https://en.wikipedia.org/wiki/Runge-Kutta_methods

    Arguments:
    f -- The ode as a function of x and y
    y0 -- the initial value for y
    x0 -- the initial value for x
    h -- the stepsize
    x_end -- the end value for x

    >>> # the exact solution is math.exp(x)
    >>> def f(x, y):
    ...     return y
    >>> y0 = 1
    >>> y = runge_kutta(f, y0, 0.0, 0.01, 5)
    >>> float(y[-1])
    148.41315904125113
    """"""
    n = int(np.ceil((x_end - x0) / h))
    y = np.zeros((n + 1,))
    y[0] = y0
    x = x0

    for k in range(n):
        k1 = f(x, y[k])
        k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)
        k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)
        k4 = f(x + h, y[k] + h * k3)
        y[k + 1] = y[k] + (1 / 6) * h * (k1 + 2 * k2 + 2 * k3 + k4)
        x += h

    return y",data\repos\Python\maths\numerical_analysis\runge_kutta.py,runge_kutta,367
2563,runge_kutta_fehlberg_45.py::runge_kutta_fehlberg_45::10,"def runge_kutta_fehlberg_45(
    func: Callable,
    x_initial: float,
    y_initial: float,
    step_size: float,
    x_final: float,
) -> np.ndarray:
    """"""
    Solve an Ordinary Differential Equations using Runge-Kutta-Fehlberg Method (rkf45)
    of order 5.

    https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method

    args:
    func: An ordinary differential equation (ODE) as function of x and y.
    x_initial: The initial value of x.
    y_initial: The initial value of y.
    step_size: The increment value of x.
    x_final: The final value of x.

    Returns:
        Solution of y at each nodal point

    # exact value of y[1] is tan(0.2) = 0.2027100937470787
    >>> def f(x, y):
    ...     return 1 + y**2
    >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, 1)
    >>> float(y[1])
    0.2027100937470787
    >>> def f(x,y):
    ...     return x
    >>> y = runge_kutta_fehlberg_45(f, -1, 0, 0.2, 0)
    >>> float(y[1])
    -0.18000000000000002
    >>> y = runge_kutta_fehlberg_45(5, 0, 0, 0.1, 1)
    Traceback (most recent call last):
        ...
    TypeError: 'int' object is not callable
    >>> def f(x, y):
    ...     return x + y
    >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, -1)
    Traceback (most recent call last):
        ...
    ValueError: The final value of x must be greater than initial value of x.
    >>> def f(x, y):
    ...     return x
    >>> y = runge_kutta_fehlberg_45(f, -1, 0, -0.2, 0)
    Traceback (most recent call last):
        ...
    ValueError: Step size must be positive.
    """"""
    if x_initial >= x_final:
        raise ValueError(
            ""The final value of x must be greater than initial value of x.""
        )

    if step_size <= 0:
        raise ValueError(""Step size must be positive."")

    n = int((x_final - x_initial) / step_size)
    y = np.zeros(
        (n + 1),
    )
    x = np.zeros(n + 1)
    y[0] = y_initial
    x[0] = x_initial
    for i in range(n):
        k1 = step_size * func(x[i], y[i])
        k2 = step_size * func(x[i] + step_size / 4, y[i] + k1 / 4)
        k3 = step_size * func(
            x[i] + (3 / 8) * step_size, y[i] + (3 / 32) * k1 + (9 / 32) * k2
        )
        k4 = step_size * func(
            x[i] + (12 / 13) * step_size,
            y[i] + (1932 / 2197) * k1 - (7200 / 2197) * k2 + (7296 / 2197) * k3,
        )
        k5 = step_size * func(
            x[i] + step_size,
            y[i] + (439 / 216) * k1 - 8 * k2 + (3680 / 513) * k3 - (845 / 4104) * k4,
        )
        k6 = step_size * func(
            x[i] + step_size / 2,
            y[i]
            - (8 / 27) * k1
            + 2 * k2
            - (3544 / 2565) * k3
            + (1859 / 4104) * k4
            - (11 / 40) * k5,
        )
        y[i + 1] = (
            y[i]
            + (16 / 135) * k1
            + (6656 / 12825) * k3
            + (28561 / 56430) * k4
            - (9 / 50) * k5
            + (2 / 55) * k6
        )
        x[i + 1] = step_size + x[i]
    return y",data\repos\Python\maths\numerical_analysis\runge_kutta_fehlberg_45.py,runge_kutta_fehlberg_45,1043
2564,runge_kutta_gills.py::runge_kutta_gills::14,"def runge_kutta_gills(
    func: Callable[[float, float], float],
    x_initial: float,
    y_initial: float,
    step_size: float,
    x_final: float,
) -> np.ndarray:
    """"""
    Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.

    args:
    func: An ordinary differential equation (ODE) as function of x and y.
    x_initial: The initial value of x.
    y_initial: The initial value of y.
    step_size: The increment value of x.
    x_final: The final value of x.

    Returns:
        Solution of y at each nodal point

    >>> def f(x, y):
    ...     return (x-y)/2
    >>> y = runge_kutta_gills(f, 0, 3, 0.2, 5)
    >>> float(y[-1])
    3.4104259225717537

    >>> def f(x,y):
    ...     return x
    >>> y = runge_kutta_gills(f, -1, 0, 0.2, 0)
    >>> y
    array([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])

    >>> def f(x, y):
    ...     return x + y
    >>> y = runge_kutta_gills(f, 0, 0, 0.2, -1)
    Traceback (most recent call last):
        ...
    ValueError: The final value of x must be greater than initial value of x.

    >>> def f(x, y):
    ...     return x
    >>> y = runge_kutta_gills(f, -1, 0, -0.2, 0)
    Traceback (most recent call last):
        ...
    ValueError: Step size must be positive.
    """"""
    if x_initial >= x_final:
        raise ValueError(
            ""The final value of x must be greater than initial value of x.""
        )

    if step_size <= 0:
        raise ValueError(""Step size must be positive."")

    n = int((x_final - x_initial) / step_size)
    y = np.zeros(n + 1)
    y[0] = y_initial
    for i in range(n):
        k1 = step_size * func(x_initial, y[i])
        k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)
        k3 = step_size * func(
            x_initial + step_size / 2,
            y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,
        )
        k4 = step_size * func(
            x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3
        )

        y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6
        x_initial += step_size
    return y",data\repos\Python\maths\numerical_analysis\runge_kutta_gills.py,runge_kutta_gills,701
2565,secant_method.py::f::9,"def f(x: float) -> float:
    """"""
    >>> f(5)
    39.98652410600183
    """"""
    return 8 * x - 2 * exp(-x)",data\repos\Python\maths\numerical_analysis\secant_method.py,f,43
2566,secant_method.py::secant_method::17,"def secant_method(lower_bound: float, upper_bound: float, repeats: int) -> float:
    """"""
    >>> secant_method(1, 3, 2)
    0.2139409276214589
    """"""
    x0 = lower_bound
    x1 = upper_bound
    for _ in range(repeats):
        x0, x1 = x1, x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0))
    return x1",data\repos\Python\maths\numerical_analysis\secant_method.py,secant_method,113
2567,simpson_rule.py::method_2::12,"def method_2(boundary: list[int], steps: int) -> float:
    # ""Simpson Rule""
    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)
    """"""
    Calculate the definite integral of a function using Simpson's Rule.
    :param boundary: A list containing the lower and upper bounds of integration.
    :param steps: The number of steps or resolution for the integration.
    :return: The approximate integral value.

    >>> round(method_2([0, 2, 4], 10), 10)
    2.6666666667
    >>> round(method_2([2, 0], 10), 10)
    -0.2666666667
    >>> round(method_2([-2, -1], 10), 10)
    2.172
    >>> round(method_2([0, 1], 10), 10)
    0.3333333333
    >>> round(method_2([0, 2], 10), 10)
    2.6666666667
    >>> round(method_2([0, 2], 100), 10)
    2.5621226667
    >>> round(method_2([0, 1], 1000), 10)
    0.3320026653
    >>> round(method_2([0, 2], 0), 10)
    Traceback (most recent call last):
        ...
    ZeroDivisionError: Number of steps must be greater than zero
    >>> round(method_2([0, 2], -10), 10)
    Traceback (most recent call last):
        ...
    ZeroDivisionError: Number of steps must be greater than zero
    """"""
    if steps <= 0:
        raise ZeroDivisionError(""Number of steps must be greater than zero"")

    h = (boundary[1] - boundary[0]) / steps
    a = boundary[0]
    b = boundary[1]
    x_i = make_points(a, b, h)
    y = 0.0
    y += (h / 3.0) * f(a)
    cnt = 2
    for i in x_i:
        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)
        cnt += 1
    y += (h / 3.0) * f(b)
    return y",data\repos\Python\maths\numerical_analysis\simpson_rule.py,method_2,543
2568,simpson_rule.py::make_points::61,"def make_points(a, b, h):
    x = a + h
    while x < (b - h):
        yield x
        x = x + h",data\repos\Python\maths\numerical_analysis\simpson_rule.py,make_points,35
2569,simpson_rule.py::f::68,"def f(x):  # enter your function here
    y = (x - 0) * (x - 0)
    return y",data\repos\Python\maths\numerical_analysis\simpson_rule.py,f,30
2570,simpson_rule.py::main::73,"def main():
    a = 0.0  # Lower bound of integration
    b = 1.0  # Upper bound of integration
    steps = 10.0  # number of steps or resolution
    boundary = [a, b]  # boundary of integration
    y = method_2(boundary, steps)
    print(f""y = {y}"")",data\repos\Python\maths\numerical_analysis\simpson_rule.py,main,80
2571,square_root.py::get_initial_point::12,"def get_initial_point(a: float) -> float:
    start = 2.0

    while start <= a:
        start = math.pow(start, 2)

    return start",data\repos\Python\maths\numerical_analysis\square_root.py,get_initial_point,38
2572,square_root.py::square_root_iterative::21,"def square_root_iterative(
    a: float, max_iter: int = 9999, tolerance: float = 1e-14
) -> float:
    """"""
    Square root approximated using Newton's method.
    https://en.wikipedia.org/wiki/Newton%27s_method

    >>> all(abs(square_root_iterative(i) - math.sqrt(i)) <= 1e-14 for i in range(500))
    True

    >>> square_root_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: math domain error

    >>> square_root_iterative(4)
    2.0

    >>> square_root_iterative(3.2)
    1.788854381999832

    >>> square_root_iterative(140)
    11.832159566199232
    """"""

    if a < 0:
        raise ValueError(""math domain error"")

    value = get_initial_point(a)

    for _ in range(max_iter):
        prev_value = value
        value = value - fx(value, a) / fx_derivative(value)
        if abs(prev_value - value) < tolerance:
            return value

    return value",data\repos\Python\maths\numerical_analysis\square_root.py,square_root_iterative,245
2573,weierstrass_method.py::weierstrass_method::6,"def weierstrass_method(
    polynomial: Callable[[np.ndarray], np.ndarray],
    degree: int,
    roots: np.ndarray | None = None,
    max_iter: int = 100,
) -> np.ndarray:
    """"""
    Approximates all complex roots of a polynomial using the
    Weierstrass (Durand-Kerner) method.
    Args:
        polynomial: A function that takes a NumPy array of complex numbers and returns
                    the polynomial values at those points.
        degree: Degree of the polynomial (number of roots to find). Must be  1.
        roots:  Optional initial guess as a NumPy array of complex numbers.
                Must have length equal to 'degree'.
                If None, perturbed complex roots of unity are used.
        max_iter: Number of iterations to perform (default: 100).

    Returns:
        np.ndarray: Array of approximated complex roots.

    Raises:
        ValueError: If degree < 1, or if initial roots length doesn't match the degree.

    Note:
        - Root updates are clipped to prevent numerical overflow.

    Example:
        >>> import numpy as np
        >>> def check(poly, degree, expected):
        ...     roots = weierstrass_method(poly, degree)
        ...     return np.allclose(np.sort(roots), np.sort(expected))

        >>> check(
        ...     lambda x: x**2 - 1,
        ...     2,
        ...     np.array([-1, 1]))
        True

        >>> check(
        ...     lambda x: x**3 - 4.5*x**2 + 5.75*x - 1.875,
        ...     3,
        ...     np.array([1.5, 0.5, 2.5])
        ... )
        True

    See Also:
        https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method
    """"""

    if degree < 1:
        raise ValueError(""Degree of the polynomial must be at least 1."")

    if roots is None:
        # Use perturbed complex roots of unity as initial guesses
        rng = np.random.default_rng()
        roots = np.array(
            [
                np.exp(2j * np.pi * i / degree) * (1 + 1e-3 * rng.random())
                for i in range(degree)
            ],
            dtype=np.complex128,
        )

    else:
        roots = np.asarray(roots, dtype=np.complex128)
        if roots.shape[0] != degree:
            raise ValueError(
                ""Length of initial roots must match the degree of the polynomial.""
            )

    for _ in range(max_iter):
        # Construct the product denominator for each root
        denominator = np.array([root - roots for root in roots], dtype=np.complex128)
        np.fill_diagonal(denominator, 1.0)  # Avoid zero in diagonal
        denominator = np.prod(denominator, axis=1)

        # Evaluate polynomial at each root
        numerator = polynomial(roots).astype(np.complex128)

        # Compute update and clip to prevent overflow
        delta = numerator / denominator
        delta = np.clip(delta, -1e10, 1e10)
        roots -= delta

    return roots",data\repos\Python\maths\numerical_analysis\weierstrass_method.py,weierstrass_method,689
2574,single_indeterminate_operations.py::evaluate::90,"    def evaluate(self, substitution: float) -> float:
        """"""
        Evaluates the polynomial at x.
        >>> p = Polynomial(2, [1, 2, 3])
        >>> p.evaluate(2)
        17
        """"""
        result: int | float = 0
        for i in range(self.degree + 1):
            result += self.coefficients[i] * (substitution**i)
        return result",data\repos\Python\maths\polynomials\single_indeterminate_operations.py,evaluate,91
2575,single_indeterminate_operations.py::derivative::135,"    def derivative(self) -> Polynomial:
        """"""
        Returns the derivative of the polynomial.
        >>> p = Polynomial(2, [1, 2, 3])
        >>> p.derivative()
        6x + 2
        """"""
        coefficients: list[float] = [0] * self.degree
        for i in range(self.degree):
            coefficients[i] = self.coefficients[i + 1] * (i + 1)
        return Polynomial(self.degree - 1, coefficients)",data\repos\Python\maths\polynomials\single_indeterminate_operations.py,derivative,104
2576,single_indeterminate_operations.py::integral::147,"    def integral(self, constant: float = 0) -> Polynomial:
        """"""
        Returns the integral of the polynomial.
        >>> p = Polynomial(2, [1, 2, 3])
        >>> p.integral()
        1.0x^3 + 1.0x^2 + 1.0x
        """"""
        coefficients: list[float] = [0] * (self.degree + 2)
        coefficients[0] = constant
        for i in range(self.degree + 1):
            coefficients[i + 1] = self.coefficients[i] / (i + 1)
        return Polynomial(self.degree + 1, coefficients)",data\repos\Python\maths\polynomials\single_indeterminate_operations.py,integral,141
2577,arithmetic.py::is_arithmetic_series::11,"def is_arithmetic_series(series: list) -> bool:
    """"""
    checking whether the input series is arithmetic series or not
    >>> is_arithmetic_series([2, 4, 6])
    True
    >>> is_arithmetic_series([3, 6, 12, 24])
    False
    >>> is_arithmetic_series([1, 2, 3])
    True
    >>> is_arithmetic_series(4)
    Traceback (most recent call last):
        ...
    ValueError: Input series is not valid, valid series - [2, 4, 6]
    >>> is_arithmetic_series([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must be a non empty list
    """"""
    if not isinstance(series, list):
        raise ValueError(""Input series is not valid, valid series - [2, 4, 6]"")
    if len(series) == 0:
        raise ValueError(""Input list must be a non empty list"")
    if len(series) == 1:
        return True
    common_diff = series[1] - series[0]
    for index in range(len(series) - 1):
        if series[index + 1] - series[index] != common_diff:
            return False
    return True",data\repos\Python\maths\series\arithmetic.py,is_arithmetic_series,269
2578,arithmetic.py::arithmetic_mean::42,"def arithmetic_mean(series: list) -> float:
    """"""
    return the arithmetic mean of series

    >>> arithmetic_mean([2, 4, 6])
    4.0
    >>> arithmetic_mean([3, 6, 9, 12])
    7.5
    >>> arithmetic_mean(4)
    Traceback (most recent call last):
        ...
    ValueError: Input series is not valid, valid series - [2, 4, 6]
    >>> arithmetic_mean([4, 8, 1])
    4.333333333333333
    >>> arithmetic_mean([1, 2, 3])
    2.0
    >>> arithmetic_mean([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must be a non empty list

    """"""
    if not isinstance(series, list):
        raise ValueError(""Input series is not valid, valid series - [2, 4, 6]"")
    if len(series) == 0:
        raise ValueError(""Input list must be a non empty list"")
    answer = 0
    for val in series:
        answer += val
    return answer / len(series)",data\repos\Python\maths\series\arithmetic.py,arithmetic_mean,248
2579,geometric.py::is_geometric_series::10,"def is_geometric_series(series: list) -> bool:
    """"""
    checking whether the input series is geometric series or not
    >>> is_geometric_series([2, 4, 8])
    True
    >>> is_geometric_series([3, 6, 12, 24])
    True
    >>> is_geometric_series([1, 2, 3])
    False
    >>> is_geometric_series([0, 0, 3])
    False
    >>> is_geometric_series([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must be a non empty list
    >>> is_geometric_series(4)
    Traceback (most recent call last):
        ...
    ValueError: Input series is not valid, valid series - [2, 4, 8]
    """"""
    if not isinstance(series, list):
        raise ValueError(""Input series is not valid, valid series - [2, 4, 8]"")
    if len(series) == 0:
        raise ValueError(""Input list must be a non empty list"")
    if len(series) == 1:
        return True
    try:
        common_ratio = series[1] / series[0]
        for index in range(len(series) - 1):
            if series[index + 1] / series[index] != common_ratio:
                return False
    except ZeroDivisionError:
        return False
    return True",data\repos\Python\maths\series\geometric.py,is_geometric_series,300
2580,geometric.py::geometric_mean::46,"def geometric_mean(series: list) -> float:
    """"""
    return the geometric mean of series

    >>> geometric_mean([2, 4, 8])
    3.9999999999999996
    >>> geometric_mean([3, 6, 12, 24])
    8.48528137423857
    >>> geometric_mean([4, 8, 16])
    7.999999999999999
    >>> geometric_mean(4)
    Traceback (most recent call last):
        ...
    ValueError: Input series is not valid, valid series - [2, 4, 8]
    >>> geometric_mean([1, 2, 3])
    1.8171205928321397
    >>> geometric_mean([0, 2, 3])
    0.0
    >>> geometric_mean([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must be a non empty list

    """"""
    if not isinstance(series, list):
        raise ValueError(""Input series is not valid, valid series - [2, 4, 8]"")
    if len(series) == 0:
        raise ValueError(""Input list must be a non empty list"")
    answer = 1
    for value in series:
        answer *= value
    return pow(answer, 1 / len(series))",data\repos\Python\maths\series\geometric.py,geometric_mean,285
2581,geometric_series.py::geometric_series::15,"def geometric_series(
    nth_term: float,
    start_term_a: float,
    common_ratio_r: float,
) -> list[float]:
    """"""
    Pure Python implementation of Geometric Series algorithm

    :param nth_term: The last term (nth term of Geometric Series)
    :param start_term_a : The first term of Geometric Series
    :param common_ratio_r : The common ratio between all the terms
    :return: The Geometric Series starting from first term a and multiple of common
        ration with first term with increase in power till last term (nth term)
    Examples:
    >>> geometric_series(4, 2, 2)
    [2, 4.0, 8.0, 16.0]
    >>> geometric_series(4.0, 2.0, 2.0)
    [2.0, 4.0, 8.0, 16.0]
    >>> geometric_series(4.1, 2.1, 2.1)
    [2.1, 4.41, 9.261000000000001, 19.448100000000004]
    >>> geometric_series(4, 2, -2)
    [2, -4.0, 8.0, -16.0]
    >>> geometric_series(4, -2, 2)
    [-2, -4.0, -8.0, -16.0]
    >>> geometric_series(-4, 2, 2)
    []
    >>> geometric_series(0, 100, 500)
    []
    >>> geometric_series(1, 1, 1)
    [1]
    >>> geometric_series(0, 0, 0)
    []
    """"""
    if not all((nth_term, start_term_a, common_ratio_r)):
        return []
    series: list[float] = []
    power = 1
    multiple = common_ratio_r
    for _ in range(int(nth_term)):
        if not series:
            series.append(start_term_a)
        else:
            power += 1
            series.append(float(start_term_a * multiple))
            multiple = pow(float(common_ratio_r), power)
    return series",data\repos\Python\maths\series\geometric_series.py,geometric_series,468
2582,harmonic.py::is_harmonic_series::10,"def is_harmonic_series(series: list) -> bool:
    """"""
    checking whether the input series is arithmetic series or not
    >>> is_harmonic_series([ 1, 2/3, 1/2, 2/5, 1/3])
    True
    >>> is_harmonic_series([ 1, 2/3, 2/5, 1/3])
    False
    >>> is_harmonic_series([1, 2, 3])
    False
    >>> is_harmonic_series([1/2, 1/3, 1/4])
    True
    >>> is_harmonic_series([2/5, 2/10, 2/15, 2/20, 2/25])
    True
    >>> is_harmonic_series(4)
    Traceback (most recent call last):
        ...
    ValueError: Input series is not valid, valid series - [1, 2/3, 2]
    >>> is_harmonic_series([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must be a non empty list
    >>> is_harmonic_series([0])
    Traceback (most recent call last):
        ...
    ValueError: Input series cannot have 0 as an element
    >>> is_harmonic_series([1,2,0,6])
    Traceback (most recent call last):
        ...
    ValueError: Input series cannot have 0 as an element
    """"""
    if not isinstance(series, list):
        raise ValueError(""Input series is not valid, valid series - [1, 2/3, 2]"")
    if len(series) == 0:
        raise ValueError(""Input list must be a non empty list"")
    if len(series) == 1 and series[0] != 0:
        return True
    rec_series = []
    series_len = len(series)
    for i in range(series_len):
        if series[i] == 0:
            raise ValueError(""Input series cannot have 0 as an element"")
        rec_series.append(1 / series[i])
    common_diff = rec_series[1] - rec_series[0]
    for index in range(2, series_len):
        if rec_series[index] - rec_series[index - 1] != common_diff:
            return False
    return True",data\repos\Python\maths\series\harmonic.py,is_harmonic_series,499
2583,harmonic.py::harmonic_mean::59,"def harmonic_mean(series: list) -> float:
    """"""
    return the harmonic mean of series

    >>> harmonic_mean([1, 4, 4])
    2.0
    >>> harmonic_mean([3, 6, 9, 12])
    5.759999999999999
    >>> harmonic_mean(4)
    Traceback (most recent call last):
        ...
    ValueError: Input series is not valid, valid series - [2, 4, 6]
    >>> harmonic_mean([1, 2, 3])
    1.6363636363636365
    >>> harmonic_mean([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must be a non empty list

    """"""
    if not isinstance(series, list):
        raise ValueError(""Input series is not valid, valid series - [2, 4, 6]"")
    if len(series) == 0:
        raise ValueError(""Input list must be a non empty list"")
    answer = 0
    for val in series:
        answer += 1 / val
    return len(series) / answer",data\repos\Python\maths\series\harmonic.py,harmonic_mean,237
2584,harmonic_series.py::harmonic_series::15,"def harmonic_series(n_term: str) -> list:
    """"""Pure Python implementation of Harmonic Series algorithm

    :param n_term: The last (nth) term of Harmonic Series
    :return: The Harmonic Series starting from 1 to last (nth) term

    Examples:
    >>> harmonic_series(5)
    ['1', '1/2', '1/3', '1/4', '1/5']
    >>> harmonic_series(5.0)
    ['1', '1/2', '1/3', '1/4', '1/5']
    >>> harmonic_series(5.1)
    ['1', '1/2', '1/3', '1/4', '1/5']
    >>> harmonic_series(-5)
    []
    >>> harmonic_series(0)
    []
    >>> harmonic_series(1)
    ['1']
    """"""
    if n_term == """":
        return []
    series: list = []
    for temp in range(int(n_term)):
        series.append(f""1/{temp + 1}"" if series else ""1"")
    return series",data\repos\Python\maths\series\harmonic_series.py,harmonic_series,234
2585,hexagonal_numbers.py::hexagonal_numbers::18,"def hexagonal_numbers(length: int) -> list[int]:
    """"""
    :param len: max number of elements
    :type len: int
    :return: Hexagonal numbers as a list

    Tests:
    >>> hexagonal_numbers(10)
    [0, 1, 6, 15, 28, 45, 66, 91, 120, 153]
    >>> hexagonal_numbers(5)
    [0, 1, 6, 15, 28]
    >>> hexagonal_numbers(0)
    Traceback (most recent call last):
      ...
    ValueError: Length must be a positive integer.
    """"""

    if length <= 0 or not isinstance(length, int):
        raise ValueError(""Length must be a positive integer."")
    return [n * (2 * n - 1) for n in range(length)]",data\repos\Python\maths\series\hexagonal_numbers.py,hexagonal_numbers,182
2586,p_series.py::p_series::15,"def p_series(nth_term: float | str, power: float | str) -> list[str]:
    """"""
    Pure Python implementation of P-Series algorithm
    :return: The P-Series starting from 1 to last (nth) term
    Examples:
    >>> p_series(5, 2)
    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']
    >>> p_series(-5, 2)
    []
    >>> p_series(5, -2)
    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']
    >>> p_series("""", 1000)
    ['']
    >>> p_series(0, 0)
    []
    >>> p_series(1, 1)
    ['1']
    """"""
    if nth_term == """":
        return [""""]
    nth_term = int(nth_term)
    power = int(power)
    series: list[str] = []
    for temp in range(int(nth_term)):
        series.append(f""1 / {pow(temp + 1, int(power))}"" if series else ""1"")
    return series",data\repos\Python\maths\series\p_series.py,p_series,266
2587,armstrong_numbers.py::armstrong_number::16,"def armstrong_number(n: int) -> bool:
    """"""
    Return True if n is an Armstrong number or False if it is not.

    >>> all(armstrong_number(n) for n in PASSING)
    True
    >>> any(armstrong_number(n) for n in FAILING)
    False
    """"""
    if not isinstance(n, int) or n < 1:
        return False

    # Initialization of sum and number of digits.
    total = 0
    number_of_digits = 0
    temp = n
    # Calculation of digits of the number
    number_of_digits = len(str(n))
    # Dividing number into separate digits and find Armstrong number
    temp = n
    while temp > 0:
        rem = temp % 10
        total += rem**number_of_digits
        temp //= 10
    return n == total",data\repos\Python\maths\special_numbers\armstrong_numbers.py,armstrong_number,185
2588,armstrong_numbers.py::pluperfect_number::43,"def pluperfect_number(n: int) -> bool:
    """"""Return True if n is a pluperfect number or False if it is not

    >>> all(pluperfect_number(n) for n in PASSING)
    True
    >>> any(pluperfect_number(n) for n in FAILING)
    False
    """"""
    if not isinstance(n, int) or n < 1:
        return False

    # Init a ""histogram"" of the digits
    digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    digit_total = 0
    total = 0
    temp = n
    while temp > 0:
        temp, rem = divmod(temp, 10)
        digit_histogram[rem] += 1
        digit_total += 1

    for cnt, i in zip(digit_histogram, range(len(digit_histogram))):
        total += cnt * i**digit_total

    return n == total",data\repos\Python\maths\special_numbers\armstrong_numbers.py,pluperfect_number,219
2589,armstrong_numbers.py::narcissistic_number::70,"def narcissistic_number(n: int) -> bool:
    """"""Return True if n is a narcissistic number or False if it is not.

    >>> all(narcissistic_number(n) for n in PASSING)
    True
    >>> any(narcissistic_number(n) for n in FAILING)
    False
    """"""
    if not isinstance(n, int) or n < 1:
        return False
    expo = len(str(n))  # the power that all digits will be raised to
    # check if sum of each digit multiplied expo times is equal to number
    return n == sum(int(i) ** expo for i in str(n))",data\repos\Python\maths\special_numbers\armstrong_numbers.py,narcissistic_number,138
2590,armstrong_numbers.py::main::85,"def main():
    """"""
    Request that user input an integer and tell them if it is Armstrong number.
    """"""
    num = int(input(""Enter an integer to see if it is an Armstrong number: "").strip())
    print(f""{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number."")
    print(f""{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number."")
    print(f""{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number."")",data\repos\Python\maths\special_numbers\armstrong_numbers.py,main,114
2591,automorphic_number.py::is_automorphic_number::14,"def is_automorphic_number(number: int) -> bool:
    """"""
    # doctest: +NORMALIZE_WHITESPACE
    This functions takes an integer number as input.
    returns True if the number is automorphic.
    >>> is_automorphic_number(-1)
    False
    >>> is_automorphic_number(0)
    True
    >>> is_automorphic_number(5)
    True
    >>> is_automorphic_number(6)
    True
    >>> is_automorphic_number(7)
    False
    >>> is_automorphic_number(25)
    True
    >>> is_automorphic_number(259918212890625)
    True
    >>> is_automorphic_number(259918212890636)
    False
    >>> is_automorphic_number(740081787109376)
    True
    >>> is_automorphic_number(5.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=5.0] must be an integer
    """"""
    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)
    if number < 0:
        return False
    number_square = number * number
    while number > 0:
        if number % 10 != number_square % 10:
            return False
        number //= 10
        number_square //= 10
    return True",data\repos\Python\maths\special_numbers\automorphic_number.py,is_automorphic_number,309
2592,bell_numbers.py::bell_numbers::11,"def bell_numbers(max_set_length: int) -> list[int]:
    """"""
    Calculate Bell numbers for the sets of lengths from 0 to max_set_length.
    In other words, calculate first (max_set_length + 1) Bell numbers.

    Args:
        max_set_length (int): The maximum length of the sets for which
        Bell numbers are calculated.

    Returns:
        list: A list of Bell numbers for sets of lengths from 0 to max_set_length.

    Examples:
    >>> bell_numbers(-2)
    Traceback (most recent call last):
        ...
    ValueError: max_set_length must be non-negative
    >>> bell_numbers(0)
    [1]
    >>> bell_numbers(1)
    [1, 1]
    >>> bell_numbers(5)
    [1, 1, 2, 5, 15, 52]
    """"""
    if max_set_length < 0:
        raise ValueError(""max_set_length must be non-negative"")

    bell = [0] * (max_set_length + 1)
    bell[0] = 1

    for i in range(1, max_set_length + 1):
        for j in range(i):
            bell[i] += _binomial_coefficient(i - 1, j) * bell[j]

    return bell",data\repos\Python\maths\special_numbers\bell_numbers.py,bell_numbers,274
2593,carmichael_number.py::power::17,"def power(x: int, y: int, mod: int) -> int:
    """"""
    Examples:
    >>> power(2, 15, 3)
    2
    >>> power(5, 1, 30)
    5
    """"""

    if y == 0:
        return 1
    temp = power(x, y // 2, mod) % mod
    temp = (temp * temp) % mod
    if y % 2 == 1:
        temp = (temp * x) % mod
    return temp",data\repos\Python\maths\special_numbers\carmichael_number.py,power,119
2594,carmichael_number.py::is_carmichael_number::35,"def is_carmichael_number(n: int) -> bool:
    """"""
    Examples:
    >>> is_carmichael_number(4)
    False
    >>> is_carmichael_number(561)
    True
    >>> is_carmichael_number(562)
    False
    >>> is_carmichael_number(900)
    False
    >>> is_carmichael_number(1105)
    True
    >>> is_carmichael_number(8911)
    True
    >>> is_carmichael_number(5.1)
    Traceback (most recent call last):
         ...
    ValueError: Number 5.1 must instead be a positive integer

    >>> is_carmichael_number(-7)
    Traceback (most recent call last):
         ...
    ValueError: Number -7 must instead be a positive integer

    >>> is_carmichael_number(0)
    Traceback (most recent call last):
         ...
    ValueError: Number 0 must instead be a positive integer
    """"""

    if n <= 0 or not isinstance(n, int):
        msg = f""Number {n} must instead be a positive integer""
        raise ValueError(msg)

    return all(
        power(b, n - 1, n) == 1
        for b in range(2, n)
        if greatest_common_divisor(b, n) == 1
    )",data\repos\Python\maths\special_numbers\carmichael_number.py,is_carmichael_number,285
2595,catalan_number.py::catalan::11,"def catalan(number: int) -> int:
    """"""
    :param number: nth catalan number to calculate
    :return: the nth catalan number
    Note: A catalan number is only defined for positive integers

    >>> catalan(5)
    14
    >>> catalan(0)
    Traceback (most recent call last):
        ...
    ValueError: Input value of [number=0] must be > 0
    >>> catalan(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input value of [number=-1] must be > 0
    >>> catalan(5.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=5.0] must be an integer
    """"""

    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)

    if number < 1:
        msg = f""Input value of [number={number}] must be > 0""
        raise ValueError(msg)

    current_number = 1

    for i in range(1, number):
        current_number *= 4 * i - 2
        current_number //= i + 1

    return current_number",data\repos\Python\maths\special_numbers\catalan_number.py,catalan,273
2596,hamming_numbers.py::hamming::8,"def hamming(n_element: int) -> list:
    """"""
    This function creates an ordered list of n length as requested, and afterwards
    returns the last value of the list. It must be given a positive integer.

    :param n_element: The number of elements on the list
    :return: The nth element of the list

    >>> hamming(-5)
    Traceback (most recent call last):
        ...
    ValueError: n_element should be a positive number
    >>> hamming(5)
    [1, 2, 3, 4, 5]
    >>> hamming(10)
    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
    >>> hamming(15)
    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]
    """"""
    n_element = int(n_element)
    if n_element < 1:
        my_error = ValueError(""n_element should be a positive number"")
        raise my_error

    hamming_list = [1]
    i, j, k = (0, 0, 0)
    index = 1
    while index < n_element:
        while hamming_list[i] * 2 <= hamming_list[-1]:
            i += 1
        while hamming_list[j] * 3 <= hamming_list[-1]:
            j += 1
        while hamming_list[k] * 5 <= hamming_list[-1]:
            k += 1
        hamming_list.append(
            min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)
        )
        index += 1
    return hamming_list",data\repos\Python\maths\special_numbers\hamming_numbers.py,hamming,406
2597,happy_number.py::is_happy_number::1,"def is_happy_number(number: int) -> bool:
    """"""
    A happy number is a number which eventually reaches 1 when replaced by the sum of
    the square of each digit.

    :param number: The number to check for happiness.
    :return: True if the number is a happy number, False otherwise.

    >>> is_happy_number(19)
    True
    >>> is_happy_number(2)
    False
    >>> is_happy_number(23)
    True
    >>> is_happy_number(1)
    True
    >>> is_happy_number(0)
    Traceback (most recent call last):
        ...
    ValueError: number=0 must be a positive integer
    >>> is_happy_number(-19)
    Traceback (most recent call last):
        ...
    ValueError: number=-19 must be a positive integer
    >>> is_happy_number(19.1)
    Traceback (most recent call last):
        ...
    ValueError: number=19.1 must be a positive integer
    >>> is_happy_number(""happy"")
    Traceback (most recent call last):
        ...
    ValueError: number='happy' must be a positive integer
    """"""
    if not isinstance(number, int) or number <= 0:
        msg = f""{number=} must be a positive integer""
        raise ValueError(msg)

    seen = set()
    while number != 1 and number not in seen:
        seen.add(number)
        number = sum(int(digit) ** 2 for digit in str(number))
    return number == 1",data\repos\Python\maths\special_numbers\happy_number.py,is_happy_number,328
2598,harshad_numbers.py::int_to_base::8,"def int_to_base(number: int, base: int) -> str:
    """"""
    Convert a given positive decimal integer to base 'base'.
    Where 'base' ranges from 2 to 36.

    Examples:
    >>> int_to_base(0, 21)
    '0'
    >>> int_to_base(23, 2)
    '10111'
    >>> int_to_base(58, 5)
    '213'
    >>> int_to_base(167, 16)
    'A7'
    >>> # bases below 2 and beyond 36 will error
    >>> int_to_base(98, 1)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    >>> int_to_base(98, 37)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    >>> int_to_base(-99, 16)
    Traceback (most recent call last):
        ...
    ValueError: number must be a positive integer
    """"""

    if base < 2 or base > 36:
        raise ValueError(""'base' must be between 2 and 36 inclusive"")

    digits = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    result = """"

    if number < 0:
        raise ValueError(""number must be a positive integer"")

    while number > 0:
        number, remainder = divmod(number, base)
        result = digits[remainder] + result

    if result == """":
        result = ""0""

    return result",data\repos\Python\maths\special_numbers\harshad_numbers.py,int_to_base,333
2599,harshad_numbers.py::sum_of_digits::56,"def sum_of_digits(num: int, base: int) -> str:
    """"""
    Calculate the sum of digit values in a positive integer
    converted to the given 'base'.
    Where 'base' ranges from 2 to 36.

    Examples:
    >>> sum_of_digits(103, 12)
    '13'
    >>> sum_of_digits(1275, 4)
    '30'
    >>> sum_of_digits(6645, 2)
    '1001'
    >>> # bases below 2 and beyond 36 will error
    >>> sum_of_digits(543, 1)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    >>> sum_of_digits(543, 37)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    """"""

    if base < 2 or base > 36:
        raise ValueError(""'base' must be between 2 and 36 inclusive"")

    num_str = int_to_base(num, base)
    res = sum(int(char, base) for char in num_str)
    res_str = int_to_base(res, base)
    return res_str",data\repos\Python\maths\special_numbers\harshad_numbers.py,sum_of_digits,262
2600,harshad_numbers.py::harshad_numbers_in_base::89,"def harshad_numbers_in_base(limit: int, base: int) -> list[str]:
    """"""
    Finds all Harshad numbers smaller than num in base 'base'.
    Where 'base' ranges from 2 to 36.

    Examples:
    >>> harshad_numbers_in_base(15, 2)
    ['1', '10', '100', '110', '1000', '1010', '1100']
    >>> harshad_numbers_in_base(12, 34)
    ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B']
    >>> harshad_numbers_in_base(12, 4)
    ['1', '2', '3', '10', '12', '20', '21']
    >>> # bases below 2 and beyond 36 will error
    >>> harshad_numbers_in_base(234, 37)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    >>> harshad_numbers_in_base(234, 1)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    >>> harshad_numbers_in_base(-12, 6)
    []
    """"""

    if base < 2 or base > 36:
        raise ValueError(""'base' must be between 2 and 36 inclusive"")

    if limit < 0:
        return []

    numbers = [
        int_to_base(i, base)
        for i in range(1, limit)
        if i % int(sum_of_digits(i, base), base) == 0
    ]

    return numbers",data\repos\Python\maths\special_numbers\harshad_numbers.py,harshad_numbers_in_base,365
2601,harshad_numbers.py::is_harshad_number_in_base::129,"def is_harshad_number_in_base(num: int, base: int) -> bool:
    """"""
    Determines whether n in base 'base' is a harshad number.
    Where 'base' ranges from 2 to 36.

    Examples:
    >>> is_harshad_number_in_base(18, 10)
    True
    >>> is_harshad_number_in_base(21, 10)
    True
    >>> is_harshad_number_in_base(-21, 5)
    False
    >>> # bases below 2 and beyond 36 will error
    >>> is_harshad_number_in_base(45, 37)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    >>> is_harshad_number_in_base(45, 1)
    Traceback (most recent call last):
        ...
    ValueError: 'base' must be between 2 and 36 inclusive
    """"""

    if base < 2 or base > 36:
        raise ValueError(""'base' must be between 2 and 36 inclusive"")

    if num < 0:
        return False

    n = int_to_base(num, base)
    d = sum_of_digits(num, base)
    return int(n, base) % int(d, base) == 0",data\repos\Python\maths\special_numbers\harshad_numbers.py,is_harshad_number_in_base,287
2602,hexagonal_number.py::hexagonal::14,"def hexagonal(number: int) -> int:
    """"""
    :param number: nth hexagonal number to calculate
    :return: the nth hexagonal number
    Note: A hexagonal number is only defined for positive integers
    >>> hexagonal(4)
    28
    >>> hexagonal(11)
    231
    >>> hexagonal(22)
    946
    >>> hexagonal(0)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a positive integer
    >>> hexagonal(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a positive integer
    >>> hexagonal(11.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=11.0] must be an integer
    """"""
    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)
    if number < 1:
        raise ValueError(""Input must be a positive integer"")
    return number * (2 * number - 1)",data\repos\Python\maths\special_numbers\hexagonal_number.py,hexagonal,238
2603,krishnamurthy_number.py::factorial::13,"def factorial(digit: int) -> int:
    """"""
    >>> factorial(3)
    6
    >>> factorial(0)
    1
    >>> factorial(5)
    120
    """"""

    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))",data\repos\Python\maths\special_numbers\krishnamurthy_number.py,factorial,68
2604,krishnamurthy_number.py::krishnamurthy::26,"def krishnamurthy(number: int) -> bool:
    """"""
    >>> krishnamurthy(145)
    True
    >>> krishnamurthy(240)
    False
    >>> krishnamurthy(1)
    True
    """"""

    fact_sum = 0
    duplicate = number
    while duplicate > 0:
        duplicate, digit = divmod(duplicate, 10)
        fact_sum += factorial(digit)
    return fact_sum == number",data\repos\Python\maths\special_numbers\krishnamurthy_number.py,krishnamurthy,102
2605,perfect_number.py::perfect::15,"def perfect(number: int) -> bool:
    """"""
    Check if a number is a perfect number.

    A perfect number is a positive integer that is equal to the sum of its proper
    divisors (excluding itself).

    Args:
        number: The number to be checked.

    Returns:
        True if the number is a perfect number, False otherwise.

    Start from 1 because dividing by 0 will raise ZeroDivisionError.
    A number at most can be divisible by the half of the number except the number
    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.

    Examples:
    >>> perfect(27)
    False
    >>> perfect(28)
    True
    >>> perfect(29)
    False
    >>> perfect(6)
    True
    >>> perfect(12)
    False
    >>> perfect(496)
    True
    >>> perfect(8128)
    True
    >>> perfect(0)
    False
    >>> perfect(-1)
    False
    >>> perfect(12.34)
    Traceback (most recent call last):
      ...
    ValueError: number must be an integer
    >>> perfect(""Hello"")
    Traceback (most recent call last):
      ...
    ValueError: number must be an integer
    """"""
    if not isinstance(number, int):
        raise ValueError(""number must be an integer"")
    if number <= 0:
        return False
    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number",data\repos\Python\maths\special_numbers\perfect_number.py,perfect,330
2606,polygonal_numbers.py::polygonal_num::1,"def polygonal_num(num: int, sides: int) -> int:
    """"""
    Returns the `num`th `sides`-gonal number. It is assumed that `num` >= 0 and
    `sides` >= 3 (see for reference https://en.wikipedia.org/wiki/Polygonal_number).

    >>> polygonal_num(0, 3)
    0
    >>> polygonal_num(3, 3)
    6
    >>> polygonal_num(5, 4)
    25
    >>> polygonal_num(2, 5)
    5
    >>> polygonal_num(-1, 0)
    Traceback (most recent call last):
        ...
    ValueError: Invalid input: num must be >= 0 and sides must be >= 3.
    >>> polygonal_num(0, 2)
    Traceback (most recent call last):
        ...
    ValueError: Invalid input: num must be >= 0 and sides must be >= 3.
    """"""
    if num < 0 or sides < 3:
        raise ValueError(""Invalid input: num must be >= 0 and sides must be >= 3."")

    return ((sides - 2) * num**2 - (sides - 4) * num) // 2",data\repos\Python\maths\special_numbers\polygonal_numbers.py,polygonal_num,274
2607,pronic_number.py::is_pronic::13,"def is_pronic(number: int) -> bool:
    """"""
    # doctest: +NORMALIZE_WHITESPACE
    This functions takes an integer number as input.
    returns True if the number is pronic.
    >>> is_pronic(-1)
    False
    >>> is_pronic(0)
    True
    >>> is_pronic(2)
    True
    >>> is_pronic(5)
    False
    >>> is_pronic(6)
    True
    >>> is_pronic(8)
    False
    >>> is_pronic(30)
    True
    >>> is_pronic(32)
    False
    >>> is_pronic(2147441940)
    True
    >>> is_pronic(9223372033963249500)
    True
    >>> is_pronic(6.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=6.0] must be an integer
    """"""
    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)
    if number < 0 or number % 2 == 1:
        return False
    number_sqrt = int(number**0.5)
    return number == number_sqrt * (number_sqrt + 1)",data\repos\Python\maths\special_numbers\pronic_number.py,is_pronic,280
2608,proth_number.py::proth::10,"def proth(number: int) -> int:
    """"""
    :param number: nth number to calculate in the sequence
    :return: the nth number in Proth number
    Note: indexing starts at 1 i.e. proth(1) gives the first Proth number of 3
    >>> proth(6)
    25
    >>> proth(0)
    Traceback (most recent call last):
        ...
    ValueError: Input value of [number=0] must be > 0
    >>> proth(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input value of [number=-1] must be > 0
    >>> proth(6.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=6.0] must be an integer
    """"""

    if not isinstance(number, int):
        msg = f""Input value of [number={number}] must be an integer""
        raise TypeError(msg)

    if number < 1:
        msg = f""Input value of [number={number}] must be > 0""
        raise ValueError(msg)
    elif number == 1:
        return 3
    elif number == 2:
        return 5
    else:
        """"""
        +1 for binary starting at 0 i.e. 2^0, 2^1, etc.
        +1 to start the sequence at the 3rd Proth number
        Hence, we have a +2 in the below statement
        """"""
        block_index = int(math.log(number // 3, 2)) + 2

        proth_list = [3, 5]
        proth_index = 2
        increment = 3
        for block in range(1, block_index):
            for _ in range(increment):
                proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])
                proth_index += 1
            increment *= 2

    return proth_list[number - 1]",data\repos\Python\maths\special_numbers\proth_number.py,proth,443
2609,proth_number.py::is_proth_number::62,"def is_proth_number(number: int) -> bool:
    """"""
    :param number: positive integer number
    :return: true if number is a Proth number, false otherwise
    >>> is_proth_number(1)
    False
    >>> is_proth_number(2)
    False
    >>> is_proth_number(3)
    True
    >>> is_proth_number(4)
    False
    >>> is_proth_number(5)
    True
    >>> is_proth_number(34)
    False
    >>> is_proth_number(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input value of [number=-1] must be > 0
    >>> is_proth_number(6.0)
    Traceback (most recent call last):
        ...
    TypeError: Input value of [number=6.0] must be an integer
    """"""
    if not isinstance(number, int):
        message = f""Input value of [{number=}] must be an integer""
        raise TypeError(message)

    if number <= 0:
        message = f""Input value of [{number=}] must be > 0""
        raise ValueError(message)

    if number == 1:
        return False

    number -= 1
    n = 0
    while number % 2 == 0:
        n += 1
        number //= 2
    return number < 2**n",data\repos\Python\maths\special_numbers\proth_number.py,is_proth_number,303
2610,triangular_numbers.py::triangular_number::11,"def triangular_number(position: int) -> int:
    """"""
    Generate the triangular number at the specified position.

    Args:
        position (int): The position of the triangular number to generate.

    Returns:
        int: The triangular number at the specified position.

    Raises:
        ValueError: If `position` is negative.

    Examples:
    >>> triangular_number(1)
    1
    >>> triangular_number(3)
    6
    >>> triangular_number(-1)
    Traceback (most recent call last):
        ...
    ValueError: param `position` must be non-negative
    """"""
    if position < 0:
        raise ValueError(""param `position` must be non-negative"")

    return position * (position + 1) // 2",data\repos\Python\maths\special_numbers\triangular_numbers.py,triangular_number,156
2611,ugly_numbers.py::ugly_numbers::12,"def ugly_numbers(n: int) -> int:
    """"""
    Returns the nth ugly number.
    >>> ugly_numbers(100)
    1536
    >>> ugly_numbers(0)
    1
    >>> ugly_numbers(20)
    36
    >>> ugly_numbers(-5)
    1
    >>> ugly_numbers(-5.5)
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    """"""
    ugly_nums = [1]

    i2, i3, i5 = 0, 0, 0
    next_2 = ugly_nums[i2] * 2
    next_3 = ugly_nums[i3] * 3
    next_5 = ugly_nums[i5] * 5

    for _ in range(1, n):
        next_num = min(next_2, next_3, next_5)
        ugly_nums.append(next_num)
        if next_num == next_2:
            i2 += 1
            next_2 = ugly_nums[i2] * 2
        if next_num == next_3:
            i3 += 1
            next_3 = ugly_nums[i3] * 3
        if next_num == next_5:
            i5 += 1
            next_5 = ugly_nums[i5] * 5
    return ugly_nums[-1]",data\repos\Python\maths\special_numbers\ugly_numbers.py,ugly_numbers,299
2612,weird_number.py::factors::10,"def factors(number: int) -> list[int]:
    """"""
    >>> factors(12)
    [1, 2, 3, 4, 6]
    >>> factors(1)
    [1]
    >>> factors(100)
    [1, 2, 4, 5, 10, 20, 25, 50]

    # >>> factors(-12)
    # [1, 2, 3, 4, 6]
    """"""

    values = [1]
    for i in range(2, int(sqrt(number)) + 1, 1):
        if number % i == 0:
            values.append(i)
            if int(number // i) != i:
                values.append(int(number // i))
    return sorted(values)",data\repos\Python\maths\special_numbers\weird_number.py,factors,163
2613,weird_number.py::abundant::32,"def abundant(n: int) -> bool:
    """"""
    >>> abundant(0)
    True
    >>> abundant(1)
    False
    >>> abundant(12)
    True
    >>> abundant(13)
    False
    >>> abundant(20)
    True

    # >>> abundant(-12)
    # True
    """"""
    return sum(factors(n)) > n",data\repos\Python\maths\special_numbers\weird_number.py,abundant,78
2614,weird_number.py::semi_perfect::51,"def semi_perfect(number: int) -> bool:
    """"""
    >>> semi_perfect(0)
    True
    >>> semi_perfect(1)
    True
    >>> semi_perfect(12)
    True
    >>> semi_perfect(13)
    False

    # >>> semi_perfect(-12)
    # True
    """"""
    values = factors(number)
    r = len(values)
    subset = [[0 for i in range(number + 1)] for j in range(r + 1)]
    for i in range(r + 1):
        subset[i][0] = True

    for i in range(1, number + 1):
        subset[0][i] = False

    for i in range(1, r + 1):
        for j in range(1, number + 1):
            if j < values[i - 1]:
                subset[i][j] = subset[i - 1][j]
            else:
                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - values[i - 1]]

    return subset[r][number] != 0",data\repos\Python\maths\special_numbers\weird_number.py,semi_perfect,243
2615,weird_number.py::weird::84,"def weird(number: int) -> bool:
    """"""
    >>> weird(0)
    False
    >>> weird(70)
    True
    >>> weird(77)
    False
    """"""
    return abundant(number) and not semi_perfect(number)",data\repos\Python\maths\special_numbers\weird_number.py,weird,52
2616,run.py::linear_regression_prediction::23,"def linear_regression_prediction(
    train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list
) -> float:
    """"""
    First method: linear regression
    input : training data (date, total_user, total_event) in list of float
    output : list of total user prediction in float
    >>> n = linear_regression_prediction([2,3,4,5], [5,3,4,6], [3,1,2,4], [2,1], [2,2])
    >>> bool(abs(n - 5.0) < 1e-6)  # Checking precision because of floating point errors
    True
    """"""
    x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])
    y = np.array(train_usr)
    beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)
    return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])",data\repos\Python\machine_learning\forecasting\run.py,linear_regression_prediction,237
2617,run.py::sarimax_predictor::40,"def sarimax_predictor(train_user: list, train_match: list, test_match: list) -> float:
    """"""
    second method: Sarimax
    sarimax is a statistic method which using previous input
    and learn its pattern to predict future data
    input : training data (total_user, with exog data = total_event) in list of float
    output : list of total user prediction in float
    >>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2])
    6.6666671111109626
    """"""
    # Suppress the User Warning raised by SARIMAX due to insufficient observations
    simplefilter(""ignore"", UserWarning)
    order = (1, 2, 1)
    seasonal_order = (1, 1, 1, 7)
    model = SARIMAX(
        train_user, exog=train_match, order=order, seasonal_order=seasonal_order
    )
    model_fit = model.fit(disp=False, maxiter=600, method=""nm"")
    result = model_fit.predict(1, len(test_match), exog=[test_match])
    return float(result[0])",data\repos\Python\machine_learning\forecasting\run.py,sarimax_predictor,254
2618,run.py::support_vector_regressor::62,"def support_vector_regressor(x_train: list, x_test: list, train_user: list) -> float:
    """"""
    Third method: Support vector regressor
    svr is quite the same with svm(support vector machine)
    it uses the same principles as the SVM for classification,
    with only a few minor differences and the only different is that
    it suits better for regression purpose
    input : training data (date, total_user, total_event) in list of float
    where x = list of set (date and total event)
    output : list of total user prediction in float
    >>> support_vector_regressor([[5,2],[1,5],[6,2]], [[3,2]], [2,1,4])
    1.634932078116079
    """"""
    regressor = SVR(kernel=""rbf"", C=1, gamma=0.1, epsilon=0.1)
    regressor.fit(x_train, train_user)
    y_pred = regressor.predict(x_test)
    return float(y_pred[0])",data\repos\Python\machine_learning\forecasting\run.py,support_vector_regressor,223
2619,run.py::interquartile_range_checker::81,"def interquartile_range_checker(train_user: list) -> float:
    """"""
    Optional method: interquatile range
    input : list of total user in float
    output : low limit of input in float
    this method can be used to check whether some data is outlier or not
    >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10])
    2.8
    """"""
    train_user.sort()
    q1 = np.percentile(train_user, 25)
    q3 = np.percentile(train_user, 75)
    iqr = q3 - q1
    low_lim = q1 - (iqr * 0.1)
    return float(low_lim)",data\repos\Python\machine_learning\forecasting\run.py,interquartile_range_checker,162
2620,run.py::data_safety_checker::98,"def data_safety_checker(list_vote: list, actual_result: float) -> bool:
    """"""
    Used to review all the votes (list result prediction)
    and compare it to the actual result.
    input : list of predictions
    output : print whether it's safe or not
    >>> data_safety_checker([2, 3, 4], 5.0)
    False
    """"""
    safe = 0
    not_safe = 0

    if not isinstance(actual_result, float):
        raise TypeError(""Actual result should be float. Value passed is a list"")

    for i in list_vote:
        if i > actual_result:
            safe = not_safe + 1
        elif abs(abs(i) - abs(actual_result)) <= 0.1:
            safe += 1
        else:
            not_safe += 1
    return safe > not_safe",data\repos\Python\machine_learning\forecasting\run.py,data_safety_checker,184
2621,local_weighted_learning.py::weight_matrix::38,"def weight_matrix(point: np.ndarray, x_train: np.ndarray, tau: float) -> np.ndarray:
    """"""
    Calculate the weight of every point in the training data around a given
    prediction point

    Args:
        point: x-value at which the prediction is being made
        x_train: ndarray of x-values for training
        tau: bandwidth value, controls how quickly the weight of training values
            decreases as the distance from the prediction point increases

    Returns:
        m x m weight matrix around the prediction point, where m is the size of
        the training set
    >>> weight_matrix(
    ...     np.array([1., 1.]),
    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),
    ...     0.6
    ... )
    array([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],
           [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],
           [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])
    """"""
    m = len(x_train)  # Number of training samples
    weights = np.eye(m)  # Initialize weights as identity matrix
    for j in range(m):
        diff = point - x_train[j]
        weights[j, j] = np.exp(diff @ diff.T / (-2.0 * tau**2))

    return weights",data\repos\Python\machine_learning\local_weighted_learning\local_weighted_learning.py,weight_matrix,351
2622,local_weighted_learning.py::local_weight::70,"def local_weight(
    point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float
) -> np.ndarray:
    """"""
    Calculate the local weights at a given prediction point using the weight
    matrix for that point

    Args:
        point: x-value at which the prediction is being made
        x_train: ndarray of x-values for training
        y_train: ndarray of y-values for training
        tau: bandwidth value, controls how quickly the weight of training values
            decreases as the distance from the prediction point increases
    Returns:
        ndarray of local weights
    >>> local_weight(
    ...     np.array([1., 1.]),
    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),
    ...     np.array([[1.01, 1.66, 3.5]]),
    ...     0.6
    ... )
    array([[0.00873174],
           [0.08272556]])
    """"""
    weight_mat = weight_matrix(point, x_train, tau)
    weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (
        x_train.T @ weight_mat @ y_train.T
    )

    return weight",data\repos\Python\machine_learning\local_weighted_learning\local_weighted_learning.py,local_weight,276
2623,local_weighted_learning.py::local_weight_regression::102,"def local_weight_regression(
    x_train: np.ndarray, y_train: np.ndarray, tau: float
) -> np.ndarray:
    """"""
    Calculate predictions for each point in the training data

    Args:
        x_train: ndarray of x-values for training
        y_train: ndarray of y-values for training
        tau: bandwidth value, controls how quickly the weight of training values
            decreases as the distance from the prediction point increases

    Returns:
        ndarray of predictions
    >>> local_weight_regression(
    ...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]),
    ...     np.array([[1.01, 1.66, 3.5]]),
    ...     0.6
    ... )
    array([1.07173261, 1.65970737, 3.50160179])
    """"""
    y_pred = np.zeros(len(x_train))  # Initialize array of predictions
    for i, item in enumerate(x_train):
        y_pred[i] = np.dot(item, local_weight(item, x_train, y_train, tau)).item()

    return y_pred",data\repos\Python\machine_learning\local_weighted_learning\local_weighted_learning.py,local_weight_regression,253
2624,local_weighted_learning.py::load_data::130,"def load_data(
    dataset_name: str, x_name: str, y_name: str
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """"""
    Load data from seaborn and split it into x and y points
    >>> pass    # No doctests, function is for demo purposes only
    """"""
    import seaborn as sns

    data = sns.load_dataset(dataset_name)
    x_data = np.array(data[x_name])
    y_data = np.array(data[y_name])

    one = np.ones(len(y_data))

    # pairing elements of one and x_data
    x_train = np.column_stack((one, x_data))

    return x_train, x_data, y_data",data\repos\Python\machine_learning\local_weighted_learning\local_weighted_learning.py,load_data,144
2625,local_weighted_learning.py::plot_preds::151,"def plot_preds(
    x_train: np.ndarray,
    preds: np.ndarray,
    x_data: np.ndarray,
    y_data: np.ndarray,
    x_name: str,
    y_name: str,
) -> None:
    """"""
    Plot predictions and display the graph
    >>> pass    # No doctests, function is for demo purposes only
    """"""
    x_train_sorted = np.sort(x_train, axis=0)
    plt.scatter(x_data, y_data, color=""blue"")
    plt.plot(
        x_train_sorted[:, 1],
        preds[x_train[:, 1].argsort(0)],
        color=""yellow"",
        linewidth=5,
    )
    plt.title(""Local Weighted Regression"")
    plt.xlabel(x_name)
    plt.ylabel(y_name)
    plt.show()",data\repos\Python\machine_learning\local_weighted_learning\local_weighted_learning.py,plot_preds,165
2626,conjugate_gradient.py::conjugate_gradient::71,"def conjugate_gradient(
    spd_matrix: np.ndarray,
    load_vector: np.ndarray,
    max_iterations: int = 1000,
    tol: float = 1e-8,
) -> Any:
    """"""
    Returns solution to the linear system np.dot(spd_matrix, x) = b.

    Input:
    spd_matrix is an NxN Symmetric Positive Definite (SPD) matrix.
    load_vector is an Nx1 vector.

    Output:
    x is an Nx1 vector that is the solution vector.

    >>> import numpy as np
    >>> spd_matrix = np.array([
    ... [8.73256573, -5.02034289, -2.68709226],
    ... [-5.02034289,  3.78188322,  0.91980451],
    ... [-2.68709226,  0.91980451,  1.94746467]])
    >>> b = np.array([
    ... [-5.80872761],
    ... [ 3.23807431],
    ... [ 1.95381422]])
    >>> conjugate_gradient(spd_matrix, b)
    array([[-0.63114139],
           [-0.01561498],
           [ 0.13979294]])
    """"""
    # Ensure proper dimensionality.
    assert np.shape(spd_matrix)[0] == np.shape(spd_matrix)[1]
    assert np.shape(load_vector)[0] == np.shape(spd_matrix)[0]
    assert _is_matrix_spd(spd_matrix)

    # Initialize solution guess, residual, search direction.
    x0 = np.zeros((np.shape(load_vector)[0], 1))
    r0 = np.copy(load_vector)
    p0 = np.copy(r0)

    # Set initial errors in solution guess and residual.
    error_residual = 1e9
    error_x_solution = 1e9
    error = 1e9

    # Set iteration counter to threshold number of iterations.
    iterations = 0

    while error > tol:
        # Save this value so we only calculate the matrix-vector product once.
        w = np.dot(spd_matrix, p0)

        # The main algorithm.

        # Update search direction magnitude.
        alpha = np.dot(r0.T, r0) / np.dot(p0.T, w)
        # Update solution guess.
        x = x0 + alpha * p0
        # Calculate new residual.
        r = r0 - alpha * w
        # Calculate new Krylov subspace scale.
        beta = np.dot(r.T, r) / np.dot(r0.T, r0)
        # Calculate new A conjuage search direction.
        p = r + beta * p0

        # Calculate errors.
        error_residual = np.linalg.norm(r - r0)
        error_x_solution = np.linalg.norm(x - x0)
        error = np.maximum(error_residual, error_x_solution)

        # Update variables.
        x0 = np.copy(x)
        r0 = np.copy(r)
        p0 = np.copy(p)

        # Update number of iterations.
        iterations += 1
        if iterations > max_iterations:
            break

    return x",data\repos\Python\linear_algebra\src\conjugate_gradient.py,conjugate_gradient,679
2627,conjugate_gradient.py::test_conjugate_gradient::154,"def test_conjugate_gradient() -> None:
    """"""
    >>> test_conjugate_gradient()  # self running tests
    """"""
    # Create linear system with SPD matrix and known solution x_true.
    dimension = 3
    spd_matrix = _create_spd_matrix(dimension)
    rng = np.random.default_rng()
    x_true = rng.normal(size=(dimension, 1))
    b = np.dot(spd_matrix, x_true)

    # Numpy solution.
    x_numpy = np.linalg.solve(spd_matrix, b)

    # Our implementation.
    x_conjugate_gradient = conjugate_gradient(spd_matrix, b)

    # Ensure both solutions are close to x_true (and therefore one another).
    assert np.linalg.norm(x_numpy - x_true) <= 1e-6
    assert np.linalg.norm(x_conjugate_gradient - x_true) <= 1e-6",data\repos\Python\linear_algebra\src\conjugate_gradient.py,test_conjugate_gradient,187
2628,gaussian_elimination_pivoting.py::solve_linear_system::4,"def solve_linear_system(matrix: np.ndarray) -> np.ndarray:
    """"""
    Solve a linear system of equations using Gaussian elimination with partial pivoting

    Args:
      - `matrix`: Coefficient matrix with the last column representing the constants.

    Returns:
      - Solution vector.

    Raises:
      - ``ValueError``: If the matrix is not correct (i.e., singular).

    https://courses.engr.illinois.edu/cs357/su2013/lect.htm Lecture 7

    Example:

    >>> A = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]], dtype=float)
    >>> B = np.array([8, -11, -3], dtype=float)
    >>> solution = solve_linear_system(np.column_stack((A, B)))
    >>> np.allclose(solution, np.array([2., 3., -1.]))
    True
    >>> solve_linear_system(np.array([[0, 0, 0]], dtype=float))
    Traceback (most recent call last):
        ...
    ValueError: Matrix is not square
    >>> solve_linear_system(np.array([[0, 0, 0], [0, 0, 0]], dtype=float))
    Traceback (most recent call last):
        ...
    ValueError: Matrix is singular
    """"""
    ab = np.copy(matrix)
    num_of_rows = ab.shape[0]
    num_of_columns = ab.shape[1] - 1
    x_lst: list[float] = []

    if num_of_rows != num_of_columns:
        raise ValueError(""Matrix is not square"")

    for column_num in range(num_of_rows):
        # Lead element search
        for i in range(column_num, num_of_columns):
            if abs(ab[i][column_num]) > abs(ab[column_num][column_num]):
                ab[[column_num, i]] = ab[[i, column_num]]

        # Upper triangular matrix
        if abs(ab[column_num, column_num]) < 1e-8:
            raise ValueError(""Matrix is singular"")

        if column_num != 0:
            for i in range(column_num, num_of_rows):
                ab[i, :] -= (
                    ab[i, column_num - 1]
                    / ab[column_num - 1, column_num - 1]
                    * ab[column_num - 1, :]
                )

    # Find x vector (Back Substitution)
    for column_num in range(num_of_rows - 1, -1, -1):
        x = ab[column_num, -1] / ab[column_num, column_num]
        x_lst.insert(0, x)
        for i in range(column_num - 1, -1, -1):
            ab[i, -1] -= ab[i, column_num] * x

    # Return the solution vector
    return np.asarray(x_lst)",data\repos\Python\linear_algebra\src\gaussian_elimination_pivoting.py,solve_linear_system,602
2629,lib.py::zero_vector::196,"def zero_vector(dimension: int) -> Vector:
    """"""
    returns a zero-vector of size 'dimension'
    """"""
    # precondition
    assert isinstance(dimension, int)
    return Vector([0] * dimension)",data\repos\Python\linear_algebra\src\lib.py,zero_vector,46
2630,lib.py::unit_basis_vector::205,"def unit_basis_vector(dimension: int, pos: int) -> Vector:
    """"""
    returns a unit basis vector with a One
    at index 'pos' (indexing at 0)
    """"""
    # precondition
    assert isinstance(dimension, int)
    assert isinstance(pos, int)
    ans = [0] * dimension
    ans[pos] = 1
    return Vector(ans)",data\repos\Python\linear_algebra\src\lib.py,unit_basis_vector,84
2631,lib.py::axpy::218,"def axpy(scalar: float, x: Vector, y: Vector) -> Vector:
    """"""
    input: a 'scalar' and two vectors 'x' and 'y'
    output: a vector
    computes the axpy operation
    """"""
    # precondition
    assert isinstance(x, Vector)
    assert isinstance(y, Vector)
    assert isinstance(scalar, (int, float))
    return x * scalar + y",data\repos\Python\linear_algebra\src\lib.py,axpy,89
2632,lib.py::random_vector::231,"def random_vector(n: int, a: int, b: int) -> Vector:
    """"""
    input: size (N) of the vector.
           random range (a,b)
    output: returns a random vector of size N, with
            random integer components between 'a' and 'b'.
    """"""
    random.seed(None)
    ans = [random.randint(a, b) for _ in range(n)]
    return Vector(ans)",data\repos\Python\linear_algebra\src\lib.py,random_vector,91
2633,lib.py::square_zero_matrix::427,"def square_zero_matrix(n: int) -> Matrix:
    """"""
    returns a square zero-matrix of dimension NxN
    """"""
    ans: list[list[float]] = [[0] * n for _ in range(n)]
    return Matrix(ans, n, n)",data\repos\Python\linear_algebra\src\lib.py,square_zero_matrix,55
2634,lib.py::random_matrix::435,"def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:
    """"""
    returns a random matrix WxH with integer components
    between 'a' and 'b'
    """"""
    random.seed(None)
    matrix: list[list[float]] = [
        [random.randint(a, b) for _ in range(width)] for _ in range(height)
    ]
    return Matrix(matrix, width, height)",data\repos\Python\linear_algebra\src\lib.py,random_matrix,92
2635,lib.py::component::135,"    def component(self, i: int) -> float:
        """"""
        input: index (0-indexed)
        output: the i-th component of the vector.
        """"""
        if isinstance(i, int) and -len(self.__components) <= i < len(self.__components):
            return self.__components[i]
        else:
            raise Exception(""index out of range"")",data\repos\Python\linear_algebra\src\lib.py,component,77
2636,lib.py::change_component::145,"    def change_component(self, pos: int, value: float) -> None:
        """"""
        input: an index (pos) and a value
        changes the specified component (pos) with the
        'value'
        """"""
        # precondition
        assert -len(self.__components) <= pos < len(self.__components)
        self.__components[pos] = value",data\repos\Python\linear_algebra\src\lib.py,change_component,76
2637,lib.py::euclidean_length::155,"    def euclidean_length(self) -> float:
        """"""
        returns the euclidean length of the vector

        >>> Vector([2, 3, 4]).euclidean_length()
        5.385164807134504
        >>> Vector([1]).euclidean_length()
        1.0
        >>> Vector([0, -1, -2, -3, 4, 5, 6]).euclidean_length()
        9.539392014169456
        >>> Vector([]).euclidean_length()
        Traceback (most recent call last):
            ...
        Exception: Vector is empty
        """"""
        if len(self.__components) == 0:
            raise Exception(""Vector is empty"")
        squares = [c**2 for c in self.__components]
        return math.sqrt(sum(squares))",data\repos\Python\linear_algebra\src\lib.py,euclidean_length,172
2638,lib.py::angle::175,"    def angle(self, other: Vector, deg: bool = False) -> float:
        """"""
        find angle between two Vector (self, Vector)

        >>> Vector([3, 4, -1]).angle(Vector([2, -1, 1]))
        1.4906464636572374
        >>> Vector([3, 4, -1]).angle(Vector([2, -1, 1]), deg = True)
        85.40775111366095
        >>> Vector([3, 4, -1]).angle(Vector([2, -1]))
        Traceback (most recent call last):
            ...
        Exception: invalid operand!
        """"""
        num = self * other
        den = self.euclidean_length() * other.euclidean_length()
        if deg:
            return math.degrees(math.acos(num / den))
        else:
            return math.acos(num / den)",data\repos\Python\linear_algebra\src\lib.py,angle,190
2639,lib.py::component::365,"    def component(self, x: int, y: int) -> float:
        """"""
        returns the specified (x,y) component
        """"""
        if 0 <= x < self.__height and 0 <= y < self.__width:
            return self.__matrix[x][y]
        else:
            raise Exception(""change_component: indices out of bounds"")",data\repos\Python\linear_algebra\src\lib.py,component,74
2640,lib.py::change_component::374,"    def change_component(self, x: int, y: int, value: float) -> None:
        """"""
        changes the x-y component of this matrix
        """"""
        if 0 <= x < self.__height and 0 <= y < self.__width:
            self.__matrix[x][y] = value
        else:
            raise Exception(""change_component: indices out of bounds"")",data\repos\Python\linear_algebra\src\lib.py,change_component,81
2641,lib.py::minor::383,"    def minor(self, x: int, y: int) -> float:
        """"""
        returns the minor along (x, y)
        """"""
        if self.__height != self.__width:
            raise Exception(""Matrix is not square"")
        minor = self.__matrix[:x] + self.__matrix[x + 1 :]
        for i in range(len(minor)):
            minor[i] = minor[i][:y] + minor[i][y + 1 :]
        return Matrix(minor, self.__width - 1, self.__height - 1).determinant()",data\repos\Python\linear_algebra\src\lib.py,minor,119
2642,lib.py::cofactor::394,"    def cofactor(self, x: int, y: int) -> float:
        """"""
        returns the cofactor (signed minor) along (x, y)
        """"""
        if self.__height != self.__width:
            raise Exception(""Matrix is not square"")
        if 0 <= x < self.__height and 0 <= y < self.__width:
            return (-1) ** (x + y) * self.minor(x, y)
        else:
            raise Exception(""Indices out of bounds"")",data\repos\Python\linear_algebra\src\lib.py,cofactor,106
2643,lib.py::determinant::405,"    def determinant(self) -> float:
        """"""
        returns the determinant of an nxn matrix using Laplace expansion
        """"""
        if self.__height != self.__width:
            raise Exception(""Matrix is not square"")
        if self.__height < 1:
            raise Exception(""Matrix has no element"")
        elif self.__height == 1:
            return self.__matrix[0][0]
        elif self.__height == 2:
            return (
                self.__matrix[0][0] * self.__matrix[1][1]
                - self.__matrix[0][1] * self.__matrix[1][0]
            )
        else:
            cofactor_prods = [
                self.__matrix[0][y] * self.cofactor(0, y) for y in range(self.__width)
            ]
            return sum(cofactor_prods)",data\repos\Python\linear_algebra\src\lib.py,determinant,180
2644,polynom_for_points.py::points_to_polynomial::1,"def points_to_polynomial(coordinates: list[list[int]]) -> str:
    """"""
    coordinates is a two dimensional matrix: [[x, y], [x, y], ...]
    number of points you want to use

    >>> points_to_polynomial([])
    Traceback (most recent call last):
        ...
    ValueError: The program cannot work out a fitting polynomial.
    >>> points_to_polynomial([[]])
    Traceback (most recent call last):
        ...
    ValueError: The program cannot work out a fitting polynomial.
    >>> points_to_polynomial([[1, 0], [2, 0], [3, 0]])
    'f(x)=x^2*0.0+x^1*-0.0+x^0*0.0'
    >>> points_to_polynomial([[1, 1], [2, 1], [3, 1]])
    'f(x)=x^2*0.0+x^1*-0.0+x^0*1.0'
    >>> points_to_polynomial([[1, 3], [2, 3], [3, 3]])
    'f(x)=x^2*0.0+x^1*-0.0+x^0*3.0'
    >>> points_to_polynomial([[1, 1], [2, 2], [3, 3]])
    'f(x)=x^2*0.0+x^1*1.0+x^0*0.0'
    >>> points_to_polynomial([[1, 1], [2, 4], [3, 9]])
    'f(x)=x^2*1.0+x^1*-0.0+x^0*0.0'
    >>> points_to_polynomial([[1, 3], [2, 6], [3, 11]])
    'f(x)=x^2*1.0+x^1*-0.0+x^0*2.0'
    >>> points_to_polynomial([[1, -3], [2, -6], [3, -11]])
    'f(x)=x^2*-1.0+x^1*-0.0+x^0*-2.0'
    >>> points_to_polynomial([[1, 5], [2, 2], [3, 9]])
    'f(x)=x^2*5.0+x^1*-18.0+x^0*18.0'
    >>> points_to_polynomial([[1, 1], [1, 2], [1, 3]])
    'x=1'
    >>> points_to_polynomial([[1, 1], [2, 2], [2, 2]])
    Traceback (most recent call last):
        ...
    ValueError: The program cannot work out a fitting polynomial.
    """"""
    if len(coordinates) == 0 or not all(len(pair) == 2 for pair in coordinates):
        raise ValueError(""The program cannot work out a fitting polynomial."")

    if len({tuple(pair) for pair in coordinates}) != len(coordinates):
        raise ValueError(""The program cannot work out a fitting polynomial."")

    set_x = {x for x, _ in coordinates}
    if len(set_x) == 1:
        return f""x={coordinates[0][0]}""

    if len(set_x) != len(coordinates):
        raise ValueError(""The program cannot work out a fitting polynomial."")

    x = len(coordinates)

    # put the x and x to the power values in a matrix
    matrix: list[list[float]] = [
        [
            coordinates[count_of_line][0] ** (x - (count_in_line + 1))
            for count_in_line in range(x)
        ]
        for count_of_line in range(x)
    ]

    # put the y values into a vector
    vector: list[float] = [coordinates[count_of_line][1] for count_of_line in range(x)]

    for count in range(x):
        for number in range(x):
            if count == number:
                continue
            fraction = matrix[number][count] / matrix[count][count]
            for counting_columns, item in enumerate(matrix[count]):
                # manipulating all the values in the matrix
                matrix[number][counting_columns] -= item * fraction
            # manipulating the values in the vector
            vector[number] -= vector[count] * fraction

    # make solutions
    solution: list[str] = [
        str(vector[count] / matrix[count][count]) for count in range(x)
    ]

    solved = ""f(x)=""

    for count in range(x):
        remove_e: list[str] = solution[count].split(""E"")
        if len(remove_e) > 1:
            solution[count] = f""{remove_e[0]}*10^{remove_e[1]}""
        solved += f""x^{x - (count + 1)}*{solution[count]}""
        if count + 1 != x:
            solved += ""+""

    return solved",data\repos\Python\linear_algebra\src\polynom_for_points.py,points_to_polynomial,1042
2645,power_iteration.py::power_iteration::4,"def power_iteration(
    input_matrix: np.ndarray,
    vector: np.ndarray,
    error_tol: float = 1e-12,
    max_iterations: int = 100,
) -> tuple[float, np.ndarray]:
    """"""
    Power Iteration.
    Find the largest eigenvalue and corresponding eigenvector
    of matrix input_matrix given a random vector in the same space.
    Will work so long as vector has component of largest eigenvector.
    input_matrix must be either real or Hermitian.

    Input
    input_matrix: input matrix whose largest eigenvalue we will find.
    Numpy array. np.shape(input_matrix) == (N,N).
    vector: random initial vector in same space as matrix.
    Numpy array. np.shape(vector) == (N,) or (N,1)

    Output
    largest_eigenvalue: largest eigenvalue of the matrix input_matrix.
    Float. Scalar.
    largest_eigenvector: eigenvector corresponding to largest_eigenvalue.
    Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).

    >>> import numpy as np
    >>> input_matrix = np.array([
    ... [41,  4, 20],
    ... [ 4, 26, 30],
    ... [20, 30, 50]
    ... ])
    >>> vector = np.array([41,4,20])
    >>> power_iteration(input_matrix,vector)
    (79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))
    """"""

    # Ensure matrix is square.
    assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]
    # Ensure proper dimensionality.
    assert np.shape(input_matrix)[0] == np.shape(vector)[0]
    # Ensure inputs are either both complex or both real
    assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)
    is_complex = np.iscomplexobj(input_matrix)
    if is_complex:
        # Ensure complex input_matrix is Hermitian
        assert np.array_equal(input_matrix, input_matrix.conj().T)

    # Set convergence to False. Will define convergence when we exceed max_iterations
    # or when we have small changes from one iteration to next.

    convergence = False
    lambda_previous = 0
    iterations = 0
    error = 1e12

    while not convergence:
        # Multiple matrix by the vector.
        w = np.dot(input_matrix, vector)
        # Normalize the resulting output vector.
        vector = w / np.linalg.norm(w)
        # Find rayleigh quotient
        # (faster than usual b/c we know vector is normalized already)
        vector_h = vector.conj().T if is_complex else vector.T
        lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))

        # Check convergence.
        error = np.abs(lambda_ - lambda_previous) / lambda_
        iterations += 1

        if error <= error_tol or iterations >= max_iterations:
            convergence = True

        lambda_previous = lambda_

    if is_complex:
        lambda_ = np.real(lambda_)

    return float(lambda_), vector",data\repos\Python\linear_algebra\src\power_iteration.py,power_iteration,678
2646,power_iteration.py::test_power_iteration::84,"def test_power_iteration() -> None:
    """"""
    >>> test_power_iteration()  # self running tests
    """"""
    real_input_matrix = np.array([[41, 4, 20], [4, 26, 30], [20, 30, 50]])
    real_vector = np.array([41, 4, 20])
    complex_input_matrix = real_input_matrix.astype(np.complex128)
    imag_matrix = np.triu(1j * complex_input_matrix, 1)
    complex_input_matrix += imag_matrix
    complex_input_matrix += -1 * imag_matrix.T
    complex_vector = np.array([41, 4, 20]).astype(np.complex128)

    for problem_type in [""real"", ""complex""]:
        if problem_type == ""real"":
            input_matrix = real_input_matrix
            vector = real_vector
        elif problem_type == ""complex"":
            input_matrix = complex_input_matrix
            vector = complex_vector

        # Our implementation.
        eigen_value, eigen_vector = power_iteration(input_matrix, vector)

        # Numpy implementation.

        # Get eigenvalues and eigenvectors using built-in numpy
        # eigh (eigh used for symmetric or hermetian matrices).
        eigen_values, eigen_vectors = np.linalg.eigh(input_matrix)
        # Last eigenvalue is the maximum one.
        eigen_value_max = eigen_values[-1]
        # Last column in this matrix is eigenvector corresponding to largest eigenvalue.
        eigen_vector_max = eigen_vectors[:, -1]

        # Check our implementation and numpy gives close answers.
        assert np.abs(eigen_value - eigen_value_max) <= 1e-6
        # Take absolute values element wise of each eigenvector.
        # as they are only unique to a minus sign.
        assert np.linalg.norm(np.abs(eigen_vector) - np.abs(eigen_vector_max)) <= 1e-6",data\repos\Python\linear_algebra\src\power_iteration.py,test_power_iteration,398
2647,rank_of_matrix.py::rank_of_matrix::8,"def rank_of_matrix(matrix: list[list[int | float]]) -> int:
    """"""
    Finds the rank of a matrix.

    Args:
        `matrix`: The matrix as a list of lists.

    Returns:
        The rank of the matrix.

    Example:

    >>> matrix1 = [[1, 2, 3],
    ...            [4, 5, 6],
    ...            [7, 8, 9]]
    >>> rank_of_matrix(matrix1)
    2
    >>> matrix2 = [[1, 0, 0],
    ...            [0, 1, 0],
    ...            [0, 0, 0]]
    >>> rank_of_matrix(matrix2)
    2
    >>> matrix3 = [[1, 2, 3, 4],
    ...            [5, 6, 7, 8],
    ...            [9, 10, 11, 12]]
    >>> rank_of_matrix(matrix3)
    2
    >>> rank_of_matrix([[2,3,-1,-1],
    ...                [1,-1,-2,4],
    ...                [3,1,3,-2],
    ...                [6,3,0,-7]])
    4
    >>> rank_of_matrix([[2,1,-3,-6],
    ...                [3,-3,1,2],
    ...                [1,1,1,2]])
    3
    >>> rank_of_matrix([[2,-1,0],
    ...                [1,3,4],
    ...                [4,1,-3]])
    3
    >>> rank_of_matrix([[3,2,1],
    ...                [-6,-4,-2]])
    1
    >>> rank_of_matrix([[],[]])
    0
    >>> rank_of_matrix([[1]])
    1
    >>> rank_of_matrix([[]])
    0
    """"""

    rows = len(matrix)
    columns = len(matrix[0])
    rank = min(rows, columns)

    for row in range(rank):
        # Check if diagonal element is not zero
        if matrix[row][row] != 0:
            # Eliminate all the elements below the diagonal
            for col in range(row + 1, rows):
                multiplier = matrix[col][row] / matrix[row][row]
                for i in range(row, columns):
                    matrix[col][i] -= multiplier * matrix[row][i]
        else:
            # Find a non-zero diagonal element to swap rows
            reduce = True
            for i in range(row + 1, rows):
                if matrix[i][row] != 0:
                    matrix[row], matrix[i] = matrix[i], matrix[row]
                    reduce = False
                    break
            if reduce:
                rank -= 1
                for i in range(rows):
                    matrix[i][row] = matrix[i][rank]

            # Reduce the row pointer by one to stay on the same row
            row -= 1

    return rank",data\repos\Python\linear_algebra\src\rank_of_matrix.py,rank_of_matrix,637
2648,rayleigh_quotient.py::is_hermitian::10,"def is_hermitian(matrix: np.ndarray) -> bool:
    """"""
    Checks if a matrix is Hermitian.
    >>> import numpy as np
    >>> A = np.array([
    ... [2,    2+1j, 4],
    ... [2-1j,  3,  1j],
    ... [4,    -1j,  1]])
    >>> is_hermitian(A)
    True
    >>> A = np.array([
    ... [2,    2+1j, 4+1j],
    ... [2-1j,  3,  1j],
    ... [4,    -1j,  1]])
    >>> is_hermitian(A)
    False
    """"""
    return np.array_equal(matrix, matrix.conjugate().T)",data\repos\Python\linear_algebra\src\rayleigh_quotient.py,is_hermitian,182
2649,rayleigh_quotient.py::rayleigh_quotient::30,"def rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:
    """"""
    Returns the Rayleigh quotient of a Hermitian matrix A and
    vector v.
    >>> import numpy as np
    >>> A = np.array([
    ... [1,  2, 4],
    ... [2,  3,  -1],
    ... [4, -1,  1]
    ... ])
    >>> v = np.array([
    ... [1],
    ... [2],
    ... [3]
    ... ])
    >>> rayleigh_quotient(A, v)
    array([[3.]])
    """"""
    v_star = v.conjugate().T
    v_star_dot = v_star.dot(a)
    assert isinstance(v_star_dot, np.ndarray)
    return (v_star_dot.dot(v)) / (v_star.dot(v))",data\repos\Python\linear_algebra\src\rayleigh_quotient.py,rayleigh_quotient,185
2650,rayleigh_quotient.py::tests::54,"def tests() -> None:
    a = np.array([[2, 2 + 1j, 4], [2 - 1j, 3, 1j], [4, -1j, 1]])
    v = np.array([[1], [2], [3]])
    assert is_hermitian(a), f""{a} is not hermitian.""
    print(rayleigh_quotient(a, v))

    a = np.array([[1, 2, 4], [2, 3, -1], [4, -1, 1]])
    assert is_hermitian(a), f""{a} is not hermitian.""
    assert rayleigh_quotient(a, v) == float(3)",data\repos\Python\linear_algebra\src\rayleigh_quotient.py,tests,159
2651,schur_complement.py::schur_complement::7,"def schur_complement(
    mat_a: np.ndarray,
    mat_b: np.ndarray,
    mat_c: np.ndarray,
    pseudo_inv: np.ndarray | None = None,
) -> np.ndarray:
    """"""
    Schur complement of a symmetric matrix X given as a 2x2 block matrix
    consisting of matrices `A`, `B` and `C`.
    Matrix `A` must be quadratic and non-singular.
    In case `A` is singular, a pseudo-inverse may be provided using
    the `pseudo_inv` argument.

    | Link to Wiki: https://en.wikipedia.org/wiki/Schur_complement
    | See also Convex Optimization - Boyd and Vandenberghe, A.5.5

    >>> import numpy as np
    >>> a = np.array([[1, 2], [2, 1]])
    >>> b = np.array([[0, 3], [3, 0]])
    >>> c = np.array([[2, 1], [6, 3]])
    >>> schur_complement(a, b, c)
    array([[ 5., -5.],
           [ 0.,  6.]])
    """"""
    shape_a = np.shape(mat_a)
    shape_b = np.shape(mat_b)
    shape_c = np.shape(mat_c)

    if shape_a[0] != shape_b[0]:
        msg = (
            ""Expected the same number of rows for A and B. ""
            f""Instead found A of size {shape_a} and B of size {shape_b}""
        )
        raise ValueError(msg)

    if shape_b[1] != shape_c[1]:
        msg = (
            ""Expected the same number of columns for B and C. ""
            f""Instead found B of size {shape_b} and C of size {shape_c}""
        )
        raise ValueError(msg)

    a_inv = pseudo_inv
    if a_inv is None:
        try:
            a_inv = np.linalg.inv(mat_a)
        except np.linalg.LinAlgError:
            raise ValueError(
                ""Input matrix A is not invertible. Cannot compute Schur complement.""
            )

    return mat_c - mat_b.T @ a_inv @ mat_b",data\repos\Python\linear_algebra\src\schur_complement.py,schur_complement,464
2652,schur_complement.py::test_schur_complement::62,"    def test_schur_complement(self) -> None:
        a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])
        b = np.array([[0, 3], [3, 0], [2, 3]])
        c = np.array([[2, 1], [6, 3]])

        s = schur_complement(a, b, c)

        input_matrix = np.block([[a, b], [b.T, c]])

        det_x = np.linalg.det(input_matrix)
        det_a = np.linalg.det(a)
        det_s = np.linalg.det(s)

        assert np.is_close(det_x, det_a * det_s)",data\repos\Python\linear_algebra\src\schur_complement.py,test_schur_complement,157
2653,schur_complement.py::test_improper_a_b_dimensions::77,"    def test_improper_a_b_dimensions(self) -> None:
        a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])
        b = np.array([[0, 3], [3, 0], [2, 3]])
        c = np.array([[2, 1], [6, 3]])

        with pytest.raises(ValueError):
            schur_complement(a, b, c)",data\repos\Python\linear_algebra\src\schur_complement.py,test_improper_a_b_dimensions,102
2654,schur_complement.py::test_improper_b_c_dimensions::85,"    def test_improper_b_c_dimensions(self) -> None:
        a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])
        b = np.array([[0, 3], [3, 0], [2, 3]])
        c = np.array([[2, 1, 3], [6, 3, 5]])

        with pytest.raises(ValueError):
            schur_complement(a, b, c)",data\repos\Python\linear_algebra\src\schur_complement.py,test_improper_b_c_dimensions,108
2655,test_linear_algebra.py::test_component::25,"    def test_component(self) -> None:
        """"""
        test for method component()
        """"""
        x = Vector([1, 2, 3])
        assert x.component(0) == 1
        assert x.component(2) == 3
        _ = Vector()",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_component,59
2656,test_linear_algebra.py::test_str::34,"    def test_str(self) -> None:
        """"""
        test for method toString()
        """"""
        x = Vector([0, 0, 0, 0, 0, 1])
        assert str(x) == ""(0,0,0,0,0,1)""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_str,60
2657,test_linear_algebra.py::test_size::41,"    def test_size(self) -> None:
        """"""
        test for method size()
        """"""
        x = Vector([1, 2, 3, 4])
        assert len(x) == 4",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_size,43
2658,test_linear_algebra.py::test_euclidean_length::48,"    def test_euclidean_length(self) -> None:
        """"""
        test for method euclidean_length()
        """"""
        x = Vector([1, 2])
        y = Vector([1, 2, 3, 4, 5])
        z = Vector([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
        w = Vector([1, -1, 1, -1, 2, -3, 4, -5])
        assert x.euclidean_length() == pytest.approx(2.236, abs=1e-3)
        assert y.euclidean_length() == pytest.approx(7.416, abs=1e-3)
        assert z.euclidean_length() == 0
        assert w.euclidean_length() == pytest.approx(7.616, abs=1e-3)",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_euclidean_length,195
2659,test_linear_algebra.py::test_add::61,"    def test_add(self) -> None:
        """"""
        test for + operator
        """"""
        x = Vector([1, 2, 3])
        y = Vector([1, 1, 1])
        assert (x + y).component(0) == 2
        assert (x + y).component(1) == 3
        assert (x + y).component(2) == 4",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_add,89
2660,test_linear_algebra.py::test_sub::71,"    def test_sub(self) -> None:
        """"""
        test for - operator
        """"""
        x = Vector([1, 2, 3])
        y = Vector([1, 1, 1])
        assert (x - y).component(0) == 0
        assert (x - y).component(1) == 1
        assert (x - y).component(2) == 2",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_sub,89
2661,test_linear_algebra.py::test_mul::81,"    def test_mul(self) -> None:
        """"""
        test for * operator
        """"""
        x = Vector([1, 2, 3])
        a = Vector([2, -1, 4])  # for test of dot product
        b = Vector([1, -2, -1])
        assert str(x * 3.0) == ""(3.0,6.0,9.0)""
        assert a * b == 0",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_mul,98
2662,test_linear_algebra.py::test_zero_vector::91,"    def test_zero_vector(self) -> None:
        """"""
        test for global function zero_vector()
        """"""
        assert str(zero_vector(10)).count(""0"") == 10",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_zero_vector,38
2663,test_linear_algebra.py::test_unit_basis_vector::97,"    def test_unit_basis_vector(self) -> None:
        """"""
        test for global function unit_basis_vector()
        """"""
        assert str(unit_basis_vector(3, 1)) == ""(0,1,0)""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_unit_basis_vector,44
2664,test_linear_algebra.py::test_axpy::103,"    def test_axpy(self) -> None:
        """"""
        test for global function axpy() (operation)
        """"""
        x = Vector([1, 2, 3])
        y = Vector([1, 0, 1])
        assert str(axpy(2, x, y)) == ""(3,4,7)""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_axpy,71
2665,test_linear_algebra.py::test_copy::111,"    def test_copy(self) -> None:
        """"""
        test for method copy()
        """"""
        x = Vector([1, 0, 0, 0, 0, 0])
        y = x.copy()
        assert str(x) == str(y)",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_copy,56
2666,test_linear_algebra.py::test_change_component::119,"    def test_change_component(self) -> None:
        """"""
        test for method change_component()
        """"""
        x = Vector([1, 0, 0])
        x.change_component(0, 0)
        x.change_component(1, 1)
        assert str(x) == ""(0,1,0)""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_change_component,67
2667,test_linear_algebra.py::test_str_matrix::128,"    def test_str_matrix(self) -> None:
        """"""
        test for Matrix method str()
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        assert str(a) == ""|1,2,3|\n|2,4,5|\n|6,7,8|\n""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_str_matrix,89
2668,test_linear_algebra.py::test_minor::135,"    def test_minor(self) -> None:
        """"""
        test for Matrix method minor()
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        minors = [[-3, -14, -10], [-5, -10, -5], [-2, -1, 0]]
        for x in range(a.height()):
            for y in range(a.width()):
                assert minors[x][y] == a.minor(x, y)",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_minor,119
2669,test_linear_algebra.py::test_cofactor::145,"    def test_cofactor(self) -> None:
        """"""
        test for Matrix method cofactor()
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        cofactors = [[-3, 14, -10], [5, -10, 5], [-2, 1, 0]]
        for x in range(a.height()):
            for y in range(a.width()):
                assert cofactors[x][y] == a.cofactor(x, y)",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_cofactor,125
2670,test_linear_algebra.py::test_determinant::155,"    def test_determinant(self) -> None:
        """"""
        test for Matrix method determinant()
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        assert a.determinant() == -5",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_determinant,69
2671,test_linear_algebra.py::test__mul__matrix::162,"    def test__mul__matrix(self) -> None:
        """"""
        test for Matrix * operator
        """"""
        a = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3)
        x = Vector([1, 2, 3])
        assert str(a * x) == ""(14,32,50)""
        assert str(a * 2) == ""|2,4,6|\n|8,10,12|\n|14,16,18|\n""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test__mul__matrix,122
2672,test_linear_algebra.py::test_change_component_matrix::171,"    def test_change_component_matrix(self) -> None:
        """"""
        test for Matrix method change_component()
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        a.change_component(0, 2, 5)
        assert str(a) == ""|1,2,5|\n|2,4,5|\n|6,7,8|\n""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_change_component_matrix,104
2673,test_linear_algebra.py::test_component_matrix::179,"    def test_component_matrix(self) -> None:
        """"""
        test for Matrix method component()
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        assert a.component(2, 1) == 7, ""0.01""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_component_matrix,77
2674,test_linear_algebra.py::test__add__matrix::186,"    def test__add__matrix(self) -> None:
        """"""
        test for Matrix + operator
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        b = Matrix([[1, 2, 7], [2, 4, 5], [6, 7, 10]], 3, 3)
        assert str(a + b) == ""|2,4,10|\n|4,8,10|\n|12,14,18|\n""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test__add__matrix,130
2675,test_linear_algebra.py::test__sub__matrix::194,"    def test__sub__matrix(self) -> None:
        """"""
        test for Matrix - operator
        """"""
        a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)
        b = Matrix([[1, 2, 7], [2, 4, 5], [6, 7, 10]], 3, 3)
        assert str(a - b) == ""|0,0,-4|\n|0,0,0|\n|0,0,-2|\n""",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test__sub__matrix,130
2676,test_linear_algebra.py::test_square_zero_matrix::202,"    def test_square_zero_matrix(self) -> None:
        """"""
        test for global function square_zero_matrix()
        """"""
        assert str(square_zero_matrix(5)) == (
            ""|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n""
        )",data\repos\Python\linear_algebra\src\test_linear_algebra.py,test_square_zero_matrix,99
2677,transformations_2d.py::scaling::20,"def scaling(scaling_factor: float) -> list[list[float]]:
    """"""
    >>> scaling(5)
    [[5.0, 0.0], [0.0, 5.0]]
    """"""
    scaling_factor = float(scaling_factor)
    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]",data\repos\Python\linear_algebra\src\transformations_2d.py,scaling,78
2678,transformations_2d.py::rotation::29,"def rotation(angle: float) -> list[list[float]]:
    """"""
    >>> rotation(45)  # doctest: +NORMALIZE_WHITESPACE
    [[0.5253219888177297, -0.8509035245341184],
     [0.8509035245341184, 0.5253219888177297]]
    """"""
    c, s = cos(angle), sin(angle)
    return [[c, -s], [s, c]]",data\repos\Python\linear_algebra\src\transformations_2d.py,rotation,99
2679,transformations_2d.py::projection::39,"def projection(angle: float) -> list[list[float]]:
    """"""
    >>> projection(45)  # doctest: +NORMALIZE_WHITESPACE
    [[0.27596319193541496, 0.446998331800279],
     [0.446998331800279, 0.7240368080645851]]
    """"""
    c, s = cos(angle), sin(angle)
    cs = c * s
    return [[c * c, cs], [cs, s * s]]",data\repos\Python\linear_algebra\src\transformations_2d.py,projection,107
2680,transformations_2d.py::reflection::50,"def reflection(angle: float) -> list[list[float]]:
    """"""
    >>> reflection(45)  # doctest: +NORMALIZE_WHITESPACE
    [[0.05064397763545947, 0.893996663600558],
     [0.893996663600558, 0.7018070490682369]]
    """"""
    c, s = cos(angle), sin(angle)
    cs = c * s
    return [[2 * c - 1, 2 * cs], [2 * cs, 2 * s - 1]]",data\repos\Python\linear_algebra\src\transformations_2d.py,reflection,119
2681,test_greedy_knapsack.py::test_sorted::13,"    def test_sorted(self):
        """"""
        kp.calc_profit takes the required argument (profit, weight, max_weight)
        and returns whether the answer matches to the expected ones
        """"""
        profit = [10, 20, 30, 40, 50, 60]
        weight = [2, 4, 6, 8, 10, 12]
        max_weight = 100
        assert kp.calc_profit(profit, weight, max_weight) == 210",data\repos\Python\knapsack\tests\test_greedy_knapsack.py,test_sorted,103
2682,test_greedy_knapsack.py::test_negative_max_weight::23,"    def test_negative_max_weight(self):
        """"""
        Returns ValueError for any negative max_weight value
        :return: ValueError
        """"""
        # profit = [10, 20, 30, 40, 50, 60]
        # weight = [2, 4, 6, 8, 10, 12]
        # max_weight = -15
        pytest.raises(ValueError, match=r""max_weight must greater than zero."")",data\repos\Python\knapsack\tests\test_greedy_knapsack.py,test_negative_max_weight,95
2683,test_greedy_knapsack.py::test_negative_profit_value::33,"    def test_negative_profit_value(self):
        """"""
        Returns ValueError for any negative profit value in the list
        :return: ValueError
        """"""
        # profit = [10, -20, 30, 40, 50, 60]
        # weight = [2, 4, 6, 8, 10, 12]
        # max_weight = 15
        pytest.raises(ValueError, match=r""Weight can not be negative."")",data\repos\Python\knapsack\tests\test_greedy_knapsack.py,test_negative_profit_value,96
2684,test_greedy_knapsack.py::test_negative_weight_value::43,"    def test_negative_weight_value(self):
        """"""
        Returns ValueError for any negative weight value in the list
        :return: ValueError
        """"""
        # profit = [10, 20, 30, 40, 50, 60]
        # weight = [2, -4, 6, -8, 10, 12]
        # max_weight = 15
        pytest.raises(ValueError, match=r""Profit can not be negative."")",data\repos\Python\knapsack\tests\test_greedy_knapsack.py,test_negative_weight_value,96
2685,test_greedy_knapsack.py::test_null_max_weight::53,"    def test_null_max_weight(self):
        """"""
        Returns ValueError for any zero max_weight value
        :return: ValueError
        """"""
        # profit = [10, 20, 30, 40, 50, 60]
        # weight = [2, 4, 6, 8, 10, 12]
        # max_weight = null
        pytest.raises(ValueError, match=r""max_weight must greater than zero."")",data\repos\Python\knapsack\tests\test_greedy_knapsack.py,test_null_max_weight,94
2686,test_greedy_knapsack.py::test_unequal_list_length::63,"    def test_unequal_list_length(self):
        """"""
        Returns IndexError if length of lists (profit and weight) are unequal.
        :return: IndexError
        """"""
        # profit = [10, 20, 30, 40, 50]
        # weight = [2, 4, 6, 8, 10, 12]
        # max_weight = 100
        pytest.raises(
            IndexError, match=r""The length of profit and weight must be same.""
        )",data\repos\Python\knapsack\tests\test_greedy_knapsack.py,test_unequal_list_length,105
2687,test_knapsack.py::test_base_case::16,"    def test_base_case(self):
        """"""
        test for the base case
        """"""
        cap = 0
        val = [0]
        w = [0]
        c = len(val)
        assert k.knapsack(cap, w, val, c) == 0

        val = [60]
        w = [10]
        c = len(val)
        assert k.knapsack(cap, w, val, c) == 0",data\repos\Python\knapsack\tests\test_knapsack.py,test_base_case,97
2688,test_knapsack.py::test_easy_case::31,"    def test_easy_case(self):
        """"""
        test for the easy case
        """"""
        cap = 3
        val = [1, 2, 3]
        w = [3, 2, 1]
        c = len(val)
        assert k.knapsack(cap, w, val, c) == 5",data\repos\Python\knapsack\tests\test_knapsack.py,test_easy_case,72
2689,test_knapsack.py::test_knapsack::41,"    def test_knapsack(self):
        """"""
        test for the knapsack
        """"""
        cap = 50
        val = [60, 100, 120]
        w = [10, 20, 30]
        c = len(val)
        assert k.knapsack(cap, w, val, c) == 220",data\repos\Python\knapsack\tests\test_knapsack.py,test_knapsack,75
2690,test_knapsack.py::test_knapsack_repetition::51,"    def test_knapsack_repetition(self):
        """"""
        test for the knapsack repetition
        """"""
        cap = 50
        val = [60, 100, 120]
        w = [10, 20, 30]
        c = len(val)
        assert k.knapsack(cap, w, val, c, True) == 300",data\repos\Python\knapsack\tests\test_knapsack.py,test_knapsack_repetition,80
2691,test_min_spanning_tree_kruskal.py::test_kruskal_successful_result::4,"def test_kruskal_successful_result():
    num_nodes = 9
    edges = [
        [0, 1, 4],
        [0, 7, 8],
        [1, 2, 8],
        [7, 8, 7],
        [7, 6, 1],
        [2, 8, 2],
        [8, 6, 6],
        [2, 3, 7],
        [2, 5, 4],
        [6, 5, 2],
        [3, 5, 14],
        [3, 4, 9],
        [5, 4, 10],
        [1, 7, 11],
    ]

    result = kruskal(num_nodes, edges)

    expected = [
        [7, 6, 1],
        [2, 8, 2],
        [6, 5, 2],
        [0, 1, 4],
        [2, 5, 4],
        [2, 3, 7],
        [0, 7, 8],
        [3, 4, 9],
    ]

    assert sorted(expected) == sorted(result)",data\repos\Python\graphs\tests\test_min_spanning_tree_kruskal.py,test_kruskal_successful_result,267
2692,test_min_spanning_tree_prim.py::test_prim_successful_result::6,"def test_prim_successful_result():
    num_nodes, num_edges = 9, 14  # noqa: F841
    edges = [
        [0, 1, 4],
        [0, 7, 8],
        [1, 2, 8],
        [7, 8, 7],
        [7, 6, 1],
        [2, 8, 2],
        [8, 6, 6],
        [2, 3, 7],
        [2, 5, 4],
        [6, 5, 2],
        [3, 5, 14],
        [3, 4, 9],
        [5, 4, 10],
        [1, 7, 11],
    ]

    adjacency = defaultdict(list)
    for node1, node2, cost in edges:
        adjacency[node1].append([node2, cost])
        adjacency[node2].append([node1, cost])

    result = mst(adjacency)

    expected = [
        [7, 6, 1],
        [2, 8, 2],
        [6, 5, 2],
        [0, 1, 4],
        [2, 5, 4],
        [2, 3, 7],
        [0, 7, 8],
        [3, 4, 9],
    ]

    for answer in expected:
        edge = tuple(answer[:2])
        reverse = tuple(edge[::-1])
        assert edge in result or reverse in result",data\repos\Python\graphs\tests\test_min_spanning_tree_prim.py,test_prim_successful_result,338
2693,test_send_file.py::test_send_file_running_as_expected::8,"def test_send_file_running_as_expected(file, sock):
    # ===== initialization =====
    conn = Mock()
    sock.return_value.accept.return_value = conn, Mock()
    f = iter([1, None])
    file.return_value.__enter__.return_value.read.side_effect = lambda _: next(f)

    # ===== invoke =====
    send_file(filename=""mytext.txt"", testing=True)

    # ===== ensurance =====
    sock.assert_called_once()
    sock.return_value.bind.assert_called_once()
    sock.return_value.listen.assert_called_once()
    sock.return_value.accept.assert_called_once()
    conn.recv.assert_called_once()

    file.return_value.__enter__.assert_called_once()
    file.return_value.__enter__.return_value.read.assert_called()

    conn.send.assert_called_once()
    conn.close.assert_called_once()
    sock.return_value.shutdown.assert_called_once()
    sock.return_value.close.assert_called_once()",data\repos\Python\file_transfer\tests\test_send_file.py,test_send_file_running_as_expected,182
2694,burkes.py::get_greyscale::40,"    def get_greyscale(cls, blue: int, green: int, red: int) -> float:
        """"""
        >>> Burkes.get_greyscale(3, 4, 5)
        4.185
        >>> Burkes.get_greyscale(0, 0, 0)
        0.0
        >>> Burkes.get_greyscale(255, 255, 255)
        255.0
        """"""
        """"""
        Formula from https://en.wikipedia.org/wiki/HSL_and_HSV
        cf Lightness section, and Fig 13c.
        We use the first of four possible.
        """"""
        return 0.114 * blue + 0.587 * green + 0.299 * red",data\repos\Python\digital_image_processing\dithering\burkes.py,get_greyscale,158
2695,burkes.py::process::56,"    def process(self) -> None:
        for y in range(self.height):
            for x in range(self.width):
                greyscale = int(self.get_greyscale(*self.input_img[y][x]))
                if self.threshold > greyscale + self.error_table[y][x]:
                    self.output_img[y][x] = (0, 0, 0)
                    current_error = greyscale + self.error_table[y][x]
                else:
                    self.output_img[y][x] = (255, 255, 255)
                    current_error = greyscale + self.error_table[y][x] - 255
                """"""
                Burkes error propagation (`*` is current pixel):

                                 *          8/32        4/32
                2/32    4/32    8/32    4/32    2/32
                """"""
                self.error_table[y][x + 1] += int(8 / 32 * current_error)
                self.error_table[y][x + 2] += int(4 / 32 * current_error)
                self.error_table[y + 1][x] += int(8 / 32 * current_error)
                self.error_table[y + 1][x + 1] += int(4 / 32 * current_error)
                self.error_table[y + 1][x + 2] += int(2 / 32 * current_error)
                self.error_table[y + 1][x - 1] += int(4 / 32 * current_error)
                self.error_table[y + 1][x - 2] += int(2 / 32 * current_error)",data\repos\Python\digital_image_processing\dithering\burkes.py,process,349
2696,canny.py::gen_gaussian_kernel::10,"def gen_gaussian_kernel(k_size, sigma):
    center = k_size // 2
    x, y = np.mgrid[0 - center : k_size - center, 0 - center : k_size - center]
    g = (
        1
        / (2 * np.pi * sigma)
        * np.exp(-(np.square(x) + np.square(y)) / (2 * np.square(sigma)))
    )
    return g",data\repos\Python\digital_image_processing\edge_detection\canny.py,gen_gaussian_kernel,92
2697,canny.py::suppress_non_maximum::21,"def suppress_non_maximum(image_shape, gradient_direction, sobel_grad):
    """"""
    Non-maximum suppression. If the edge strength of the current pixel is the largest
    compared to the other pixels in the mask with the same direction, the value will be
    preserved. Otherwise, the value will be suppressed.
    """"""
    destination = np.zeros(image_shape)

    for row in range(1, image_shape[0] - 1):
        for col in range(1, image_shape[1] - 1):
            direction = gradient_direction[row, col]

            if (
                0 <= direction < PI / 8
                or 15 * PI / 8 <= direction <= 2 * PI
                or 7 * PI / 8 <= direction <= 9 * PI / 8
            ):
                w = sobel_grad[row, col - 1]
                e = sobel_grad[row, col + 1]
                if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:
                    destination[row, col] = sobel_grad[row, col]

            elif (
                PI / 8 <= direction < 3 * PI / 8
                or 9 * PI / 8 <= direction < 11 * PI / 8
            ):
                sw = sobel_grad[row + 1, col - 1]
                ne = sobel_grad[row - 1, col + 1]
                if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:
                    destination[row, col] = sobel_grad[row, col]

            elif (
                3 * PI / 8 <= direction < 5 * PI / 8
                or 11 * PI / 8 <= direction < 13 * PI / 8
            ):
                n = sobel_grad[row - 1, col]
                s = sobel_grad[row + 1, col]
                if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:
                    destination[row, col] = sobel_grad[row, col]

            elif (
                5 * PI / 8 <= direction < 7 * PI / 8
                or 13 * PI / 8 <= direction < 15 * PI / 8
            ):
                nw = sobel_grad[row - 1, col - 1]
                se = sobel_grad[row + 1, col + 1]
                if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:
                    destination[row, col] = sobel_grad[row, col]

    return destination",data\repos\Python\digital_image_processing\edge_detection\canny.py,suppress_non_maximum,562
2698,canny.py::detect_high_low_threshold::73,"def detect_high_low_threshold(
    image_shape, destination, threshold_low, threshold_high, weak, strong
):
    """"""
    High-Low threshold detection. If an edge pixel's gradient value is higher
    than the high threshold value, it is marked as a strong edge pixel. If an
    edge pixel's gradient value is smaller than the high threshold value and
    larger than the low threshold value, it is marked as a weak edge pixel. If
    an edge pixel's value is smaller than the low threshold value, it will be
    suppressed.
    """"""
    for row in range(1, image_shape[0] - 1):
        for col in range(1, image_shape[1] - 1):
            if destination[row, col] >= threshold_high:
                destination[row, col] = strong
            elif destination[row, col] <= threshold_low:
                destination[row, col] = 0
            else:
                destination[row, col] = weak",data\repos\Python\digital_image_processing\edge_detection\canny.py,detect_high_low_threshold,204
2699,canny.py::track_edge::94,"def track_edge(image_shape, destination, weak, strong):
    """"""
    Edge tracking. Usually a weak edge pixel caused from true edges will be connected
    to a strong edge pixel while noise responses are unconnected. As long as there is
    one strong edge pixel that is involved in its 8-connected neighborhood, that weak
    edge point can be identified as one that should be preserved.
    """"""
    for row in range(1, image_shape[0]):
        for col in range(1, image_shape[1]):
            if destination[row, col] == weak:
                if 255 in (
                    destination[row, col + 1],
                    destination[row, col - 1],
                    destination[row - 1, col],
                    destination[row + 1, col],
                    destination[row - 1, col - 1],
                    destination[row + 1, col - 1],
                    destination[row - 1, col + 1],
                    destination[row + 1, col + 1],
                ):
                    destination[row, col] = strong
                else:
                    destination[row, col] = 0",data\repos\Python\digital_image_processing\edge_detection\canny.py,track_edge,232
2700,canny.py::canny::119,"def canny(image, threshold_low=15, threshold_high=30, weak=128, strong=255):
    # gaussian_filter
    gaussian_out = img_convolve(image, gen_gaussian_kernel(9, sigma=1.4))
    # get the gradient and degree by sobel_filter
    sobel_grad, sobel_theta = sobel_filter(gaussian_out)
    gradient_direction = PI + np.rad2deg(sobel_theta)

    destination = suppress_non_maximum(image.shape, gradient_direction, sobel_grad)

    detect_high_low_threshold(
        image.shape, destination, threshold_low, threshold_high, weak, strong
    )

    track_edge(image.shape, destination, weak, strong)

    return destination",data\repos\Python\digital_image_processing\edge_detection\canny.py,canny,147
2701,bilateral_filter.py::vec_gaussian::20,"def vec_gaussian(img: np.ndarray, variance: float) -> np.ndarray:
    # For applying gaussian function for each element in matrix.
    sigma = math.sqrt(variance)
    cons = 1 / (sigma * math.sqrt(2 * math.pi))
    return cons * np.exp(-((img / sigma) ** 2) * 0.5)",data\repos\Python\digital_image_processing\filters\bilateral_filter.py,vec_gaussian,76
2702,bilateral_filter.py::get_slice::27,"def get_slice(img: np.ndarray, x: int, y: int, kernel_size: int) -> np.ndarray:
    half = kernel_size // 2
    return img[x - half : x + half + 1, y - half : y + half + 1]",data\repos\Python\digital_image_processing\filters\bilateral_filter.py,get_slice,59
2703,bilateral_filter.py::get_gauss_kernel::32,"def get_gauss_kernel(kernel_size: int, spatial_variance: float) -> np.ndarray:
    # Creates a gaussian kernel of given dimension.
    arr = np.zeros((kernel_size, kernel_size))
    for i in range(kernel_size):
        for j in range(kernel_size):
            arr[i, j] = math.sqrt(
                abs(i - kernel_size // 2) ** 2 + abs(j - kernel_size // 2) ** 2
            )
    return vec_gaussian(arr, spatial_variance)",data\repos\Python\digital_image_processing\filters\bilateral_filter.py,get_gauss_kernel,106
2704,bilateral_filter.py::bilateral_filter::43,"def bilateral_filter(
    img: np.ndarray,
    spatial_variance: float,
    intensity_variance: float,
    kernel_size: int,
) -> np.ndarray:
    img2 = np.zeros(img.shape)
    gauss_ker = get_gauss_kernel(kernel_size, spatial_variance)
    size_x, size_y = img.shape
    for i in range(kernel_size // 2, size_x - kernel_size // 2):
        for j in range(kernel_size // 2, size_y - kernel_size // 2):
            img_s = get_slice(img, i, j, kernel_size)
            img_i = img_s - img_s[kernel_size // 2, kernel_size // 2]
            img_ig = vec_gaussian(img_i, intensity_variance)
            weights = np.multiply(gauss_ker, img_ig)
            vals = np.multiply(img_s, weights)
            val = np.sum(vals) / np.sum(weights)
            img2[i, j] = val
    return img2",data\repos\Python\digital_image_processing\filters\bilateral_filter.py,bilateral_filter,208
2705,bilateral_filter.py::parse_args::64,"def parse_args(args: list) -> tuple:
    filename = args[1] if args[1:] else ""../image_data/lena.jpg""
    spatial_variance = float(args[2]) if args[2:] else 1.0
    intensity_variance = float(args[3]) if args[3:] else 1.0
    if args[4:]:
        kernel_size = int(args[4])
        kernel_size = kernel_size + abs(kernel_size % 2 - 1)
    else:
        kernel_size = 5
    return filename, spatial_variance, intensity_variance, kernel_size",data\repos\Python\digital_image_processing\filters\bilateral_filter.py,parse_args,124
2706,convolve.py::im2col::8,"def im2col(image, block_size):
    rows, cols = image.shape
    dst_height = cols - block_size[1] + 1
    dst_width = rows - block_size[0] + 1
    image_array = zeros((dst_height * dst_width, block_size[1] * block_size[0]))
    row = 0
    for i in range(dst_height):
        for j in range(dst_width):
            window = ravel(image[i : i + block_size[0], j : j + block_size[1]])
            image_array[row, :] = window
            row += 1

    return image_array",data\repos\Python\digital_image_processing\filters\convolve.py,im2col,135
2707,convolve.py::img_convolve::23,"def img_convolve(image, filter_kernel):
    height, width = image.shape[0], image.shape[1]
    k_size = filter_kernel.shape[0]
    pad_size = k_size // 2
    # Pads image with the edge values of array.
    image_tmp = pad(image, pad_size, mode=""edge"")

    # im2col, turn the k_size*k_size pixels into a row and np.vstack all rows
    image_array = im2col(image_tmp, (k_size, k_size))

    #  turn the kernel into shape(k*k, 1)
    kernel_array = ravel(filter_kernel)
    # reshape and get the dst image
    dst = dot(image_array, kernel_array).reshape(height, width)
    return dst",data\repos\Python\digital_image_processing\filters\convolve.py,img_convolve,159
2708,gabor_filter.py::gabor_filter_kernel::7,"def gabor_filter_kernel(
    ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int
) -> np.ndarray:
    """"""
    :param ksize:   The kernelsize of the convolutional filter (ksize x ksize)
    :param sigma:   standard deviation of the gaussian bell curve
    :param theta:   The orientation of the normal to the parallel stripes
                    of Gabor function.
    :param lambd:   Wavelength of the sinusoidal component.
    :param gamma:   The spatial aspect ratio and specifies the ellipticity
                    of the support of Gabor function.
    :param psi:     The phase offset of the sinusoidal function.

    >>> gabor_filter_kernel(3, 8, 0, 10, 0, 0).tolist()
    [[0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, \
0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046]]

    """"""

    # prepare kernel
    # the kernel size have to be odd
    if (ksize % 2) == 0:
        ksize = ksize + 1
    gabor = np.zeros((ksize, ksize), dtype=np.float32)

    # each value
    for y in range(ksize):
        for x in range(ksize):
            # distance from center
            px = x - ksize // 2
            py = y - ksize // 2

            # degree to radiant
            _theta = theta / 180 * np.pi
            cos_theta = np.cos(_theta)
            sin_theta = np.sin(_theta)

            # get kernel x
            _x = cos_theta * px + sin_theta * py

            # get kernel y
            _y = -sin_theta * px + cos_theta * py

            # fill kernel
            gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(
                2 * np.pi * _x / lambd + psi
            )

    return gabor",data\repos\Python\digital_image_processing\filters\gabor_filter.py,gabor_filter_kernel,502
2709,gaussian_filter.py::gen_gaussian_kernel::11,"def gen_gaussian_kernel(k_size, sigma):
    center = k_size // 2
    x, y = mgrid[0 - center : k_size - center, 0 - center : k_size - center]
    g = 1 / (2 * pi * sigma) * exp(-(square(x) + square(y)) / (2 * square(sigma)))
    return g",data\repos\Python\digital_image_processing\filters\gaussian_filter.py,gen_gaussian_kernel,79
2710,gaussian_filter.py::gaussian_filter::18,"def gaussian_filter(image, k_size, sigma):
    height, width = image.shape[0], image.shape[1]
    # dst image height and width
    dst_height = height - k_size + 1
    dst_width = width - k_size + 1

    # im2col, turn the k_size*k_size pixels into a row and np.vstack all rows
    image_array = zeros((dst_height * dst_width, k_size * k_size))
    for row, (i, j) in enumerate(product(range(dst_height), range(dst_width))):
        window = ravel(image[i : i + k_size, j : j + k_size])
        image_array[row, :] = window

    #  turn the kernel into shape(k*k, 1)
    gaussian_kernel = gen_gaussian_kernel(k_size, sigma)
    filter_array = ravel(gaussian_kernel)

    # reshape and get the dst image
    dst = dot(image_array, filter_array).reshape(dst_height, dst_width).astype(uint8)

    return dst",data\repos\Python\digital_image_processing\filters\gaussian_filter.py,gaussian_filter,216
2711,laplacian_filter.py::my_laplacian::20,"def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:
    """"""
    :param src: the source image, which should be a grayscale or color image.
    :param ksize: the size of the kernel used to compute the Laplacian filter,
                  which can be 1, 3, 5, or 7.

    >>> my_laplacian(src=np.array([]), ksize=0)
    Traceback (most recent call last):
        ...
    ValueError: ksize must be in (1, 3, 5, 7)
    """"""
    kernels = {
        1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),
        3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),
        5: np.array(
            [
                [0, 0, -1, 0, 0],
                [0, -1, -2, -1, 0],
                [-1, -2, 16, -2, -1],
                [0, -1, -2, -1, 0],
                [0, 0, -1, 0, 0],
            ]
        ),
        7: np.array(
            [
                [0, 0, 0, -1, 0, 0, 0],
                [0, 0, -2, -3, -2, 0, 0],
                [0, -2, -7, -10, -7, -2, 0],
                [-1, -3, -10, 68, -10, -3, -1],
                [0, -2, -7, -10, -7, -2, 0],
                [0, 0, -2, -3, -2, 0, 0],
                [0, 0, 0, -1, 0, 0, 0],
            ]
        ),
    }
    if ksize not in kernels:
        msg = f""ksize must be in {tuple(kernels)}""
        raise ValueError(msg)

    # Apply the Laplacian kernel using convolution
    return filter2D(
        src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)
    )",data\repos\Python\digital_image_processing\filters\laplacian_filter.py,my_laplacian,535
2712,local_binary_pattern.py::get_neighbors_pixel::5,"def get_neighbors_pixel(
    image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int
) -> int:
    """"""
    Comparing local neighborhood pixel value with threshold value of centre pixel.
    Exception is required when neighborhood value of a center pixel value is null.
    i.e. values present at boundaries.

    :param image: The image we're working with
    :param x_coordinate: x-coordinate of the  pixel
    :param y_coordinate: The y coordinate of the pixel
    :param center: center pixel value
    :return: The value of the pixel is being returned.
    """"""

    try:
        return int(image[x_coordinate][y_coordinate] >= center)
    except (IndexError, TypeError):
        return 0",data\repos\Python\digital_image_processing\filters\local_binary_pattern.py,get_neighbors_pixel,159
2713,local_binary_pattern.py::local_binary_value::26,"def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:
    """"""
    It takes an image, an x and y coordinate, and returns the
    decimal value of the local binary patternof the pixel
    at that coordinate

    :param image: the image to be processed
    :param x_coordinate: x coordinate of the pixel
    :param y_coordinate: the y coordinate of the pixel
    :return: The decimal value of the binary value of the pixels
    around the center pixel.
    """"""
    center = image[x_coordinate][y_coordinate]
    powers = [1, 2, 4, 8, 16, 32, 64, 128]

    # skip get_neighbors_pixel if center is null
    if center is None:
        return 0

    # Starting from the top right, assigning value to pixels clockwise
    binary_values = [
        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),
        get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),
        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),
        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),
        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),
        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),
        get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),
        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),
    ]

    # Converting the binary value to decimal.
    return sum(
        binary_value * power for binary_value, power in zip(binary_values, powers)
    )",data\repos\Python\digital_image_processing\filters\local_binary_pattern.py,local_binary_value,377
2714,median_filter.py::median_filter::9,"def median_filter(gray_img, mask=3):
    """"""
    :param gray_img: gray image
    :param mask: mask size
    :return: image with median filter
    """"""
    # set image borders
    bd = int(mask / 2)
    # copy image size
    median_img = zeros_like(gray_img)
    for i in range(bd, gray_img.shape[0] - bd):
        for j in range(bd, gray_img.shape[1] - bd):
            # get mask according with mask
            kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])
            # calculate mask median
            median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]
            median_img[i, j] = median
    return median_img",data\repos\Python\digital_image_processing\filters\median_filter.py,median_filter,184
2715,sobel_filter.py::sobel_filter::10,"def sobel_filter(image):
    kernel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
    kernel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])

    dst_x = np.abs(img_convolve(image, kernel_x))
    dst_y = np.abs(img_convolve(image, kernel_y))
    # modify the pix within [0, 255]
    dst_x = dst_x * 255 / np.max(dst_x)
    dst_y = dst_y * 255 / np.max(dst_y)

    dst_xy = np.sqrt((np.square(dst_x)) + (np.square(dst_y)))
    dst_xy = dst_xy * 255 / np.max(dst_xy)
    dst = dst_xy.astype(np.uint8)

    theta = np.arctan2(dst_y, dst_x)
    return dst, theta",data\repos\Python\digital_image_processing\filters\sobel_filter.py,sobel_filter,206
2716,histogram_stretch.py::stretch::27,"    def stretch(self, input_image):
        self.img = cv2.imread(input_image, 0)
        self.original_image = copy.deepcopy(self.img)
        x, _, _ = plt.hist(self.img.ravel(), 256, [0, 256], label=""x"")
        self.k = np.sum(x)
        for i in range(len(x)):
            prk = x[i] / self.k
            self.sk += prk
            last = (self.L - 1) * self.sk
            if self.rem != 0:
                self.rem = int(last % last)
            last = int(last + 1 if self.rem >= 0.5 else last)
            self.last_list.append(last)
            self.number_of_rows = int(np.ma.count(self.img) / self.img[1].size)
            self.number_of_cols = self.img[1].size
        for i in range(self.number_of_cols):
            for j in range(self.number_of_rows):
                num = self.img[j][i]
                if num != self.last_list[num]:
                    self.img[j][i] = self.last_list[num]
        cv2.imwrite(""output_data/output.jpg"", self.img)",data\repos\Python\digital_image_processing\histogram_equalization\histogram_stretch.py,stretch,245
2717,histogram_stretch.py::show_image::52,"    def show_image(self):
        cv2.imshow(""Output-Image"", self.img)
        cv2.imshow(""Input-Image"", self.original_image)
        cv2.waitKey(5000)
        cv2.destroyAllWindows()",data\repos\Python\digital_image_processing\histogram_equalization\histogram_stretch.py,show_image,44
2718,dilation_operation.py::rgb_to_gray::7,"def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:
    """"""
    Return gray image from rgb image
    >>> rgb_to_gray(np.array([[[127, 255, 0]]]))
    array([[187.6453]])
    >>> rgb_to_gray(np.array([[[0, 0, 0]]]))
    array([[0.]])
    >>> rgb_to_gray(np.array([[[2, 4, 1]]]))
    array([[3.0598]])
    >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))
    array([[159.0524,  90.0635, 117.6989]])
    """"""
    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]
    return 0.2989 * r + 0.5870 * g + 0.1140 * b",data\repos\Python\digital_image_processing\morphological_operations\dilation_operation.py,rgb_to_gray,208
2719,dilation_operation.py::gray_to_binary::23,"def gray_to_binary(gray: np.ndarray) -> np.ndarray:
    """"""
    Return binary image from gray image
    >>> gray_to_binary(np.array([[127, 255, 0]]))
    array([[False,  True, False]])
    >>> gray_to_binary(np.array([[0]]))
    array([[False]])
    >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))
    array([[False, False, False]])
    >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))
    array([[False,  True, False],
           [False,  True, False],
           [False,  True, False]])
    """"""
    return (gray > 127) & (gray <= 255)",data\repos\Python\digital_image_processing\morphological_operations\dilation_operation.py,gray_to_binary,181
2720,dilation_operation.py::dilation::40,"def dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:
    """"""
    Return dilated image
    >>> dilation(np.array([[True, False, True]]), np.array([[0, 1, 0]]))
    array([[False, False, False]])
    >>> dilation(np.array([[False, False, True]]), np.array([[1, 0, 1]]))
    array([[False, False, False]])
    """"""
    output = np.zeros_like(image)
    image_padded = np.zeros(
        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)
    )

    # Copy image to padded image
    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image

    # Iterate over image & apply kernel
    for x in range(image.shape[1]):
        for y in range(image.shape[0]):
            summation = (
                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]
            ).sum()
            output[y, x] = int(summation > 0)
    return output",data\repos\Python\digital_image_processing\morphological_operations\dilation_operation.py,dilation,264
2721,erosion_operation.py::rgb_to_gray::7,"def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:
    """"""
    Return gray image from rgb image

    >>> rgb_to_gray(np.array([[[127, 255, 0]]]))
    array([[187.6453]])
    >>> rgb_to_gray(np.array([[[0, 0, 0]]]))
    array([[0.]])
    >>> rgb_to_gray(np.array([[[2, 4, 1]]]))
    array([[3.0598]])
    >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))
    array([[159.0524,  90.0635, 117.6989]])
    """"""
    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]
    return 0.2989 * r + 0.5870 * g + 0.1140 * b",data\repos\Python\digital_image_processing\morphological_operations\erosion_operation.py,rgb_to_gray,208
2722,erosion_operation.py::gray_to_binary::24,"def gray_to_binary(gray: np.ndarray) -> np.ndarray:
    """"""
    Return binary image from gray image

    >>> gray_to_binary(np.array([[127, 255, 0]]))
    array([[False,  True, False]])
    >>> gray_to_binary(np.array([[0]]))
    array([[False]])
    >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))
    array([[False, False, False]])
    >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))
    array([[False,  True, False],
           [False,  True, False],
           [False,  True, False]])
    """"""
    return (gray > 127) & (gray <= 255)",data\repos\Python\digital_image_processing\morphological_operations\erosion_operation.py,gray_to_binary,181
2723,erosion_operation.py::erosion::42,"def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:
    """"""
    Return eroded image

    >>> erosion(np.array([[True, True, False]]), np.array([[0, 1, 0]]))
    array([[False, False, False]])
    >>> erosion(np.array([[True, False, False]]), np.array([[1, 1, 0]]))
    array([[False, False, False]])
    """"""
    output = np.zeros_like(image)
    image_padded = np.zeros(
        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)
    )

    # Copy image to padded image
    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image

    # Iterate over image & apply kernel
    for x in range(image.shape[1]):
        for y in range(image.shape[0]):
            summation = (
                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]
            ).sum()
            output[y, x] = int(summation == 5)
    return output",data\repos\Python\digital_image_processing\morphological_operations\erosion_operation.py,erosion,264
2724,resize.py::process::30,"    def process(self):
        for i in range(self.dst_h):
            for j in range(self.dst_w):
                self.output[i][j] = self.img[self.get_y(i)][self.get_x(j)]",data\repos\Python\digital_image_processing\resize\resize.py,process,43
2725,resize.py::get_x::35,"    def get_x(self, x: int) -> int:
        """"""
        Get parent X coordinate for destination X
        :param x: Destination X coordinate
        :return: Parent X coordinate based on `x ratio`
        >>> nn = NearestNeighbour(imread(""digital_image_processing/image_data/lena.jpg"",
        ...                              1), 100, 100)
        >>> nn.ratio_x = 0.5
        >>> nn.get_x(4)
        2
        """"""
        return int(self.ratio_x * x)",data\repos\Python\digital_image_processing\resize\resize.py,get_x,114
2726,resize.py::get_y::48,"    def get_y(self, y: int) -> int:
        """"""
        Get parent Y coordinate for destination Y
        :param y: Destination X coordinate
        :return: Parent X coordinate based on `y ratio`
        >>> nn = NearestNeighbour(imread(""digital_image_processing/image_data/lena.jpg"",
        ...                              1), 100, 100)
        >>> nn.ratio_y = 0.5
        >>> nn.get_y(4)
        2
        """"""
        return int(self.ratio_y * y)",data\repos\Python\digital_image_processing\resize\resize.py,get_y,114
2727,rotation.py::get_rotation::8,"def get_rotation(
    img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int
) -> np.ndarray:
    """"""
    Get image rotation
    :param img: np.ndarray
    :param pt1: 3x2 list
    :param pt2: 3x2 list
    :param rows: columns image shape
    :param cols: rows image shape
    :return: np.ndarray
    """"""
    matrix = cv2.getAffineTransform(pt1, pt2)
    return cv2.warpAffine(img, matrix, (rows, cols))",data\repos\Python\digital_image_processing\rotation\rotation.py,get_rotation,131
2728,equilibrium_index_in_array.py::equilibrium_index::23,"def equilibrium_index(arr: list[int]) -> int:
    """"""
    Find the equilibrium index of an array.

    Args:
        arr (list[int]): The input array of integers.

    Returns:
        int: The equilibrium index or -1 if no equilibrium index exists.

    Examples:
        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])
        3
        >>> equilibrium_index([1, 2, 3, 4, 5])
        -1
        >>> equilibrium_index([1, 1, 1, 1, 1])
        2
        >>> equilibrium_index([2, 4, 6, 8, 10, 3])
        -1
    """"""
    total_sum = sum(arr)
    left_sum = 0

    for i, value in enumerate(arr):
        total_sum -= value
        if left_sum == total_sum:
            return i
        left_sum += value

    return -1",data\repos\Python\data_structures\arrays\equilibrium_index_in_array.py,equilibrium_index,212
2729,find_triplets_with_0_sum.py::find_triplets_with_0_sum::4,"def find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:
    """"""
    Given a list of integers, return elements a, b, c such that a + b + c = 0.
    Args:
        nums: list of integers
    Returns:
        list of lists of integers where sum(each_list) == 0
    Examples:
        >>> find_triplets_with_0_sum([-1, 0, 1, 2, -1, -4])
        [[-1, -1, 2], [-1, 0, 1]]
        >>> find_triplets_with_0_sum([])
        []
        >>> find_triplets_with_0_sum([0, 0, 0])
        [[0, 0, 0]]
        >>> find_triplets_with_0_sum([1, 2, 3, 0, -1, -2, -3])
        [[-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]
    """"""
    return [
        list(x)
        for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})
    ]",data\repos\Python\data_structures\arrays\find_triplets_with_0_sum.py,find_triplets_with_0_sum,274
2730,find_triplets_with_0_sum.py::find_triplets_with_0_sum_hashing::27,"def find_triplets_with_0_sum_hashing(arr: list[int]) -> list[list[int]]:
    """"""
    Function for finding the triplets with a given sum in the array using hashing.

    Given a list of integers, return elements a, b, c such that a + b + c = 0.

    Args:
        nums: list of integers
    Returns:
        list of lists of integers where sum(each_list) == 0
    Examples:
        >>> find_triplets_with_0_sum_hashing([-1, 0, 1, 2, -1, -4])
        [[-1, 0, 1], [-1, -1, 2]]
        >>> find_triplets_with_0_sum_hashing([])
        []
        >>> find_triplets_with_0_sum_hashing([0, 0, 0])
        [[0, 0, 0]]
        >>> find_triplets_with_0_sum_hashing([1, 2, 3, 0, -1, -2, -3])
        [[-1, 0, 1], [-3, 1, 2], [-2, 0, 2], [-2, -1, 3], [-3, 0, 3]]

    Time complexity: O(N^2)
    Auxiliary Space: O(N)

    """"""
    target_sum = 0

    # Initialize the final output array with blank.
    output_arr = []

    # Set the initial element as arr[i].
    for index, item in enumerate(arr[:-2]):
        # to store second elements that can complement the final sum.
        set_initialize = set()

        # current sum needed for reaching the target sum
        current_sum = target_sum - item

        # Traverse the subarray arr[i+1:].
        for other_item in arr[index + 1 :]:
            # required value for the second element
            required_value = current_sum - other_item

            # Verify if the desired value exists in the set.
            if required_value in set_initialize:
                # finding triplet elements combination.
                combination_array = sorted([item, other_item, required_value])
                if combination_array not in output_arr:
                    output_arr.append(combination_array)

            # Include the current element in the set
            # for subsequent complement verification.
            set_initialize.add(other_item)

    # Return all the triplet combinations.
    return output_arr",data\repos\Python\data_structures\arrays\find_triplets_with_0_sum.py,find_triplets_with_0_sum_hashing,504
2731,index_2d_array_in_1d.py::index_2d_array_in_1d::62,"def index_2d_array_in_1d(array: list[list[int]], index: int) -> int:
    """"""
    Retrieves the value of the one-dimensional index from a two-dimensional array.

    Args:
        array: A 2D array of integers where all rows are the same size and all
               columns are the same size.
        index: A 1D index.

    Returns:
        int: The 0-indexed value of the 1D index in the array.

    Examples:
    >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 5)
    5
    >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], -1)
    Traceback (most recent call last):
        ...
    ValueError: index out of range
    >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 12)
    Traceback (most recent call last):
        ...
    ValueError: index out of range
    >>> index_2d_array_in_1d([[]], 0)
    Traceback (most recent call last):
        ...
    ValueError: no items in array
    """"""
    rows = len(array)
    cols = len(array[0])

    if rows == 0 or cols == 0:
        raise ValueError(""no items in array"")

    if index < 0 or index >= rows * cols:
        raise ValueError(""index out of range"")

    return array[index // cols][index % cols]",data\repos\Python\data_structures\arrays\index_2d_array_in_1d.py,index_2d_array_in_1d,402
2732,kth_largest_element.py::partition::8,"def partition(arr: list[int], low: int, high: int) -> int:
    """"""
    Partitions list based on the pivot element.

    This function rearranges the elements in the input list 'elements' such that
    all elements greater than or equal to the chosen pivot are on the right side
    of the pivot, and all elements smaller than the pivot are on the left side.

    Args:
        arr: The list to be partitioned
        low: The lower index of the list
        high: The higher index of the list

    Returns:
        int: The index of pivot element after partitioning

        Examples:
        >>> partition([3, 1, 4, 5, 9, 2, 6, 5, 3, 5], 0, 9)
        4
        >>> partition([7, 1, 4, 5, 9, 2, 6, 5, 8], 0, 8)
        1
        >>> partition(['apple', 'cherry', 'date', 'banana'], 0, 3)
        2
        >>> partition([3.1, 1.2, 5.6, 4.7], 0, 3)
        1
    """"""
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] >= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1",data\repos\Python\data_structures\arrays\kth_largest_element.py,partition,357
2733,kth_largest_element.py::kth_largest_element::44,"def kth_largest_element(arr: list[int], position: int) -> int:
    """"""
    Finds the kth largest element in a list.
    Should deliver similar results to:
    ```python
    def kth_largest_element(arr, position):
        return sorted(arr)[-position]
    ```

    Args:
        nums: The list of numbers.
        k: The position of the desired kth largest element.

    Returns:
        int: The kth largest element.

    Examples:
        >>> kth_largest_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3)
        5
        >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], 1)
        9
        >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], -2)
        Traceback (most recent call last):
        ...
        ValueError: Invalid value of 'position'
        >>> kth_largest_element([9, 1, 3, 6, 7, 9, 8, 4, 2, 4, 9], 110)
        Traceback (most recent call last):
        ...
        ValueError: Invalid value of 'position'
        >>> kth_largest_element([1, 2, 4, 3, 5, 9, 7, 6, 5, 9, 3], 0)
        Traceback (most recent call last):
        ...
        ValueError: Invalid value of 'position'
        >>> kth_largest_element(['apple', 'cherry', 'date', 'banana'], 2)
        'cherry'
        >>> kth_largest_element([3.1, 1.2, 5.6, 4.7,7.9,5,0], 2)
        5.6
        >>> kth_largest_element([-2, -5, -4, -1], 1)
        -1
        >>> kth_largest_element([], 1)
        -1
        >>> kth_largest_element([3.1, 1.2, 5.6, 4.7, 7.9, 5, 0], 1.5)
        Traceback (most recent call last):
        ...
        ValueError: The position should be an integer
        >>> kth_largest_element((4, 6, 1, 2), 4)
        Traceback (most recent call last):
        ...
        TypeError: 'tuple' object does not support item assignment
    """"""
    if not arr:
        return -1
    if not isinstance(position, int):
        raise ValueError(""The position should be an integer"")
    if not 1 <= position <= len(arr):
        raise ValueError(""Invalid value of 'position'"")
    low, high = 0, len(arr) - 1
    while low <= high:
        if low > len(arr) - 1 or high < 0:
            return -1
        pivot_index = partition(arr, low, high)
        if pivot_index == position - 1:
            return arr[pivot_index]
        elif pivot_index > position - 1:
            high = pivot_index - 1
        else:
            low = pivot_index + 1
    return -1",data\repos\Python\data_structures\arrays\kth_largest_element.py,kth_largest_element,765
2734,median_two_array.py::find_median_sorted_arrays::6,"def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:
    """"""
    Find the median of two arrays.

    Args:
        nums1: The first array.
        nums2: The second array.

    Returns:
    The median of the two arrays.

    Examples:
        >>> find_median_sorted_arrays([1, 3], [2])
        2.0

        >>> find_median_sorted_arrays([1, 2], [3, 4])
        2.5

        >>> find_median_sorted_arrays([0, 0], [0, 0])
        0.0

        >>> find_median_sorted_arrays([], [])
        Traceback (most recent call last):
            ...
        ValueError: Both input arrays are empty.

        >>> find_median_sorted_arrays([], [1])
        1.0

        >>> find_median_sorted_arrays([-1000], [1000])
        0.0

        >>> find_median_sorted_arrays([-1.1, -2.2], [-3.3, -4.4])
        -2.75
    """"""
    if not nums1 and not nums2:
        raise ValueError(""Both input arrays are empty."")

    # Merge the arrays into a single sorted array.
    merged = sorted(nums1 + nums2)
    total = len(merged)

    if total % 2 == 1:  # If the total number of elements is odd
        return float(merged[total // 2])  # then return the middle element

    # If the total number of elements is even, calculate
    # the average of the two middle elements as the median.
    middle1 = merged[total // 2 - 1]
    middle2 = merged[total // 2]
    return (float(middle1) + float(middle2)) / 2.0",data\repos\Python\data_structures\arrays\median_two_array.py,find_median_sorted_arrays,388
2735,monotonic_array.py::is_monotonic::2,"def is_monotonic(nums: list[int]) -> bool:
    """"""
    Check if a list is monotonic.

    >>> is_monotonic([1, 2, 2, 3])
    True
    >>> is_monotonic([6, 5, 4, 4])
    True
    >>> is_monotonic([1, 3, 2])
    False
    >>> is_monotonic([1,2,3,4,5,6,5])
    False
    >>> is_monotonic([-3,-2,-1])
    True
    >>> is_monotonic([-5,-6,-7])
    True
    >>> is_monotonic([0,0,0])
    True
    >>> is_monotonic([-100,0,100])
    True
    """"""
    return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1)) or all(
        nums[i] >= nums[i + 1] for i in range(len(nums) - 1)
    )",data\repos\Python\data_structures\arrays\monotonic_array.py,is_monotonic,225
2736,pairs_with_given_sum.py::pairs_with_sum::13,"def pairs_with_sum(arr: list, req_sum: int) -> int:
    """"""
    Return the no. of pairs with sum ""sum""
    >>> pairs_with_sum([1, 5, 7, 1], 6)
    2
    >>> pairs_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 2)
    28
    >>> pairs_with_sum([1, 7, 6, 2, 5, 4, 3, 1, 9, 8], 7)
    4
    """"""
    return len([1 for a, b in combinations(arr, 2) if a + b == req_sum])",data\repos\Python\data_structures\arrays\pairs_with_given_sum.py,pairs_with_sum,158
2737,permutations.py::permute_recursive::1,"def permute_recursive(nums: list[int]) -> list[list[int]]:
    """"""
    Return all permutations.

    >>> permute_recursive([1, 2, 3])
    [[3, 2, 1], [2, 3, 1], [1, 3, 2], [3, 1, 2], [2, 1, 3], [1, 2, 3]]
    """"""
    result: list[list[int]] = []
    if len(nums) == 0:
        return [[]]
    for _ in range(len(nums)):
        n = nums.pop(0)
        permutations = permute_recursive(nums.copy())
        for perm in permutations:
            perm.append(n)
        result.extend(permutations)
        nums.append(n)
    return result",data\repos\Python\data_structures\arrays\permutations.py,permute_recursive,164
2738,permutations.py::permute_backtrack::21,"def permute_backtrack(nums: list[int]) -> list[list[int]]:
    """"""
    Return all permutations of the given list.

    >>> permute_backtrack([1, 2, 3])
    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]
    """"""

    def backtrack(start: int) -> None:
        if start == len(nums) - 1:
            output.append(nums[:])
        else:
            for i in range(start, len(nums)):
                nums[start], nums[i] = nums[i], nums[start]
                backtrack(start + 1)
                nums[start], nums[i] = nums[i], nums[start]  # backtrack

    output: list[list[int]] = []
    backtrack(0)
    return output",data\repos\Python\data_structures\arrays\permutations.py,permute_backtrack,194
2739,permutations.py::backtrack::29,"    def backtrack(start: int) -> None:
        if start == len(nums) - 1:
            output.append(nums[:])
        else:
            for i in range(start, len(nums)):
                nums[start], nums[i] = nums[i], nums[start]
                backtrack(start + 1)
                nums[start], nums[i] = nums[i], nums[start]  # backtrack",data\repos\Python\data_structures\arrays\permutations.py,backtrack,78
2740,prefix_sum.py::get_sum::21,"    def get_sum(self, start: int, end: int) -> int:
        """"""
        The function returns the sum of array from the start to the end indexes.
        Runtime : O(1)
        Space: O(1)

        >>> PrefixSum([1,2,3]).get_sum(0, 2)
        6
        >>> PrefixSum([1,2,3]).get_sum(1, 2)
        5
        >>> PrefixSum([1,2,3]).get_sum(2, 2)
        3
        >>> PrefixSum([]).get_sum(0, 0)
        Traceback (most recent call last):
        ...
        ValueError: The array is empty.
        >>> PrefixSum([1,2,3]).get_sum(-1, 2)
        Traceback (most recent call last):
        ...
        ValueError: Invalid range specified.
        >>> PrefixSum([1,2,3]).get_sum(2, 3)
        Traceback (most recent call last):
        ...
        ValueError: Invalid range specified.
        >>> PrefixSum([1,2,3]).get_sum(2, 1)
        Traceback (most recent call last):
        ...
        ValueError: Invalid range specified.
        """"""
        if not self.prefix_sum:
            raise ValueError(""The array is empty."")

        if start < 0 or end >= len(self.prefix_sum) or start > end:
            raise ValueError(""Invalid range specified."")

        if start == 0:
            return self.prefix_sum[end]

        return self.prefix_sum[end] - self.prefix_sum[start - 1]",data\repos\Python\data_structures\arrays\prefix_sum.py,get_sum,337
2741,prefix_sum.py::contains_sum::61,"    def contains_sum(self, target_sum: int) -> bool:
        """"""
        The function returns True if array contains the target_sum,
        False otherwise.

        Runtime : O(n)
        Space: O(n)

        >>> PrefixSum([1,2,3]).contains_sum(6)
        True
        >>> PrefixSum([1,2,3]).contains_sum(5)
        True
        >>> PrefixSum([1,2,3]).contains_sum(3)
        True
        >>> PrefixSum([1,2,3]).contains_sum(4)
        False
        >>> PrefixSum([1,2,3]).contains_sum(7)
        False
        >>> PrefixSum([1,-2,3]).contains_sum(2)
        True
        """"""

        sums = {0}
        for sum_item in self.prefix_sum:
            if sum_item - target_sum in sums:
                return True

            sums.add(sum_item)

        return False",data\repos\Python\data_structures\arrays\prefix_sum.py,contains_sum,198
2742,product_sum.py::product_sum::23,"def product_sum(arr: list[int | list], depth: int) -> int:
    """"""
    Recursively calculates the product sum of an array.

    The product sum of an array is defined as the sum of its elements multiplied by
    their respective depths.  If an element is a list, its product sum is calculated
    recursively by multiplying the sum of its elements with its depth plus one.

    Args:
        arr: The array of integers and nested lists.
        depth: The current depth level.

    Returns:
        int: The product sum of the array.

    Examples:
        >>> product_sum([1, 2, 3], 1)
        6
        >>> product_sum([-1, 2, [-3, 4]], 2)
        8
        >>> product_sum([1, 2, 3], -1)
        -6
        >>> product_sum([1, 2, 3], 0)
        0
        >>> product_sum([1, 2, 3], 7)
        42
        >>> product_sum((1, 2, 3), 7)
        42
        >>> product_sum({1, 2, 3}, 7)
        42
        >>> product_sum([1, -1], 1)
        0
        >>> product_sum([1, -2], 1)
        -1
        >>> product_sum([-3.5, [1, [0.5]]], 1)
        1.5

    """"""
    total_sum = 0
    for ele in arr:
        total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele
    return total_sum * depth",data\repos\Python\data_structures\arrays\product_sum.py,product_sum,367
2743,product_sum.py::product_sum_array::67,"def product_sum_array(array: list[int | list]) -> int:
    """"""
    Calculates the product sum of an array.

    Args:
        array (List[Union[int, List]]): The array of integers and nested lists.

    Returns:
        int: The product sum of the array.

    Examples:
        >>> product_sum_array([1, 2, 3])
        6
        >>> product_sum_array([1, [2, 3]])
        11
        >>> product_sum_array([1, [2, [3, 4]]])
        47
        >>> product_sum_array([0])
        0
        >>> product_sum_array([-3.5, [1, [0.5]]])
        1.5
        >>> product_sum_array([1, -2])
        -1

    """"""
    return product_sum(array, 1)",data\repos\Python\data_structures\arrays\product_sum.py,product_sum_array,184
2744,rotate_array.py::rotate_array::1,"def rotate_array(arr: list[int], steps: int) -> list[int]:
    """"""
    Rotates a list to the right by steps positions.

    Parameters:
    arr (List[int]): The list of integers to rotate.
    steps (int): Number of positions to rotate. Can be negative for left rotation.

    Returns:
    List[int]: Rotated list.

    Examples:
    >>> rotate_array([1, 2, 3, 4, 5], 2)
    [4, 5, 1, 2, 3]
    >>> rotate_array([1, 2, 3, 4, 5], -2)
    [3, 4, 5, 1, 2]
    >>> rotate_array([1, 2, 3, 4, 5], 7)
    [4, 5, 1, 2, 3]
    >>> rotate_array([], 3)
    []
    """"""

    n = len(arr)
    if n == 0:
        return arr

    steps = steps % n

    if steps < 0:
        steps += n

    def reverse(start: int, end: int) -> None:
        """"""
        Reverses a portion of the list in place from index start to end.

        Parameters:
        start (int): Starting index of the portion to reverse.
        end (int): Ending index of the portion to reverse.

        Returns:
        None

        Examples:
        >>> example = [1, 2, 3, 4, 5]
        >>> def reverse_test(arr, start, end):
        ...     while start < end:
        ...         arr[start], arr[end] = arr[end], arr[start]
        ...         start += 1
        ...         end -= 1
        >>> reverse_test(example, 0, 2)
        >>> example
        [3, 2, 1, 4, 5]
        >>> reverse_test(example, 2, 4)
        >>> example
        [3, 2, 5, 4, 1]
        """"""

        while start < end:
            arr[start], arr[end] = arr[end], arr[start]
            start += 1
            end -= 1

    reverse(0, n - 1)
    reverse(0, steps - 1)
    reverse(steps, n - 1)

    return arr",data\repos\Python\data_structures\arrays\rotate_array.py,rotate_array,511
2745,rotate_array.py::reverse::32,"    def reverse(start: int, end: int) -> None:
        """"""
        Reverses a portion of the list in place from index start to end.

        Parameters:
        start (int): Starting index of the portion to reverse.
        end (int): Ending index of the portion to reverse.

        Returns:
        None

        Examples:
        >>> example = [1, 2, 3, 4, 5]
        >>> def reverse_test(arr, start, end):
        ...     while start < end:
        ...         arr[start], arr[end] = arr[end], arr[start]
        ...         start += 1
        ...         end -= 1
        >>> reverse_test(example, 0, 2)
        >>> example
        [3, 2, 1, 4, 5]
        >>> reverse_test(example, 2, 4)
        >>> example
        [3, 2, 5, 4, 1]
        """"""

        while start < end:
            arr[start], arr[end] = arr[end], arr[start]
            start += 1
            end -= 1",data\repos\Python\data_structures\arrays\rotate_array.py,reverse,238
2746,sparse_table.py::build_sparse_table::17,"def build_sparse_table(number_list: list[int]) -> list[list[int]]:
    """"""
    Precompute range minimum queries with power of two length and store the precomputed
    values in a table.

    >>> build_sparse_table([8, 1, 0, 3, 4, 9, 3])
    [[8, 1, 0, 3, 4, 9, 3], [1, 0, 0, 3, 4, 3, 0], [0, 0, 0, 3, 0, 0, 0]]
    >>> build_sparse_table([3, 1, 9])
    [[3, 1, 9], [1, 1, 0]]
    >>> build_sparse_table([])
    Traceback (most recent call last):
    ...
    ValueError: empty number list not allowed
    """"""
    if not number_list:
        raise ValueError(""empty number list not allowed"")

    length = len(number_list)
    # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the
    # subset of length (2 ** j) of number_list, starting from index i.

    # smallest power of 2 subset length that fully covers number_list
    row = int(log2(length)) + 1
    sparse_table = [[0 for i in range(length)] for j in range(row)]

    # minimum of subset of length 1 is that value itself
    for i, value in enumerate(number_list):
        sparse_table[0][i] = value
    j = 1

    # compute the minimum value for all intervals with size (2 ** j)
    while (1 << j) <= length:
        i = 0
        # while subset starting from i still have at least (2 ** j) elements
        while (i + (1 << j) - 1) < length:
            # split range [i, i + 2 ** j] and find minimum of 2 halves
            sparse_table[j][i] = min(
                sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]
            )
            i += 1
        j += 1
    return sparse_table",data\repos\Python\data_structures\arrays\sparse_table.py,build_sparse_table,484
2747,sparse_table.py::query::61,"def query(sparse_table: list[list[int]], left_bound: int, right_bound: int) -> int:
    """"""
    >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 4)
    0
    >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 4, 6)
    3
    >>> query(build_sparse_table([3, 1, 9]), 2, 2)
    9
    >>> query(build_sparse_table([3, 1, 9]), 0, 1)
    1
    >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 11)
    Traceback (most recent call last):
    ...
    IndexError: list index out of range
    >>> query(build_sparse_table([]), 0, 0)
    Traceback (most recent call last):
    ...
    ValueError: empty number list not allowed
    """"""
    if left_bound < 0 or right_bound >= len(sparse_table[0]):
        raise IndexError(""list index out of range"")

    # highest subset length of power of 2 that is within range [left_bound, right_bound]
    j = int(log2(right_bound - left_bound + 1))

    # minimum of 2 overlapping smaller subsets:
    # [left_bound, left_bound + 2 ** j - 1] and [right_bound - 2 ** j + 1, right_bound]
    return min(sparse_table[j][right_bound - (1 << j) + 1], sparse_table[j][left_bound])",data\repos\Python\data_structures\arrays\sparse_table.py,query,372
2748,sudoku_solver.py::cross::11,"def cross(items_a, items_b):
    """"""
    Cross product of elements in A and elements in B.

    >>> cross('AB', '12')
    ['A1', 'A2', 'B1', 'B2']
    >>> cross('ABC', '123')
    ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
    >>> cross('ABC', '1234')
    ['A1', 'A2', 'A3', 'A4', 'B1', 'B2', 'B3', 'B4', 'C1', 'C2', 'C3', 'C4']
    >>> cross('', '12')
    []
    >>> cross('A', '')
    []
    >>> cross('', '')
    []
    """"""
    return [a + b for a in items_a for b in items_b]",data\repos\Python\data_structures\arrays\sudoku_solver.py,cross,197
2749,sudoku_solver.py::test::44,"def test():
    """"""A set of unit tests.""""""
    assert len(squares) == 81
    assert len(unitlist) == 27
    assert all(len(units[s]) == 3 for s in squares)
    assert all(len(peers[s]) == 20 for s in squares)
    assert units[""C2""] == [
        [""A2"", ""B2"", ""C2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2""],
        [""C1"", ""C2"", ""C3"", ""C4"", ""C5"", ""C6"", ""C7"", ""C8"", ""C9""],
        [""A1"", ""A2"", ""A3"", ""B1"", ""B2"", ""B3"", ""C1"", ""C2"", ""C3""],
    ]
    # fmt: off
    assert peers[""C2""] == {
        ""A2"", ""B2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2"", ""C1"", ""C3"",
        ""C4"", ""C5"", ""C6"", ""C7"", ""C8"", ""C9"", ""A1"", ""A3"", ""B1"", ""B3""
    }
    # fmt: on
    print(""All tests pass."")",data\repos\Python\data_structures\arrays\sudoku_solver.py,test,296
2750,sudoku_solver.py::parse_grid::64,"def parse_grid(grid):
    """"""
    Convert grid to a dict of possible values, {square: digits}, or
    return False if a contradiction is detected.
    """"""
    ## To start, every square can be any digit; then assign values from the grid.
    values = dict.fromkeys(squares, digits)
    for s, d in grid_values(grid).items():
        if d in digits and not assign(values, s, d):
            return False  ## (Fail if we can't assign d to square s.)
    return values",data\repos\Python\data_structures\arrays\sudoku_solver.py,parse_grid,111
2751,sudoku_solver.py::grid_values::77,"def grid_values(grid):
    """"""
    Convert grid into a dict of {square: char} with '0' or '.' for empties.
    """"""
    chars = [c for c in grid if c in digits or c in ""0.""]
    assert len(chars) == 81
    return dict(zip(squares, chars))",data\repos\Python\data_structures\arrays\sudoku_solver.py,grid_values,68
2752,sudoku_solver.py::assign::86,"def assign(values, s, d):
    """"""
    Eliminate all the other values (except d) from values[s] and propagate.
    Return values, except return False if a contradiction is detected.
    """"""
    other_values = values[s].replace(d, """")
    if all(eliminate(values, s, d2) for d2 in other_values):
        return values
    else:
        return False",data\repos\Python\data_structures\arrays\sudoku_solver.py,assign,84
2753,sudoku_solver.py::eliminate::98,"def eliminate(values, s, d):
    """"""
    Eliminate d from values[s]; propagate when values or places <= 2.
    Return values, except return False if a contradiction is detected.
    """"""
    if d not in values[s]:
        return values  ## Already eliminated
    values[s] = values[s].replace(d, """")
    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.
    if len(values[s]) == 0:
        return False  ## Contradiction: removed last value
    elif len(values[s]) == 1:
        d2 = values[s]
        if not all(eliminate(values, s2, d2) for s2 in peers[s]):
            return False
    ## (2) If a unit u is reduced to only one place for a value d, then put it there.
    for u in units[s]:
        dplaces = [s for s in u if d in values[s]]
        if len(dplaces) == 0:
            return False  ## Contradiction: no place for this value
        # d can only be in one place in unit; assign it there
        elif len(dplaces) == 1 and not assign(values, dplaces[0], d):
            return False
    return values",data\repos\Python\data_structures\arrays\sudoku_solver.py,eliminate,278
2754,sudoku_solver.py::display::124,"def display(values):
    """"""
    Display these values as a 2-D grid.
    """"""
    width = 1 + max(len(values[s]) for s in squares)
    line = ""+"".join([""-"" * (width * 3)] * 3)
    for r in rows:
        print(
            """".join(
                values[r + c].center(width) + (""|"" if c in ""36"" else """") for c in cols
            )
        )
        if r in ""CF"":
            print(line)
    print()",data\repos\Python\data_structures\arrays\sudoku_solver.py,display,110
2755,sudoku_solver.py::some::148,"def some(seq):
    """"""Return some element of seq that is true.""""""
    for e in seq:
        if e:
            return e
    return False",data\repos\Python\data_structures\arrays\sudoku_solver.py,some,32
2756,sudoku_solver.py::search::156,"def search(values):
    """"""
    Using depth-first search and propagation, try all possible values.
    """"""
    if values is False:
        return False  ## Failed earlier
    if all(len(values[s]) == 1 for s in squares):
        return values  ## Solved!
    ## Chose the unfilled square s with the fewest possibilities
    _n, s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)
    return some(search(assign(values.copy(), s, d)) for d in values[s])",data\repos\Python\data_structures\arrays\sudoku_solver.py,search,118
2757,sudoku_solver.py::solve_all::169,"def solve_all(grids, name="""", showif=0.0):
    """"""
    Attempt to solve a sequence of grids. Report results.
    When showif is a number of seconds, display puzzles that take longer.
    When showif is None, don't display any puzzles.
    """"""

    def time_solve(grid):
        start = time.monotonic()
        values = solve(grid)
        t = time.monotonic() - start
        ## Display puzzles that take long enough
        if showif is not None and t > showif:
            display(grid_values(grid))
            if values:
                display(values)
            print(f""({t:.5f} seconds)\n"")
        return (t, solved(values))

    times, results = zip(*[time_solve(grid) for grid in grids])
    if (n := len(grids)) > 1:
        print(
            ""Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs).""  # noqa: UP031
            % (sum(results), n, name, sum(times) / n, n / sum(times), max(times))
        )",data\repos\Python\data_structures\arrays\sudoku_solver.py,solve_all,243
2758,sudoku_solver.py::solved::196,"def solved(values):
    """"""
    A puzzle is solved if each unit is a permutation of the digits 1 to 9.
    """"""

    def unitsolved(unit):
        return {values[s] for s in unit} == set(digits)

    return values is not False and all(unitsolved(unit) for unit in unitlist)",data\repos\Python\data_structures\arrays\sudoku_solver.py,solved,67
2759,sudoku_solver.py::from_file::207,"def from_file(filename, sep=""\n""):
    ""Parse a file into a list of strings, separated by sep.""
    with open(filename) as file:
        return file.read().strip().split(sep)",data\repos\Python\data_structures\arrays\sudoku_solver.py,from_file,43
2760,sudoku_solver.py::random_puzzle::213,"def random_puzzle(assignments=17):
    """"""
    Make a random puzzle with N or more assignments. Restart on contradictions.
    Note the resulting puzzle is not guaranteed to be solvable, but empirically
    about 99.8% of them are solvable. Some have multiple solutions.
    """"""
    values = dict.fromkeys(squares, digits)
    for s in shuffled(squares):
        if not assign(values, s, random.choice(values[s])):
            break
        ds = [values[s] for s in squares if len(values[s]) == 1]
        if len(ds) >= assignments and len(set(ds)) >= 8:
            return """".join(values[s] if len(values[s]) == 1 else ""."" for s in squares)
    return random_puzzle(assignments)  ## Give up and make a new puzzle",data\repos\Python\data_structures\arrays\sudoku_solver.py,random_puzzle,173
2761,sudoku_solver.py::shuffled::229,"def shuffled(seq):
    """"""
    Return a randomly shuffled copy of the input sequence.
    """"""
    seq = list(seq)
    random.shuffle(seq)
    return seq",data\repos\Python\data_structures\arrays\sudoku_solver.py,shuffled,33
2762,sudoku_solver.py::time_solve::176,"    def time_solve(grid):
        start = time.monotonic()
        values = solve(grid)
        t = time.monotonic() - start
        ## Display puzzles that take long enough
        if showif is not None and t > showif:
            display(grid_values(grid))
            if values:
                display(values)
            print(f""({t:.5f} seconds)\n"")
        return (t, solved(values))",data\repos\Python\data_structures\arrays\sudoku_solver.py,time_solve,89
2763,avl_tree.py::get_height::75,"def get_height(node: MyNode | None) -> int:
    if node is None:
        return 0
    return node.get_height()",data\repos\Python\data_structures\binary_tree\avl_tree.py,get_height,30
2764,avl_tree.py::right_rotation::87,"def right_rotation(node: MyNode) -> MyNode:
    r""""""
            A                      B
           / \                    / \
          B   C                  Bl  A
         / \       -->          /   / \
        Bl  Br                 UB Br  C
       /
     UB
    UB = unbalanced node
    """"""
    print(""left rotation node:"", node.get_data())
    ret = node.get_left()
    assert ret is not None
    node.set_left(ret.get_right())
    ret.set_right(node)
    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1
    node.set_height(h1)
    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1
    ret.set_height(h2)
    return ret",data\repos\Python\data_structures\binary_tree\avl_tree.py,right_rotation,169
2765,avl_tree.py::left_rotation::110,"def left_rotation(node: MyNode) -> MyNode:
    """"""
    a mirror symmetry rotation of the left_rotation
    """"""
    print(""right rotation node:"", node.get_data())
    ret = node.get_right()
    assert ret is not None
    node.set_right(ret.get_left())
    ret.set_left(node)
    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1
    node.set_height(h1)
    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1
    ret.set_height(h2)
    return ret",data\repos\Python\data_structures\binary_tree\avl_tree.py,left_rotation,126
2766,avl_tree.py::lr_rotation::126,"def lr_rotation(node: MyNode) -> MyNode:
    r""""""
            A              A                    Br
           / \            / \                  /  \
          B   C    LR    Br  C       RR       B    A
         / \       -->  /  \         -->    /     / \
        Bl  Br         B   UB              Bl    UB  C
             \        /
             UB     Bl
    RR = right_rotation   LR = left_rotation
    """"""
    left_child = node.get_left()
    assert left_child is not None
    node.set_left(left_rotation(left_child))
    return right_rotation(node)",data\repos\Python\data_structures\binary_tree\avl_tree.py,lr_rotation,133
2767,avl_tree.py::rl_rotation::143,"def rl_rotation(node: MyNode) -> MyNode:
    right_child = node.get_right()
    assert right_child is not None
    node.set_right(right_rotation(right_child))
    return left_rotation(node)",data\repos\Python\data_structures\binary_tree\avl_tree.py,rl_rotation,43
2768,avl_tree.py::insert_node::150,"def insert_node(node: MyNode | None, data: Any) -> MyNode | None:
    if node is None:
        return MyNode(data)
    if data < node.get_data():
        node.set_left(insert_node(node.get_left(), data))
        if (
            get_height(node.get_left()) - get_height(node.get_right()) == 2
        ):  # an unbalance detected
            left_child = node.get_left()
            assert left_child is not None
            if (
                data < left_child.get_data()
            ):  # new node is the left child of the left child
                node = right_rotation(node)
            else:
                node = lr_rotation(node)
    else:
        node.set_right(insert_node(node.get_right(), data))
        if get_height(node.get_right()) - get_height(node.get_left()) == 2:
            right_child = node.get_right()
            assert right_child is not None
            if data < right_child.get_data():
                node = rl_rotation(node)
            else:
                node = left_rotation(node)
    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1
    node.set_height(h1)
    return node",data\repos\Python\data_structures\binary_tree\avl_tree.py,insert_node,249
2769,avl_tree.py::get_right_most::180,"def get_right_most(root: MyNode) -> Any:
    while True:
        right_child = root.get_right()
        if right_child is None:
            break
        root = right_child
    return root.get_data()",data\repos\Python\data_structures\binary_tree\avl_tree.py,get_right_most,46
2770,avl_tree.py::get_left_most::189,"def get_left_most(root: MyNode) -> Any:
    while True:
        left_child = root.get_left()
        if left_child is None:
            break
        root = left_child
    return root.get_data()",data\repos\Python\data_structures\binary_tree\avl_tree.py,get_left_most,46
2771,avl_tree.py::del_node::198,"def del_node(root: MyNode, data: Any) -> MyNode | None:
    left_child = root.get_left()
    right_child = root.get_right()
    if root.get_data() == data:
        if left_child is not None and right_child is not None:
            temp_data = get_left_most(right_child)
            root.set_data(temp_data)
            root.set_right(del_node(right_child, temp_data))
        elif left_child is not None:
            root = left_child
        elif right_child is not None:
            root = right_child
        else:
            return None
    elif root.get_data() > data:
        if left_child is None:
            print(""No such data"")
            return root
        else:
            root.set_left(del_node(left_child, data))
    # root.get_data() < data
    elif right_child is None:
        return root
    else:
        root.set_right(del_node(right_child, data))

    # Re-fetch left_child and right_child references
    left_child = root.get_left()
    right_child = root.get_right()

    if get_height(right_child) - get_height(left_child) == 2:
        assert right_child is not None
        if get_height(right_child.get_right()) > get_height(right_child.get_left()):
            root = left_rotation(root)
        else:
            root = rl_rotation(root)
    elif get_height(right_child) - get_height(left_child) == -2:
        assert left_child is not None
        if get_height(left_child.get_left()) > get_height(left_child.get_right()):
            root = right_rotation(root)
        else:
            root = lr_rotation(root)
    height = my_max(get_height(root.get_right()), get_height(root.get_left())) + 1
    root.set_height(height)
    return root",data\repos\Python\data_structures\binary_tree\avl_tree.py,del_node,371
2772,avl_tree.py::print_queue::37,"    def print_queue(self) -> None:
        print(self.data)
        print(""**************"")
        print(self.data[self.head : self.tail])",data\repos\Python\data_structures\binary_tree\avl_tree.py,print_queue,30
2773,avl_tree.py::insert::285,"    def insert(self, data: Any) -> None:
        print(""insert:"" + str(data))
        self.root = insert_node(self.root, data)",data\repos\Python\data_structures\binary_tree\avl_tree.py,insert,32
2774,avl_tree.py::del_node::289,"    def del_node(self, data: Any) -> None:
        print(""delete:"" + str(data))
        if self.root is None:
            print(""Tree is empty!"")
            return
        self.root = del_node(self.root, data)",data\repos\Python\data_structures\binary_tree\avl_tree.py,del_node,50
2775,basic_binary_tree.py::is_full::23,"    def is_full(self) -> bool:
        if not self or (not self.left and not self.right):
            return True
        if self.left and self.right:
            return self.left.is_full() and self.right.is_full()
        return False",data\repos\Python\data_structures\binary_tree\basic_binary_tree.py,is_full,51
2776,basic_binary_tree.py::small_tree::42,"    def small_tree(cls) -> BinaryTree:
        """"""
        Return a small binary tree with 3 nodes.
        >>> binary_tree = BinaryTree.small_tree()
        >>> len(binary_tree)
        3
        >>> list(binary_tree)
        [1, 2, 3]
        """"""
        binary_tree = BinaryTree(Node(2))
        binary_tree.root.left = Node(1)
        binary_tree.root.right = Node(3)
        return binary_tree",data\repos\Python\data_structures\binary_tree\basic_binary_tree.py,small_tree,92
2777,basic_binary_tree.py::medium_tree::57,"    def medium_tree(cls) -> BinaryTree:
        """"""
        Return a medium binary tree with 3 nodes.
        >>> binary_tree = BinaryTree.medium_tree()
        >>> len(binary_tree)
        7
        >>> list(binary_tree)
        [1, 2, 3, 4, 5, 6, 7]
        """"""
        binary_tree = BinaryTree(Node(4))
        binary_tree.root.left = two = Node(2)
        two.left = Node(1)
        two.right = Node(3)
        binary_tree.root.right = five = Node(5)
        five.right = six = Node(6)
        six.right = Node(7)
        return binary_tree",data\repos\Python\data_structures\binary_tree\basic_binary_tree.py,medium_tree,142
2778,basic_binary_tree.py::depth::75,"    def depth(self) -> int:
        """"""
        Returns the depth of the tree

        >>> BinaryTree(Node(1)).depth()
        1
        >>> BinaryTree.small_tree().depth()
        2
        >>> BinaryTree.medium_tree().depth()
        4
        """"""
        return self._depth(self.root)",data\repos\Python\data_structures\binary_tree\basic_binary_tree.py,depth,65
2779,basic_binary_tree.py::is_full::93,"    def is_full(self) -> bool:
        """"""
        Returns True if the tree is full

        >>> BinaryTree(Node(1)).is_full()
        True
        >>> BinaryTree.small_tree().is_full()
        True
        >>> BinaryTree.medium_tree().is_full()
        False
        """"""
        return self.root.is_full()",data\repos\Python\data_structures\binary_tree\basic_binary_tree.py,is_full,66
2780,binary_search_tree.py::inorder::333,"def inorder(curr_node: Node | None) -> list[Node]:
    """"""
    inorder (left, self, right)
    """"""
    node_list = []
    if curr_node is not None:
        node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]
    return node_list",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,inorder,65
2781,binary_search_tree.py::postorder::343,"def postorder(curr_node: Node | None) -> list[Node]:
    """"""
    postOrder (left, right, self)
    """"""
    node_list = []
    if curr_node is not None:
        node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]
    return node_list",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,postorder,68
2782,binary_search_tree.py::empty::156,"    def empty(self) -> bool:
        """"""
        Returns True if the tree does not have any element(s).
        False if the tree has element(s).

        >>> BinarySearchTree().empty()
        True
        >>> BinarySearchTree().insert(1).empty()
        False
        >>> BinarySearchTree().insert(8, 3, 6, 1, 10, 14, 13, 4, 7).empty()
        False
        """"""
        return not self.root",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,empty,101
2783,binary_search_tree.py::search::200,"    def search(self, value) -> Node | None:
        """"""
        >>> tree = BinarySearchTree().insert(10, 20, 30, 40, 50)
        >>> tree.search(10)
        {'10': (None, {'20': (None, {'30': (None, {'40': (None, 50)})})})}
        >>> tree.search(20)
        {'20': (None, {'30': (None, {'40': (None, 50)})})}
        >>> tree.search(30)
        {'30': (None, {'40': (None, 50)})}
        >>> tree.search(40)
        {'40': (None, 50)}
        >>> tree.search(50)
        50
        >>> tree.search(5) is None  # element not present
        True
        >>> tree.search(0) is None  # element not present
        True
        >>> tree.search(-5) is None  # element not present
        True
        >>> BinarySearchTree().search(10)
        Traceback (most recent call last):
            ...
        IndexError: Warning: Tree is empty! please use another.
        """"""

        if self.empty():
            raise IndexError(""Warning: Tree is empty! please use another."")
        else:
            node = self.root
            # use lazy evaluation here to avoid NoneType Attribute error
            while node is not None and node.value is not value:
                node = node.left if value < node.value else node.right
            return node",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,search,316
2784,binary_search_tree.py::get_max::234,"    def get_max(self, node: Node | None = None) -> Node | None:
        """"""
        We go deep on the right branch

        >>> BinarySearchTree().insert(10, 20, 30, 40, 50).get_max()
        50
        >>> BinarySearchTree().insert(-5, -1, 0.1, -0.3, -4.5).get_max()
        {'0.1': (-0.3, None)}
        >>> BinarySearchTree().insert(1, 78.3, 30, 74.0, 1).get_max()
        {'78.3': ({'30': (1, 74.0)}, None)}
        >>> BinarySearchTree().insert(1, 783, 30, 740, 1).get_max()
        {'783': ({'30': (1, 740)}, None)}
        """"""
        if node is None:
            if self.root is None:
                return None
            node = self.root

        if not self.empty():
            while node.right is not None:
                node = node.right
        return node",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,get_max,237
2785,binary_search_tree.py::get_min::257,"    def get_min(self, node: Node | None = None) -> Node | None:
        """"""
        We go deep on the left branch

        >>> BinarySearchTree().insert(10, 20, 30, 40, 50).get_min()
        {'10': (None, {'20': (None, {'30': (None, {'40': (None, 50)})})})}
        >>> BinarySearchTree().insert(-5, -1, 0, -0.3, -4.5).get_min()
        {'-5': (None, {'-1': (-4.5, {'0': (-0.3, None)})})}
        >>> BinarySearchTree().insert(1, 78.3, 30, 74.0, 1).get_min()
        {'1': (None, {'78.3': ({'30': (1, 74.0)}, None)})}
        >>> BinarySearchTree().insert(1, 783, 30, 740, 1).get_min()
        {'1': (None, {'783': ({'30': (1, 740)}, None)})}
        """"""
        if node is None:
            node = self.root
        if self.root is None:
            return None
        if not self.empty():
            node = self.root
            while node.left is not None:
                node = node.left
        return node",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,get_min,296
2786,binary_search_tree.py::remove::280,"    def remove(self, value: int) -> None:
        # Look for the node with that label
        node = self.search(value)
        if node is None:
            msg = f""Value {value} not found""
            raise ValueError(msg)

        if node.left is None and node.right is None:  # If it has no children
            self.__reassign_nodes(node, None)
        elif node.left is None:  # Has only right children
            self.__reassign_nodes(node, node.right)
        elif node.right is None:  # Has only left children
            self.__reassign_nodes(node, node.left)
        else:
            predecessor = self.get_max(
                node.left
            )  # Gets the max value of the left branch
            self.remove(predecessor.value)  # type: ignore[union-attr]
            node.value = (
                predecessor.value  # type: ignore[union-attr]
            )  # Assigns the value to the node to delete and keep tree structure",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,remove,212
2787,binary_search_tree.py::preorder_traverse::302,"    def preorder_traverse(self, node: Node | None) -> Iterable:
        if node is not None:
            yield node  # Preorder Traversal
            yield from self.preorder_traverse(node.left)
            yield from self.preorder_traverse(node.right)",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,preorder_traverse,55
2788,binary_search_tree.py::traversal_tree::308,"    def traversal_tree(self, traversal_function=None) -> Any:
        """"""
        This function traversal the tree.
        You can pass a function to traversal the tree as needed by client code
        """"""
        if traversal_function is None:
            return self.preorder_traverse(self.root)
        else:
            return traversal_function(self.root)",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,traversal_tree,67
2789,binary_search_tree.py::inorder::318,"    def inorder(self, arr: list, node: Node | None) -> None:
        """"""Perform an inorder traversal and append values of the nodes to
        a list named arr""""""
        if node:
            self.inorder(arr, node.left)
            arr.append(node.value)
            self.inorder(arr, node.right)",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,inorder,66
2790,binary_search_tree.py::find_kth_smallest::326,"    def find_kth_smallest(self, k: int, node: Node) -> int:
        """"""Return the kth smallest element in a binary search tree""""""
        arr: list[int] = []
        self.inorder(arr, node)  # append all values to list using inorder traversal
        return arr[k - 1]",data\repos\Python\data_structures\binary_tree\binary_search_tree.py,find_kth_smallest,69
2791,binary_search_tree_recursive.py::binary_search_tree_example::546,"def binary_search_tree_example() -> None:
    r""""""
    Example
                  8
                 / \
                3   10
               / \    \
              1   6    14
                 / \   /
                4   7 13
                \
                5

    Example After Deletion
                  4
                 / \
                1   7
                     \
                      5

    """"""

    t = BinarySearchTree()
    t.put(8)
    t.put(3)
    t.put(6)
    t.put(1)
    t.put(10)
    t.put(14)
    t.put(13)
    t.put(4)
    t.put(7)
    t.put(5)

    print(
        """"""
            8
           / \\
          3   10
         / \\    \\
        1   6    14
           / \\   /
          4   7 13
           \\
            5
        """"""
    )

    print(""Label 6 exists:"", t.exists(6))
    print(""Label 13 exists:"", t.exists(13))
    print(""Label -1 exists:"", t.exists(-1))
    print(""Label 12 exists:"", t.exists(12))

    # Prints all the elements of the list in inorder traversal
    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]
    print(""Inorder traversal:"", inorder_traversal_nodes)

    # Prints all the elements of the list in preorder traversal
    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]
    print(""Preorder traversal:"", preorder_traversal_nodes)

    print(""Max. label:"", t.get_max_label())
    print(""Min. label:"", t.get_min_label())

    # Delete elements
    print(""\nDeleting elements 13, 10, 8, 3, 6, 14"")
    print(
        """"""
          4
         / \\
        1   7
             \\
              5
        """"""
    )
    t.remove(13)
    t.remove(10)
    t.remove(8)
    t.remove(3)
    t.remove(6)
    t.remove(14)

    # Prints all the elements of the list in inorder traversal after delete
    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]
    print(""Inorder traversal after delete:"", inorder_traversal_nodes)

    # Prints all the elements of the list in preorder traversal after delete
    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]
    print(""Preorder traversal after delete:"", preorder_traversal_nodes)

    print(""Max. label:"", t.get_max_label())
    print(""Min. label:"", t.get_min_label())",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,binary_search_tree_example,590
2792,binary_search_tree_recursive.py::empty::31,"    def empty(self) -> None:
        """"""
        Empties the tree

        >>> t = BinarySearchTree()
        >>> assert t.root is None
        >>> t.put(8)
        >>> assert t.root is not None
        """"""
        self.root = None",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,empty,55
2793,binary_search_tree_recursive.py::is_empty::42,"    def is_empty(self) -> bool:
        """"""
        Checks if the tree is empty

        >>> t = BinarySearchTree()
        >>> t.is_empty()
        True
        >>> t.put(8)
        >>> t.is_empty()
        False
        """"""
        return self.root is None",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,is_empty,59
2794,binary_search_tree_recursive.py::put::55,"    def put(self, label: int) -> None:
        """"""
        Put a new node in the tree

        >>> t = BinarySearchTree()
        >>> t.put(8)
        >>> assert t.root.parent is None
        >>> assert t.root.label == 8

        >>> t.put(10)
        >>> assert t.root.right.parent == t.root
        >>> assert t.root.right.label == 10

        >>> t.put(3)
        >>> assert t.root.left.parent == t.root
        >>> assert t.root.left.label == 3
        """"""
        self.root = self._put(self.root, label)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,put,128
2795,binary_search_tree_recursive.py::search::87,"    def search(self, label: int) -> Node:
        """"""
        Searches a node in the tree

        >>> t = BinarySearchTree()
        >>> t.put(8)
        >>> t.put(10)
        >>> node = t.search(8)
        >>> assert node.label == 8

        >>> node = t.search(3)
        Traceback (most recent call last):
            ...
        ValueError: Node with label 3 does not exist
        """"""
        return self._search(self.root, label)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,search,105
2796,binary_search_tree_recursive.py::remove::115,"    def remove(self, label: int) -> None:
        """"""
        Removes a node in the tree

        >>> t = BinarySearchTree()
        >>> t.put(8)
        >>> t.put(10)
        >>> t.remove(8)
        >>> assert t.root.label == 10

        >>> t.remove(3)
        Traceback (most recent call last):
            ...
        ValueError: Node with label 3 does not exist
        """"""
        node = self.search(label)
        if node.right and node.left:
            lowest_node = self._get_lowest_node(node.right)
            lowest_node.left = node.left
            lowest_node.right = node.right
            node.left.parent = lowest_node
            if node.right:
                node.right.parent = lowest_node
            self._reassign_nodes(node, lowest_node)
        elif not node.right and node.left:
            self._reassign_nodes(node, node.left)
        elif node.right and not node.left:
            self._reassign_nodes(node, node.right)
        else:
            self._reassign_nodes(node, None)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,remove,221
2797,binary_search_tree_recursive.py::exists::167,"    def exists(self, label: int) -> bool:
        """"""
        Checks if a node exists in the tree

        >>> t = BinarySearchTree()
        >>> t.put(8)
        >>> t.put(10)
        >>> t.exists(8)
        True

        >>> t.exists(3)
        False
        """"""
        try:
            self.search(label)
            return True
        except ValueError:
            return False",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,exists,86
2798,binary_search_tree_recursive.py::get_max_label::186,"    def get_max_label(self) -> int:
        """"""
        Gets the max label inserted in the tree

        >>> t = BinarySearchTree()
        >>> t.get_max_label()
        Traceback (most recent call last):
            ...
        ValueError: Binary search tree is empty

        >>> t.put(8)
        >>> t.put(10)
        >>> t.get_max_label()
        10
        """"""
        if self.root is None:
            raise ValueError(""Binary search tree is empty"")

        node = self.root
        while node.right is not None:
            node = node.right

        return node.label",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,get_max_label,124
2799,binary_search_tree_recursive.py::get_min_label::210,"    def get_min_label(self) -> int:
        """"""
        Gets the min label inserted in the tree

        >>> t = BinarySearchTree()
        >>> t.get_min_label()
        Traceback (most recent call last):
            ...
        ValueError: Binary search tree is empty

        >>> t.put(8)
        >>> t.put(10)
        >>> t.get_min_label()
        8
        """"""
        if self.root is None:
            raise ValueError(""Binary search tree is empty"")

        node = self.root
        while node.left is not None:
            node = node.left

        return node.label",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,get_min_label,124
2800,binary_search_tree_recursive.py::inorder_traversal::234,"    def inorder_traversal(self) -> Iterator[Node]:
        """"""
        Return the inorder traversal of the tree

        >>> t = BinarySearchTree()
        >>> [i.label for i in t.inorder_traversal()]
        []

        >>> t.put(8)
        >>> t.put(10)
        >>> t.put(9)
        >>> [i.label for i in t.inorder_traversal()]
        [8, 9, 10]
        """"""
        return self._inorder_traversal(self.root)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,inorder_traversal,104
2801,binary_search_tree_recursive.py::preorder_traversal::256,"    def preorder_traversal(self) -> Iterator[Node]:
        """"""
        Return the preorder traversal of the tree

        >>> t = BinarySearchTree()
        >>> [i.label for i in t.preorder_traversal()]
        []

        >>> t.put(8)
        >>> t.put(10)
        >>> t.put(9)
        >>> [i.label for i in t.preorder_traversal()]
        [8, 10, 9]
        """"""
        return self._preorder_traversal(self.root)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,preorder_traversal,104
2802,binary_search_tree_recursive.py::test_put::307,"    def test_put(self) -> None:
        t = BinarySearchTree()
        assert t.is_empty()

        t.put(8)
        r""""""
              8
        """"""
        assert t.root is not None
        assert t.root.parent is None
        assert t.root.label == 8

        t.put(10)
        r""""""
              8
               \
                10
        """"""
        assert t.root.right is not None
        assert t.root.right.parent == t.root
        assert t.root.right.label == 10

        t.put(3)
        r""""""
              8
             / \
            3   10
        """"""
        assert t.root.left is not None
        assert t.root.left.parent == t.root
        assert t.root.left.label == 3

        t.put(6)
        r""""""
              8
             / \
            3   10
             \
              6
        """"""
        assert t.root.left.right is not None
        assert t.root.left.right.parent == t.root.left
        assert t.root.left.right.label == 6

        t.put(1)
        r""""""
              8
             / \
            3   10
           / \
          1   6
        """"""
        assert t.root.left.left is not None
        assert t.root.left.left.parent == t.root.left
        assert t.root.left.left.label == 1

        with pytest.raises(ValueError):
            t.put(1)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_put,309
2803,binary_search_tree_recursive.py::test_search::366,"    def test_search(self) -> None:
        t = self._get_binary_search_tree()

        node = t.search(6)
        assert node.label == 6

        node = t.search(13)
        assert node.label == 13

        with pytest.raises(ValueError):
            t.search(2)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_search,63
2804,binary_search_tree_recursive.py::test_remove::378,"    def test_remove(self) -> None:
        t = self._get_binary_search_tree()

        t.remove(13)
        r""""""
              8
             / \
            3   10
           / \    \
          1   6    14
             / \
            4   7
             \
              5
        """"""
        assert t.root is not None
        assert t.root.right is not None
        assert t.root.right.right is not None
        assert t.root.right.right.right is None
        assert t.root.right.right.left is None

        t.remove(7)
        r""""""
              8
             / \
            3   10
           / \    \
          1   6    14
             /
            4
             \
              5
        """"""
        assert t.root.left is not None
        assert t.root.left.right is not None
        assert t.root.left.right.left is not None
        assert t.root.left.right.right is None
        assert t.root.left.right.left.label == 4

        t.remove(6)
        r""""""
              8
             / \
            3   10
           / \    \
          1   4    14
               \
                5
        """"""
        assert t.root.left.left is not None
        assert t.root.left.right.right is not None
        assert t.root.left.left.label == 1
        assert t.root.left.right.label == 4
        assert t.root.left.right.right.label == 5
        assert t.root.left.right.left is None
        assert t.root.left.left.parent == t.root.left
        assert t.root.left.right.parent == t.root.left

        t.remove(3)
        r""""""
              8
             / \
            4   10
           / \    \
          1   5    14
        """"""
        assert t.root is not None
        assert t.root.left.label == 4
        assert t.root.left.right.label == 5
        assert t.root.left.left.label == 1
        assert t.root.left.parent == t.root
        assert t.root.left.left.parent == t.root.left
        assert t.root.left.right.parent == t.root.left

        t.remove(4)
        r""""""
              8
             / \
            5   10
           /      \
          1        14
        """"""
        assert t.root.left is not None
        assert t.root.left.left is not None
        assert t.root.left.label == 5
        assert t.root.left.right is None
        assert t.root.left.left.label == 1
        assert t.root.left.parent == t.root
        assert t.root.left.left.parent == t.root.left",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_remove,581
2805,binary_search_tree_recursive.py::test_remove_2::468,"    def test_remove_2(self) -> None:
        t = self._get_binary_search_tree()

        t.remove(3)
        r""""""
              8
             / \
            4   10
           / \    \
          1   6    14
             / \   /
            5   7 13
        """"""
        assert t.root is not None
        assert t.root.left is not None
        assert t.root.left.left is not None
        assert t.root.left.right is not None
        assert t.root.left.right.left is not None
        assert t.root.left.right.right is not None
        assert t.root.left.label == 4
        assert t.root.left.right.label == 6
        assert t.root.left.left.label == 1
        assert t.root.left.right.right.label == 7
        assert t.root.left.right.left.label == 5
        assert t.root.left.parent == t.root
        assert t.root.left.right.parent == t.root.left
        assert t.root.left.left.parent == t.root.left
        assert t.root.left.right.left.parent == t.root.left.right",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_remove_2,237
2806,binary_search_tree_recursive.py::test_is_empty::502,"    def test_is_empty(self) -> None:
        t = self._get_binary_search_tree()
        assert not t.is_empty()

        t.empty()
        assert t.is_empty()",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_is_empty,37
2807,binary_search_tree_recursive.py::test_exists::509,"    def test_exists(self) -> None:
        t = self._get_binary_search_tree()

        assert t.exists(6)
        assert not t.exists(-1)",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_exists,34
2808,binary_search_tree_recursive.py::test_get_max_label::515,"    def test_get_max_label(self) -> None:
        t = self._get_binary_search_tree()

        assert t.get_max_label() == 14

        t.empty()
        with pytest.raises(ValueError):
            t.get_max_label()",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_get_max_label,48
2809,binary_search_tree_recursive.py::test_get_min_label::524,"    def test_get_min_label(self) -> None:
        t = self._get_binary_search_tree()

        assert t.get_min_label() == 1

        t.empty()
        with pytest.raises(ValueError):
            t.get_min_label()",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_get_min_label,48
2810,binary_search_tree_recursive.py::test_inorder_traversal::533,"    def test_inorder_traversal(self) -> None:
        t = self._get_binary_search_tree()

        inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]
        assert inorder_traversal_nodes == [1, 3, 4, 5, 6, 7, 8, 10, 13, 14]",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_inorder_traversal,77
2811,binary_search_tree_recursive.py::test_preorder_traversal::539,"    def test_preorder_traversal(self) -> None:
        t = self._get_binary_search_tree()

        preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]
        assert preorder_traversal_nodes == [8, 3, 1, 6, 4, 5, 7, 10, 14, 13]",data\repos\Python\data_structures\binary_tree\binary_search_tree_recursive.py,test_preorder_traversal,77
2812,binary_tree_mirror.py::binary_tree_mirror_dict::7,"def binary_tree_mirror_dict(binary_tree_mirror_dictionary: dict, root: int):
    if not root or root not in binary_tree_mirror_dictionary:
        return
    left_child, right_child = binary_tree_mirror_dictionary[root][:2]
    binary_tree_mirror_dictionary[root] = [right_child, left_child]
    binary_tree_mirror_dict(binary_tree_mirror_dictionary, left_child)
    binary_tree_mirror_dict(binary_tree_mirror_dictionary, right_child)",data\repos\Python\data_structures\binary_tree\binary_tree_mirror.py,binary_tree_mirror_dict,88
2813,binary_tree_mirror.py::binary_tree_mirror::16,"def binary_tree_mirror(binary_tree: dict, root: int = 1) -> dict:
    """"""
    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 7: [8,9]}, 1)
    {1: [3, 2], 2: [5, 4], 3: [7, 6], 7: [9, 8]}
    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 1)
    {1: [3, 2], 2: [5, 4], 3: [7, 6], 4: [11, 10]}
    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 5)
    Traceback (most recent call last):
        ...
    ValueError: root 5 is not present in the binary_tree
    >>> binary_tree_mirror({}, 5)
    Traceback (most recent call last):
        ...
    ValueError: binary tree cannot be empty
    """"""
    if not binary_tree:
        raise ValueError(""binary tree cannot be empty"")
    if root not in binary_tree:
        msg = f""root {root} is not present in the binary_tree""
        raise ValueError(msg)
    binary_tree_mirror_dictionary = dict(binary_tree)
    binary_tree_mirror_dict(binary_tree_mirror_dictionary, root)
    return binary_tree_mirror_dictionary",data\repos\Python\data_structures\binary_tree\binary_tree_mirror.py,binary_tree_mirror,348
2814,binary_tree_node_sum.py::depth_first_search::61,"    def depth_first_search(self, node: Node | None) -> int:
        if node is None:
            return 0
        return node.value + (
            self.depth_first_search(node.left) + self.depth_first_search(node.right)
        )",data\repos\Python\data_structures\binary_tree\binary_tree_node_sum.py,depth_first_search,51
2815,binary_tree_path_sum.py::depth_first_search::80,"    def depth_first_search(self, node: Node | None, path_sum: int) -> None:
        if node is None:
            return

        if path_sum == self.target:
            self.paths += 1

        if node.left:
            self.depth_first_search(node.left, path_sum + node.left.value)
        if node.right:
            self.depth_first_search(node.right, path_sum + node.right.value)",data\repos\Python\data_structures\binary_tree\binary_tree_path_sum.py,depth_first_search,85
2816,binary_tree_path_sum.py::path_sum::92,"    def path_sum(self, node: Node | None, target: int | None = None) -> int:
        if node is None:
            return 0
        if target is not None:
            self.target = target

        self.depth_first_search(node, node.value)
        self.path_sum(node.left)
        self.path_sum(node.right)

        return self.paths",data\repos\Python\data_structures\binary_tree\binary_tree_path_sum.py,path_sum,75
2817,binary_tree_traversals.py::make_tree::16,"def make_tree() -> Node | None:
    r""""""
    The below tree
        1
       / \
      2   3
     / \
    4   5
    """"""
    tree = Node(1)
    tree.left = Node(2)
    tree.right = Node(3)
    tree.left.left = Node(4)
    tree.left.right = Node(5)
    return tree",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,make_tree,87
2818,binary_tree_traversals.py::preorder::33,"def preorder(root: Node | None) -> Generator[int]:
    """"""
    Pre-order traversal visits root node, left subtree, right subtree.
    >>> list(preorder(make_tree()))
    [1, 2, 4, 5, 3]
    """"""
    if not root:
        return
    yield root.data
    yield from preorder(root.left)
    yield from preorder(root.right)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,preorder,81
2819,binary_tree_traversals.py::postorder::46,"def postorder(root: Node | None) -> Generator[int]:
    """"""
    Post-order traversal visits left subtree, right subtree, root node.
    >>> list(postorder(make_tree()))
    [4, 5, 2, 3, 1]
    """"""
    if not root:
        return
    yield from postorder(root.left)
    yield from postorder(root.right)
    yield root.data",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,postorder,83
2820,binary_tree_traversals.py::inorder::59,"def inorder(root: Node | None) -> Generator[int]:
    """"""
    In-order traversal visits left subtree, root node, right subtree.
    >>> list(inorder(make_tree()))
    [4, 2, 5, 1, 3]
    """"""
    if not root:
        return
    yield from inorder(root.left)
    yield root.data
    yield from inorder(root.right)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,inorder,81
2821,binary_tree_traversals.py::reverse_inorder::72,"def reverse_inorder(root: Node | None) -> Generator[int]:
    """"""
    Reverse in-order traversal visits right subtree, root node, left subtree.
    >>> list(reverse_inorder(make_tree()))
    [3, 1, 5, 2, 4]
    """"""
    if not root:
        return
    yield from reverse_inorder(root.right)
    yield root.data
    yield from reverse_inorder(root.left)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,reverse_inorder,89
2822,binary_tree_traversals.py::height::85,"def height(root: Node | None) -> int:
    """"""
    Recursive function for calculating the height of the binary tree.
    >>> height(None)
    0
    >>> height(make_tree())
    3
    """"""
    return (max(height(root.left), height(root.right)) + 1) if root else 0",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,height,67
2823,binary_tree_traversals.py::level_order::96,"def level_order(root: Node | None) -> Generator[int]:
    """"""
    Returns a list of nodes value from a whole binary tree in Level Order Traverse.
    Level Order traverse: Visit nodes of the tree level-by-level.
    >>> list(level_order(make_tree()))
    [1, 2, 3, 4, 5]
    """"""

    if root is None:
        return

    process_queue = deque([root])

    while process_queue:
        node = process_queue.popleft()
        yield node.data

        if node.left:
            process_queue.append(node.left)
        if node.right:
            process_queue.append(node.right)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,level_order,131
2824,binary_tree_traversals.py::get_nodes_from_left_to_right::119,"def get_nodes_from_left_to_right(root: Node | None, level: int) -> Generator[int]:
    """"""
    Returns a list of nodes value from a particular level:
    Left to right direction of the binary tree.
    >>> list(get_nodes_from_left_to_right(make_tree(), 1))
    [1]
    >>> list(get_nodes_from_left_to_right(make_tree(), 2))
    [2, 3]
    """"""

    def populate_output(root: Node | None, level: int) -> Generator[int]:
        if not root:
            return
        if level == 1:
            yield root.data
        elif level > 1:
            yield from populate_output(root.left, level - 1)
            yield from populate_output(root.right, level - 1)

    yield from populate_output(root, level)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,get_nodes_from_left_to_right,168
2825,binary_tree_traversals.py::get_nodes_from_right_to_left::141,"def get_nodes_from_right_to_left(root: Node | None, level: int) -> Generator[int]:
    """"""
    Returns a list of nodes value from a particular level:
    Right to left direction of the binary tree.
    >>> list(get_nodes_from_right_to_left(make_tree(), 1))
    [1]
    >>> list(get_nodes_from_right_to_left(make_tree(), 2))
    [3, 2]
    """"""

    def populate_output(root: Node | None, level: int) -> Generator[int]:
        if not root:
            return
        if level == 1:
            yield root.data
        elif level > 1:
            yield from populate_output(root.right, level - 1)
            yield from populate_output(root.left, level - 1)

    yield from populate_output(root, level)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,get_nodes_from_right_to_left,168
2826,binary_tree_traversals.py::zigzag::163,"def zigzag(root: Node | None) -> Generator[int]:
    """"""
    ZigZag traverse:
    Returns a list of nodes value from left to right and right to left, alternatively.
    >>> list(zigzag(make_tree()))
    [1, 3, 2, 4, 5]
    """"""
    if root is None:
        return

    flag = 0
    height_tree = height(root)

    for h in range(1, height_tree + 1):
        if not flag:
            yield from get_nodes_from_left_to_right(root, h)
            flag = 1
        else:
            yield from get_nodes_from_right_to_left(root, h)
            flag = 0",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,zigzag,147
2827,binary_tree_traversals.py::main::185,"def main() -> None:  # Main function for testing.
    # Create binary tree.
    root = make_tree()

    # All Traversals of the binary are as follows:
    print(f""In-order Traversal: {list(inorder(root))}"")
    print(f""Reverse In-order Traversal: {list(reverse_inorder(root))}"")
    print(f""Pre-order Traversal: {list(preorder(root))}"")
    print(f""Post-order Traversal: {list(postorder(root))}"", ""\n"")

    print(f""Height of Tree: {height(root)}"", ""\n"")

    print(""Complete Level Order Traversal: "")
    print(f""{list(level_order(root))} \n"")

    print(""Level-wise order Traversal: "")

    for level in range(1, height(root) + 1):
        print(f""Level {level}:"", list(get_nodes_from_left_to_right(root, level=level)))

    print(""\nZigZag order Traversal: "")
    print(f""{list(zigzag(root))}"")",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,main,216
2828,binary_tree_traversals.py::populate_output::129,"    def populate_output(root: Node | None, level: int) -> Generator[int]:
        if not root:
            return
        if level == 1:
            yield root.data
        elif level > 1:
            yield from populate_output(root.left, level - 1)
            yield from populate_output(root.right, level - 1)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,populate_output,71
2829,binary_tree_traversals.py::populate_output::151,"    def populate_output(root: Node | None, level: int) -> Generator[int]:
        if not root:
            return
        if level == 1:
            yield root.data
        elif level > 1:
            yield from populate_output(root.right, level - 1)
            yield from populate_output(root.left, level - 1)",data\repos\Python\data_structures\binary_tree\binary_tree_traversals.py,populate_output,71
2830,diameter_of_binary_tree.py::depth::17,"    def depth(self) -> int:
        """"""
        >>> root = Node(1)
        >>> root.depth()
        1
        >>> root.left = Node(2)
        >>> root.depth()
        2
        >>> root.left.depth()
        1
        >>> root.right = Node(3)
        >>> root.depth()
        2
        """"""
        left_depth = self.left.depth() if self.left else 0
        right_depth = self.right.depth() if self.right else 0
        return max(left_depth, right_depth) + 1",data\repos\Python\data_structures\binary_tree\diameter_of_binary_tree.py,depth,117
2831,diameter_of_binary_tree.py::diameter::35,"    def diameter(self) -> int:
        """"""
        >>> root = Node(1)
        >>> root.diameter()
        1
        >>> root.left = Node(2)
        >>> root.diameter()
        2
        >>> root.left.diameter()
        1
        >>> root.right = Node(3)
        >>> root.diameter()
        3
        """"""
        left_depth = self.left.depth() if self.left else 0
        right_depth = self.right.depth() if self.right else 0
        return left_depth + right_depth + 1",data\repos\Python\data_structures\binary_tree\diameter_of_binary_tree.py,diameter,119
2832,diff_views_of_binary_tree.py::make_tree::22,"def make_tree() -> TreeNode:
    """"""
    >>> make_tree().val
    3
    """"""
    return TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,make_tree,44
2833,diff_views_of_binary_tree.py::binary_tree_right_side_view::30,"def binary_tree_right_side_view(root: TreeNode) -> list[int]:
    r""""""
    Function returns the right side view of binary tree.

       3       <-  3
     / \
    9   20    <-  20
       /  \
      15   7  <-  7

    >>> binary_tree_right_side_view(make_tree())
    [3, 20, 7]
    >>> binary_tree_right_side_view(None)
    []
    """"""

    def depth_first_search(
        root: TreeNode | None, depth: int, right_view: list[int]
    ) -> None:
        """"""
        A depth first search preorder traversal to append the values at
        right side of tree.
        """"""
        if not root:
            return

        if depth == len(right_view):
            right_view.append(root.val)

        depth_first_search(root.right, depth + 1, right_view)
        depth_first_search(root.left, depth + 1, right_view)

    right_view: list = []
    if not root:
        return right_view

    depth_first_search(root, 0, right_view)
    return right_view",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,binary_tree_right_side_view,238
2834,diff_views_of_binary_tree.py::binary_tree_left_side_view::70,"def binary_tree_left_side_view(root: TreeNode) -> list[int]:
    r""""""
    Function returns the left side view of binary tree.

    3  ->    3
            / \
    9  ->  9   20
              /  \
    15 ->    15   7

    >>> binary_tree_left_side_view(make_tree())
    [3, 9, 15]
    >>> binary_tree_left_side_view(None)
    []
    """"""

    def depth_first_search(
        root: TreeNode | None, depth: int, left_view: list[int]
    ) -> None:
        """"""
        A depth first search preorder traversal to append the values
        at left side of tree.
        """"""
        if not root:
            return

        if depth == len(left_view):
            left_view.append(root.val)

        depth_first_search(root.left, depth + 1, left_view)
        depth_first_search(root.right, depth + 1, left_view)

    left_view: list = []
    if not root:
        return left_view

    depth_first_search(root, 0, left_view)
    return left_view",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,binary_tree_left_side_view,237
2835,diff_views_of_binary_tree.py::binary_tree_top_side_view::110,"def binary_tree_top_side_view(root: TreeNode) -> list[int]:
    r""""""
    Function returns the top side view of binary tree.

    9 3 20 7
        

      3
     / \
    9   20
       /  \
      15   7

    >>> binary_tree_top_side_view(make_tree())
    [9, 3, 20, 7]
    >>> binary_tree_top_side_view(None)
    []
    """"""

    def breadth_first_search(root: TreeNode, top_view: list[int]) -> None:
        """"""
        A breadth first search traversal with defaultdict ds to append
        the values of tree from top view
        """"""
        queue = [(root, 0)]
        lookup = defaultdict(list)

        while queue:
            first = queue.pop(0)
            node, hd = first

            lookup[hd].append(node.val)

            if node.left:
                queue.append((node.left, hd - 1))
            if node.right:
                queue.append((node.right, hd + 1))

        for pair in sorted(lookup.items(), key=lambda each: each[0]):
            top_view.append(pair[1][0])

    top_view: list = []
    if not root:
        return top_view

    breadth_first_search(root, top_view)
    return top_view",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,binary_tree_top_side_view,291
2836,diff_views_of_binary_tree.py::binary_tree_bottom_side_view::159,"def binary_tree_bottom_side_view(root: TreeNode) -> list[int]:
    r""""""
    Function returns the bottom side view of binary tree

      3
     / \
    9   20
       /  \
      15   7
         
    9 15 20 7

    >>> binary_tree_bottom_side_view(make_tree())
    [9, 15, 20, 7]
    >>> binary_tree_bottom_side_view(None)
    []
    """"""
    from collections import defaultdict

    def breadth_first_search(root: TreeNode, bottom_view: list[int]) -> None:
        """"""
        A breadth first search traversal with defaultdict ds to append
        the values of tree from bottom view
        """"""
        queue = [(root, 0)]
        lookup = defaultdict(list)

        while queue:
            first = queue.pop(0)
            node, hd = first
            lookup[hd].append(node.val)

            if node.left:
                queue.append((node.left, hd - 1))
            if node.right:
                queue.append((node.right, hd + 1))

        for pair in sorted(lookup.items(), key=lambda each: each[0]):
            bottom_view.append(pair[1][-1])

    bottom_view: list = []
    if not root:
        return bottom_view

    breadth_first_search(root, bottom_view)
    return bottom_view",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,binary_tree_bottom_side_view,290
2837,diff_views_of_binary_tree.py::depth_first_search::46,"    def depth_first_search(
        root: TreeNode | None, depth: int, right_view: list[int]
    ) -> None:
        """"""
        A depth first search preorder traversal to append the values at
        right side of tree.
        """"""
        if not root:
            return

        if depth == len(right_view):
            right_view.append(root.val)

        depth_first_search(root.right, depth + 1, right_view)
        depth_first_search(root.left, depth + 1, right_view)",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,depth_first_search,104
2838,diff_views_of_binary_tree.py::depth_first_search::86,"    def depth_first_search(
        root: TreeNode | None, depth: int, left_view: list[int]
    ) -> None:
        """"""
        A depth first search preorder traversal to append the values
        at left side of tree.
        """"""
        if not root:
            return

        if depth == len(left_view):
            left_view.append(root.val)

        depth_first_search(root.left, depth + 1, left_view)
        depth_first_search(root.right, depth + 1, left_view)",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,depth_first_search,104
2839,diff_views_of_binary_tree.py::breadth_first_search::129,"    def breadth_first_search(root: TreeNode, top_view: list[int]) -> None:
        """"""
        A breadth first search traversal with defaultdict ds to append
        the values of tree from top view
        """"""
        queue = [(root, 0)]
        lookup = defaultdict(list)

        while queue:
            first = queue.pop(0)
            node, hd = first

            lookup[hd].append(node.val)

            if node.left:
                queue.append((node.left, hd - 1))
            if node.right:
                queue.append((node.right, hd + 1))

        for pair in sorted(lookup.items(), key=lambda each: each[0]):
            top_view.append(pair[1][0])",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,breadth_first_search,147
2840,diff_views_of_binary_tree.py::breadth_first_search::178,"    def breadth_first_search(root: TreeNode, bottom_view: list[int]) -> None:
        """"""
        A breadth first search traversal with defaultdict ds to append
        the values of tree from bottom view
        """"""
        queue = [(root, 0)]
        lookup = defaultdict(list)

        while queue:
            first = queue.pop(0)
            node, hd = first
            lookup[hd].append(node.val)

            if node.left:
                queue.append((node.left, hd - 1))
            if node.right:
                queue.append((node.right, hd + 1))

        for pair in sorted(lookup.items(), key=lambda each: each[0]):
            bottom_view.append(pair[1][-1])",data\repos\Python\data_structures\binary_tree\diff_views_of_binary_tree.py,breadth_first_search,147
2841,distribute_coins.py::distribute_coins::58,"def distribute_coins(root: TreeNode | None) -> int:
    """"""
    >>> distribute_coins(TreeNode(3, TreeNode(0), TreeNode(0)))
    2
    >>> distribute_coins(TreeNode(0, TreeNode(3), TreeNode(0)))
    3
    >>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(3)))
    3
    >>> distribute_coins(None)
    0
    >>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(0)))
    Traceback (most recent call last):
     ...
    ValueError: The nodes number should be same as the number of coins
    >>> distribute_coins(TreeNode(0, TreeNode(1), TreeNode(1)))
    Traceback (most recent call last):
     ...
    ValueError: The nodes number should be same as the number of coins
    """"""

    if root is None:
        return 0

    # Validation
    def count_nodes(node: TreeNode | None) -> int:
        """"""
        >>> count_nodes(None)
        0
        """"""
        if node is None:
            return 0

        return count_nodes(node.left) + count_nodes(node.right) + 1

    def count_coins(node: TreeNode | None) -> int:
        """"""
        >>> count_coins(None)
        0
        """"""
        if node is None:
            return 0

        return count_coins(node.left) + count_coins(node.right) + node.data

    if count_nodes(root) != count_coins(root):
        raise ValueError(""The nodes number should be same as the number of coins"")

    # Main calculation
    def get_distrib(node: TreeNode | None) -> CoinsDistribResult:
        """"""
        >>> get_distrib(None)
        namedtuple(""CoinsDistribResult"", ""0 2"")
        """"""

        if node is None:
            return CoinsDistribResult(0, 1)

        left_distrib_moves, left_distrib_excess = get_distrib(node.left)
        right_distrib_moves, right_distrib_excess = get_distrib(node.right)

        coins_to_left = 1 - left_distrib_excess
        coins_to_right = 1 - right_distrib_excess

        result_moves = (
            left_distrib_moves
            + right_distrib_moves
            + abs(coins_to_left)
            + abs(coins_to_right)
        )
        result_excess = node.data - coins_to_left - coins_to_right

        return CoinsDistribResult(result_moves, result_excess)

    return get_distrib(root)[0]",data\repos\Python\data_structures\binary_tree\distribute_coins.py,distribute_coins,536
2842,distribute_coins.py::count_nodes::82,"    def count_nodes(node: TreeNode | None) -> int:
        """"""
        >>> count_nodes(None)
        0
        """"""
        if node is None:
            return 0

        return count_nodes(node.left) + count_nodes(node.right) + 1",data\repos\Python\data_structures\binary_tree\distribute_coins.py,count_nodes,54
2843,distribute_coins.py::count_coins::92,"    def count_coins(node: TreeNode | None) -> int:
        """"""
        >>> count_coins(None)
        0
        """"""
        if node is None:
            return 0

        return count_coins(node.left) + count_coins(node.right) + node.data",data\repos\Python\data_structures\binary_tree\distribute_coins.py,count_coins,58
2844,distribute_coins.py::get_distrib::106,"    def get_distrib(node: TreeNode | None) -> CoinsDistribResult:
        """"""
        >>> get_distrib(None)
        namedtuple(""CoinsDistribResult"", ""0 2"")
        """"""

        if node is None:
            return CoinsDistribResult(0, 1)

        left_distrib_moves, left_distrib_excess = get_distrib(node.left)
        right_distrib_moves, right_distrib_excess = get_distrib(node.right)

        coins_to_left = 1 - left_distrib_excess
        coins_to_right = 1 - right_distrib_excess

        result_moves = (
            left_distrib_moves
            + right_distrib_moves
            + abs(coins_to_left)
            + abs(coins_to_right)
        )
        result_excess = node.data - coins_to_left - coins_to_right

        return CoinsDistribResult(result_moves, result_excess)",data\repos\Python\data_structures\binary_tree\distribute_coins.py,get_distrib,188
2845,fenwick_tree.py::init::28,"    def init(self, arr: list[int]) -> None:
        """"""
        Initialize the Fenwick tree with arr in O(N)

        Parameters:
            arr (list): list of elements to initialize the tree with

        Returns:
            None

        >>> a = [1, 2, 3, 4, 5]
        >>> f1 = FenwickTree(a)
        >>> f2 = FenwickTree(size=len(a))
        >>> for index, value in enumerate(a):
        ...     f2.add(index, value)
        >>> f1.tree == f2.tree
        True
        """"""
        self.size = len(arr)
        self.tree = deepcopy(arr)
        for i in range(1, self.size):
            j = self.next_(i)
            if j < self.size:
                self.tree[j] += self.tree[i]",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,init,176
2846,fenwick_tree.py::get_array::53,"    def get_array(self) -> list[int]:
        """"""
        Get the Normal Array of the Fenwick tree in O(N)

        Returns:
            list: Normal Array of the Fenwick tree

        >>> a = [i for i in range(128)]
        >>> f = FenwickTree(a)
        >>> f.get_array() == a
        True
        """"""
        arr = self.tree[:]
        for i in range(self.size - 1, 0, -1):
            j = self.next_(i)
            if j < self.size:
                arr[j] -= arr[i]
        return arr",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,get_array,125
2847,fenwick_tree.py::add::80,"    def add(self, index: int, value: int) -> None:
        """"""
        Add a value to index in O(lg N)

        Parameters:
            index (int): index to add value to
            value (int): value to add to index

        Returns:
            None

        >>> f = FenwickTree([1, 2, 3, 4, 5])
        >>> f.add(0, 1)
        >>> f.add(1, 2)
        >>> f.add(2, 3)
        >>> f.add(3, 4)
        >>> f.add(4, 5)
        >>> f.get_array()
        [2, 4, 6, 8, 10]
        """"""
        if index == 0:
            self.tree[0] += value
            return
        while index < self.size:
            self.tree[index] += value
            index = self.next_(index)",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,add,199
2848,fenwick_tree.py::update::107,"    def update(self, index: int, value: int) -> None:
        """"""
        Set the value of index in O(lg N)

        Parameters:
            index (int): index to set value to
            value (int): value to set in index

        Returns:
            None

        >>> f = FenwickTree([5, 4, 3, 2, 1])
        >>> f.update(0, 1)
        >>> f.update(1, 2)
        >>> f.update(2, 3)
        >>> f.update(3, 4)
        >>> f.update(4, 5)
        >>> f.get_array()
        [1, 2, 3, 4, 5]
        """"""
        self.add(index, value - self.get(index))",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,update,168
2849,fenwick_tree.py::prefix::129,"    def prefix(self, right: int) -> int:
        """"""
        Prefix sum of all elements in [0, right) in O(lg N)

        Parameters:
            right (int): right bound of the query (exclusive)

        Returns:
            int: sum of all elements in [0, right)

        >>> a = [i for i in range(128)]
        >>> f = FenwickTree(a)
        >>> res = True
        >>> for i in range(len(a)):
        ...     res = res and f.prefix(i) == sum(a[:i])
        >>> res
        True
        """"""
        if right == 0:
            return 0
        result = self.tree[0]
        right -= 1  # make right inclusive
        while right > 0:
            result += self.tree[right]
            right = self.prev(right)
        return result",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,prefix,182
2850,fenwick_tree.py::query::156,"    def query(self, left: int, right: int) -> int:
        """"""
        Query the sum of all elements in [left, right) in O(lg N)

        Parameters:
            left (int): left bound of the query (inclusive)
            right (int): right bound of the query (exclusive)

        Returns:
            int: sum of all elements in [left, right)

        >>> a = [i for i in range(128)]
        >>> f = FenwickTree(a)
        >>> res = True
        >>> for i in range(len(a)):
        ...     for j in range(i + 1, len(a)):
        ...         res = res and f.query(i, j) == sum(a[i:j])
        >>> res
        True
        """"""
        return self.prefix(right) - self.prefix(left)",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,query,173
2851,fenwick_tree.py::get::178,"    def get(self, index: int) -> int:
        """"""
        Get value at index in O(lg N)

        Parameters:
            index (int): index to get the value

        Returns:
            int: Value of element at index

        >>> a = [i for i in range(128)]
        >>> f = FenwickTree(a)
        >>> res = True
        >>> for i in range(len(a)):
        ...     res = res and f.get(i) == a[i]
        >>> res
        True
        """"""
        return self.query(index, index + 1)",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,get,123
2852,fenwick_tree.py::rank_query::198,"    def rank_query(self, value: int) -> int:
        """"""
        Find the largest index with prefix(i) <= value in O(lg N)
        NOTE: Requires that all values are non-negative!

        Parameters:
            value (int): value to find the largest index of

        Returns:
            -1: if value is smaller than all elements in prefix sum
            int: largest index with prefix(i) <= value

        >>> f = FenwickTree([1, 2, 0, 3, 0, 5])
        >>> f.rank_query(0)
        -1
        >>> f.rank_query(2)
        0
        >>> f.rank_query(1)
        0
        >>> f.rank_query(3)
        2
        >>> f.rank_query(5)
        2
        >>> f.rank_query(6)
        4
        >>> f.rank_query(11)
        5
        """"""
        value -= self.tree[0]
        if value < 0:
            return -1

        j = 1  # Largest power of 2 <= size
        while j * 2 < self.size:
            j *= 2

        i = 0

        while j > 0:
            if i + j < self.size and self.tree[i + j] <= value:
                value -= self.tree[i + j]
                i += j
            j //= 2
        return i",data\repos\Python\data_structures\binary_tree\fenwick_tree.py,rank_query,305
2853,flatten_binarytree_to_linkedlist.py::build_tree::29,"def build_tree() -> TreeNode:
    """"""
    Build and return a sample binary tree.

    Returns:
        TreeNode: The root of the binary tree.

    Examples:
        >>> root = build_tree()
        >>> root.data
        1
        >>> root.left.data
        2
        >>> root.right.data
        5
        >>> root.left.left.data
        3
        >>> root.left.right.data
        4
        >>> root.right.right.data
        6
    """"""
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(5)
    root.left.left = TreeNode(3)
    root.left.right = TreeNode(4)
    root.right.right = TreeNode(6)
    return root",data\repos\Python\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py,build_tree,158
2854,flatten_binarytree_to_linkedlist.py::flatten::60,"def flatten(root: TreeNode | None) -> None:
    """"""
    Flatten a binary tree into a linked list in-place, where the linked list is
    represented using the right pointers of the tree nodes.

    Args:
        root (TreeNode): The root of the binary tree to be flattened.

    Examples:
        >>> root = TreeNode(1)
        >>> root.left = TreeNode(2)
        >>> root.right = TreeNode(5)
        >>> root.left.left = TreeNode(3)
        >>> root.left.right = TreeNode(4)
        >>> root.right.right = TreeNode(6)
        >>> flatten(root)
        >>> root.data
        1
        >>> root.right.right is None
        False
        >>> root.right.right = TreeNode(3)
        >>> root.right.right.right is None
        True
    """"""
    if not root:
        return

    # Flatten the left subtree
    flatten(root.left)

    # Save the right subtree
    right_subtree = root.right

    # Make the left subtree the new right subtree
    root.right = root.left
    root.left = None

    # Find the end of the new right subtree
    current = root
    while current.right:
        current = current.right

    # Append the original right subtree to the end
    current.right = right_subtree

    # Flatten the updated right subtree
    flatten(right_subtree)",data\repos\Python\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py,flatten,287
2855,flatten_binarytree_to_linkedlist.py::display_linked_list::109,"def display_linked_list(root: TreeNode | None) -> None:
    """"""
    Display the flattened linked list.

    Args:
        root (TreeNode | None): The root of the flattened linked list.

    Examples:
        >>> root = TreeNode(1)
        >>> root.right = TreeNode(2)
        >>> root.right.right = TreeNode(3)
        >>> display_linked_list(root)
        1 2 3
        >>> root = None
        >>> display_linked_list(root)

    """"""
    current = root
    while current:
        if current.right is None:
            print(current.data, end="""")
            break
        print(current.data, end="" "")
        current = current.right",data\repos\Python\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py,display_linked_list,139
2856,floor_and_ceiling.py::floor_ceiling::36,"def floor_ceiling(root: Node | None, key: int) -> tuple[int | None, int | None]:
    """"""
    Find the floor and ceiling values for a given key in a Binary Search Tree (BST).

    Args:
        root: The root of the binary search tree.
        key: The key for which to find the floor and ceiling.

    Returns:
        A tuple containing the floor and ceiling values, respectively.

    Examples:
        >>> root = Node(10)
        >>> root.left = Node(5)
        >>> root.right = Node(20)
        >>> root.left.left = Node(3)
        >>> root.left.right = Node(7)
        >>> root.right.left = Node(15)
        >>> root.right.right = Node(25)
        >>> tuple(root)
        (3, 5, 7, 10, 15, 20, 25)
        >>> floor_ceiling(root, 8)
        (7, 10)
        >>> floor_ceiling(root, 14)
        (10, 15)
        >>> floor_ceiling(root, -1)
        (None, 3)
        >>> floor_ceiling(root, 30)
        (25, None)
    """"""
    floor_val = None
    ceiling_val = None

    while root:
        if root.key == key:
            floor_val = root.key
            ceiling_val = root.key
            break

        if key < root.key:
            ceiling_val = root.key
            root = root.left
        else:
            floor_val = root.key
            root = root.right

    return floor_val, ceiling_val",data\repos\Python\data_structures\binary_tree\floor_and_ceiling.py,floor_ceiling,336
2857,inorder_tree_traversal_2022.py::insert::17,"def insert(node: BinaryTreeNode | None, new_value: int) -> BinaryTreeNode | None:
    """"""
    If the binary search tree is empty, make a new node and declare it as root.
    >>> node_a = BinaryTreeNode(12345)
    >>> node_b = insert(node_a, 67890)
    >>> node_a.left_child == node_b.left_child
    True
    >>> node_a.right_child == node_b.right_child
    True
    >>> node_a.data == node_b.data
    True
    """"""
    if node is None:
        node = BinaryTreeNode(new_value)
        return node

    # binary search tree is not empty,
    # so we will insert it into the tree
    # if new_value is less than value of data in node,
    #  add it to left subtree and proceed recursively
    if new_value < node.data:
        node.left_child = insert(node.left_child, new_value)
    else:
        # if new_value is greater than value of data in node,
        #  add it to right subtree and proceed recursively
        node.right_child = insert(node.right_child, new_value)
    return node",data\repos\Python\data_structures\binary_tree\inorder_tree_traversal_2022.py,insert,240
2858,inorder_tree_traversal_2022.py::inorder::46,"def inorder(node: None | BinaryTreeNode) -> list[int]:  # if node is None,return
    """"""
    >>> inorder(make_tree())
    [6, 10, 14, 15, 20, 25, 60]
    """"""
    if node:
        inorder_array = inorder(node.left_child)
        inorder_array = [*inorder_array, node.data]
        inorder_array = inorder_array + inorder(node.right_child)
    else:
        inorder_array = []
    return inorder_array",data\repos\Python\data_structures\binary_tree\inorder_tree_traversal_2022.py,inorder,103
2859,inorder_tree_traversal_2022.py::make_tree::60,"def make_tree() -> BinaryTreeNode | None:
    root = insert(None, 15)
    insert(root, 10)
    insert(root, 25)
    insert(root, 6)
    insert(root, 14)
    insert(root, 20)
    insert(root, 60)
    return root",data\repos\Python\data_structures\binary_tree\inorder_tree_traversal_2022.py,make_tree,64
2860,inorder_tree_traversal_2022.py::main::71,"def main() -> None:
    # main function
    root = make_tree()
    print(""Printing values of binary search tree in Inorder Traversal."")
    inorder(root)",data\repos\Python\data_structures\binary_tree\inorder_tree_traversal_2022.py,main,36
2861,is_sorted.py::is_sorted::48,"    def is_sorted(self) -> bool:
        """"""
        >>> Node(data='abc').is_sorted
        True
        >>> Node(data=2,
        ...      left=Node(data=1.999),
        ...      right=Node(data=3)).is_sorted
        True
        >>> Node(data=0,
        ...      left=Node(data=0),
        ...      right=Node(data=0)).is_sorted
        True
        >>> Node(data=0,
        ...      left=Node(data=-11),
        ...      right=Node(data=3)).is_sorted
        True
        >>> Node(data=5,
        ...      left=Node(data=1),
        ...      right=Node(data=4, left=Node(data=3))).is_sorted
        False
        >>> Node(data='a',
        ...      left=Node(data=1),
        ...      right=Node(data=4, left=Node(data=3))).is_sorted
        Traceback (most recent call last):
            ...
        TypeError: '<' not supported between instances of 'str' and 'int'
        >>> Node(data=2,
        ...      left=Node([]),
        ...      right=Node(data=4, left=Node(data=3))).is_sorted
        Traceback (most recent call last):
            ...
        TypeError: '<' not supported between instances of 'int' and 'list'
        """"""
        if self.left and (self.data < self.left.data or not self.left.is_sorted):
            return False
        return not (
            self.right and (self.data > self.right.data or not self.right.is_sorted)
        )",data\repos\Python\data_structures\binary_tree\is_sorted.py,is_sorted,342
2862,is_sum_tree.py::is_sum_node::46,"    def is_sum_node(self) -> bool:
        """"""
        >>> root = Node(3)
        >>> root.is_sum_node
        True
        >>> root.left = Node(1)
        >>> root.is_sum_node
        False
        >>> root.right = Node(2)
        >>> root.is_sum_node
        True
        """"""
        if not self.left and not self.right:
            return True  # leaf nodes are considered sum nodes
        left_sum = sum(self.left) if self.left else 0
        right_sum = sum(self.right) if self.right else 0
        return all(
            (
                self.data == left_sum + right_sum,
                self.left.is_sum_node if self.left else True,
                self.right.is_sum_node if self.right else True,
            )
        )",data\repos\Python\data_structures\binary_tree\is_sum_tree.py,is_sum_node,166
2863,is_sum_tree.py::is_sum_tree::99,"    def is_sum_tree(self) -> bool:
        """"""
        >>> BinaryTree.build_a_tree().is_sum_tree
        False
        >>> BinaryTree.build_a_sum_tree().is_sum_tree
        True
        """"""
        return self.root.is_sum_node",data\repos\Python\data_structures\binary_tree\is_sum_tree.py,is_sum_tree,50
2864,is_sum_tree.py::build_a_tree::109,"    def build_a_tree(cls) -> BinaryTree:
        r""""""
        Create a binary tree with the specified structure:
              11
           /     \
          2       29
         / \     /  \
        1   7  15    40
                       \
                        35
        >>> list(BinaryTree.build_a_tree())
        [1, 2, 7, 11, 15, 29, 35, 40]
        """"""
        tree = BinaryTree(Node(11))
        root = tree.root
        root.left = Node(2)
        root.right = Node(29)
        root.left.left = Node(1)
        root.left.right = Node(7)
        root.right.left = Node(15)
        root.right.right = Node(40)
        root.right.right.left = Node(35)
        return tree",data\repos\Python\data_structures\binary_tree\is_sum_tree.py,build_a_tree,179
2865,is_sum_tree.py::build_a_sum_tree::134,"    def build_a_sum_tree(cls) -> BinaryTree:
        r""""""
        Create a binary tree with the specified structure:
             26
            /  \
          10    3
         /  \    \
        4    6    3
        >>> list(BinaryTree.build_a_sum_tree())
        [4, 10, 6, 26, 3, 3]
        """"""
        tree = BinaryTree(Node(26))
        root = tree.root
        root.left = Node(10)
        root.right = Node(3)
        root.left.left = Node(4)
        root.left.right = Node(6)
        root.right.right = Node(3)
        return tree",data\repos\Python\data_structures\binary_tree\is_sum_tree.py,build_a_sum_tree,146
2866,lazy_segment_tree.py::left::15,"    def left(self, idx: int) -> int:
        """"""
        >>> segment_tree = SegmentTree(15)
        >>> segment_tree.left(1)
        2
        >>> segment_tree.left(2)
        4
        >>> segment_tree.left(12)
        24
        """"""
        return idx * 2",data\repos\Python\data_structures\binary_tree\lazy_segment_tree.py,left,68
2867,lazy_segment_tree.py::right::27,"    def right(self, idx: int) -> int:
        """"""
        >>> segment_tree = SegmentTree(15)
        >>> segment_tree.right(1)
        3
        >>> segment_tree.right(2)
        5
        >>> segment_tree.right(12)
        25
        """"""
        return idx * 2 + 1",data\repos\Python\data_structures\binary_tree\lazy_segment_tree.py,right,71
2868,lazy_segment_tree.py::build::39,"    def build(
        self, idx: int, left_element: int, right_element: int, a: list[int]
    ) -> None:
        if left_element == right_element:
            self.segment_tree[idx] = a[left_element - 1]
        else:
            mid = (left_element + right_element) // 2
            self.build(self.left(idx), left_element, mid, a)
            self.build(self.right(idx), mid + 1, right_element, a)
            self.segment_tree[idx] = max(
                self.segment_tree[self.left(idx)], self.segment_tree[self.right(idx)]
            )",data\repos\Python\data_structures\binary_tree\lazy_segment_tree.py,build,127
2869,lazy_segment_tree.py::update::52,"    def update(
        self, idx: int, left_element: int, right_element: int, a: int, b: int, val: int
    ) -> bool:
        """"""
        update with O(lg n) (Normal segment tree without lazy update will take O(nlg n)
        for each update)

        update(1, 1, size, a, b, v) for update val v to [a,b]
        """"""
        if self.flag[idx] is True:
            self.segment_tree[idx] = self.lazy[idx]
            self.flag[idx] = False
            if left_element != right_element:
                self.lazy[self.left(idx)] = self.lazy[idx]
                self.lazy[self.right(idx)] = self.lazy[idx]
                self.flag[self.left(idx)] = True
                self.flag[self.right(idx)] = True

        if right_element < a or left_element > b:
            return True
        if left_element >= a and right_element <= b:
            self.segment_tree[idx] = val
            if left_element != right_element:
                self.lazy[self.left(idx)] = val
                self.lazy[self.right(idx)] = val
                self.flag[self.left(idx)] = True
                self.flag[self.right(idx)] = True
            return True
        mid = (left_element + right_element) // 2
        self.update(self.left(idx), left_element, mid, a, b, val)
        self.update(self.right(idx), mid + 1, right_element, a, b, val)
        self.segment_tree[idx] = max(
            self.segment_tree[self.left(idx)], self.segment_tree[self.right(idx)]
        )
        return True",data\repos\Python\data_structures\binary_tree\lazy_segment_tree.py,update,345
2870,lazy_segment_tree.py::query::89,"    def query(
        self, idx: int, left_element: int, right_element: int, a: int, b: int
    ) -> int | float:
        """"""
        query(1, 1, size, a, b) for query max of [a,b]
        >>> A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]
        >>> segment_tree = SegmentTree(15)
        >>> segment_tree.build(1, 1, 15, A)
        >>> segment_tree.query(1, 1, 15, 4, 6)
        7
        >>> segment_tree.query(1, 1, 15, 7, 11)
        14
        >>> segment_tree.query(1, 1, 15, 7, 12)
        15
        """"""
        if self.flag[idx] is True:
            self.segment_tree[idx] = self.lazy[idx]
            self.flag[idx] = False
            if left_element != right_element:
                self.lazy[self.left(idx)] = self.lazy[idx]
                self.lazy[self.right(idx)] = self.lazy[idx]
                self.flag[self.left(idx)] = True
                self.flag[self.right(idx)] = True
        if right_element < a or left_element > b:
            return -math.inf
        if left_element >= a and right_element <= b:
            return self.segment_tree[idx]
        mid = (left_element + right_element) // 2
        q1 = self.query(self.left(idx), left_element, mid, a, b)
        q2 = self.query(self.right(idx), mid + 1, right_element, a, b)
        return max(q1, q2)",data\repos\Python\data_structures\binary_tree\lazy_segment_tree.py,query,390
2871,lowest_common_ancestor.py::swap::9,"def swap(a: int, b: int) -> tuple[int, int]:
    """"""
    Return a tuple (b, a) when given two integers a and b
    >>> swap(2,3)
    (3, 2)
    >>> swap(3,4)
    (4, 3)
    >>> swap(67, 12)
    (12, 67)
    >>> swap(3,-4)
    (-4, 3)
    """"""
    a ^= b
    b ^= a
    a ^= b
    return a, b",data\repos\Python\data_structures\binary_tree\lowest_common_ancestor.py,swap,118
2872,lowest_common_ancestor.py::create_sparse::27,"def create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:
    """"""
    creating sparse table which saves each nodes 2^i-th parent
    >>> max_node = 6
    >>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range(19)]
    >>> parent = create_sparse(max_node=max_node, parent=parent)
    >>> parent[0]
    [0, 0, 1, 1, 2, 2, 3]
    >>> parent[1]
    [0, 0, 0, 0, 1, 1, 1]
    >>> parent[2]
    [0, 0, 0, 0, 0, 0, 0]

    >>> max_node = 1
    >>> parent = [[0, 0]] + [[0] * 2 for _ in range(19)]
    >>> parent = create_sparse(max_node=max_node, parent=parent)
    >>> parent[0]
    [0, 0]
    >>> parent[1]
    [0, 0]
    """"""
    j = 1
    while (1 << j) < max_node:
        for i in range(1, max_node + 1):
            parent[j][i] = parent[j - 1][parent[j - 1][i]]
        j += 1
    return parent",data\repos\Python\data_structures\binary_tree\lowest_common_ancestor.py,create_sparse,318
2873,lowest_common_ancestor.py::lowest_common_ancestor::57,"def lowest_common_ancestor(
    u: int, v: int, level: list[int], parent: list[list[int]]
) -> int:
    """"""
    Return the lowest common ancestor between u and v

    >>> level = [-1, 0, 1, 1, 2, 2, 2]
    >>> parent = [[0, 0, 1, 1, 2, 2, 3],[0, 0, 0, 0, 1, 1, 1]] + \
                    [[0] * 7 for _ in range(17)]
    >>> lowest_common_ancestor(u=4, v=5, level=level, parent=parent)
    2
    >>> lowest_common_ancestor(u=4, v=6, level=level, parent=parent)
    1
    >>> lowest_common_ancestor(u=2, v=3, level=level, parent=parent)
    1
    >>> lowest_common_ancestor(u=6, v=6, level=level, parent=parent)
    6
    """"""
    # u must be deeper in the tree than v
    if level[u] < level[v]:
        u, v = swap(u, v)
    # making depth of u same as depth of v
    for i in range(18, -1, -1):
        if level[u] - (1 << i) >= level[v]:
            u = parent[i][u]
    # at the same depth if u==v that mean lca is found
    if u == v:
        return u
    # moving both nodes upwards till lca in found
    for i in range(18, -1, -1):
        if parent[i][u] not in [0, parent[i][v]]:
            u, v = parent[i][u], parent[i][v]
    # returning longest common ancestor of u,v
    return parent[0][u]",data\repos\Python\data_structures\binary_tree\lowest_common_ancestor.py,lowest_common_ancestor,418
2874,lowest_common_ancestor.py::breadth_first_search::94,"def breadth_first_search(
    level: list[int],
    parent: list[list[int]],
    max_node: int,
    graph: dict[int, list[int]],
    root: int = 1,
) -> tuple[list[int], list[list[int]]]:
    """"""
    sets every nodes direct parent
    parent of root node is set to 0
    calculates depth of each node from root node
    >>> level = [-1] * 7
    >>> parent = [[0] * 7 for _ in range(20)]
    >>> graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: []}
    >>> level, parent = breadth_first_search(
    ...     level=level, parent=parent, max_node=6, graph=graph, root=1)
    >>> level
    [-1, 0, 1, 1, 2, 2, 2]
    >>> parent[0]
    [0, 0, 1, 1, 2, 2, 3]


    >>> level = [-1] * 2
    >>> parent = [[0] * 2 for _ in range(20)]
    >>> graph = {1: []}
    >>> level, parent = breadth_first_search(
    ...     level=level, parent=parent, max_node=1, graph=graph, root=1)
    >>> level
    [-1, 0]
    >>> parent[0]
    [0, 0]
    """"""
    level[root] = 0
    q: Queue[int] = Queue(maxsize=max_node)
    q.put(root)
    while q.qsize() != 0:
        u = q.get()
        for v in graph[u]:
            if level[v] == -1:
                level[v] = level[u] + 1
                q.put(v)
                parent[0][v] = u
    return level, parent",data\repos\Python\data_structures\binary_tree\lowest_common_ancestor.py,breadth_first_search,426
2875,lowest_common_ancestor.py::main::139,"def main() -> None:
    max_node = 13
    # initializing with 0
    parent = [[0 for _ in range(max_node + 10)] for _ in range(20)]
    # initializing with -1 which means every node is unvisited
    level = [-1 for _ in range(max_node + 10)]
    graph: dict[int, list[int]] = {
        1: [2, 3, 4],
        2: [5],
        3: [6, 7],
        4: [8],
        5: [9, 10],
        6: [11],
        7: [],
        8: [12, 13],
        9: [],
        10: [],
        11: [],
        12: [],
        13: [],
    }
    level, parent = breadth_first_search(level, parent, max_node, graph, 1)
    parent = create_sparse(max_node, parent)
    print(""LCA of node 1 and 3 is: "", lowest_common_ancestor(1, 3, level, parent))
    print(""LCA of node 5 and 6 is: "", lowest_common_ancestor(5, 6, level, parent))
    print(""LCA of node 7 and 11 is: "", lowest_common_ancestor(7, 11, level, parent))
    print(""LCA of node 6 and 7 is: "", lowest_common_ancestor(6, 7, level, parent))
    print(""LCA of node 4 and 12 is: "", lowest_common_ancestor(4, 12, level, parent))
    print(""LCA of node 8 and 8 is: "", lowest_common_ancestor(8, 8, level, parent))",data\repos\Python\data_structures\binary_tree\lowest_common_ancestor.py,main,382
2876,maximum_fenwick_tree.py::get_next::54,"    def get_next(index: int) -> int:
        """"""
        Get next index in O(1)
        """"""
        return index | (index + 1)",data\repos\Python\data_structures\binary_tree\maximum_fenwick_tree.py,get_next,34
2877,maximum_fenwick_tree.py::get_prev::61,"    def get_prev(index: int) -> int:
        """"""
        Get previous index in O(1)
        """"""
        return (index & (index + 1)) - 1",data\repos\Python\data_structures\binary_tree\maximum_fenwick_tree.py,get_prev,38
2878,maximum_fenwick_tree.py::update::67,"    def update(self, index: int, value: int) -> None:
        """"""
        Set index to value in O(lg^2 N)

        Parameters:
            index: index to update
            value: value to set

        Returns:
            None
        """"""
        self.arr[index] = value
        while index < self.size:
            current_left_border = self.get_prev(index) + 1
            if current_left_border == index:
                self.tree[index] = value
            else:
                self.tree[index] = max(value, current_left_border, index)
            index = self.get_next(index)",data\repos\Python\data_structures\binary_tree\maximum_fenwick_tree.py,update,127
2879,maximum_fenwick_tree.py::query::87,"    def query(self, left: int, right: int) -> int:
        """"""
        Answer the query of maximum range [l, r) in O(lg^2 N)

        Parameters:
            left: left index of query range (inclusive)
            right: right index of query range (exclusive)

        Returns:
            Maximum value of range [left, right)
        """"""
        right -= 1  # Because of right is exclusive
        result = 0
        while left <= right:
            current_left = self.get_prev(right)
            if left <= current_left:
                result = max(result, self.tree[right])
                right = current_left
            else:
                result = max(result, self.arr[right])
                right -= 1
        return result",data\repos\Python\data_structures\binary_tree\maximum_fenwick_tree.py,query,157
2880,maximum_sum_bst.py::max_sum_bst::17,"def max_sum_bst(root: TreeNode | None) -> int:
    """"""
    The solution traverses a binary tree to find the maximum sum of
    keys in any subtree that is a Binary Search Tree (BST). It uses
    recursion to validate BST properties and calculates sums, returning
    the highest sum found among all valid BST subtrees.

    >>> t1 = TreeNode(4)
    >>> t1.left = TreeNode(3)
    >>> t1.left.left = TreeNode(1)
    >>> t1.left.right = TreeNode(2)
    >>> print(max_sum_bst(t1))
    2
    >>> t2 = TreeNode(-4)
    >>> t2.left = TreeNode(-2)
    >>> t2.right = TreeNode(-5)
    >>> print(max_sum_bst(t2))
    0
    >>> t3 = TreeNode(1)
    >>> t3.left = TreeNode(4)
    >>> t3.left.left = TreeNode(2)
    >>> t3.left.right = TreeNode(4)
    >>> t3.right = TreeNode(3)
    >>> t3.right.left = TreeNode(2)
    >>> t3.right.right = TreeNode(5)
    >>> t3.right.right.left = TreeNode(4)
    >>> t3.right.right.right = TreeNode(6)
    >>> print(max_sum_bst(t3))
    20
    """"""
    ans: int = 0

    def solver(node: TreeNode | None) -> tuple[bool, int, int, int]:
        """"""
        Returns the maximum sum by making recursive calls
        >>> t1 = TreeNode(1)
        >>> print(solver(t1))
        1
        """"""
        nonlocal ans

        if not node:
            return True, INT_MAX, INT_MIN, 0  # Valid BST, min, max, sum

        is_left_valid, min_left, max_left, sum_left = solver(node.left)
        is_right_valid, min_right, max_right, sum_right = solver(node.right)

        if is_left_valid and is_right_valid and max_left < node.val < min_right:
            total_sum = sum_left + sum_right + node.val
            ans = max(ans, total_sum)
            return True, min(min_left, node.val), max(max_right, node.val), total_sum

        return False, -1, -1, -1  # Not a valid BST

    solver(root)
    return ans",data\repos\Python\data_structures\binary_tree\maximum_sum_bst.py,max_sum_bst,503
2881,maximum_sum_bst.py::solver::49,"    def solver(node: TreeNode | None) -> tuple[bool, int, int, int]:
        """"""
        Returns the maximum sum by making recursive calls
        >>> t1 = TreeNode(1)
        >>> print(solver(t1))
        1
        """"""
        nonlocal ans

        if not node:
            return True, INT_MAX, INT_MIN, 0  # Valid BST, min, max, sum

        is_left_valid, min_left, max_left, sum_left = solver(node.left)
        is_right_valid, min_right, max_right, sum_right = solver(node.right)

        if is_left_valid and is_right_valid and max_left < node.val < min_right:
            total_sum = sum_left + sum_right + node.val
            ans = max(ans, total_sum)
            return True, min(min_left, node.val), max(max_right, node.val), total_sum

        return False, -1, -1, -1  # Not a valid BST",data\repos\Python\data_structures\binary_tree\maximum_sum_bst.py,solver,204
2882,merge_two_binary_trees.py::merge_two_binary_trees::23,"def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:
    """"""
    Returns root node of the merged tree.

    >>> tree1 = Node(5)
    >>> tree1.left = Node(6)
    >>> tree1.right = Node(7)
    >>> tree1.left.left = Node(2)
    >>> tree2 = Node(4)
    >>> tree2.left = Node(5)
    >>> tree2.right = Node(8)
    >>> tree2.left.right = Node(1)
    >>> tree2.right.right = Node(4)
    >>> merged_tree = merge_two_binary_trees(tree1, tree2)
    >>> print_preorder(merged_tree)
    9
    11
    2
    1
    15
    4
    """"""
    if tree1 is None:
        return tree2
    if tree2 is None:
        return tree1

    tree1.value = tree1.value + tree2.value
    tree1.left = merge_two_binary_trees(tree1.left, tree2.left)
    tree1.right = merge_two_binary_trees(tree1.right, tree2.right)
    return tree1",data\repos\Python\data_structures\binary_tree\merge_two_binary_trees.py,merge_two_binary_trees,251
2883,merge_two_binary_trees.py::print_preorder::56,"def print_preorder(root: Node | None) -> None:
    """"""
    Print pre-order traversal of the tree.

    >>> root = Node(1)
    >>> root.left = Node(2)
    >>> root.right = Node(3)
    >>> print_preorder(root)
    1
    2
    3
    >>> print_preorder(root.right)
    3
    """"""
    if root:
        print(root.value)
        print_preorder(root.left)
        print_preorder(root.right)",data\repos\Python\data_structures\binary_tree\merge_two_binary_trees.py,print_preorder,106
2884,mirror_binary_tree.py::make_tree_seven::56,"def make_tree_seven() -> Node:
    r""""""
    Return a binary tree with 7 nodes that looks like this:
    ::

           1
         /   \
        2     3
       / \   / \
      4   5 6   7

    >>> tree_seven = make_tree_seven()
    >>> len(tree_seven)
    7
    >>> list(tree_seven)
    [4, 2, 5, 1, 6, 3, 7]
    """"""
    tree = Node(1)
    tree.left = Node(2)
    tree.right = Node(3)
    tree.left.left = Node(4)
    tree.left.right = Node(5)
    tree.right.left = Node(6)
    tree.right.right = Node(7)
    return tree",data\repos\Python\data_structures\binary_tree\mirror_binary_tree.py,make_tree_seven,177
2885,mirror_binary_tree.py::make_tree_nine::83,"def make_tree_nine() -> Node:
    r""""""
    Return a binary tree with 9 nodes that looks like this:
    ::

            1
           / \
          2   3
         / \   \
        4   5   6
       / \   \
      7   8   9

    >>> tree_nine = make_tree_nine()
    >>> len(tree_nine)
    9
    >>> list(tree_nine)
    [7, 4, 8, 2, 5, 9, 1, 3, 6]
    """"""
    tree = Node(1)
    tree.left = Node(2)
    tree.right = Node(3)
    tree.left.left = Node(4)
    tree.left.right = Node(5)
    tree.right.right = Node(6)
    tree.left.left.left = Node(7)
    tree.left.left.right = Node(8)
    tree.left.right.right = Node(9)
    return tree",data\repos\Python\data_structures\binary_tree\mirror_binary_tree.py,make_tree_nine,215
2886,mirror_binary_tree.py::main::114,"def main() -> None:
    r""""""
    Mirror binary trees with the given root and returns the root

    >>> tree = make_tree_nine()
    >>> tuple(tree)
    (7, 4, 8, 2, 5, 9, 1, 3, 6)
    >>> tuple(tree.mirror())
    (6, 3, 1, 9, 5, 2, 8, 4, 7)

    nine_tree::

            1
           / \
          2   3
         / \   \
        4   5   6
       / \   \
      7   8   9

    The mirrored tree looks like this::

          1
         / \
        3   2
       /   / \
      6   5   4
         /   / \
        9   8   7
    """"""
    trees = {""zero"": Node(0), ""seven"": make_tree_seven(), ""nine"": make_tree_nine()}
    for name, tree in trees.items():
        print(f""      The {name} tree: {tuple(tree)}"")
        # (0,)
        # (4, 2, 5, 1, 6, 3, 7)
        # (7, 4, 8, 2, 5, 9, 1, 3, 6)
        print(f""Mirror of {name} tree: {tuple(tree.mirror())}"")",data\repos\Python\data_structures\binary_tree\mirror_binary_tree.py,main,327
2887,mirror_binary_tree.py::mirror::33,"    def mirror(self) -> Node:
        """"""
        Mirror the binary tree rooted at this node by swapping left and right children.

        >>> tree = Node(0)
        >>> list(tree)
        [0]
        >>> list(tree.mirror())
        [0]
        >>> tree = Node(1, Node(0), Node(3, Node(2), Node(4, None, Node(5))))
        >>> tuple(tree)
        (0, 1, 2, 3, 4, 5)
        >>> tuple(tree.mirror())
        (5, 4, 3, 2, 1, 0)
        """"""
        self.left, self.right = self.right, self.left
        if self.left:
            self.left.mirror()
        if self.right:
            self.right.mirror()
        return self",data\repos\Python\data_structures\binary_tree\mirror_binary_tree.py,mirror,174
2888,non_recursive_segment_tree.py::build::67,"    def build(self) -> None:
        for p in range(self.N - 1, 0, -1):
            self.st[p] = self.fn(self.st[p * 2], self.st[p * 2 + 1])",data\repos\Python\data_structures\binary_tree\non_recursive_segment_tree.py,build,50
2889,non_recursive_segment_tree.py::update::71,"    def update(self, p: int, v: T) -> None:
        """"""
        Update an element in log(N) time
        :param p: position to be update
        :param v: new value

        >>> st = SegmentTree([3, 1, 2, 4], min)
        >>> st.query(0, 3)
        1
        >>> st.update(2, -1)
        >>> st.query(0, 3)
        -1
        """"""
        p += self.N
        self.st[p] = v
        while p > 1:
            p = p // 2
            self.st[p] = self.fn(self.st[p * 2], self.st[p * 2 + 1])",data\repos\Python\data_structures\binary_tree\non_recursive_segment_tree.py,update,160
2890,non_recursive_segment_tree.py::query::90,"    def query(self, left: int, right: int) -> T | None:
        """"""
        Get range query value in log(N) time
        :param left: left element index
        :param right: right element index
        :return: element combined in the range [left, right]

        >>> st = SegmentTree([1, 2, 3, 4], lambda a, b: a + b)
        >>> st.query(0, 2)
        6
        >>> st.query(1, 2)
        5
        >>> st.query(0, 3)
        10
        >>> st.query(2, 3)
        7
        """"""
        left, right = left + self.N, right + self.N

        res: T | None = None
        while left <= right:
            if left % 2 == 1:
                res = self.st[left] if res is None else self.fn(res, self.st[left])
            if right % 2 == 0:
                res = self.st[right] if res is None else self.fn(res, self.st[right])
            left, right = (left + 1) // 2, (right - 1) // 2
        return res",data\repos\Python\data_structures\binary_tree\non_recursive_segment_tree.py,query,266
2891,non_recursive_segment_tree.py::test_all_segments::143,"    def test_all_segments() -> None:
        """"""
        Test all possible segments
        """"""
        for i in range(len(test_array)):
            for j in range(i, len(test_array)):
                min_range = reduce(min, test_array[i : j + 1])
                max_range = reduce(max, test_array[i : j + 1])
                sum_range = reduce(lambda a, b: a + b, test_array[i : j + 1])
                assert min_range == min_segment_tree.query(i, j)
                assert max_range == max_segment_tree.query(i, j)
                assert sum_range == sum_segment_tree.query(i, j)",data\repos\Python\data_structures\binary_tree\non_recursive_segment_tree.py,test_all_segments,133
2892,number_of_possible_binary_trees.py::binomial_coefficient::20,"def binomial_coefficient(n: int, k: int) -> int:
    """"""
    Since Here we Find the Binomial Coefficient:
    https://en.wikipedia.org/wiki/Binomial_coefficient
    C(n,k) = n! / k!(n-k)!
    :param n: 2 times of Number of nodes
    :param k: Number of nodes
    :return:  Integer Value

    >>> binomial_coefficient(4, 2)
    6
    """"""
    result = 1  # To kept the Calculated Value
    # Since C(n, k) = C(n, n-k)
    k = min(k, n - k)
    # Calculate C(n,k)
    for i in range(k):
        result *= n - i
        result //= i + 1
    return result",data\repos\Python\data_structures\binary_tree\number_of_possible_binary_trees.py,binomial_coefficient,175
2893,number_of_possible_binary_trees.py::catalan_number::42,"def catalan_number(node_count: int) -> int:
    """"""
    We can find Catalan number many ways but here we use Binomial Coefficient because it
    does the job in O(n)

    return the Catalan number of n using 2nCn/(n+1).
    :param n: number of nodes
    :return: Catalan number of n nodes

    >>> catalan_number(5)
    42
    >>> catalan_number(6)
    132
    """"""
    return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)",data\repos\Python\data_structures\binary_tree\number_of_possible_binary_trees.py,catalan_number,127
2894,number_of_possible_binary_trees.py::factorial::59,"def factorial(n: int) -> int:
    """"""
    Return the factorial of a number.
    :param n: Number to find the Factorial of.
    :return: Factorial of n.

    >>> import math
    >>> all(factorial(i) == math.factorial(i) for i in range(10))
    True
    >>> factorial(-5)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValueError: factorial() not defined for negative values
    """"""
    if n < 0:
        raise ValueError(""factorial() not defined for negative values"")
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result",data\repos\Python\data_structures\binary_tree\number_of_possible_binary_trees.py,factorial,156
2895,number_of_possible_binary_trees.py::binary_tree_count::81,"def binary_tree_count(node_count: int) -> int:
    """"""
    Return the number of possible of binary trees.
    :param n: number of nodes
    :return: Number of possible binary trees

    >>> binary_tree_count(5)
    5040
    >>> binary_tree_count(6)
    95040
    """"""
    return catalan_number(node_count) * factorial(node_count)",data\repos\Python\data_structures\binary_tree\number_of_possible_binary_trees.py,binary_tree_count,84
2896,red_black_tree.py::color::512,"def color(node: RedBlackTree | None) -> int:
    """"""Returns the color of a node, allowing for None leaves.""""""
    if node is None:
        return 0
    else:
        return node.color",data\repos\Python\data_structures\binary_tree\red_black_tree.py,color,45
2897,red_black_tree.py::test_rotations::526,"def test_rotations() -> bool:
    """"""Test that the rotate_left and rotate_right functions work.""""""
    # Make a tree to test on
    tree = RedBlackTree(0)
    tree.left = RedBlackTree(-10, parent=tree)
    tree.right = RedBlackTree(10, parent=tree)
    tree.left.left = RedBlackTree(-20, parent=tree.left)
    tree.left.right = RedBlackTree(-5, parent=tree.left)
    tree.right.left = RedBlackTree(5, parent=tree.right)
    tree.right.right = RedBlackTree(20, parent=tree.right)
    # Make the right rotation
    left_rot = RedBlackTree(10)
    left_rot.left = RedBlackTree(0, parent=left_rot)
    left_rot.left.left = RedBlackTree(-10, parent=left_rot.left)
    left_rot.left.right = RedBlackTree(5, parent=left_rot.left)
    left_rot.left.left.left = RedBlackTree(-20, parent=left_rot.left.left)
    left_rot.left.left.right = RedBlackTree(-5, parent=left_rot.left.left)
    left_rot.right = RedBlackTree(20, parent=left_rot)
    tree = tree.rotate_left()
    if tree != left_rot:
        return False
    tree = tree.rotate_right()
    tree = tree.rotate_right()
    # Make the left rotation
    right_rot = RedBlackTree(-10)
    right_rot.left = RedBlackTree(-20, parent=right_rot)
    right_rot.right = RedBlackTree(0, parent=right_rot)
    right_rot.right.left = RedBlackTree(-5, parent=right_rot.right)
    right_rot.right.right = RedBlackTree(10, parent=right_rot.right)
    right_rot.right.right.left = RedBlackTree(5, parent=right_rot.right.right)
    right_rot.right.right.right = RedBlackTree(20, parent=right_rot.right.right)
    return tree == right_rot",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_rotations,419
2898,red_black_tree.py::test_insertion_speed::560,"def test_insertion_speed() -> bool:
    """"""Test that the tree balances inserts to O(log(n)) by doing a lot
    of them.
    """"""
    tree = RedBlackTree(-1)
    for i in range(300000):
        tree = tree.insert(i)
    return True",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_insertion_speed,61
2899,red_black_tree.py::test_insert::570,"def test_insert() -> bool:
    """"""Test the insert() method of the tree correctly balances, colors,
    and inserts.
    """"""
    tree = RedBlackTree(0)
    tree.insert(8)
    tree.insert(-8)
    tree.insert(4)
    tree.insert(12)
    tree.insert(10)
    tree.insert(11)
    ans = RedBlackTree(0, 0)
    ans.left = RedBlackTree(-8, 0, ans)
    ans.right = RedBlackTree(8, 1, ans)
    ans.right.left = RedBlackTree(4, 0, ans.right)
    ans.right.right = RedBlackTree(11, 0, ans.right)
    ans.right.right.left = RedBlackTree(10, 1, ans.right.right)
    ans.right.right.right = RedBlackTree(12, 1, ans.right.right)
    return tree == ans",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_insert,192
2900,red_black_tree.py::test_insert_and_search::591,"def test_insert_and_search() -> bool:
    """"""Tests searching through the tree for values.""""""
    tree = RedBlackTree(0)
    tree.insert(8)
    tree.insert(-8)
    tree.insert(4)
    tree.insert(12)
    tree.insert(10)
    tree.insert(11)
    if any(i in tree for i in (5, -6, -10, 13)):
        # Found something not in there
        return False
    # Find all these things in there
    return all(i in tree for i in (11, 12, -8, 0))",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_insert_and_search,127
2901,red_black_tree.py::test_insert_delete::607,"def test_insert_delete() -> bool:
    """"""Test the insert() and delete() method of the tree, verifying the
    insertion and removal of elements, and the balancing of the tree.
    """"""
    tree = RedBlackTree(0)
    tree = tree.insert(-12)
    tree = tree.insert(8)
    tree = tree.insert(-8)
    tree = tree.insert(15)
    tree = tree.insert(4)
    tree = tree.insert(12)
    tree = tree.insert(10)
    tree = tree.insert(9)
    tree = tree.insert(11)
    tree = tree.remove(15)
    tree = tree.remove(-12)
    tree = tree.remove(9)
    if not tree.check_color_properties():
        return False
    return list(tree.inorder_traverse()) == [-8, 0, 4, 8, 10, 11, 12]",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_insert_delete,189
2902,red_black_tree.py::test_floor_ceil::629,"def test_floor_ceil() -> bool:
    """"""Tests the floor and ceiling functions in the tree.""""""
    tree = RedBlackTree(0)
    tree.insert(-16)
    tree.insert(16)
    tree.insert(8)
    tree.insert(24)
    tree.insert(20)
    tree.insert(22)
    tuples = [(-20, None, -16), (-10, -16, 0), (8, 8, 8), (50, 24, None)]
    for val, floor, ceil in tuples:
        if tree.floor(val) != floor or tree.ceil(val) != ceil:
            return False
    return True",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_floor_ceil,137
2903,red_black_tree.py::test_min_max::645,"def test_min_max() -> bool:
    """"""Tests the min and max functions in the tree.""""""
    tree = RedBlackTree(0)
    tree.insert(-16)
    tree.insert(16)
    tree.insert(8)
    tree.insert(24)
    tree.insert(20)
    tree.insert(22)
    return not (tree.get_max() != 22 or tree.get_min() != -16)",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_min_max,85
2904,red_black_tree.py::test_tree_traversal::657,"def test_tree_traversal() -> bool:
    """"""Tests the three different tree traversal functions.""""""
    tree = RedBlackTree(0)
    tree = tree.insert(-16)
    tree.insert(16)
    tree.insert(8)
    tree.insert(24)
    tree.insert(20)
    tree.insert(22)
    if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:
        return False
    if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:
        return False
    return list(tree.postorder_traverse()) == [-16, 8, 20, 24, 22, 16, 0]",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_tree_traversal,167
2905,red_black_tree.py::test_tree_chaining::673,"def test_tree_chaining() -> bool:
    """"""Tests the three different tree chaining functions.""""""
    tree = RedBlackTree(0)
    tree = tree.insert(-16).insert(16).insert(8).insert(24).insert(20).insert(22)
    if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:
        return False
    if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:
        return False
    return list(tree.postorder_traverse()) == [-16, 8, 20, 24, 22, 16, 0]",data\repos\Python\data_structures\binary_tree\red_black_tree.py,test_tree_chaining,157
2906,red_black_tree.py::print_results::684,"def print_results(msg: str, passes: bool) -> None:
    print(str(msg), ""works!"" if passes else ""doesn't work :("")",data\repos\Python\data_structures\binary_tree\red_black_tree.py,print_results,32
2907,red_black_tree.py::pytests::688,"def pytests() -> None:
    assert test_rotations()
    assert test_insert()
    assert test_insert_and_search()
    assert test_insert_delete()
    assert test_floor_ceil()
    assert test_tree_traversal()
    assert test_tree_chaining()",data\repos\Python\data_structures\binary_tree\red_black_tree.py,pytests,52
2908,red_black_tree.py::main::698,"def main() -> None:
    """"""
    >>> pytests()
    """"""
    print_results(""Rotating right and left"", test_rotations())
    print_results(""Inserting"", test_insert())
    print_results(""Searching"", test_insert_and_search())
    print_results(""Deleting"", test_insert_delete())
    print_results(""Floor and ceil"", test_floor_ceil())
    print_results(""Tree traversal"", test_tree_traversal())
    print_results(""Tree traversal"", test_tree_chaining())
    print(""Testing tree balancing..."")
    print(""This should only be a few seconds."")
    test_insertion_speed()
    print(""Done!"")",data\repos\Python\data_structures\binary_tree\red_black_tree.py,main,126
2909,red_black_tree.py::rotate_left::43,"    def rotate_left(self) -> RedBlackTree:
        """"""Rotate the subtree rooted at this node to the left and
        returns the new root to this subtree.
        Performing one rotation can be done in O(1).
        """"""
        parent = self.parent
        right = self.right
        if right is None:
            return self
        self.right = right.left
        if self.right:
            self.right.parent = self
        self.parent = right
        right.left = self
        if parent is not None:
            if parent.left == self:
                parent.left = right
            else:
                parent.right = right
        right.parent = parent
        return right",data\repos\Python\data_structures\binary_tree\red_black_tree.py,rotate_left,139
2910,red_black_tree.py::rotate_right::65,"    def rotate_right(self) -> RedBlackTree:
        """"""Rotate the subtree rooted at this node to the right and
        returns the new root to this subtree.
        Performing one rotation can be done in O(1).
        """"""
        if self.left is None:
            return self
        parent = self.parent
        left = self.left
        self.left = left.right
        if self.left:
            self.left.parent = self
        self.parent = left
        left.right = self
        if parent is not None:
            if parent.right is self:
                parent.right = left
            else:
                parent.left = left
        left.parent = parent
        return left",data\repos\Python\data_structures\binary_tree\red_black_tree.py,rotate_right,140
2911,red_black_tree.py::insert::87,"    def insert(self, label: int) -> RedBlackTree:
        """"""Inserts label into the subtree rooted at self, performs any
        rotations necessary to maintain balance, and then returns the
        new root to this subtree (likely self).
        This is guaranteed to run in O(log(n)) time.
        """"""
        if self.label is None:
            # Only possible with an empty tree
            self.label = label
            return self
        if self.label == label:
            return self
        elif self.label > label:
            if self.left:
                self.left.insert(label)
            else:
                self.left = RedBlackTree(label, 1, self)
                self.left._insert_repair()
        elif self.right:
            self.right.insert(label)
        else:
            self.right = RedBlackTree(label, 1, self)
            self.right._insert_repair()
        return self.parent or self",data\repos\Python\data_structures\binary_tree\red_black_tree.py,insert,188
2912,red_black_tree.py::remove::150,"    def remove(self, label: int) -> RedBlackTree:
        """"""Remove label from this tree.""""""
        if self.label == label:
            if self.left and self.right:
                # It's easier to balance a node with at most one child,
                # so we replace this node with the greatest one less than
                # it and remove that.
                value = self.left.get_max()
                if value is not None:
                    self.label = value
                    self.left.remove(value)
            else:
                # This node has at most one non-None child, so we don't
                # need to replace
                child = self.left or self.right
                if self.color == 1:
                    # This node is red, and its child is black
                    # The only way this happens to a node with one child
                    # is if both children are None leaves.
                    # We can just remove this node and call it a day.
                    if self.parent:
                        if self.is_left():
                            self.parent.left = None
                        else:
                            self.parent.right = None
                # The node is black
                elif child is None:
                    # This node and its child are black
                    if self.parent is None:
                        # The tree is now empty
                        return RedBlackTree(None)
                    else:
                        self._remove_repair()
                        if self.is_left():
                            self.parent.left = None
                        else:
                            self.parent.right = None
                        self.parent = None
                else:
                    # This node is black and its child is red
                    # Move the child node here and make it black
                    self.label = child.label
                    self.left = child.left
                    self.right = child.right
                    if self.left:
                        self.left.parent = self
                    if self.right:
                        self.right.parent = self
        elif self.label is not None and self.label > label:
            if self.left:
                self.left.remove(label)
        elif self.right:
            self.right.remove(label)
        return self.parent or self",data\repos\Python\data_structures\binary_tree\red_black_tree.py,remove,420
2913,red_black_tree.py::check_color_properties::278,"    def check_color_properties(self) -> bool:
        """"""Check the coloring of the tree, and return True iff the tree
        is colored in a way which matches these five properties:
        (wording stolen from wikipedia article)
         1. Each node is either red or black.
         2. The root node is black.
         3. All leaves are black.
         4. If a node is red, then both its children are black.
         5. Every path from any node to all of its descendent NIL nodes
            has the same number of black nodes.
        This function runs in O(n) time, because properties 4 and 5 take
        that long to check.
        """"""
        # I assume property 1 to hold because there is nothing that can
        # make the color be anything other than 0 or 1.
        # Property 2
        if self.color:
            # The root was red
            print(""Property 2"")
            return False
        # Property 3 does not need to be checked, because None is assumed
        # to be black and is all the leaves.
        # Property 4
        if not self.check_coloring():
            print(""Property 4"")
            return False
        # Property 5
        if self.black_height() is None:
            print(""Property 5"")
            return False
        # All properties were met
        return True",data\repos\Python\data_structures\binary_tree\red_black_tree.py,check_color_properties,298
2914,red_black_tree.py::check_coloring::311,"    def check_coloring(self) -> bool:
        """"""A helper function to recursively check Property 4 of a
        Red-Black Tree. See check_color_properties for more info.
        """"""
        if self.color == 1 and 1 in (color(self.left), color(self.right)):
            return False
        if self.left and not self.left.check_coloring():
            return False
        return not (self.right and not self.right.check_coloring())",data\repos\Python\data_structures\binary_tree\red_black_tree.py,check_coloring,94
2915,red_black_tree.py::black_height::321,"    def black_height(self) -> int | None:
        """"""Returns the number of black nodes from this node to the
        leaves of the tree, or None if there isn't one such value (the
        tree is color incorrectly).
        """"""
        if self is None or self.left is None or self.right is None:
            # If we're already at a leaf, there is no path
            return 1
        left = RedBlackTree.black_height(self.left)
        right = RedBlackTree.black_height(self.right)
        if left is None or right is None:
            # There are issues with coloring below children nodes
            return None
        if left != right:
            # The two children have unequal depths
            return None
        # Return the black depth of children, plus one if this node is
        # black
        return left + (1 - self.color)",data\repos\Python\data_structures\binary_tree\red_black_tree.py,black_height,183
2916,red_black_tree.py::search::350,"    def search(self, label: int) -> RedBlackTree | None:
        """"""Search through the tree for label, returning its node if
        it's found, and None otherwise.
        This method is guaranteed to run in O(log(n)) time.
        """"""
        if self.label == label:
            return self
        elif self.label is not None and label > self.label:
            if self.right is None:
                return None
            else:
                return self.right.search(label)
        elif self.left is None:
            return None
        else:
            return self.left.search(label)",data\repos\Python\data_structures\binary_tree\red_black_tree.py,search,121
2917,red_black_tree.py::floor::367,"    def floor(self, label: int) -> int | None:
        """"""Returns the largest element in this tree which is at most label.
        This method is guaranteed to run in O(log(n)) time.""""""
        if self.label == label:
            return self.label
        elif self.label is not None and self.label > label:
            if self.left:
                return self.left.floor(label)
            else:
                return None
        else:
            if self.right:
                attempt = self.right.floor(label)
                if attempt is not None:
                    return attempt
            return self.label",data\repos\Python\data_structures\binary_tree\red_black_tree.py,floor,118
2918,red_black_tree.py::ceil::384,"    def ceil(self, label: int) -> int | None:
        """"""Returns the smallest element in this tree which is at least label.
        This method is guaranteed to run in O(log(n)) time.
        """"""
        if self.label == label:
            return self.label
        elif self.label is not None and self.label < label:
            if self.right:
                return self.right.ceil(label)
            else:
                return None
        else:
            if self.left:
                attempt = self.left.ceil(label)
                if attempt is not None:
                    return attempt
            return self.label",data\repos\Python\data_structures\binary_tree\red_black_tree.py,ceil,120
2919,red_black_tree.py::get_max::402,"    def get_max(self) -> int | None:
        """"""Returns the largest element in this tree.
        This method is guaranteed to run in O(log(n)) time.
        """"""
        if self.right:
            # Go as far right as possible
            return self.right.get_max()
        else:
            return self.label",data\repos\Python\data_structures\binary_tree\red_black_tree.py,get_max,65
2920,red_black_tree.py::get_min::412,"    def get_min(self) -> int | None:
        """"""Returns the smallest element in this tree.
        This method is guaranteed to run in O(log(n)) time.
        """"""
        if self.left:
            # Go as far left as possible
            return self.left.get_min()
        else:
            return self.label",data\repos\Python\data_structures\binary_tree\red_black_tree.py,get_min,65
2921,red_black_tree.py::grandparent::423,"    def grandparent(self) -> RedBlackTree | None:
        """"""Get the current node's grandparent, or None if it doesn't exist.""""""
        if self.parent is None:
            return None
        else:
            return self.parent.parent",data\repos\Python\data_structures\binary_tree\red_black_tree.py,grandparent,50
2922,red_black_tree.py::sibling::431,"    def sibling(self) -> RedBlackTree | None:
        """"""Get the current node's sibling, or None if it doesn't exist.""""""
        if self.parent is None:
            return None
        elif self.parent.left is self:
            return self.parent.right
        else:
            return self.parent.left",data\repos\Python\data_structures\binary_tree\red_black_tree.py,sibling,62
2923,red_black_tree.py::is_left::440,"    def is_left(self) -> bool:
        """"""Returns true iff this node is the left child of its parent.""""""
        if self.parent is None:
            return False
        return self.parent.left is self",data\repos\Python\data_structures\binary_tree\red_black_tree.py,is_left,42
2924,red_black_tree.py::is_right::446,"    def is_right(self) -> bool:
        """"""Returns true iff this node is the right child of its parent.""""""
        if self.parent is None:
            return False
        return self.parent.right is self",data\repos\Python\data_structures\binary_tree\red_black_tree.py,is_right,42
2925,red_black_tree.py::preorder_traverse::466,"    def preorder_traverse(self) -> Iterator[int | None]:
        yield self.label
        if self.left:
            yield from self.left.preorder_traverse()
        if self.right:
            yield from self.right.preorder_traverse()",data\repos\Python\data_structures\binary_tree\red_black_tree.py,preorder_traverse,48
2926,red_black_tree.py::inorder_traverse::473,"    def inorder_traverse(self) -> Iterator[int | None]:
        if self.left:
            yield from self.left.inorder_traverse()
        yield self.label
        if self.right:
            yield from self.right.inorder_traverse()",data\repos\Python\data_structures\binary_tree\red_black_tree.py,inorder_traverse,48
2927,red_black_tree.py::postorder_traverse::480,"    def postorder_traverse(self) -> Iterator[int | None]:
        if self.left:
            yield from self.left.postorder_traverse()
        if self.right:
            yield from self.right.postorder_traverse()
        yield self.label",data\repos\Python\data_structures\binary_tree\red_black_tree.py,postorder_traverse,48
2928,segment_tree.py::left::14,"    def left(self, idx):
        """"""
        Returns the left child index for a given index in a binary tree.

        >>> s = SegmentTree([1, 2, 3])
        >>> s.left(1)
        2
        >>> s.left(2)
        4
        """"""
        return idx * 2",data\repos\Python\data_structures\binary_tree\segment_tree.py,left,69
2929,segment_tree.py::right::26,"    def right(self, idx):
        """"""
        Returns the right child index for a given index in a binary tree.

        >>> s = SegmentTree([1, 2, 3])
        >>> s.right(1)
        3
        >>> s.right(2)
        5
        """"""
        return idx * 2 + 1",data\repos\Python\data_structures\binary_tree\segment_tree.py,right,72
2930,segment_tree.py::build::38,"    def build(self, idx, left, right):
        if left == right:
            self.st[idx] = self.A[left]
        else:
            mid = (left + right) // 2
            self.build(self.left(idx), left, mid)
            self.build(self.right(idx), mid + 1, right)
            self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])",data\repos\Python\data_structures\binary_tree\segment_tree.py,build,86
2931,segment_tree.py::update::47,"    def update(self, a, b, val):
        """"""
        Update the values in the segment tree in the range [a,b] with the given value.

        >>> s = SegmentTree([1, 2, 3, 4, 5])
        >>> s.update(2, 4, 10)
        True
        >>> s.query(1, 5)
        10
        """"""
        return self.update_recursive(1, 0, self.N - 1, a - 1, b - 1, val)",data\repos\Python\data_structures\binary_tree\segment_tree.py,update,115
2932,segment_tree.py::update_recursive::59,"    def update_recursive(self, idx, left, right, a, b, val):
        """"""
        update(1, 1, N, a, b, v) for update val v to [a,b]
        """"""
        if right < a or left > b:
            return True
        if left == right:
            self.st[idx] = val
            return True
        mid = (left + right) // 2
        self.update_recursive(self.left(idx), left, mid, a, b, val)
        self.update_recursive(self.right(idx), mid + 1, right, a, b, val)
        self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])
        return True",data\repos\Python\data_structures\binary_tree\segment_tree.py,update_recursive,152
2933,segment_tree.py::query::74,"    def query(self, a, b):
        """"""
        Query the maximum value in the range [a,b].

        >>> s = SegmentTree([1, 2, 3, 4, 5])
        >>> s.query(1, 3)
        3
        >>> s.query(1, 5)
        5
        """"""
        return self.query_recursive(1, 0, self.N - 1, a - 1, b - 1)",data\repos\Python\data_structures\binary_tree\segment_tree.py,query,101
2934,segment_tree.py::query_recursive::86,"    def query_recursive(self, idx, left, right, a, b):
        """"""
        query(1, 1, N, a, b) for query max of [a,b]
        """"""
        if right < a or left > b:
            return -math.inf
        if left >= a and right <= b:
            return self.st[idx]
        mid = (left + right) // 2
        q1 = self.query_recursive(self.left(idx), left, mid, a, b)
        q2 = self.query_recursive(self.right(idx), mid + 1, right, a, b)
        return max(q1, q2)",data\repos\Python\data_structures\binary_tree\segment_tree.py,query_recursive,136
2935,segment_tree.py::show_data::99,"    def show_data(self):
        show_list = []
        for i in range(1, self.N + 1):
            show_list += [self.query(i, i)]
        print(show_list)",data\repos\Python\data_structures\binary_tree\segment_tree.py,show_data,41
2936,segment_tree_other.py::update::136,"    def update(self, i, val):
        """"""
        Update an element in log(N) time
        :param i: position to be update
        :param val: new value
        >>> import operator
        >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add)
        >>> num_arr.update(1, 5)
        >>> num_arr.query_range(1, 3)
        13
        """"""
        self._update_tree(self.root, i, val)",data\repos\Python\data_structures\binary_tree\segment_tree_other.py,update,110
2937,segment_tree_other.py::query_range::149,"    def query_range(self, i, j):
        """"""
        Get range query value in log(N) time
        :param i: left element index
        :param j: right element index
        :return: element combined in the range [i, j]
        >>> import operator
        >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add)
        >>> num_arr.update(1, 5)
        >>> num_arr.query_range(3, 4)
        7
        >>> num_arr.query_range(2, 2)
        5
        >>> num_arr.query_range(1, 3)
        13
        >>>
        """"""
        return self._query_range(self.root, i, j)",data\repos\Python\data_structures\binary_tree\segment_tree_other.py,query_range,162
2938,segment_tree_other.py::traverse::204,"    def traverse(self):
        if self.root is not None:
            queue = Queue()
            queue.put(self.root)
            while not queue.empty():
                node = queue.get()
                yield node

                if node.left is not None:
                    queue.put(node.left)

                if node.right is not None:
                    queue.put(node.right)",data\repos\Python\data_structures\binary_tree\segment_tree_other.py,traverse,68
2939,serialize_deserialize_binary_tree.py::deserialize::86,"def deserialize(data: str) -> TreeNode | None:
    """"""
    Deserialize a string to a binary tree.

    Args:
        data(str): The serialized string.

    Returns:
        The root of the binary tree.

    >>> root = TreeNode.five_tree()
    >>> serialzed_data = repr(root)
    >>> deserialized = deserialize(serialzed_data)
    >>> root == deserialized
    True
    >>> root is deserialized  # two separate trees
    False
    >>> root.right.right.value = 6
    >>> root == deserialized
    False
    >>> serialzed_data = repr(root)
    >>> deserialized = deserialize(serialzed_data)
    >>> root == deserialized
    True
    >>> deserialize("""")
    Traceback (most recent call last):
        ...
    ValueError: Data cannot be empty.
    """"""

    if not data:
        raise ValueError(""Data cannot be empty."")

    # Split the serialized string by a comma to get node values
    nodes = data.split("","")

    def build_tree() -> TreeNode | None:
        # Get the next value from the list
        value = nodes.pop(0)

        if value == ""null"":
            return None

        node = TreeNode(int(value))
        node.left = build_tree()  # Recursively build left subtree
        node.right = build_tree()  # Recursively build right subtree
        return node

    return build_tree()",data\repos\Python\data_structures\binary_tree\serialize_deserialize_binary_tree.py,deserialize,291
2940,serialize_deserialize_binary_tree.py::five_tree::73,"    def five_tree(cls) -> TreeNode:
        """"""
        >>> repr(TreeNode.five_tree())
        '1,2,null,null,3,4,null,null,5,null,null'
        """"""
        root = TreeNode(1)
        root.left = TreeNode(2)
        root.right = TreeNode(3)
        root.right.left = TreeNode(4)
        root.right.right = TreeNode(5)
        return root",data\repos\Python\data_structures\binary_tree\serialize_deserialize_binary_tree.py,five_tree,83
2941,serialize_deserialize_binary_tree.py::build_tree::122,"    def build_tree() -> TreeNode | None:
        # Get the next value from the list
        value = nodes.pop(0)

        if value == ""null"":
            return None

        node = TreeNode(int(value))
        node.left = build_tree()  # Recursively build left subtree
        node.right = build_tree()  # Recursively build right subtree
        return node",data\repos\Python\data_structures\binary_tree\serialize_deserialize_binary_tree.py,build_tree,79
2942,symmetric_tree.py::make_symmetric_tree::38,"def make_symmetric_tree() -> Node:
    r""""""
    Create a symmetric tree for testing.

    The tree looks like this:
           1
         /   \
        2     2
      / \    / \
     3   4   4  3

    Returns:
    Node: Root node of a symmetric tree.

    Example:
    >>> tree = make_symmetric_tree()
    >>> tree.data
    1
    >>> tree.left.data == tree.right.data
    True
    >>> tree.left.left.data == tree.right.right.data
    True
    """"""
    root = Node(1)
    root.left = Node(2)
    root.right = Node(2)
    root.left.left = Node(3)
    root.left.right = Node(4)
    root.right.left = Node(4)
    root.right.right = Node(3)
    return root",data\repos\Python\data_structures\binary_tree\symmetric_tree.py,make_symmetric_tree,187
2943,symmetric_tree.py::make_asymmetric_tree::71,"def make_asymmetric_tree() -> Node:
    r""""""
    Create an asymmetric tree for testing.

    The tree looks like this:
           1
         /   \
        2     2
      / \    / \
     3   4   3  4

    Returns:
    Node: Root node of an asymmetric tree.

    Example:
    >>> tree = make_asymmetric_tree()
    >>> tree.data
    1
    >>> tree.left.data == tree.right.data
    True
    >>> tree.left.left.data == tree.right.right.data
    False
    """"""
    root = Node(1)
    root.left = Node(2)
    root.right = Node(2)
    root.left.left = Node(3)
    root.left.right = Node(4)
    root.right.left = Node(3)
    root.right.right = Node(4)
    return root",data\repos\Python\data_structures\binary_tree\symmetric_tree.py,make_asymmetric_tree,187
2944,symmetric_tree.py::is_symmetric_tree::104,"def is_symmetric_tree(tree: Node) -> bool:
    """"""
    Check if a binary tree is symmetric (i.e., a mirror of itself).

    Parameters:
    tree: The root node of the binary tree.

    Returns:
    bool: True if the tree is symmetric, False otherwise.

    Example:
    >>> is_symmetric_tree(make_symmetric_tree())
    True
    >>> is_symmetric_tree(make_asymmetric_tree())
    False
    """"""
    if tree:
        return is_mirror(tree.left, tree.right)
    return True  # An empty tree is considered symmetric.",data\repos\Python\data_structures\binary_tree\symmetric_tree.py,is_symmetric_tree,120
2945,symmetric_tree.py::is_mirror::125,"def is_mirror(left: Node | None, right: Node | None) -> bool:
    """"""
    Check if two subtrees are mirror images of each other.

    Parameters:
    left: The root node of the left subtree.
    right: The root node of the right subtree.

    Returns:
    bool: True if the two subtrees are mirrors of each other, False otherwise.

    Example:
    >>> tree1 = make_symmetric_tree()
    >>> is_mirror(tree1.left, tree1.right)
    True
    >>> tree2 = make_asymmetric_tree()
    >>> is_mirror(tree2.left, tree2.right)
    False
    """"""
    if left is None and right is None:
        # Both sides are empty, which is symmetric.
        return True
    if left is None or right is None:
        # One side is empty while the other is not, which is not symmetric.
        return False
    if left.data == right.data:
        # The values match, so check the subtrees recursively.
        return is_mirror(left.left, right.right) and is_mirror(left.right, right.left)
    return False",data\repos\Python\data_structures\binary_tree\symmetric_tree.py,is_mirror,233
2946,treap.py::split::35,"def split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:
    """"""
    We split current tree into 2 trees with value:

    Left tree contains all values less than split value.
    Right tree contains all values greater or equal, than split value
    """"""
    if root is None or root.value is None:  # None tree is split into 2 Nones
        return None, None
    elif value < root.value:
        """"""
        Right tree's root will be current node.
        Now we split(with the same value) current node's left son
        Left tree: left part of that split
        Right tree's left son: right part of that split
        """"""
        left, root.left = split(root.left, value)
        return left, root
    else:
        """"""
        Just symmetric to previous case
        """"""
        root.right, right = split(root.right, value)
        return root, right",data\repos\Python\data_structures\binary_tree\treap.py,split,201
2947,treap.py::merge::61,"def merge(left: Node | None, right: Node | None) -> Node | None:
    """"""
    We merge 2 trees into one.
    Note: all left tree's values must be less than all right tree's
    """"""
    if (not left) or (not right):  # If one node is None, return the other
        return left or right
    elif left.prior < right.prior:
        """"""
        Left will be root because it has more priority
        Now we need to merge left's right son and right tree
        """"""
        left.right = merge(left.right, right)
        return left
    else:
        """"""
        Symmetric as well
        """"""
        right.left = merge(left, right.left)
        return right",data\repos\Python\data_structures\binary_tree\treap.py,merge,157
2948,treap.py::insert::83,"def insert(root: Node | None, value: int) -> Node | None:
    """"""
    Insert element

    Split current tree with a value into left, right,
    Insert new node into the middle
    Merge left, node, right into root
    """"""
    node = Node(value)
    left, right = split(root, value)
    return merge(merge(left, node), right)",data\repos\Python\data_structures\binary_tree\treap.py,insert,82
2949,treap.py::erase::96,"def erase(root: Node | None, value: int) -> Node | None:
    """"""
    Erase element

    Split all nodes with values less into left,
    Split all nodes with values greater into right.
    Merge left, right
    """"""
    left, right = split(root, value - 1)
    _, right = split(right, value)
    return merge(left, right)",data\repos\Python\data_structures\binary_tree\treap.py,erase,81
2950,treap.py::inorder::109,"def inorder(root: Node | None) -> None:
    """"""
    Just recursive print of a tree
    """"""
    if not root:  # None
        return
    else:
        inorder(root.left)
        print(root.value, end="","")
        inorder(root.right)",data\repos\Python\data_structures\binary_tree\treap.py,inorder,56
2951,treap.py::interact_treap::121,"def interact_treap(root: Node | None, args: str) -> Node | None:
    """"""
    Commands:
    + value to add value into treap
    - value to erase all nodes with value

        >>> root = interact_treap(None, ""+1"")
        >>> inorder(root)
        1,
        >>> root = interact_treap(root, ""+3 +5 +17 +19 +2 +16 +4 +0"")
        >>> inorder(root)
        0,1,2,3,4,5,16,17,19,
        >>> root = interact_treap(root, ""+4 +4 +4"")
        >>> inorder(root)
        0,1,2,3,4,4,4,4,5,16,17,19,
        >>> root = interact_treap(root, ""-0"")
        >>> inorder(root)
        1,2,3,4,4,4,4,5,16,17,19,
        >>> root = interact_treap(root, ""-4"")
        >>> inorder(root)
        1,2,3,5,16,17,19,
        >>> root = interact_treap(root, ""=0"")
        Unknown command
    """"""
    for arg in args.split():
        if arg[0] == ""+"":
            root = insert(root, int(arg[1:]))

        elif arg[0] == ""-"":
            root = erase(root, int(arg[1:]))

        else:
            print(""Unknown command"")

    return root",data\repos\Python\data_structures\binary_tree\treap.py,interact_treap,323
2952,treap.py::main::158,"def main() -> None:
    """"""After each command, program prints treap""""""
    root = None
    print(
        ""enter numbers to create a tree, + value to add value into treap, ""
        ""- value to erase all nodes with value. 'q' to quit. ""
    )

    args = input()
    while args != ""q"":
        root = interact_treap(root, args)
        print(root)
        args = input()

    print(""good by!"")",data\repos\Python\data_structures\binary_tree\treap.py,main,101
2953,wavelet_tree.py::build_tree::35,"def build_tree(arr: list[int]) -> Node | None:
    """"""
    Builds the tree for arr and returns the root
    of the constructed tree

    >>> build_tree(test_array)
    Node(min_value=0 max_value=9)
    """"""
    root = Node(len(arr))
    root.minn, root.maxx = min(arr), max(arr)
    # Leaf node case where the node contains only one unique value
    if root.minn == root.maxx:
        return root
    """"""
    Take the mean of min and max element of arr as the pivot and
    partition arr into left_arr and right_arr with all elements <= pivot in the
    left_arr and the rest in right_arr, maintaining the order of the elements,
    then recursively build trees for left_arr and right_arr
    """"""
    pivot = (root.minn + root.maxx) // 2

    left_arr: list[int] = []
    right_arr: list[int] = []

    for index, num in enumerate(arr):
        if num <= pivot:
            left_arr.append(num)
        else:
            right_arr.append(num)
        root.map_left[index] = len(left_arr)
    root.left = build_tree(left_arr)
    root.right = build_tree(right_arr)
    return root",data\repos\Python\data_structures\binary_tree\wavelet_tree.py,build_tree,264
2954,wavelet_tree.py::rank_till_index::70,"def rank_till_index(node: Node | None, num: int, index: int) -> int:
    """"""
    Returns the number of occurrences of num in interval [0, index] in the list

    >>> root = build_tree(test_array)
    >>> rank_till_index(root, 6, 6)
    1
    >>> rank_till_index(root, 2, 0)
    1
    >>> rank_till_index(root, 1, 10)
    2
    >>> rank_till_index(root, 17, 7)
    0
    >>> rank_till_index(root, 0, 9)
    1
    """"""
    if index < 0 or node is None:
        return 0
    # Leaf node cases
    if node.minn == node.maxx:
        return index + 1 if node.minn == num else 0
    pivot = (node.minn + node.maxx) // 2
    if num <= pivot:
        # go the left subtree and map index to the left subtree
        return rank_till_index(node.left, num, node.map_left[index] - 1)
    else:
        # go to the right subtree and map index to the right subtree
        return rank_till_index(node.right, num, index - node.map_left[index])",data\repos\Python\data_structures\binary_tree\wavelet_tree.py,rank_till_index,284
2955,wavelet_tree.py::rank::100,"def rank(node: Node | None, num: int, start: int, end: int) -> int:
    """"""
    Returns the number of occurrences of num in interval [start, end] in the list

    >>> root = build_tree(test_array)
    >>> rank(root, 6, 3, 13)
    2
    >>> rank(root, 2, 0, 19)
    4
    >>> rank(root, 9, 2 ,2)
    0
    >>> rank(root, 0, 5, 10)
    2
    """"""
    if start > end:
        return 0
    rank_till_end = rank_till_index(node, num, end)
    rank_before_start = rank_till_index(node, num, start - 1)
    return rank_till_end - rank_before_start",data\repos\Python\data_structures\binary_tree\wavelet_tree.py,rank,181
2956,wavelet_tree.py::quantile::121,"def quantile(node: Node | None, index: int, start: int, end: int) -> int:
    """"""
    Returns the index'th smallest element in interval [start, end] in the list
    index is 0-indexed

    >>> root = build_tree(test_array)
    >>> quantile(root, 2, 2, 5)
    5
    >>> quantile(root, 5, 2, 13)
    4
    >>> quantile(root, 0, 6, 6)
    8
    >>> quantile(root, 4, 2, 5)
    -1
    """"""
    if index > (end - start) or start > end or node is None:
        return -1
    # Leaf node case
    if node.minn == node.maxx:
        return node.minn
    # Number of elements in the left subtree in interval [start, end]
    num_elements_in_left_tree = node.map_left[end] - (
        node.map_left[start - 1] if start else 0
    )
    if num_elements_in_left_tree > index:
        return quantile(
            node.left,
            index,
            (node.map_left[start - 1] if start else 0),
            node.map_left[end] - 1,
        )
    else:
        return quantile(
            node.right,
            index - num_elements_in_left_tree,
            start - (node.map_left[start - 1] if start else 0),
            end - node.map_left[end],
        )",data\repos\Python\data_structures\binary_tree\wavelet_tree.py,quantile,331
2957,wavelet_tree.py::range_counting::161,"def range_counting(
    node: Node | None, start: int, end: int, start_num: int, end_num: int
) -> int:
    """"""
    Returns the number of elements in range [start_num, end_num]
    in interval [start, end] in the list

    >>> root = build_tree(test_array)
    >>> range_counting(root, 1, 10, 3, 7)
    3
    >>> range_counting(root, 2, 2, 1, 4)
    1
    >>> range_counting(root, 0, 19, 0, 100)
    20
    >>> range_counting(root, 1, 0, 1, 100)
    0
    >>> range_counting(root, 0, 17, 100, 1)
    0
    """"""
    if (
        start > end
        or node is None
        or start_num > end_num
        or node.minn > end_num
        or node.maxx < start_num
    ):
        return 0
    if start_num <= node.minn and node.maxx <= end_num:
        return end - start + 1
    left = range_counting(
        node.left,
        (node.map_left[start - 1] if start else 0),
        node.map_left[end] - 1,
        start_num,
        end_num,
    )
    right = range_counting(
        node.right,
        start - (node.map_left[start - 1] if start else 0),
        end - node.map_left[end],
        start_num,
        end_num,
    )
    return left + right",data\repos\Python\data_structures\binary_tree\wavelet_tree.py,range_counting,360
2958,alternate_disjoint_set.py::merge::19,"    def merge(self, src: int, dst: int) -> bool:
        """"""
        Merge two sets together using Union by rank heuristic
        Return True if successful
        Merge two disjoint sets
        >>> A = DisjointSet([1, 1, 1])
        >>> A.merge(1, 2)
        True
        >>> A.merge(0, 2)
        True
        >>> A.merge(0, 1)
        False
        """"""
        src_parent = self.get_parent(src)
        dst_parent = self.get_parent(dst)

        if src_parent == dst_parent:
            return False

        if self.ranks[dst_parent] >= self.ranks[src_parent]:
            self.set_counts[dst_parent] += self.set_counts[src_parent]
            self.set_counts[src_parent] = 0
            self.parents[src_parent] = dst_parent
            if self.ranks[dst_parent] == self.ranks[src_parent]:
                self.ranks[dst_parent] += 1
            joined_set_size = self.set_counts[dst_parent]
        else:
            self.set_counts[src_parent] += self.set_counts[dst_parent]
            self.set_counts[dst_parent] = 0
            self.parents[dst_parent] = src_parent
            joined_set_size = self.set_counts[src_parent]

        self.max_set = max(self.max_set, joined_set_size)
        return True",data\repos\Python\data_structures\disjoint_set\alternate_disjoint_set.py,merge,289
2959,alternate_disjoint_set.py::get_parent::54,"    def get_parent(self, disj_set: int) -> int:
        """"""
        Find the Parent of a given set
        >>> A = DisjointSet([1, 1, 1])
        >>> A.merge(1, 2)
        True
        >>> A.get_parent(0)
        0
        >>> A.get_parent(1)
        2
        """"""
        if self.parents[disj_set] == disj_set:
            return disj_set
        self.parents[disj_set] = self.get_parent(self.parents[disj_set])
        return self.parents[disj_set]",data\repos\Python\data_structures\disjoint_set\alternate_disjoint_set.py,get_parent,129
2960,disjoint_set.py::make_set::14,"def make_set(x: Node) -> None:
    """"""
    Make x as a set.
    """"""
    # rank is the distance from x to its' parent
    # root's rank is 0
    x.rank = 0
    x.parent = x",data\repos\Python\data_structures\disjoint_set\disjoint_set.py,make_set,55
2961,disjoint_set.py::union_set::24,"def union_set(x: Node, y: Node) -> None:
    """"""
    Union of two sets.
    set with bigger rank should be parent, so that the
    disjoint set tree will be more flat.
    """"""
    x, y = find_set(x), find_set(y)
    if x == y:
        return

    elif x.rank > y.rank:
        y.parent = x
    else:
        x.parent = y
        if x.rank == y.rank:
            y.rank += 1",data\repos\Python\data_structures\disjoint_set\disjoint_set.py,union_set,105
2962,disjoint_set.py::find_set::42,"def find_set(x: Node) -> Node:
    """"""
    Return the parent of x
    """"""
    if x != x.parent:
        x.parent = find_set(x.parent)
    return x.parent",data\repos\Python\data_structures\disjoint_set\disjoint_set.py,find_set,41
2963,disjoint_set.py::find_python_set::51,"def find_python_set(node: Node) -> set:
    """"""
    Return a Python Standard Library set that contains i.
    """"""
    sets = ({0, 1, 2}, {3, 4, 5})
    for s in sets:
        if node.data in s:
            return s
    msg = f""{node.data} is not in {sets}""
    raise ValueError(msg)",data\repos\Python\data_structures\disjoint_set\disjoint_set.py,find_python_set,83
2964,disjoint_set.py::test_disjoint_set::63,"def test_disjoint_set() -> None:
    """"""
    >>> test_disjoint_set()
    """"""
    vertex = [Node(i) for i in range(6)]
    for v in vertex:
        make_set(v)

    union_set(vertex[0], vertex[1])
    union_set(vertex[1], vertex[2])
    union_set(vertex[3], vertex[4])
    union_set(vertex[3], vertex[5])

    for node0 in vertex:
        for node1 in vertex:
            if find_python_set(node0).isdisjoint(find_python_set(node1)):
                assert find_set(node0) != find_set(node1)
            else:
                assert find_set(node0) == find_set(node1)",data\repos\Python\data_structures\disjoint_set\disjoint_set.py,test_disjoint_set,149
2965,bloom_filter.py::exists::76,"    def exists(self, value: str) -> bool:
        h = self.hash_(value)
        return (h & self.bitarray) == h",data\repos\Python\data_structures\hashing\bloom_filter.py,exists,31
2966,bloom_filter.py::format_bin::83,"    def format_bin(self, bitarray: int) -> str:
        res = bin(bitarray)[2:]
        return res.zfill(self.size)",data\repos\Python\data_structures\hashing\bloom_filter.py,format_bin,31
2967,bloom_filter.py::hash_::91,"    def hash_(self, value: str) -> int:
        res = 0b0
        for func in HASH_FUNCTIONS:
            position = (
                int.from_bytes(func(value.encode()).digest(), ""little"") % self.size
            )
            res |= 2**position
        return res",data\repos\Python\data_structures\hashing\bloom_filter.py,hash_,62
2968,bloom_filter.py::estimated_error_rate::104,"    def estimated_error_rate(self) -> float:
        n_ones = bin(self.bitarray).count(""1"")
        return (n_ones / self.size) ** len(HASH_FUNCTIONS)",data\repos\Python\data_structures\hashing\bloom_filter.py,estimated_error_rate,40
2969,hash_table.py::keys::25,"    def keys(self):
        """"""
        The keys function returns a dictionary containing the key value pairs.
        key being the index number in hash table and value being the data value.

        Examples:
        1. creating HashTable with size 10 and inserting 3 elements
        >>> ht = HashTable(10)
        >>> ht.insert_data(10)
        >>> ht.insert_data(20)
        >>> ht.insert_data(30)
        >>> ht.keys()
        {0: 10, 1: 20, 2: 30}

        2. creating HashTable with size 5 and inserting 5 elements
        >>> ht = HashTable(5)
        >>> ht.insert_data(5)
        >>> ht.insert_data(4)
        >>> ht.insert_data(3)
        >>> ht.insert_data(2)
        >>> ht.insert_data(1)
        >>> ht.keys()
        {0: 5, 4: 4, 3: 3, 2: 2, 1: 1}
        """"""
        return self._keys",data\repos\Python\data_structures\hashing\hash_table.py,keys,222
2970,hash_table.py::balanced_factor::51,"    def balanced_factor(self):
        return sum(1 for slot in self.values if slot is not None) / (
            self.size_table * self.charge_factor
        )",data\repos\Python\data_structures\hashing\hash_table.py,balanced_factor,36
2971,hash_table.py::hash_function::56,"    def hash_function(self, key):
        """"""
        Generates hash for the given key value

        Examples:

        Creating HashTable with size 5
        >>> ht = HashTable(5)
        >>> ht.hash_function(10)
        0
        >>> ht.hash_function(20)
        0
        >>> ht.hash_function(4)
        4
        >>> ht.hash_function(18)
        3
        >>> ht.hash_function(-18)
        2
        >>> ht.hash_function(18.5)
        3.5
        >>> ht.hash_function(0)
        0
        >>> ht.hash_function(-0)
        0
        """"""
        return key % self.size_table",data\repos\Python\data_structures\hashing\hash_table.py,hash_function,149
2972,hash_table.py::bulk_insert::88,"    def bulk_insert(self, values):
        """"""
        bulk_insert is used for entering more than one element at a time
        in the HashTable.

        Examples:
        1.
        >>> ht = HashTable(5)
        >>> ht.bulk_insert((10,20,30))
        step 1
        [0, 1, 2, 3, 4]
        [10, None, None, None, None]
        step 2
        [0, 1, 2, 3, 4]
        [10, 20, None, None, None]
        step 3
        [0, 1, 2, 3, 4]
        [10, 20, 30, None, None]

        2.
        >>> ht = HashTable(5)
        >>> ht.bulk_insert([5,4,3,2,1])
        step 1
        [0, 1, 2, 3, 4]
        [5, None, None, None, None]
        step 2
        [0, 1, 2, 3, 4]
        [5, None, None, None, 4]
        step 3
        [0, 1, 2, 3, 4]
        [5, None, None, 3, 4]
        step 4
        [0, 1, 2, 3, 4]
        [5, None, 2, 3, 4]
        step 5
        [0, 1, 2, 3, 4]
        [5, 1, 2, 3, 4]
        """"""
        i = 1
        self.__aux_list = values
        for value in values:
            self.insert_data(value)
            self._step_by_step(i)
            i += 1",data\repos\Python\data_structures\hashing\hash_table.py,bulk_insert,406
2973,hash_table.py::rehashing::239,"    def rehashing(self):
        survivor_values = [value for value in self.values if value is not None]
        self.size_table = next_prime(self.size_table, factor=2)
        self._keys.clear()
        self.values = [None] * self.size_table  # hell's pointers D: don't DRY ;/
        for value in survivor_values:
            self.insert_data(value)",data\repos\Python\data_structures\hashing\hash_table.py,rehashing,82
2974,hash_table.py::insert_data::247,"    def insert_data(self, data):
        """"""
        insert_data is used for inserting a single element at a time in the HashTable.

        Examples:

        >>> ht = HashTable(3)
        >>> ht.insert_data(5)
        >>> ht.keys()
        {2: 5}
        >>> ht = HashTable(5)
        >>> ht.insert_data(30)
        >>> ht.insert_data(50)
        >>> ht.keys()
        {0: 30, 1: 50}
        """"""
        key = self.hash_function(data)

        if self.values[key] is None:
            self._set_value(key, data)

        elif self.values[key] == data:
            pass

        else:
            collision_resolution = self._collision_resolution(key, data)
            if collision_resolution is not None:
                self._set_value(collision_resolution, data)
            else:
                self.rehashing()
                self.insert_data(data)",data\repos\Python\data_structures\hashing\hash_table.py,insert_data,192
2975,hash_table_with_linked_list.py::balanced_factor::15,"    def balanced_factor(self):
        return (
            sum(self.charge_factor - len(slot) for slot in self.values)
            / self.size_table
            * self.charge_factor
        )",data\repos\Python\data_structures\hashing\hash_table_with_linked_list.py,balanced_factor,40
2976,binomial_heap.py::merge_trees::23,"    def merge_trees(self, other):
        """"""
        In-place merge of two binomial trees of equal size.
        Returns the root of the resulting tree
        """"""
        assert self.left_tree_size == other.left_tree_size, ""Unequal Sizes of Blocks""

        if self.val < other.val:
            other.left = self.right
            other.parent = None
            if self.right:
                self.right.parent = other
            self.right = other
            self.left_tree_size = self.left_tree_size * 2 + 1
            return self
        else:
            self.left = other.right
            self.parent = None
            if other.right:
                other.right.parent = self
            other.right = self
            other.left_tree_size = other.left_tree_size * 2 + 1
            return other",data\repos\Python\data_structures\heap\binomial_heap.py,merge_trees,167
2977,binomial_heap.py::merge_heaps::131,"    def merge_heaps(self, other):
        """"""
        In-place merge of two binomial heaps.
        Both of them become the resulting merged heap
        """"""

        # Empty heaps corner cases
        if other.size == 0:
            return None
        if self.size == 0:
            self.size = other.size
            self.bottom_root = other.bottom_root
            self.min_node = other.min_node
            return None
        # Update size
        self.size = self.size + other.size

        # Update min.node
        if self.min_node.val > other.min_node.val:
            self.min_node = other.min_node
        # Merge

        # Order roots by left_subtree_size
        combined_roots_list = []
        i, j = self.bottom_root, other.bottom_root
        while i or j:
            if i and ((not j) or i.left_tree_size < j.left_tree_size):
                combined_roots_list.append((i, True))
                i = i.parent
            else:
                combined_roots_list.append((j, False))
                j = j.parent
        # Insert links between them
        for i in range(len(combined_roots_list) - 1):
            if combined_roots_list[i][1] != combined_roots_list[i + 1][1]:
                combined_roots_list[i][0].parent = combined_roots_list[i + 1][0]
                combined_roots_list[i + 1][0].left = combined_roots_list[i][0]
        # Consecutively merge roots with same left_tree_size
        i = combined_roots_list[0][0]
        while i.parent:
            if (
                (i.left_tree_size == i.parent.left_tree_size) and (not i.parent.parent)
            ) or (
                i.left_tree_size == i.parent.left_tree_size
                and i.left_tree_size != i.parent.parent.left_tree_size
            ):
                # Neighbouring Nodes
                previous_node = i.left
                next_node = i.parent.parent

                # Merging trees
                i = i.merge_trees(i.parent)

                # Updating links
                i.left = previous_node
                i.parent = next_node
                if previous_node:
                    previous_node.parent = i
                if next_node:
                    next_node.left = i
            else:
                i = i.parent
        # Updating self.bottom_root
        while i.left:
            i = i.left
        self.bottom_root = i

        # Update other
        other.size = self.size
        other.bottom_root = self.bottom_root
        other.min_node = self.min_node

        # Return the merged heap
        return self",data\repos\Python\data_structures\heap\binomial_heap.py,merge_heaps,556
2978,binomial_heap.py::insert::206,"    def insert(self, val):
        """"""
        insert a value in the heap
        """"""
        if self.size == 0:
            self.bottom_root = Node(val)
            self.size = 1
            self.min_node = self.bottom_root
        else:
            # Create new node
            new_node = Node(val)

            # Update size
            self.size += 1

            # update min_node
            if val < self.min_node.val:
                self.min_node = new_node
            # Put new_node as a bottom_root in heap
            self.bottom_root.left = new_node
            new_node.parent = self.bottom_root
            self.bottom_root = new_node

            # Consecutively merge roots with same left_tree_size
            while (
                self.bottom_root.parent
                and self.bottom_root.left_tree_size
                == self.bottom_root.parent.left_tree_size
            ):
                # Next node
                next_node = self.bottom_root.parent.parent

                # Merge
                self.bottom_root = self.bottom_root.merge_trees(self.bottom_root.parent)

                # Update Links
                self.bottom_root.parent = next_node
                self.bottom_root.left = None
                if next_node:
                    next_node.left = self.bottom_root",data\repos\Python\data_structures\heap\binomial_heap.py,insert,253
2979,binomial_heap.py::delete_min::256,"    def delete_min(self):
        """"""
        delete min element and return it
        """"""
        # assert not self.isEmpty(), ""Empty Heap""

        # Save minimal value
        min_value = self.min_node.val

        # Last element in heap corner case
        if self.size == 1:
            # Update size
            self.size = 0

            # Update bottom root
            self.bottom_root = None

            # Update min_node
            self.min_node = None

            return min_value
        # No right subtree corner case
        # The structure of the tree implies that this should be the bottom root
        # and there is at least one other root
        if self.min_node.right is None:
            # Update size
            self.size -= 1

            # Update bottom root
            self.bottom_root = self.bottom_root.parent
            self.bottom_root.left = None

            # Update min_node
            self.min_node = self.bottom_root
            i = self.bottom_root.parent
            while i:
                if i.val < self.min_node.val:
                    self.min_node = i
                i = i.parent
            return min_value
        # General case
        # Find the BinomialHeap of the right subtree of min_node
        bottom_of_new = self.min_node.right
        bottom_of_new.parent = None
        min_of_new = bottom_of_new
        size_of_new = 1

        # Size, min_node and bottom_root
        while bottom_of_new.left:
            size_of_new = size_of_new * 2 + 1
            bottom_of_new = bottom_of_new.left
            if bottom_of_new.val < min_of_new.val:
                min_of_new = bottom_of_new
        # Corner case of single root on top left path
        if (not self.min_node.left) and (not self.min_node.parent):
            self.size = size_of_new
            self.bottom_root = bottom_of_new
            self.min_node = min_of_new
            # print(""Single root, multiple nodes case"")
            return min_value
        # Remaining cases
        # Construct heap of right subtree
        new_heap = BinomialHeap(
            bottom_root=bottom_of_new, min_node=min_of_new, heap_size=size_of_new
        )

        # Update size
        self.size = self.size - 1 - size_of_new

        # Neighbour nodes
        previous_node = self.min_node.left
        next_node = self.min_node.parent

        # Initialize new bottom_root and min_node
        self.min_node = previous_node or next_node
        self.bottom_root = next_node

        # Update links of previous_node and search below for new min_node and
        # bottom_root
        if previous_node:
            previous_node.parent = next_node

            # Update bottom_root and search for min_node below
            self.bottom_root = previous_node
            self.min_node = previous_node
            while self.bottom_root.left:
                self.bottom_root = self.bottom_root.left
                if self.bottom_root.val < self.min_node.val:
                    self.min_node = self.bottom_root
        if next_node:
            next_node.left = previous_node

            # Search for new min_node above min_node
            i = next_node
            while i:
                if i.val < self.min_node.val:
                    self.min_node = i
                i = i.parent
        # Merge heaps
        self.merge_heaps(new_heap)

        return int(min_value)",data\repos\Python\data_structures\heap\binomial_heap.py,delete_min,719
2980,binomial_heap.py::pre_order::359,"    def pre_order(self):
        """"""
        Returns the Pre-order representation of the heap including
        values of nodes plus their level distance from the root;
        Empty nodes appear as #
        """"""
        # Find top root
        top_root = self.bottom_root
        while top_root.parent:
            top_root = top_root.parent
        # preorder
        heap_pre_order = []
        self.__traversal(top_root, heap_pre_order)
        return heap_pre_order",data\repos\Python\data_structures\heap\binomial_heap.py,pre_order,94
2981,heap.py::parent_index::55,"    def parent_index(self, child_idx: int) -> int | None:
        """"""
        returns the parent index based on the given child index

        >>> h = Heap()
        >>> h.build_max_heap([103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5])
        >>> h
        [209, 201, 25, 103, 107, 15, 1, 9, 7, 11, 5]

        >>> h.parent_index(-1)  # returns none if index is <=0

        >>> h.parent_index(0)   # returns none if index is <=0

        >>> h.parent_index(1)
        0
        >>> h.parent_index(2)
        0
        >>> h.parent_index(3)
        1
        >>> h.parent_index(4)
        1
        >>> h.parent_index(5)
        2
        >>> h.parent_index(10.5)
        4.0
        >>> h.parent_index(209.0)
        104.0
        >>> h.parent_index(""Test"")
        Traceback (most recent call last):
        ...
        TypeError: '>' not supported between instances of 'str' and 'int'
        """"""
        if child_idx > 0:
            return (child_idx - 1) // 2
        return None",data\repos\Python\data_structures\heap\heap.py,parent_index,302
2982,heap.py::left_child_idx::91,"    def left_child_idx(self, parent_idx: int) -> int | None:
        """"""
        return the left child index if the left child exists.
        if not, return None.
        """"""
        left_child_index = 2 * parent_idx + 1
        if left_child_index < self.heap_size:
            return left_child_index
        return None",data\repos\Python\data_structures\heap\heap.py,left_child_idx,73
2983,heap.py::right_child_idx::101,"    def right_child_idx(self, parent_idx: int) -> int | None:
        """"""
        return the right child index if the right child exists.
        if not, return None.
        """"""
        right_child_index = 2 * parent_idx + 2
        if right_child_index < self.heap_size:
            return right_child_index
        return None",data\repos\Python\data_structures\heap\heap.py,right_child_idx,73
2984,heap.py::max_heapify::111,"    def max_heapify(self, index: int) -> None:
        """"""
        correct a single violation of the heap property in a subtree's root.

        It is the function that is responsible for restoring the property
        of Max heap i.e the maximum element is always at top.
        """"""
        if index < self.heap_size:
            violation: int = index
            left_child = self.left_child_idx(index)
            right_child = self.right_child_idx(index)
            # check which child is larger than its parent
            if left_child is not None and self.h[left_child] > self.h[violation]:
                violation = left_child
            if right_child is not None and self.h[right_child] > self.h[violation]:
                violation = right_child
            # if violation indeed exists
            if violation != index:
                # swap to fix the violation
                self.h[violation], self.h[index] = self.h[index], self.h[violation]
                # fix the subsequent violation recursively if any
                self.max_heapify(violation)",data\repos\Python\data_structures\heap\heap.py,max_heapify,216
2985,heap.py::build_max_heap::134,"    def build_max_heap(self, collection: Iterable[T]) -> None:
        """"""
        build max heap from an unsorted array

        >>> h = Heap()
        >>> h.build_max_heap([20,40,50,20,10])
        >>> h
        [50, 40, 20, 20, 10]

        >>> h = Heap()
        >>> h.build_max_heap([1,2,3,4,5,6,7,8,9,0])
        >>> h
        [9, 8, 7, 4, 5, 6, 3, 2, 1, 0]

        >>> h = Heap()
        >>> h.build_max_heap([514,5,61,57,8,99,105])
        >>> h
        [514, 57, 105, 5, 8, 99, 61]

        >>> h = Heap()
        >>> h.build_max_heap([514,5,61.6,57,8,9.9,105])
        >>> h
        [514, 57, 105, 5, 8, 9.9, 61.6]
        """"""
        self.h = list(collection)
        self.heap_size = len(self.h)
        if self.heap_size > 1:
            # max_heapify from right to left but exclude leaves (last level)
            for i in range(self.heap_size // 2 - 1, -1, -1):
                self.max_heapify(i)",data\repos\Python\data_structures\heap\heap.py,build_max_heap,323
2986,heap.py::extract_max::165,"    def extract_max(self) -> T:
        """"""
        get and remove max from heap

        >>> h = Heap()
        >>> h.build_max_heap([20,40,50,20,10])
        >>> h.extract_max()
        50

        >>> h = Heap()
        >>> h.build_max_heap([514,5,61,57,8,99,105])
        >>> h.extract_max()
        514

        >>> h = Heap()
        >>> h.build_max_heap([1,2,3,4,5,6,7,8,9,0])
        >>> h.extract_max()
        9
        """"""
        if self.heap_size >= 2:
            me = self.h[0]
            self.h[0] = self.h.pop(-1)
            self.heap_size -= 1
            self.max_heapify(0)
            return me
        elif self.heap_size == 1:
            self.heap_size -= 1
            return self.h.pop(-1)
        else:
            raise Exception(""Empty heap"")",data\repos\Python\data_structures\heap\heap.py,extract_max,219
2987,heap.py::insert::196,"    def insert(self, value: T) -> None:
        """"""
        insert a new value into the max heap

        >>> h = Heap()
        >>> h.insert(10)
        >>> h
        [10]

        >>> h = Heap()
        >>> h.insert(10)
        >>> h.insert(10)
        >>> h
        [10, 10]

        >>> h = Heap()
        >>> h.insert(10)
        >>> h.insert(10.1)
        >>> h
        [10.1, 10]

        >>> h = Heap()
        >>> h.insert(0.1)
        >>> h.insert(0)
        >>> h.insert(9)
        >>> h.insert(5)
        >>> h
        [9, 5, 0.1, 0]
        """"""
        self.h.append(value)
        idx = (self.heap_size - 1) // 2
        self.heap_size += 1
        while idx >= 0:
            self.max_heapify(idx)
            idx = (idx - 1) // 2",data\repos\Python\data_structures\heap\heap.py,insert,223
2988,heap.py::heap_sort::232,"    def heap_sort(self) -> None:
        size = self.heap_size
        for j in range(size - 1, 0, -1):
            self.h[0], self.h[j] = self.h[j], self.h[0]
            self.heap_size -= 1
            self.max_heapify(0)
        self.heap_size = size",data\repos\Python\data_structures\heap\heap.py,heap_sort,74
2989,heap_generic.py::test_heap::131,"def test_heap() -> None:
    """"""
    >>> h = Heap()  # Max-heap
    >>> h.insert_item(5, 34)
    >>> h.insert_item(6, 31)
    >>> h.insert_item(7, 37)
    >>> h.get_top()
    [7, 37]
    >>> h.extract_top()
    [7, 37]
    >>> h.extract_top()
    [5, 34]
    >>> h.extract_top()
    [6, 31]
    >>> h = Heap(key=lambda x: -x)  # Min heap
    >>> h.insert_item(5, 34)
    >>> h.insert_item(6, 31)
    >>> h.insert_item(7, 37)
    >>> h.get_top()
    [6, -31]
    >>> h.extract_top()
    [6, -31]
    >>> h.extract_top()
    [5, -34]
    >>> h.extract_top()
    [7, -37]
    >>> h.insert_item(8, 45)
    >>> h.insert_item(9, 40)
    >>> h.insert_item(10, 50)
    >>> h.get_top()
    [9, -40]
    >>> h.update_item(10, 30)
    >>> h.get_top()
    [10, -30]
    >>> h.delete_item(10)
    >>> h.get_top()
    [9, -40]
    """"""",data\repos\Python\data_structures\heap\heap_generic.py,test_heap,301
2990,heap_generic.py::update_item::79,"    def update_item(self, item: int, item_value: int) -> None:
        """"""Updates given item value in heap if present""""""
        if item not in self.pos_map:
            return
        index = self.pos_map[item]
        self.arr[index] = [item, self.key(item_value)]
        # Make sure heap is right in both up and down direction.
        # Ideally only one of them will make any change.
        self._heapify_up(index)
        self._heapify_down(index)",data\repos\Python\data_structures\heap\heap_generic.py,update_item,105
2991,heap_generic.py::delete_item::90,"    def delete_item(self, item: int) -> None:
        """"""Deletes given item from heap if present""""""
        if item not in self.pos_map:
            return
        index = self.pos_map[item]
        del self.pos_map[item]
        self.arr[index] = self.arr[self.size - 1]
        self.pos_map[self.arr[self.size - 1][0]] = index
        self.size -= 1
        # Make sure heap is right in both up and down direction. Ideally only one
        # of them will make any change- so no performance loss in calling both.
        if self.size > index:
            self._heapify_up(index)
            self._heapify_down(index)",data\repos\Python\data_structures\heap\heap_generic.py,delete_item,146
2992,heap_generic.py::insert_item::105,"    def insert_item(self, item: int, item_value: int) -> None:
        """"""Inserts given item with given value in heap""""""
        arr_len = len(self.arr)
        if arr_len == self.size:
            self.arr.append([item, self.key(item_value)])
        else:
            self.arr[self.size] = [item, self.key(item_value)]
        self.pos_map[item] = self.size
        self.size += 1
        self._heapify_up(self.size - 1)",data\repos\Python\data_structures\heap\heap_generic.py,insert_item,105
2993,heap_generic.py::get_top::116,"    def get_top(self) -> tuple | None:
        """"""Returns top item tuple (Calculated value, item) from heap if present""""""
        return self.arr[0] if self.size else None",data\repos\Python\data_structures\heap\heap_generic.py,get_top,41
2994,heap_generic.py::extract_top::120,"    def extract_top(self) -> tuple | None:
        """"""
        Return top item tuple (Calculated value, item) from heap and removes it as well
        if present
        """"""
        top_item_tuple = self.get_top()
        if top_item_tuple:
            self.delete_item(top_item_tuple[0])
        return top_item_tuple",data\repos\Python\data_structures\heap\heap_generic.py,extract_top,69
2995,max_heap.py::insert::32,"    def insert(self, value: int) -> None:
        """"""Insert new element""""""
        self.__heap.append(value)
        self.__size += 1
        self.__swap_up(self.__size)",data\repos\Python\data_structures\heap\max_heap.py,insert,42
2996,max_heap.py::pop::53,"    def pop(self) -> int:
        """"""Pop the root element""""""
        max_value = self.__heap[1]
        self.__heap[1] = self.__heap[self.__size]
        self.__size -= 1
        self.__heap.pop()
        self.__swap_down(1)
        return max_value",data\repos\Python\data_structures\heap\max_heap.py,pop,66
2997,min_heap.py::build_heap::54,"    def build_heap(self, array):
        last_idx = len(array) - 1
        start_from = self.get_parent_idx(last_idx)

        for idx, i in enumerate(array):
            self.idx_of_element[i] = idx
            self.heap_dict[i.name] = i.val

        for i in range(start_from, -1, -1):
            self.sift_down(i, array)
        return array",data\repos\Python\data_structures\heap\min_heap.py,build_heap,86
2998,min_heap.py::sift_down::67,"    def sift_down(self, idx, array):
        while True:
            left = self.get_left_child_idx(idx)
            right = self.get_right_child_idx(idx)

            smallest = idx
            if left < len(array) and array[left] < array[idx]:
                smallest = left
            if right < len(array) and array[right] < array[smallest]:
                smallest = right

            if smallest != idx:
                array[idx], array[smallest] = array[smallest], array[idx]
                (
                    self.idx_of_element[array[idx]],
                    self.idx_of_element[array[smallest]],
                ) = (
                    self.idx_of_element[array[smallest]],
                    self.idx_of_element[array[idx]],
                )
                idx = smallest
            else:
                break",data\repos\Python\data_structures\heap\min_heap.py,sift_down,159
2999,min_heap.py::sift_up::91,"    def sift_up(self, idx):
        p = self.get_parent_idx(idx)
        while p >= 0 and self.heap[p] > self.heap[idx]:
            self.heap[p], self.heap[idx] = self.heap[idx], self.heap[p]
            self.idx_of_element[self.heap[p]], self.idx_of_element[self.heap[idx]] = (
                self.idx_of_element[self.heap[idx]],
                self.idx_of_element[self.heap[p]],
            )
            idx = p
            p = self.get_parent_idx(idx)",data\repos\Python\data_structures\heap\min_heap.py,sift_up,104
3000,min_heap.py::remove::105,"    def remove(self):
        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]
        self.idx_of_element[self.heap[0]], self.idx_of_element[self.heap[-1]] = (
            self.idx_of_element[self.heap[-1]],
            self.idx_of_element[self.heap[0]],
        )

        x = self.heap.pop()
        del self.idx_of_element[x]
        self.sift_down(0, self.heap)
        return x",data\repos\Python\data_structures\heap\min_heap.py,remove,99
3001,min_heap.py::insert::117,"    def insert(self, node):
        self.heap.append(node)
        self.idx_of_element[node] = len(self.heap) - 1
        self.heap_dict[node.name] = node.val
        self.sift_up(len(self.heap) - 1)",data\repos\Python\data_structures\heap\min_heap.py,insert,53
3002,min_heap.py::decrease_key::126,"    def decrease_key(self, node, new_value):
        assert self.heap[self.idx_of_element[node]].val > new_value, (
            ""newValue must be less that current value""
        )
        node.val = new_value
        self.heap_dict[node.name] = new_value
        self.sift_up(self.idx_of_element[node])",data\repos\Python\data_structures\heap\min_heap.py,decrease_key,68
3003,randomized_heap.py::value::24,"    def value(self) -> T:
        """"""
        Return the value of the node.

        >>> rhn = RandomizedHeapNode(10)
        >>> rhn.value
        10
        >>> rhn = RandomizedHeapNode(-10)
        >>> rhn.value
        -10
        """"""
        return self._value",data\repos\Python\data_structures\heap\randomized_heap.py,value,69
3004,randomized_heap.py::merge::38,"    def merge(
        root1: RandomizedHeapNode[T] | None, root2: RandomizedHeapNode[T] | None
    ) -> RandomizedHeapNode[T] | None:
        """"""
        Merge 2 nodes together.

        >>> rhn1 = RandomizedHeapNode(10)
        >>> rhn2 = RandomizedHeapNode(20)
        >>> RandomizedHeapNode.merge(rhn1, rhn2).value
        10

        >>> rhn1 = RandomizedHeapNode(20)
        >>> rhn2 = RandomizedHeapNode(10)
        >>> RandomizedHeapNode.merge(rhn1, rhn2).value
        10

        >>> rhn1 = RandomizedHeapNode(5)
        >>> rhn2 = RandomizedHeapNode(0)
        >>> RandomizedHeapNode.merge(rhn1, rhn2).value
        0
        """"""
        if not root1:
            return root2

        if not root2:
            return root1

        if root1.value > root2.value:
            root1, root2 = root2, root1

        if random.choice([True, False]):
            root1.left, root1.right = root1.right, root1.left

        root1.left = RandomizedHeapNode.merge(root1.left, root2)

        return root1",data\repos\Python\data_structures\heap\randomized_heap.py,merge,285
3005,randomized_heap.py::insert::111,"    def insert(self, value: T) -> None:
        """"""
        Insert the value into the heap.

        >>> rh = RandomizedHeap()
        >>> rh.insert(3)
        >>> rh.insert(1)
        >>> rh.insert(3)
        >>> rh.insert(7)
        >>> rh.to_sorted_list()
        [1, 3, 3, 7]
        """"""
        self._root = RandomizedHeapNode.merge(self._root, RandomizedHeapNode(value))",data\repos\Python\data_structures\heap\randomized_heap.py,insert,100
3006,randomized_heap.py::pop::125,"    def pop(self) -> T | None:
        """"""
        Pop the smallest value from the heap and return it.

        >>> rh = RandomizedHeap([3, 1, 3, 7])
        >>> rh.pop()
        1
        >>> rh.pop()
        3
        >>> rh.pop()
        3
        >>> rh.pop()
        7
        >>> rh.pop()
        Traceback (most recent call last):
            ...
        IndexError: Can't get top element for the empty heap.
        """"""

        result = self.top()

        if self._root is None:
            return None

        self._root = RandomizedHeapNode.merge(self._root.left, self._root.right)

        return result",data\repos\Python\data_structures\heap\randomized_heap.py,pop,151
3007,randomized_heap.py::top::153,"    def top(self) -> T:
        """"""
        Return the smallest value from the heap.

        >>> rh = RandomizedHeap()
        >>> rh.insert(3)
        >>> rh.top()
        3
        >>> rh.insert(1)
        >>> rh.top()
        1
        >>> rh.insert(3)
        >>> rh.top()
        1
        >>> rh.insert(7)
        >>> rh.top()
        1
        """"""
        if not self._root:
            raise IndexError(""Can't get top element for the empty heap."")
        return self._root.value",data\repos\Python\data_structures\heap\randomized_heap.py,top,120
3008,randomized_heap.py::clear::175,"    def clear(self) -> None:
        """"""
        Clear the heap.

        >>> rh = RandomizedHeap([3, 1, 3, 7])
        >>> rh.clear()
        >>> rh.pop()
        Traceback (most recent call last):
            ...
        IndexError: Can't get top element for the empty heap.
        """"""
        self._root = None",data\repos\Python\data_structures\heap\randomized_heap.py,clear,76
3009,randomized_heap.py::to_sorted_list::188,"    def to_sorted_list(self) -> list[Any]:
        """"""
        Returns sorted list containing all the values in the heap.

        >>> rh = RandomizedHeap([3, 1, 3, 7])
        >>> rh.to_sorted_list()
        [1, 3, 3, 7]
        """"""
        result = []
        while self:
            result.append(self.pop())

        return result",data\repos\Python\data_structures\heap\randomized_heap.py,to_sorted_list,83
3010,skew_heap.py::value::23,"    def value(self) -> T:
        """"""
        Return the value of the node.

        >>> SkewNode(0).value
        0
        >>> SkewNode(3.14159).value
        3.14159
        >>> SkewNode(""hello"").value
        'hello'
        >>> SkewNode(None).value

        >>> SkewNode(True).value
        True
        >>> SkewNode([]).value
        []
        >>> SkewNode({}).value
        {}
        >>> SkewNode(set()).value
        set()
        >>> SkewNode(0.0).value
        0.0
        >>> SkewNode(-1e-10).value
        -1e-10
        >>> SkewNode(10).value
        10
        >>> SkewNode(-10.5).value
        -10.5
        >>> SkewNode().value
        Traceback (most recent call last):
        ...
        TypeError: SkewNode.__init__() missing 1 required positional argument: 'value'
        """"""
        return self._value",data\repos\Python\data_structures\heap\skew_heap.py,value,236
3011,skew_heap.py::merge::59,"    def merge(
        root1: SkewNode[T] | None, root2: SkewNode[T] | None
    ) -> SkewNode[T] | None:
        """"""
        Merge 2 nodes together.
        >>> SkewNode.merge(SkewNode(10),SkewNode(-10.5)).value
        -10.5
        >>> SkewNode.merge(SkewNode(10),SkewNode(10.5)).value
        10
        >>> SkewNode.merge(SkewNode(10),SkewNode(10)).value
        10
        >>> SkewNode.merge(SkewNode(-100),SkewNode(-10.5)).value
        -100
        """"""
        if not root1:
            return root2

        if not root2:
            return root1

        if root1.value > root2.value:
            root1, root2 = root2, root1

        result = root1
        temp = root1.right
        result.right = root1.left
        result.left = SkewNode.merge(temp, root2)

        return result",data\repos\Python\data_structures\heap\skew_heap.py,merge,239
3012,skew_heap.py::insert::159,"    def insert(self, value: T) -> None:
        """"""
        Insert the value into the heap.

        >>> sh = SkewHeap()
        >>> sh.insert(3)
        >>> sh.insert(1)
        >>> sh.insert(3)
        >>> sh.insert(7)
        >>> list(sh)
        [1, 3, 3, 7]
        """"""
        self._root = SkewNode.merge(self._root, SkewNode(value))",data\repos\Python\data_structures\heap\skew_heap.py,insert,96
3013,skew_heap.py::pop::173,"    def pop(self) -> T | None:
        """"""
        Pop the smallest value from the heap and return it.

        >>> sh = SkewHeap([3, 1, 3, 7])
        >>> sh.pop()
        1
        >>> sh.pop()
        3
        >>> sh.pop()
        3
        >>> sh.pop()
        7
        >>> sh.pop()
        Traceback (most recent call last):
            ...
        IndexError: Can't get top element for the empty heap.
        """"""
        result = self.top()
        self._root = (
            SkewNode.merge(self._root.left, self._root.right) if self._root else None
        )

        return result",data\repos\Python\data_structures\heap\skew_heap.py,pop,149
3014,skew_heap.py::top::198,"    def top(self) -> T:
        """"""
        Return the smallest value from the heap.

        >>> sh = SkewHeap()
        >>> sh.insert(3)
        >>> sh.top()
        3
        >>> sh.insert(1)
        >>> sh.top()
        1
        >>> sh.insert(3)
        >>> sh.top()
        1
        >>> sh.insert(7)
        >>> sh.top()
        1
        """"""
        if not self._root:
            raise IndexError(""Can't get top element for the empty heap."")
        return self._root.value",data\repos\Python\data_structures\heap\skew_heap.py,top,120
3015,skew_heap.py::clear::220,"    def clear(self) -> None:
        """"""
        Clear the heap.

        >>> sh = SkewHeap([3, 1, 3, 7])
        >>> sh.clear()
        >>> sh.pop()
        Traceback (most recent call last):
            ...
        IndexError: Can't get top element for the empty heap.
        """"""
        self._root = None",data\repos\Python\data_structures\heap\skew_heap.py,clear,76
3016,build_kdtree.py::build_kdtree::12,"def build_kdtree(points: list[list[float]], depth: int = 0) -> KDNode | None:
    """"""
    Builds a KD-Tree from a list of points.

    Args:
        points: The list of points to build the KD-Tree from.
        depth: The current depth in the tree
                     (used to determine axis for splitting).

    Returns:
        The root node of the KD-Tree,
                       or None if no points are provided.
    """"""
    if not points:
        return None

    k = len(points[0])  # Dimensionality of the points
    axis = depth % k

    # Sort point list and choose median as pivot element
    points.sort(key=lambda point: point[axis])
    median_idx = len(points) // 2

    # Create node and construct subtrees
    left_points = points[:median_idx]
    right_points = points[median_idx + 1 :]

    return KDNode(
        point=points[median_idx],
        left=build_kdtree(left_points, depth + 1),
        right=build_kdtree(right_points, depth + 1),
    )",data\repos\Python\data_structures\kd_tree\build_kdtree.py,build_kdtree,240
3017,nearest_neighbour_search.py::nearest_neighbour_search::12,"def nearest_neighbour_search(
    root: KDNode | None, query_point: list[float]
) -> tuple[list[float] | None, float, int]:
    """"""
    Performs a nearest neighbor search in a KD-Tree for a given query point.

    Args:
        root (KDNode | None): The root node of the KD-Tree.
        query_point (list[float]): The point for which the nearest neighbor
                                    is being searched.

    Returns:
        tuple[list[float] | None, float, int]:
            - The nearest point found in the KD-Tree to the query point,
              or None if no point is found.
            - The squared distance to the nearest point.
            - The number of nodes visited during the search.
    """"""
    nearest_point: list[float] | None = None
    nearest_dist: float = float(""inf"")
    nodes_visited: int = 0

    def search(node: KDNode | None, depth: int = 0) -> None:
        """"""
        Recursively searches for the nearest neighbor in the KD-Tree.

        Args:
            node: The current node in the KD-Tree.
            depth: The current depth in the KD-Tree.
        """"""
        nonlocal nearest_point, nearest_dist, nodes_visited
        if node is None:
            return

        nodes_visited += 1

        # Calculate the current distance (squared distance)
        current_point = node.point
        current_dist = sum(
            (query_coord - point_coord) ** 2
            for query_coord, point_coord in zip(query_point, current_point)
        )

        # Update nearest point if the current node is closer
        if nearest_point is None or current_dist < nearest_dist:
            nearest_point = current_point
            nearest_dist = current_dist

        # Determine which subtree to search first (based on axis and query point)
        k = len(query_point)  # Dimensionality of points
        axis = depth % k

        if query_point[axis] <= current_point[axis]:
            nearer_subtree = node.left
            further_subtree = node.right
        else:
            nearer_subtree = node.right
            further_subtree = node.left

        # Search the nearer subtree first
        search(nearer_subtree, depth + 1)

        # If the further subtree has a closer point
        if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:
            search(further_subtree, depth + 1)

    search(root, 0)
    return nearest_point, nearest_dist, nodes_visited",data\repos\Python\data_structures\kd_tree\nearest_neighbour_search.py,nearest_neighbour_search,533
3018,nearest_neighbour_search.py::search::34,"    def search(node: KDNode | None, depth: int = 0) -> None:
        """"""
        Recursively searches for the nearest neighbor in the KD-Tree.

        Args:
            node: The current node in the KD-Tree.
            depth: The current depth in the KD-Tree.
        """"""
        nonlocal nearest_point, nearest_dist, nodes_visited
        if node is None:
            return

        nodes_visited += 1

        # Calculate the current distance (squared distance)
        current_point = node.point
        current_dist = sum(
            (query_coord - point_coord) ** 2
            for query_coord, point_coord in zip(query_point, current_point)
        )

        # Update nearest point if the current node is closer
        if nearest_point is None or current_dist < nearest_dist:
            nearest_point = current_point
            nearest_dist = current_dist

        # Determine which subtree to search first (based on axis and query point)
        k = len(query_point)  # Dimensionality of points
        axis = depth % k

        if query_point[axis] <= current_point[axis]:
            nearer_subtree = node.left
            further_subtree = node.right
        else:
            nearer_subtree = node.right
            further_subtree = node.left

        # Search the nearer subtree first
        search(nearer_subtree, depth + 1)

        # If the further subtree has a closer point
        if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:
            search(further_subtree, depth + 1)",data\repos\Python\data_structures\kd_tree\nearest_neighbour_search.py,search,330
3019,circular_linked_list.py::test_circular_linked_list::151,"def test_circular_linked_list() -> None:
    """"""
    Test cases for the CircularLinkedList class.
    >>> test_circular_linked_list()
    """"""
    circular_linked_list = CircularLinkedList()
    assert len(circular_linked_list) == 0
    assert circular_linked_list.is_empty() is True
    assert str(circular_linked_list) == """"

    try:
        circular_linked_list.delete_front()
        raise AssertionError  # This should not happen
    except IndexError:
        assert True  # This should happen

    try:
        circular_linked_list.delete_tail()
        raise AssertionError  # This should not happen
    except IndexError:
        assert True  # This should happen

    try:
        circular_linked_list.delete_nth(-1)
        raise AssertionError
    except IndexError:
        assert True

    try:
        circular_linked_list.delete_nth(0)
        raise AssertionError
    except IndexError:
        assert True

    assert circular_linked_list.is_empty() is True
    for i in range(5):
        assert len(circular_linked_list) == i
        circular_linked_list.insert_nth(i, i + 1)
    assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 6))

    circular_linked_list.insert_tail(6)
    assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 7))
    circular_linked_list.insert_head(0)
    assert str(circular_linked_list) == ""->"".join(str(i) for i in range(7))

    assert circular_linked_list.delete_front() == 0
    assert circular_linked_list.delete_tail() == 6
    assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 6))
    assert circular_linked_list.delete_nth(2) == 3

    circular_linked_list.insert_nth(2, 3)
    assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 6))

    assert circular_linked_list.is_empty() is False",data\repos\Python\data_structures\linked_list\circular_linked_list.py,test_circular_linked_list,429
3020,circular_linked_list.py::insert_tail::46,"    def insert_tail(self, data: Any) -> None:
        """"""
        Insert a node with the given data at the end of the Circular Linked List.
        """"""
        self.insert_nth(len(self), data)",data\repos\Python\data_structures\linked_list\circular_linked_list.py,insert_tail,43
3021,circular_linked_list.py::insert_head::52,"    def insert_head(self, data: Any) -> None:
        """"""
        Insert a node with the given data at the beginning of the Circular Linked List.
        """"""
        self.insert_nth(0, data)",data\repos\Python\data_structures\linked_list\circular_linked_list.py,insert_head,43
3022,circular_linked_list.py::insert_nth::58,"    def insert_nth(self, index: int, data: Any) -> None:
        """"""
        Insert the data of the node at the nth pos in the Circular Linked List.
        Args:
            index: The index at which the data should be inserted.
            data: The data to be inserted.

        Raises:
            IndexError: If the index is out of range.
        """"""
        if index < 0 or index > len(self):
            raise IndexError(""list index out of range."")
        new_node: Node = Node(data)
        if self.head is None:
            new_node.next_node = new_node  # First node points to itself
            self.tail = self.head = new_node
        elif index == 0:  # Insert at the head
            new_node.next_node = self.head
            assert self.tail is not None  # List is not empty, tail exists
            self.head = self.tail.next_node = new_node
        else:
            temp: Node | None = self.head
            for _ in range(index - 1):
                assert temp is not None
                temp = temp.next_node
            assert temp is not None
            new_node.next_node = temp.next_node
            temp.next_node = new_node
            if index == len(self) - 1:  # Insert at the tail
                self.tail = new_node",data\repos\Python\data_structures\linked_list\circular_linked_list.py,insert_nth,279
3023,circular_linked_list.py::delete_front::89,"    def delete_front(self) -> Any:
        """"""
        Delete and return the data of the node at the front of the Circular Linked List.
        Raises:
            IndexError: If the list is empty.
        """"""
        return self.delete_nth(0)",data\repos\Python\data_structures\linked_list\circular_linked_list.py,delete_front,51
3024,circular_linked_list.py::delete_tail::97,"    def delete_tail(self) -> Any:
        """"""
        Delete and return the data of the node at the end of the Circular Linked List.
        Returns:
            Any: The data of the deleted node.
        Raises:
            IndexError: If the index is out of range.
        """"""
        return self.delete_nth(len(self) - 1)",data\repos\Python\data_structures\linked_list\circular_linked_list.py,delete_tail,70
3025,circular_linked_list.py::delete_nth::107,"    def delete_nth(self, index: int = 0) -> Any:
        """"""
        Delete and return the data of the node at the nth pos in Circular Linked List.
        Args:
            index (int): The index of the node to be deleted. Defaults to 0.
        Returns:
            Any: The data of the deleted node.
        Raises:
            IndexError: If the index is out of range.
        """"""
        if not 0 <= index < len(self):
            raise IndexError(""list index out of range."")

        assert self.head is not None
        assert self.tail is not None
        delete_node: Node = self.head
        if self.head == self.tail:  # Just one node
            self.head = self.tail = None
        elif index == 0:  # Delete head node
            assert self.tail.next_node is not None
            self.tail.next_node = self.tail.next_node.next_node
            self.head = self.head.next_node
        else:
            temp: Node | None = self.head
            for _ in range(index - 1):
                assert temp is not None
                temp = temp.next_node
            assert temp is not None
            assert temp.next_node is not None
            delete_node = temp.next_node
            temp.next_node = temp.next_node.next_node
            if index == len(self) - 1:  # Delete at tail
                self.tail = temp
        return delete_node.data",data\repos\Python\data_structures\linked_list\circular_linked_list.py,delete_nth,301
3026,circular_linked_list.py::is_empty::142,"    def is_empty(self) -> bool:
        """"""
        Check if the Circular Linked List is empty.
        Returns:
            bool: True if the list is empty, False otherwise.
        """"""
        return len(self) == 0",data\repos\Python\data_structures\linked_list\circular_linked_list.py,is_empty,47
3027,deque_doubly.py::first::63,"    def first(self):
        """"""return first element
        >>> d = LinkedDeque()
        >>> d.add_first('A').first()
        'A'
        >>> d.add_first('B').first()
        'B'
        """"""
        if self.is_empty():
            raise Exception(""List is empty"")
        return self._header._next._data",data\repos\Python\data_structures\linked_list\deque_doubly.py,first,71
3028,deque_doubly.py::last::75,"    def last(self):
        """"""return last element
        >>> d = LinkedDeque()
        >>> d.add_last('A').last()
        'A'
        >>> d.add_last('B').last()
        'B'
        """"""
        if self.is_empty():
            raise Exception(""List is empty"")
        return self._trailer._prev._data",data\repos\Python\data_structures\linked_list\deque_doubly.py,last,72
3029,deque_doubly.py::add_first::89,"    def add_first(self, element):
        """"""insertion in the front
        >>> LinkedDeque().add_first('AV').first()
        'AV'
        """"""
        return self._insert(self._header, element, self._header._next)",data\repos\Python\data_structures\linked_list\deque_doubly.py,add_first,51
3030,deque_doubly.py::add_last::96,"    def add_last(self, element):
        """"""insertion in the end
        >>> LinkedDeque().add_last('B').last()
        'B'
        """"""
        return self._insert(self._trailer._prev, element, self._trailer)",data\repos\Python\data_structures\linked_list\deque_doubly.py,add_last,53
3031,deque_doubly.py::remove_first::105,"    def remove_first(self):
        """"""removal from the front
        >>> d = LinkedDeque()
        >>> d.is_empty()
        True
        >>> d.remove_first()
        Traceback (most recent call last):
           ...
        IndexError: remove_first from empty list
        >>> d.add_first('A') # doctest: +ELLIPSIS
        <data_structures.linked_list.deque_doubly.LinkedDeque object at ...
        >>> d.remove_first()
        'A'
        >>> d.is_empty()
        True
        """"""
        if self.is_empty():
            raise IndexError(""remove_first from empty list"")
        return self._delete(self._header._next)",data\repos\Python\data_structures\linked_list\deque_doubly.py,remove_first,139
3032,deque_doubly.py::remove_last::125,"    def remove_last(self):
        """"""removal in the end
        >>> d = LinkedDeque()
        >>> d.is_empty()
        True
        >>> d.remove_last()
        Traceback (most recent call last):
           ...
        IndexError: remove_first from empty list
        >>> d.add_first('A') # doctest: +ELLIPSIS
        <data_structures.linked_list.deque_doubly.LinkedDeque object at ...
        >>> d.remove_last()
        'A'
        >>> d.is_empty()
        True
        """"""
        if self.is_empty():
            raise IndexError(""remove_first from empty list"")
        return self._delete(self._trailer._prev)",data\repos\Python\data_structures\linked_list\deque_doubly.py,remove_last,140
3033,deque_doubly.py::has_next_and_prev::22,"        def has_next_and_prev(self):
            return (
                f"" Prev -> {self._prev is not None}, Next -> {self._next is not None}""
            )",data\repos\Python\data_structures\linked_list\deque_doubly.py,has_next_and_prev,36
3034,doubly_linked_list.py::test_doubly_linked_list::191,"def test_doubly_linked_list() -> None:
    """"""
    >>> test_doubly_linked_list()
    """"""
    linked_list = DoublyLinkedList()
    assert linked_list.is_empty() is True
    assert str(linked_list) == """"

    try:
        linked_list.delete_head()
        raise AssertionError  # This should not happen.
    except IndexError:
        assert True  # This should happen.

    try:
        linked_list.delete_tail()
        raise AssertionError  # This should not happen.
    except IndexError:
        assert True  # This should happen.

    for i in range(10):
        assert len(linked_list) == i
        linked_list.insert_at_nth(i, i + 1)
    assert str(linked_list) == ""->"".join(str(i) for i in range(1, 11))

    linked_list.insert_at_head(0)
    linked_list.insert_at_tail(11)
    assert str(linked_list) == ""->"".join(str(i) for i in range(12))

    assert linked_list.delete_head() == 0
    assert linked_list.delete_at_nth(9) == 10
    assert linked_list.delete_tail() == 11
    assert len(linked_list) == 9
    assert str(linked_list) == ""->"".join(str(i) for i in range(1, 10))",data\repos\Python\data_structures\linked_list\doubly_linked_list.py,test_doubly_linked_list,280
3035,doubly_linked_list.py::insert_at_nth::62,"    def insert_at_nth(self, index: int, data):
        """"""
        >>> linked_list = DoublyLinkedList()
        >>> linked_list.insert_at_nth(-1, 666)
        Traceback (most recent call last):
            ....
        IndexError: list index out of range
        >>> linked_list.insert_at_nth(1, 666)
        Traceback (most recent call last):
            ....
        IndexError: list index out of range
        >>> linked_list.insert_at_nth(0, 2)
        >>> linked_list.insert_at_nth(0, 1)
        >>> linked_list.insert_at_nth(2, 4)
        >>> linked_list.insert_at_nth(2, 3)
        >>> str(linked_list)
        '1->2->3->4'
        >>> linked_list.insert_at_nth(5, 5)
        Traceback (most recent call last):
            ....
        IndexError: list index out of range
        """"""
        length = len(self)

        if not 0 <= index <= length:
            raise IndexError(""list index out of range"")
        new_node = Node(data)
        if self.head is None:
            self.head = self.tail = new_node
        elif index == 0:
            self.head.previous = new_node
            new_node.next = self.head
            self.head = new_node
        elif index == length:
            self.tail.next = new_node
            new_node.previous = self.tail
            self.tail = new_node
        else:
            temp = self.head
            for _ in range(index):
                temp = temp.next
            temp.previous.next = new_node
            new_node.previous = temp.previous
            new_node.next = temp
            temp.previous = new_node",data\repos\Python\data_structures\linked_list\doubly_linked_list.py,insert_at_nth,357
3036,doubly_linked_list.py::delete_at_nth::114,"    def delete_at_nth(self, index: int):
        """"""
        >>> linked_list = DoublyLinkedList()
        >>> linked_list.delete_at_nth(0)
        Traceback (most recent call last):
            ....
        IndexError: list index out of range
        >>> for i in range(0, 5):
        ...     linked_list.insert_at_nth(i, i + 1)
        >>> linked_list.delete_at_nth(0) == 1
        True
        >>> linked_list.delete_at_nth(3) == 5
        True
        >>> linked_list.delete_at_nth(1) == 3
        True
        >>> str(linked_list)
        '2->4'
        >>> linked_list.delete_at_nth(2)
        Traceback (most recent call last):
            ....
        IndexError: list index out of range
        """"""
        length = len(self)

        if not 0 <= index <= length - 1:
            raise IndexError(""list index out of range"")
        delete_node = self.head  # default first node
        if length == 1:
            self.head = self.tail = None
        elif index == 0:
            self.head = self.head.next
            self.head.previous = None
        elif index == length - 1:
            delete_node = self.tail
            self.tail = self.tail.previous
            self.tail.next = None
        else:
            temp = self.head
            for _ in range(index):
                temp = temp.next
            delete_node = temp
            temp.next.previous = temp.previous
            temp.previous.next = temp.next
        return delete_node.data",data\repos\Python\data_structures\linked_list\doubly_linked_list.py,delete_at_nth,336
3037,doubly_linked_list.py::delete::159,"    def delete(self, data) -> str:
        current = self.head

        while current.data != data:  # Find the position to delete
            if current.next:
                current = current.next
            else:  # We have reached the end an no value matches
                raise ValueError(""No data matching given value"")

        if current == self.head:
            self.delete_head()

        elif current == self.tail:
            self.delete_tail()

        else:  # Before: 1 <--> 2(current) <--> 3
            current.previous.next = current.next  # 1 --> 3
            current.next.previous = current.previous  # 1 <--> 3
        return data",data\repos\Python\data_structures\linked_list\doubly_linked_list.py,delete,145
3038,doubly_linked_list.py::is_empty::179,"    def is_empty(self):
        """"""
        >>> linked_list = DoublyLinkedList()
        >>> linked_list.is_empty()
        True
        >>> linked_list.insert_at_tail(1)
        >>> linked_list.is_empty()
        False
        """"""
        return len(self) == 0",data\repos\Python\data_structures\linked_list\doubly_linked_list.py,is_empty,57
3039,doubly_linked_list_two.py::create_linked_list::166,"def create_linked_list() -> None:
    """"""
    >>> new_linked_list = LinkedList()
    >>> new_linked_list.get_head_data() is None
    True
    >>> new_linked_list.get_tail_data() is None
    True
    >>> new_linked_list.is_empty()
    True
    >>> new_linked_list.insert(10)
    >>> new_linked_list.get_head_data()
    10
    >>> new_linked_list.get_tail_data()
    10
    >>> new_linked_list.insert_at_position(position=3, value=20)
    >>> new_linked_list.get_head_data()
    10
    >>> new_linked_list.get_tail_data()
    20
    >>> new_linked_list.set_head(Node(1000))
    >>> new_linked_list.get_head_data()
    1000
    >>> new_linked_list.get_tail_data()
    20
    >>> new_linked_list.set_tail(Node(2000))
    >>> new_linked_list.get_head_data()
    1000
    >>> new_linked_list.get_tail_data()
    2000
    >>> for value in new_linked_list:
    ...    print(value)
    1000
    10
    20
    2000
    >>> new_linked_list.is_empty()
    False
    >>> for value in new_linked_list:
    ...    print(value)
    1000
    10
    20
    2000
    >>> 10 in new_linked_list
    True
    >>> new_linked_list.delete_value(value=10)
    >>> 10 in new_linked_list
    False
    >>> new_linked_list.delete_value(value=2000)
    >>> new_linked_list.get_tail_data()
    20
    >>> new_linked_list.delete_value(value=1000)
    >>> new_linked_list.get_tail_data()
    20
    >>> new_linked_list.get_head_data()
    20
    >>> for value in new_linked_list:
    ...    print(value)
    20
    >>> new_linked_list.delete_value(value=20)
    >>> for value in new_linked_list:
    ...    print(value)
    >>> for value in range(1,10):
    ...    new_linked_list.insert(value=value)
    >>> for value in new_linked_list:
    ...    print(value)
    1
    2
    3
    4
    5
    6
    7
    8
    9
    >>> linked_list = LinkedList()
    >>> linked_list.insert_at_position(position=1, value=10)
    >>> str(linked_list)
    '10'
    >>> linked_list.insert_at_position(position=2, value=20)
    >>> str(linked_list)
    '10 20'
    >>> linked_list.insert_at_position(position=1, value=30)
    >>> str(linked_list)
    '30 10 20'
    >>> linked_list.insert_at_position(position=3, value=40)
    >>> str(linked_list)
    '30 10 40 20'
    >>> linked_list.insert_at_position(position=5, value=50)
    >>> str(linked_list)
    '30 10 40 20 50'
    """"""",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,create_linked_list,666
3040,doubly_linked_list_two.py::set_head::78,"    def set_head(self, node: Node) -> None:
        if self.head is None:
            self.head = node
            self.tail = node
        else:
            self.insert_before_node(self.head, node)",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,set_head,45
3041,doubly_linked_list_two.py::set_tail::85,"    def set_tail(self, node: Node) -> None:
        if self.tail is None:
            self.head = node
            self.tail = node
        else:
            self.insert_after_node(self.tail, node)",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,set_tail,45
3042,doubly_linked_list_two.py::insert::92,"    def insert(self, value: DataType) -> None:
        node = Node(value)
        if self.head is None:
            self.set_head(node)
        else:
            self.set_tail(node)",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,insert,40
3043,doubly_linked_list_two.py::insert_before_node::99,"    def insert_before_node(self, node: Node, node_to_insert: Node) -> None:
        node_to_insert.next = node
        node_to_insert.previous = node.previous

        if node.previous is None:
            self.head = node_to_insert
        else:
            node.previous.next = node_to_insert

        node.previous = node_to_insert",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,insert_before_node,71
3044,doubly_linked_list_two.py::insert_after_node::110,"    def insert_after_node(self, node: Node, node_to_insert: Node) -> None:
        node_to_insert.previous = node
        node_to_insert.next = node.next

        if node.next is None:
            self.tail = node_to_insert
        else:
            node.next.previous = node_to_insert

        node.next = node_to_insert",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,insert_after_node,71
3045,doubly_linked_list_two.py::insert_at_position::121,"    def insert_at_position(self, position: int, value: DataType) -> None:
        current_position = 1
        new_node = Node(value)
        node = self.head
        while node:
            if current_position == position:
                self.insert_before_node(node, new_node)
                return
            current_position += 1
            node = node.next
        self.set_tail(new_node)",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,insert_at_position,82
3046,doubly_linked_list_two.py::get_node::133,"    def get_node(self, item: DataType) -> Node:
        node = self.head
        while node:
            if node.data == item:
                return node
            node = node.next
        raise Exception(""Node not found"")",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,get_node,48
3047,doubly_linked_list_two.py::delete_value::141,"    def delete_value(self, value):
        if (node := self.get_node(value)) is not None:
            if node == self.head:
                self.head = self.head.next

            if node == self.tail:
                self.tail = self.tail.previous

            self.remove_node_pointers(node)",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,delete_value,60
3048,doubly_linked_list_two.py::remove_node_pointers::152,"    def remove_node_pointers(node: Node) -> None:
        if node.next:
            node.next.previous = node.previous

        if node.previous:
            node.previous.next = node.next

        node.next = None
        node.previous = None",data\repos\Python\data_structures\linked_list\doubly_linked_list_two.py,remove_node_pointers,50
3049,floyds_cycle_detection.py::add_node::61,"    def add_node(self, data: Any) -> None:
        """"""
        Adds a new node to the end of the linked list.

        Args:
            data (Any): The data to be stored in the new node.

        Examples:
        >>> linked_list = LinkedList()
        >>> linked_list.add_node(1)
        >>> linked_list.add_node(2)
        >>> linked_list.add_node(3)
        >>> linked_list.add_node(4)
        >>> tuple(linked_list)
        (1, 2, 3, 4)
        """"""
        new_node = Node(data)

        if self.head is None:
            self.head = new_node
            return

        current_node = self.head
        while current_node.next_node is not None:
            current_node = current_node.next_node

        current_node.next_node = new_node",data\repos\Python\data_structures\linked_list\floyds_cycle_detection.py,add_node,172
3050,floyds_cycle_detection.py::detect_cycle::89,"    def detect_cycle(self) -> bool:
        """"""
        Detects if there is a cycle in the linked list using
        Floyd's cycle detection algorithm.

        Returns:
            bool: True if there is a cycle, False otherwise.

        Examples:
        >>> linked_list = LinkedList()
        >>> linked_list.add_node(1)
        >>> linked_list.add_node(2)
        >>> linked_list.add_node(3)
        >>> linked_list.add_node(4)

        >>> linked_list.detect_cycle()
        False

        # Create a cycle in the linked list
        >>> linked_list.head.next_node.next_node.next_node = linked_list.head.next_node

        >>> linked_list.detect_cycle()
        True
        """"""
        if self.head is None:
            return False

        slow_pointer: Node | None = self.head
        fast_pointer: Node | None = self.head

        while fast_pointer is not None and fast_pointer.next_node is not None:
            slow_pointer = slow_pointer.next_node if slow_pointer else None
            fast_pointer = fast_pointer.next_node.next_node
            if slow_pointer == fast_pointer:
                return True

        return False",data\repos\Python\data_structures\linked_list\floyds_cycle_detection.py,detect_cycle,233
3051,from_sequence.py::make_linked_list::23,"def make_linked_list(elements_list: list | tuple) -> Node:
    """"""
    Creates a Linked List from the elements of the given sequence
    (list/tuple) and returns the head of the Linked List.

    >>> make_linked_list([])
    Traceback (most recent call last):
        ...
    ValueError: The Elements List is empty
    >>> make_linked_list(())
    Traceback (most recent call last):
        ...
    ValueError: The Elements List is empty
    >>> make_linked_list([1])
    <1> ---> <END>
    >>> make_linked_list((1,))
    <1> ---> <END>
    >>> make_linked_list([1, 3, 5, 32, 44, 12, 43])
    <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>
    >>> make_linked_list((1, 3, 5, 32, 44, 12, 43))
    <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>
    """"""

    # if elements_list is empty
    if not elements_list:
        raise ValueError(""The Elements List is empty"")

    # Set first element as Head
    head = Node(elements_list[0])
    current = head
    # Loop through elements from position 1
    for data in elements_list[1:]:
        current.next = Node(data)
        current = current.next
    return head",data\repos\Python\data_structures\linked_list\from_sequence.py,make_linked_list,327
3052,has_loop.py::has_loop::26,"    def has_loop(self) -> bool:
        """"""
        A loop is when the exact same Node appears more than once in a linked list.
        >>> root_node = Node(1)
        >>> root_node.next_node = Node(2)
        >>> root_node.next_node.next_node = Node(3)
        >>> root_node.next_node.next_node.next_node = Node(4)
        >>> root_node.has_loop
        False
        >>> root_node.next_node.next_node.next_node = root_node.next_node
        >>> root_node.has_loop
        True
        """"""
        try:
            list(self)
            return False
        except ContainsLoopError:
            return True",data\repos\Python\data_structures\linked_list\has_loop.py,has_loop,135
3053,is_palindrome.py::is_palindrome::12,"def is_palindrome(head: ListNode | None) -> bool:
    """"""
    Check if a linked list is a palindrome.

    Args:
        head: The head of the linked list.

    Returns:
        bool: True if the linked list is a palindrome, False otherwise.

    Examples:
        >>> is_palindrome(None)
        True

        >>> is_palindrome(ListNode(1))
        True

        >>> is_palindrome(ListNode(1, ListNode(2)))
        False

        >>> is_palindrome(ListNode(1, ListNode(2, ListNode(1))))
        True

        >>> is_palindrome(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))
        True
    """"""
    if not head:
        return True
    # split the list to two parts
    fast: ListNode | None = head.next_node
    slow: ListNode | None = head
    while fast and fast.next_node:
        fast = fast.next_node.next_node
        slow = slow.next_node if slow else None
    if slow:
        # slow will always be defined,
        # adding this check to resolve mypy static check
        second = slow.next_node
        slow.next_node = None  # Don't forget here! But forget still works!
    # reverse the second part
    node: ListNode | None = None
    while second:
        nxt = second.next_node
        second.next_node = node
        node = second
        second = nxt
    # compare two parts
    # second part has the same or one less node
    while node and head:
        if node.val != head.val:
            return False
        node = node.next_node
        head = head.next_node
    return True",data\repos\Python\data_structures\linked_list\is_palindrome.py,is_palindrome,355
3054,is_palindrome.py::is_palindrome_stack::68,"def is_palindrome_stack(head: ListNode | None) -> bool:
    """"""
    Check if a linked list is a palindrome using a stack.

    Args:
        head (ListNode): The head of the linked list.

    Returns:
        bool: True if the linked list is a palindrome, False otherwise.

    Examples:
        >>> is_palindrome_stack(None)
        True

        >>> is_palindrome_stack(ListNode(1))
        True

        >>> is_palindrome_stack(ListNode(1, ListNode(2)))
        False

        >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(1))))
        True

        >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))
        True
    """"""
    if not head or not head.next_node:
        return True

    # 1. Get the midpoint (slow)
    slow: ListNode | None = head
    fast: ListNode | None = head
    while fast and fast.next_node:
        fast = fast.next_node.next_node
        slow = slow.next_node if slow else None

    # slow will always be defined,
    # adding this check to resolve mypy static check
    if slow:
        stack = [slow.val]

        # 2. Push the second half into the stack
        while slow.next_node:
            slow = slow.next_node
            stack.append(slow.val)

        # 3. Comparison
        cur: ListNode | None = head
        while stack and cur:
            if stack.pop() != cur.val:
                return False
            cur = cur.next_node

    return True",data\repos\Python\data_structures\linked_list\is_palindrome.py,is_palindrome_stack,334
3055,is_palindrome.py::is_palindrome_dict::124,"def is_palindrome_dict(head: ListNode | None) -> bool:
    """"""
    Check if a linked list is a palindrome using a dictionary.

    Args:
        head (ListNode): The head of the linked list.

    Returns:
        bool: True if the linked list is a palindrome, False otherwise.

    Examples:
        >>> is_palindrome_dict(None)
        True

        >>> is_palindrome_dict(ListNode(1))
        True

        >>> is_palindrome_dict(ListNode(1, ListNode(2)))
        False

        >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(1))))
        True

        >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))
        True

        >>> is_palindrome_dict(
        ...     ListNode(
        ...         1, ListNode(2, ListNode(1, ListNode(3, ListNode(2, ListNode(1)))))
        ...     )
        ... )
        False
    """"""
    if not head or not head.next_node:
        return True
    d: dict[int, list[int]] = {}
    pos = 0
    while head:
        if head.val in d:
            d[head.val].append(pos)
        else:
            d[head.val] = [pos]
        head = head.next_node
        pos += 1
    checksum = pos - 1
    middle = 0
    for v in d.values():
        if len(v) % 2 != 0:
            middle += 1
        else:
            for step, i in enumerate(range(len(v))):
                if v[i] + v[len(v) - 1 - step] != checksum:
                    return False
        if middle > 1:
            return False
    return True",data\repos\Python\data_structures\linked_list\is_palindrome.py,is_palindrome_dict,369
3056,merge_two_lists.py::merge_lists::62,"def merge_lists(
    sll_one: SortedLinkedList, sll_two: SortedLinkedList
) -> SortedLinkedList:
    """"""
    >>> SSL = SortedLinkedList
    >>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))
    >>> len(merged)
    16
    >>> str(merged)
    '-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'
    >>> list(merged) == list(sorted(test_data_odd + test_data_even))
    True
    """"""
    return SortedLinkedList(list(sll_one) + list(sll_two))",data\repos\Python\data_structures\linked_list\merge_two_lists.py,merge_lists,152
3057,middle_element_of_linked_list.py::push::14,"    def push(self, new_data: int) -> int:
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node
        return self.head.data",data\repos\Python\data_structures\linked_list\middle_element_of_linked_list.py,push,41
3058,middle_element_of_linked_list.py::middle_element::20,"    def middle_element(self) -> int | None:
        """"""
        >>> link = LinkedList()
        >>> link.middle_element()
        No element found.
        >>> link.push(5)
        5
        >>> link.push(6)
        6
        >>> link.push(8)
        8
        >>> link.push(8)
        8
        >>> link.push(10)
        10
        >>> link.push(12)
        12
        >>> link.push(17)
        17
        >>> link.push(7)
        7
        >>> link.push(3)
        3
        >>> link.push(20)
        20
        >>> link.push(-20)
        -20
        >>> link.middle_element()
        12
        >>>
        """"""
        slow_pointer = self.head
        fast_pointer = self.head
        if self.head:
            while fast_pointer and fast_pointer.next:
                fast_pointer = fast_pointer.next.next
                slow_pointer = slow_pointer.next
            return slow_pointer.data
        else:
            print(""No element found."")
            return None",data\repos\Python\data_structures\linked_list\middle_element_of_linked_list.py,middle_element,230
3059,print_reverse.py::make_linked_list::88,"def make_linked_list(elements_list: Iterable[int]) -> LinkedList:
    """"""Creates a Linked List from the elements of the given sequence
    (list/tuple) and returns the head of the Linked List.
    >>> make_linked_list([])
    Traceback (most recent call last):
        ...
    Exception: The Elements List is empty
    >>> make_linked_list([7])
    7
    >>> make_linked_list(['abc'])
    abc
    >>> make_linked_list([7, 25])
    7 -> 25
    """"""
    if not elements_list:
        raise Exception(""The Elements List is empty"")

    linked_list = LinkedList()
    linked_list.extend(elements_list)
    return linked_list",data\repos\Python\data_structures\linked_list\print_reverse.py,make_linked_list,144
3060,print_reverse.py::in_reverse::110,"def in_reverse(linked_list: LinkedList) -> str:
    """"""Prints the elements of the given Linked List in reverse order
    >>> in_reverse(LinkedList())
    ''
    >>> in_reverse(make_linked_list([69, 88, 73]))
    '73 <- 88 <- 69'
    """"""
    return "" <- "".join(str(line) for line in reversed(tuple(linked_list)))",data\repos\Python\data_structures\linked_list\print_reverse.py,in_reverse,82
3061,print_reverse.py::append::54,"    def append(self, data: int) -> None:
        """"""Appends a new node with the given data to the end of the LinkedList.
        >>> linked_list = LinkedList()
        >>> str(linked_list)
        ''
        >>> linked_list.append(1)
        >>> str(linked_list)
        '1'
        >>> linked_list.append(2)
        >>> str(linked_list)
        '1 -> 2'
        """"""
        if self.tail:
            self.tail.next_node = self.tail = Node(data)
        else:
            self.head = self.tail = Node(data)",data\repos\Python\data_structures\linked_list\print_reverse.py,append,119
3062,print_reverse.py::extend::71,"    def extend(self, items: Iterable[int]) -> None:
        """"""Appends each item to the end of the LinkedList.
        >>> linked_list = LinkedList()
        >>> linked_list.extend([])
        >>> str(linked_list)
        ''
        >>> linked_list.extend([1, 2])
        >>> str(linked_list)
        '1 -> 2'
        >>> linked_list.extend([3,4])
        >>> str(linked_list)
        '1 -> 2 -> 3 -> 4'
        """"""
        for item in items:
            self.append(item)",data\repos\Python\data_structures\linked_list\print_reverse.py,extend,116
3063,reverse_k_group.py::append::54,"    def append(self, data: int) -> None:
        """"""
        >>> ll = LinkedList([1, 2])
        >>> tuple(ll)
        (1, 2)
        >>> ll.append(3)
        >>> tuple(ll)
        (1, 2, 3)
        >>> ll.append(4)
        >>> tuple(ll)
        (1, 2, 3, 4)
        >>> len(ll)
        4
        """"""
        if not self.head:
            self.head = Node(data)
            return
        node = self.head
        while node.next_node:
            node = node.next_node
        node.next_node = Node(data)",data\repos\Python\data_structures\linked_list\reverse_k_group.py,append,138
3064,reverse_k_group.py::reverse_k_nodes::76,"    def reverse_k_nodes(self, group_size: int) -> None:
        """"""
        reverse nodes within groups of size k
        >>> ll = LinkedList([1, 2, 3, 4, 5])
        >>> ll.reverse_k_nodes(2)
        >>> tuple(ll)
        (2, 1, 4, 3, 5)
        >>> str(ll)
        '2 -> 1 -> 4 -> 3 -> 5'
        """"""
        if self.head is None or self.head.next_node is None:
            return

        length = len(self)
        dummy_head = Node(0)
        dummy_head.next_node = self.head
        previous_node = dummy_head

        while length >= group_size:
            current_node = previous_node.next_node
            assert current_node
            next_node = current_node.next_node
            for _ in range(1, group_size):
                assert next_node, current_node
                current_node.next_node = next_node.next_node
                assert previous_node
                next_node.next_node = previous_node.next_node
                previous_node.next_node = next_node
                next_node = current_node.next_node
            previous_node = current_node
            length -= group_size
        self.head = dummy_head.next_node",data\repos\Python\data_structures\linked_list\reverse_k_group.py,reverse_k_nodes,261
3065,rotate_to_the_right.py::print_linked_list::12,"def print_linked_list(head: Node | None) -> None:
    """"""
        Print the entire linked list iteratively.

        This function prints the elements of a linked list separated by '->'.

        Parameters:
            head (Node | None): The head of the linked list to be printed,
    or None if the linked list is empty.

        >>> head = insert_node(None, 0)
        >>> head = insert_node(head, 2)
        >>> head = insert_node(head, 1)
        >>> print_linked_list(head)
        0->2->1
        >>> head = insert_node(head, 4)
        >>> head = insert_node(head, 5)
        >>> print_linked_list(head)
        0->2->1->4->5
    """"""
    if head is None:
        return
    while head.next_node is not None:
        print(head.data, end=""->"")
        head = head.next_node
    print(head.data)",data\repos\Python\data_structures\linked_list\rotate_to_the_right.py,print_linked_list,199
3066,rotate_to_the_right.py::insert_node::40,"def insert_node(head: Node | None, data: int) -> Node:
    """"""
    Insert a new node at the end of a linked list and return the new head.

    Parameters:
        head (Node | None): The head of the linked list.
        data (int): The data to be inserted into the new node.

    Returns:
        Node: The new head of the linked list.

    >>> head = insert_node(None, 10)
    >>> head = insert_node(head, 9)
    >>> head = insert_node(head, 8)
    >>> print_linked_list(head)
    10->9->8
    """"""
    new_node = Node(data)
    # If the linked list is empty, the new_node becomes the head
    if head is None:
        return new_node

    temp_node = head
    while temp_node.next_node:
        temp_node = temp_node.next_node

    temp_node.next_node = new_node
    return head",data\repos\Python\data_structures\linked_list\rotate_to_the_right.py,insert_node,200
3067,rotate_to_the_right.py::rotate_to_the_right::70,"def rotate_to_the_right(head: Node, places: int) -> Node:
    """"""
    Rotate a linked list to the right by places times.

    Parameters:
        head: The head of the linked list.
        places: The number of places to rotate.

    Returns:
        Node: The head of the rotated linked list.

    >>> rotate_to_the_right(None, places=1)
    Traceback (most recent call last):
        ...
    ValueError: The linked list is empty.
    >>> head = insert_node(None, 1)
    >>> rotate_to_the_right(head, places=1) == head
    True
    >>> head = insert_node(None, 1)
    >>> head = insert_node(head, 2)
    >>> head = insert_node(head, 3)
    >>> head = insert_node(head, 4)
    >>> head = insert_node(head, 5)
    >>> new_head = rotate_to_the_right(head, places=2)
    >>> print_linked_list(new_head)
    4->5->1->2->3
    """"""
    # Check if the list is empty or has only one element
    if not head:
        raise ValueError(""The linked list is empty."")

    if head.next_node is None:
        return head

    # Calculate the length of the linked list
    length = 1
    temp_node = head
    while temp_node.next_node is not None:
        length += 1
        temp_node = temp_node.next_node

    # Adjust the value of places to avoid places longer than the list.
    places %= length

    if places == 0:
        return head  # As no rotation is needed.

    # Find the new head position after rotation.
    new_head_index = length - places

    # Traverse to the new head position
    temp_node = head
    for _ in range(new_head_index - 1):
        assert temp_node.next_node
        temp_node = temp_node.next_node

    # Update pointers to perform rotation
    assert temp_node.next_node
    new_head = temp_node.next_node
    temp_node.next_node = None
    temp_node = new_head
    while temp_node.next_node:
        temp_node = temp_node.next_node
    temp_node.next_node = head

    assert new_head
    return new_head",data\repos\Python\data_structures\linked_list\rotate_to_the_right.py,rotate_to_the_right,480
3068,singly_linked_list.py::test_singly_linked_list::366,"def test_singly_linked_list() -> None:
    """"""
    >>> test_singly_linked_list()
    """"""
    linked_list = LinkedList()
    assert linked_list.is_empty() is True
    assert str(linked_list) == """"

    try:
        linked_list.delete_head()
        raise AssertionError  # This should not happen.
    except IndexError:
        assert True  # This should happen.

    try:
        linked_list.delete_tail()
        raise AssertionError  # This should not happen.
    except IndexError:
        assert True  # This should happen.

    for i in range(10):
        assert len(linked_list) == i
        linked_list.insert_nth(i, i + 1)
    assert str(linked_list) == "" -> "".join(str(i) for i in range(1, 11))

    linked_list.insert_head(0)
    linked_list.insert_tail(11)
    assert str(linked_list) == "" -> "".join(str(i) for i in range(12))

    assert linked_list.delete_head() == 0
    assert linked_list.delete_nth(9) == 10
    assert linked_list.delete_tail() == 11
    assert len(linked_list) == 9
    assert str(linked_list) == "" -> "".join(str(i) for i in range(1, 10))

    assert all(linked_list[i] == i + 1 for i in range(9)) is True

    for i in range(9):
        linked_list[i] = -i
    assert all(linked_list[i] == -i for i in range(9)) is True

    linked_list.reverse()
    assert str(linked_list) == "" -> "".join(str(i) for i in range(-8, 1))",data\repos\Python\data_structures\linked_list\singly_linked_list.py,test_singly_linked_list,366
3069,singly_linked_list.py::test_singly_linked_list_2::411,"def test_singly_linked_list_2() -> None:
    """"""
    This section of the test used varying data types for input.
    >>> test_singly_linked_list_2()
    """"""
    test_input = [
        -9,
        100,
        Node(77345112),
        ""dlrow olleH"",
        7,
        5555,
        0,
        -192.55555,
        ""Hello, world!"",
        77.9,
        Node(10),
        None,
        None,
        12.20,
    ]
    linked_list = LinkedList()

    for i in test_input:
        linked_list.insert_tail(i)

    # Check if it's empty or not
    assert linked_list.is_empty() is False
    assert (
        str(linked_list)
        == ""-9 -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> ""
        ""0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2""
    )

    # Delete the head
    result = linked_list.delete_head()
    assert result == -9
    assert (
        str(linked_list) == ""100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> ""
        ""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2""
    )

    # Delete the tail
    result = linked_list.delete_tail()
    assert result == 12.2
    assert (
        str(linked_list) == ""100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> ""
        ""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None""
    )

    # Delete a node in specific location in linked list
    result = linked_list.delete_nth(10)
    assert result is None
    assert (
        str(linked_list) == ""100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> ""
        ""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None""
    )

    # Add a Node instance to its head
    linked_list.insert_head(Node(""Hello again, world!""))
    assert (
        str(linked_list)
        == ""Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> ""
        ""7 -> 5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None""
    )

    # Add None to its tail
    linked_list.insert_tail(None)
    assert (
        str(linked_list)
        == ""Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> ""
        ""5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None""
    )

    # Reverse the linked list
    linked_list.reverse()
    assert (
        str(linked_list)
        == ""None -> None -> Node(10) -> 77.9 -> Hello, world! -> -192.55555 -> 0 -> ""
        ""5555 -> 7 -> dlrow olleH -> Node(77345112) -> 100 -> Node(Hello again, world!)""
    )",data\repos\Python\data_structures\linked_list\singly_linked_list.py,test_singly_linked_list_2,775
3070,singly_linked_list.py::main::494,"def main():
    from doctest import testmod

    testmod()

    linked_list = LinkedList()
    linked_list.insert_head(input(""Inserting 1st at head "").strip())
    linked_list.insert_head(input(""Inserting 2nd at head "").strip())
    print(""\nPrint list:"")
    linked_list.print_list()
    linked_list.insert_tail(input(""\nInserting 1st at tail "").strip())
    linked_list.insert_tail(input(""Inserting 2nd at tail "").strip())
    print(""\nPrint list:"")
    linked_list.print_list()
    print(""\nDelete head"")
    linked_list.delete_head()
    print(""Delete tail"")
    linked_list.delete_tail()
    print(""\nPrint list:"")
    linked_list.print_list()
    print(""\nReverse linked list"")
    linked_list.reverse()
    print(""\nPrint list:"")
    linked_list.print_list()
    print(""\nString representation of linked list:"")
    print(linked_list)
    print(""\nReading/changing Node data using indexing:"")
    print(f""Element at Position 1: {linked_list[1]}"")
    linked_list[1] = input(""Enter New Value: "").strip()
    print(""New list:"")
    print(linked_list)
    print(f""length of linked_list is : {len(linked_list)}"")",data\repos\Python\data_structures\linked_list\singly_linked_list.py,main,270
3071,singly_linked_list.py::insert_tail::160,"    def insert_tail(self, data: Any) -> None:
        """"""
        Insert data to the end of linked list.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_tail(""tail"")
        >>> linked_list
        tail
        >>> linked_list.insert_tail(""tail_2"")
        >>> linked_list
        tail -> tail_2
        >>> linked_list.insert_tail(""tail_3"")
        >>> linked_list
        tail -> tail_2 -> tail_3
        """"""
        self.insert_nth(len(self), data)",data\repos\Python\data_structures\linked_list\singly_linked_list.py,insert_tail,110
3072,singly_linked_list.py::insert_head::176,"    def insert_head(self, data: Any) -> None:
        """"""
        Insert data to the beginning of linked list.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_head(""head"")
        >>> linked_list
        head
        >>> linked_list.insert_head(""head_2"")
        >>> linked_list
        head_2 -> head
        >>> linked_list.insert_head(""head_3"")
        >>> linked_list
        head_3 -> head_2 -> head
        """"""
        self.insert_nth(0, data)",data\repos\Python\data_structures\linked_list\singly_linked_list.py,insert_head,110
3073,singly_linked_list.py::insert_nth::192,"    def insert_nth(self, index: int, data: Any) -> None:
        """"""
        Insert data at given index.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_tail(""first"")
        >>> linked_list.insert_tail(""second"")
        >>> linked_list.insert_tail(""third"")
        >>> linked_list
        first -> second -> third
        >>> linked_list.insert_nth(1, ""fourth"")
        >>> linked_list
        first -> fourth -> second -> third
        >>> linked_list.insert_nth(3, ""fifth"")
        >>> linked_list
        first -> fourth -> second -> fifth -> third
        """"""
        if not 0 <= index <= len(self):
            raise IndexError(""list index out of range"")
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        elif index == 0:
            new_node.next_node = self.head  # link new_node to head
            self.head = new_node
        else:
            temp = self.head
            for _ in range(index - 1):
                temp = temp.next_node
            new_node.next_node = temp.next_node
            temp.next_node = new_node",data\repos\Python\data_structures\linked_list\singly_linked_list.py,insert_nth,245
3074,singly_linked_list.py::print_list::223,"    def print_list(self) -> None:  # print every node data
        """"""
        This method prints every node data.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_tail(""first"")
        >>> linked_list.insert_tail(""second"")
        >>> linked_list.insert_tail(""third"")
        >>> linked_list
        first -> second -> third
        """"""
        print(self)",data\repos\Python\data_structures\linked_list\singly_linked_list.py,print_list,78
3075,singly_linked_list.py::delete_head::235,"    def delete_head(self) -> Any:
        """"""
        Delete the first node and return the
        node's data.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_tail(""first"")
        >>> linked_list.insert_tail(""second"")
        >>> linked_list.insert_tail(""third"")
        >>> linked_list
        first -> second -> third
        >>> linked_list.delete_head()
        'first'
        >>> linked_list
        second -> third
        >>> linked_list.delete_head()
        'second'
        >>> linked_list
        third
        >>> linked_list.delete_head()
        'third'
        >>> linked_list.delete_head()
        Traceback (most recent call last):
            ...
        IndexError: List index out of range.
        """"""
        return self.delete_nth(0)",data\repos\Python\data_structures\linked_list\singly_linked_list.py,delete_head,159
3076,singly_linked_list.py::delete_tail::262,"    def delete_tail(self) -> Any:  # delete from tail
        """"""
        Delete the tail end node and return the
        node's data.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_tail(""first"")
        >>> linked_list.insert_tail(""second"")
        >>> linked_list.insert_tail(""third"")
        >>> linked_list
        first -> second -> third
        >>> linked_list.delete_tail()
        'third'
        >>> linked_list
        first -> second
        >>> linked_list.delete_tail()
        'second'
        >>> linked_list
        first
        >>> linked_list.delete_tail()
        'first'
        >>> linked_list.delete_tail()
        Traceback (most recent call last):
            ...
        IndexError: List index out of range.
        """"""
        return self.delete_nth(len(self) - 1)",data\repos\Python\data_structures\linked_list\singly_linked_list.py,delete_tail,170
3077,singly_linked_list.py::delete_nth::289,"    def delete_nth(self, index: int = 0) -> Any:
        """"""
        Delete node at given index and return the
        node's data.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_tail(""first"")
        >>> linked_list.insert_tail(""second"")
        >>> linked_list.insert_tail(""third"")
        >>> linked_list
        first -> second -> third
        >>> linked_list.delete_nth(1) # delete middle
        'second'
        >>> linked_list
        first -> third
        >>> linked_list.delete_nth(5) # this raises error
        Traceback (most recent call last):
            ...
        IndexError: List index out of range.
        >>> linked_list.delete_nth(-1) # this also raises error
        Traceback (most recent call last):
            ...
        IndexError: List index out of range.
        """"""
        if not 0 <= index <= len(self) - 1:  # test if index is valid
            raise IndexError(""List index out of range."")
        delete_node = self.head  # default first node
        if index == 0:
            self.head = self.head.next_node
        else:
            temp = self.head
            for _ in range(index - 1):
                temp = temp.next_node
            delete_node = temp.next_node
            temp.next_node = temp.next_node.next_node
        return delete_node.data",data\repos\Python\data_structures\linked_list\singly_linked_list.py,delete_nth,288
3078,singly_linked_list.py::is_empty::325,"    def is_empty(self) -> bool:
        """"""
        Check if linked list is empty.
        >>> linked_list = LinkedList()
        >>> linked_list.is_empty()
        True
        >>> linked_list.insert_head(""first"")
        >>> linked_list.is_empty()
        False
        """"""
        return self.head is None",data\repos\Python\data_structures\linked_list\singly_linked_list.py,is_empty,63
3079,singly_linked_list.py::reverse::337,"    def reverse(self) -> None:
        """"""
        This reverses the linked list order.
        >>> linked_list = LinkedList()
        >>> linked_list.insert_tail(""first"")
        >>> linked_list.insert_tail(""second"")
        >>> linked_list.insert_tail(""third"")
        >>> linked_list
        first -> second -> third
        >>> linked_list.reverse()
        >>> linked_list
        third -> second -> first
        """"""
        prev = None
        current = self.head

        while current:
            # Store the current node's next node.
            next_node = current.next_node
            # Make the current node's next_node point backwards
            current.next_node = prev
            # Make the previous node be the current node
            prev = current
            # Make the current node the next_node node (to progress iteration)
            current = next_node
        # Return prev in order to put the head at the end
        self.head = prev",data\repos\Python\data_structures\linked_list\singly_linked_list.py,reverse,193
3080,skip_list.py::test_insert::249,"def test_insert():
    skip_list = SkipList()
    skip_list.insert(""Key1"", 3)
    skip_list.insert(""Key2"", 12)
    skip_list.insert(""Key3"", 41)
    skip_list.insert(""Key4"", -19)

    node = skip_list.head
    all_values = {}
    while node.level != 0:
        node = node.forward[0]
        all_values[node.key] = node.value

    assert len(all_values) == 4
    assert all_values[""Key1""] == 3
    assert all_values[""Key2""] == 12
    assert all_values[""Key3""] == 41
    assert all_values[""Key4""] == -19",data\repos\Python\data_structures\linked_list\skip_list.py,test_insert,150
3081,skip_list.py::test_insert_overrides_existing_value::269,"def test_insert_overrides_existing_value():
    skip_list = SkipList()
    skip_list.insert(""Key1"", 10)
    skip_list.insert(""Key1"", 12)

    skip_list.insert(""Key5"", 7)
    skip_list.insert(""Key7"", 10)
    skip_list.insert(""Key10"", 5)

    skip_list.insert(""Key7"", 7)
    skip_list.insert(""Key5"", 5)
    skip_list.insert(""Key10"", 10)

    node = skip_list.head
    all_values = {}
    while node.level != 0:
        node = node.forward[0]
        all_values[node.key] = node.value

    if len(all_values) != 4:
        print()
    assert len(all_values) == 4
    assert all_values[""Key1""] == 12
    assert all_values[""Key7""] == 7
    assert all_values[""Key5""] == 5
    assert all_values[""Key10""] == 10",data\repos\Python\data_structures\linked_list\skip_list.py,test_insert_overrides_existing_value,211
3082,skip_list.py::test_search::302,"def test_search():
    skip_list = SkipList()

    skip_list.insert(""Key2"", 20)
    assert skip_list.find(""Key2"") == 20

    skip_list.insert(""Some Key"", 10)
    skip_list.insert(""Key2"", 8)
    skip_list.insert(""V"", 13)

    assert skip_list.find(""Y"") is None
    assert skip_list.find(""Key2"") == 8
    assert skip_list.find(""Some Key"") == 10
    assert skip_list.find(""V"") == 13",data\repos\Python\data_structures\linked_list\skip_list.py,test_search,115
3083,skip_list.py::test_deleting_item_from_empty_list_do_nothing::318,"def test_deleting_item_from_empty_list_do_nothing():
    skip_list = SkipList()
    skip_list.delete(""Some key"")

    assert len(skip_list.head.forward) == 0",data\repos\Python\data_structures\linked_list\skip_list.py,test_deleting_item_from_empty_list_do_nothing,38
3084,skip_list.py::test_deleted_items_are_not_founded_by_find_method::325,"def test_deleted_items_are_not_founded_by_find_method():
    skip_list = SkipList()

    skip_list.insert(""Key1"", 12)
    skip_list.insert(""V"", 13)
    skip_list.insert(""X"", 14)
    skip_list.insert(""Key2"", 15)

    skip_list.delete(""V"")
    skip_list.delete(""Key2"")

    assert skip_list.find(""V"") is None
    assert skip_list.find(""Key2"") is None",data\repos\Python\data_structures\linked_list\skip_list.py,test_deleted_items_are_not_founded_by_find_method,98
3085,skip_list.py::test_delete_removes_only_given_key::340,"def test_delete_removes_only_given_key():
    skip_list = SkipList()

    skip_list.insert(""Key1"", 12)
    skip_list.insert(""V"", 13)
    skip_list.insert(""X"", 14)
    skip_list.insert(""Key2"", 15)

    skip_list.delete(""V"")
    assert skip_list.find(""V"") is None
    assert skip_list.find(""X"") == 14
    assert skip_list.find(""Key1"") == 12
    assert skip_list.find(""Key2"") == 15

    skip_list.delete(""X"")
    assert skip_list.find(""V"") is None
    assert skip_list.find(""X"") is None
    assert skip_list.find(""Key1"") == 12
    assert skip_list.find(""Key2"") == 15

    skip_list.delete(""Key1"")
    assert skip_list.find(""V"") is None
    assert skip_list.find(""X"") is None
    assert skip_list.find(""Key1"") is None
    assert skip_list.find(""Key2"") == 15

    skip_list.delete(""Key2"")
    assert skip_list.find(""V"") is None
    assert skip_list.find(""X"") is None
    assert skip_list.find(""Key1"") is None
    assert skip_list.find(""Key2"") is None",data\repos\Python\data_structures\linked_list\skip_list.py,test_delete_removes_only_given_key,277
3086,skip_list.py::test_delete_doesnt_leave_dead_nodes::373,"def test_delete_doesnt_leave_dead_nodes():
    skip_list = SkipList()

    skip_list.insert(""Key1"", 12)
    skip_list.insert(""V"", 13)
    skip_list.insert(""X"", 142)
    skip_list.insert(""Key2"", 15)

    skip_list.delete(""X"")

    def traverse_keys(node):
        yield node.key
        for forward_node in node.forward:
            yield from traverse_keys(forward_node)

    assert len(set(traverse_keys(skip_list.head))) == 4",data\repos\Python\data_structures\linked_list\skip_list.py,test_delete_doesnt_leave_dead_nodes,107
3087,skip_list.py::test_iter_always_yields_sorted_values::391,"def test_iter_always_yields_sorted_values():
    def is_sorted(lst):
        return all(next_item >= item for item, next_item in pairwise(lst))

    skip_list = SkipList()
    for i in range(10):
        skip_list.insert(i, i)
    assert is_sorted(list(skip_list))
    skip_list.delete(5)
    skip_list.delete(8)
    skip_list.delete(2)
    assert is_sorted(list(skip_list))
    skip_list.insert(-12, -12)
    skip_list.insert(77, 77)
    assert is_sorted(list(skip_list))",data\repos\Python\data_structures\linked_list\skip_list.py,test_iter_always_yields_sorted_values,120
3088,skip_list.py::pytests::408,"def pytests():
    for _ in range(100):
        # Repeat test 100 times due to the probabilistic nature of skip list
        # random values == random bugs
        test_insert()
        test_insert_overrides_existing_value()

        test_searching_empty_list_returns_none()
        test_search()

        test_deleting_item_from_empty_list_do_nothing()
        test_deleted_items_are_not_founded_by_find_method()
        test_delete_removes_only_given_key()
        test_delete_doesnt_leave_dead_nodes()

        test_iter_always_yields_sorted_values()",data\repos\Python\data_structures\linked_list\skip_list.py,pytests,114
3089,skip_list.py::main::426,"def main():
    """"""
    >>> pytests()
    """"""

    skip_list = SkipList()
    skip_list.insert(2, ""2"")
    skip_list.insert(4, ""4"")
    skip_list.insert(6, ""4"")
    skip_list.insert(4, ""5"")
    skip_list.insert(8, ""4"")
    skip_list.insert(9, ""4"")

    skip_list.delete(4)

    print(skip_list)",data\repos\Python\data_structures\linked_list\skip_list.py,main,91
3090,skip_list.py::level::34,"    def level(self) -> int:
        """"""
        :return: Number of forward references

        >>> node = Node(""Key"", 2)
        >>> node.level
        0
        >>> node.forward.append(Node(""Key2"", 4))
        >>> node.level
        1
        >>> node.forward.append(Node(""Key3"", 6))
        >>> node.level
        2
        """"""

        return len(self.forward)",data\repos\Python\data_structures\linked_list\skip_list.py,level,91
3091,skip_list.py::random_level::116,"    def random_level(self) -> int:
        """"""
        :return: Random level from [1, self.max_level] interval.
                 Higher values are less likely.
        """"""

        level = 1
        while random() < self.p and level < self.max_level:
            level += 1

        return level",data\repos\Python\data_structures\linked_list\skip_list.py,random_level,65
3092,skip_list.py::delete::163,"    def delete(self, key: KT):
        """"""
        :param key: Key to remove from list.

        >>> skip_list = SkipList()
        >>> skip_list.insert(2, ""Two"")
        >>> skip_list.insert(1, ""One"")
        >>> skip_list.insert(3, ""Three"")
        >>> list(skip_list)
        [1, 2, 3]
        >>> skip_list.delete(2)
        >>> list(skip_list)
        [1, 3]
        """"""

        node, update_vector = self._locate_node(key)

        if node is not None:
            for i, update_node in enumerate(update_vector):
                # Remove or replace all references to removed node.
                if update_node.level > i and update_node.forward[i].key == key:
                    if node.level > i:
                        update_node.forward[i] = node.forward[i]
                    else:
                        update_node.forward = update_node.forward[:i]",data\repos\Python\data_structures\linked_list\skip_list.py,delete,192
3093,skip_list.py::insert::189,"    def insert(self, key: KT, value: VT):
        """"""
        :param key: Key to insert.
        :param value: Value associated with given key.

        >>> skip_list = SkipList()
        >>> skip_list.insert(2, ""Two"")
        >>> skip_list.find(2)
        'Two'
        >>> list(skip_list)
        [2]
        """"""

        node, update_vector = self._locate_node(key)
        if node is not None:
            node.value = value
        else:
            level = self.random_level()

            if level > self.level:
                # After level increase we have to add additional nodes to head.
                for _ in range(self.level - 1, level):
                    update_vector.append(self.head)
                self.level = level

            new_node = Node(key, value)

            for i, update_node in enumerate(update_vector[:level]):
                # Change references to pass through new node.
                if update_node.level > i:
                    new_node.forward.append(update_node.forward[i])

                if update_node.level < i + 1:
                    update_node.forward.append(new_node)
                else:
                    update_node.forward[i] = new_node",data\repos\Python\data_structures\linked_list\skip_list.py,insert,241
3094,skip_list.py::find::226,"    def find(self, key: VT) -> VT | None:
        """"""
        :param key: Search key.
        :return: Value associated with given key or None if given key is not present.

        >>> skip_list = SkipList()
        >>> skip_list.find(2)
        >>> skip_list.insert(2, ""Two"")
        >>> skip_list.find(2)
        'Two'
        >>> skip_list.insert(2, ""Three"")
        >>> skip_list.find(2)
        'Three'
        """"""

        node, _ = self._locate_node(key)

        if node is not None:
            return node.value

        return None",data\repos\Python\data_structures\linked_list\skip_list.py,find,132
3095,swap_nodes.py::push::43,"    def push(self, new_data: Any) -> None:
        """"""
        Add a new node with the given data to the beginning of the Linked List.

        Args:
            new_data (Any): The data to be added to the new node.

        Returns:
            None

        Examples:
            >>> linked_list = LinkedList()
            >>> linked_list.push(5)
            >>> linked_list.push(4)
            >>> linked_list.push(3)
            >>> linked_list.push(2)
            >>> linked_list.push(1)
            >>> list(linked_list)
            [1, 2, 3, 4, 5]
        """"""
        new_node = Node(new_data)
        new_node.next_node = self.head
        self.head = new_node",data\repos\Python\data_structures\linked_list\swap_nodes.py,push,155
3096,swap_nodes.py::swap_nodes::67,"    def swap_nodes(self, node_data_1: Any, node_data_2: Any) -> None:
        """"""
        Swap the positions of two nodes in the Linked List based on their data values.

        Args:
            node_data_1: Data value of the first node to be swapped.
            node_data_2: Data value of the second node to be swapped.


        Note:
            If either of the specified data values isn't found then, no swapping occurs.

        Examples:
        When both values are present in a linked list.
            >>> linked_list = LinkedList()
            >>> linked_list.push(5)
            >>> linked_list.push(4)
            >>> linked_list.push(3)
            >>> linked_list.push(2)
            >>> linked_list.push(1)
            >>> list(linked_list)
            [1, 2, 3, 4, 5]
            >>> linked_list.swap_nodes(1, 5)
            >>> tuple(linked_list)
            (5, 2, 3, 4, 1)

        When one value is present and the other isn't in the linked list.
            >>> second_list = LinkedList()
            >>> second_list.push(6)
            >>> second_list.push(7)
            >>> second_list.push(8)
            >>> second_list.push(9)
            >>> second_list.swap_nodes(1, 6) is None
            True

        When both values are absent in the linked list.
            >>> second_list = LinkedList()
            >>> second_list.push(10)
            >>> second_list.push(9)
            >>> second_list.push(8)
            >>> second_list.push(7)
            >>> second_list.swap_nodes(1, 3) is None
            True

        When linkedlist is empty.
            >>> second_list = LinkedList()
            >>> second_list.swap_nodes(1, 3) is None
            True

        Returns:
            None
        """"""
        if node_data_1 == node_data_2:
            return

        node_1 = self.head
        while node_1 and node_1.data != node_data_1:
            node_1 = node_1.next_node
        node_2 = self.head
        while node_2 and node_2.data != node_data_2:
            node_2 = node_2.next_node
        if node_1 is None or node_2 is None:
            return
        # Swap the data values of the two nodes
        node_1.data, node_2.data = node_2.data, node_1.data",data\repos\Python\data_structures\linked_list\swap_nodes.py,swap_nodes,530
3097,__init__.py::add::25,"    def add(self, item: Any, position: int = 0) -> None:
        """"""
        Add an item to the LinkedList at the specified position.
        Default position is 0 (the head).

        Args:
            item (Any): The item to add to the LinkedList.
            position (int, optional): The position at which to add the item.
                Defaults to 0.

        Raises:
            ValueError: If the position is negative or out of bounds.

        >>> linked_list = LinkedList()
        >>> linked_list.add(1)
        >>> linked_list.add(2)
        >>> linked_list.add(3)
        >>> linked_list.add(4, 2)
        >>> print(linked_list)
        3 --> 2 --> 4 --> 1

        # Test adding to a negative position
        >>> linked_list.add(5, -3)
        Traceback (most recent call last):
            ...
        ValueError: Position must be non-negative

        # Test adding to an out-of-bounds position
        >>> linked_list.add(5,7)
        Traceback (most recent call last):
            ...
        ValueError: Out of bounds
        >>> linked_list.add(5, 4)
        >>> print(linked_list)
        3 --> 2 --> 4 --> 1 --> 5
        """"""
        if position < 0:
            raise ValueError(""Position must be non-negative"")

        if position == 0 or self.head is None:
            new_node = Node(item, self.head)
            self.head = new_node
        else:
            current = self.head
            for _ in range(position - 1):
                current = current.next
                if current is None:
                    raise ValueError(""Out of bounds"")
            new_node = Node(item, current.next)
            current.next = new_node
        self.size += 1",data\repos\Python\data_structures\linked_list\__init__.py,add,383
3098,__init__.py::remove::77,"    def remove(self) -> Any:
        # Switched 'self.is_empty()' to 'self.head is None'
        # because mypy was considering the possibility that 'self.head'
        # can be None in below else part and giving error
        if self.head is None:
            return None
        else:
            item = self.head.item
            self.head = self.head.next
            self.size -= 1
            return item",data\repos\Python\data_structures\linked_list\__init__.py,remove,90
3099,circular_queue.py::is_empty::28,"    def is_empty(self) -> bool:
        """"""
        Checks whether the queue is empty or not
        >>> cq = CircularQueue(5)
        >>> cq.is_empty()
        True
        >>> cq.enqueue(""A"").is_empty()
        False
        """"""
        return self.size == 0",data\repos\Python\data_structures\queues\circular_queue.py,is_empty,61
3100,circular_queue.py::first::39,"    def first(self):
        """"""
        Returns the first element of the queue
        >>> cq = CircularQueue(5)
        >>> cq.first()
        False
        >>> cq.enqueue(""A"").first()
        'A'
        """"""
        return False if self.is_empty() else self.array[self.front]",data\repos\Python\data_structures\queues\circular_queue.py,first,62
3101,circular_queue.py::enqueue::50,"    def enqueue(self, data):
        """"""
        This function inserts an element at the end of the queue using self.rear value
        as an index.

        >>> cq = CircularQueue(5)
        >>> cq.enqueue(""A"")  # doctest: +ELLIPSIS
        <data_structures.queues.circular_queue.CircularQueue object at ...>
        >>> (cq.size, cq.first())
        (1, 'A')
        >>> cq.enqueue(""B"")  # doctest: +ELLIPSIS
        <data_structures.queues.circular_queue.CircularQueue object at ...>
        >>> cq.array
        ['A', 'B', None, None, None]
        >>> (cq.size, cq.first())
        (2, 'A')
        >>> cq.enqueue(""C"").enqueue(""D"").enqueue(""E"")  # doctest: +ELLIPSIS
        <data_structures.queues.circular_queue.CircularQueue object at ...>
        >>> cq.enqueue(""F"")
        Traceback (most recent call last):
           ...
        Exception: QUEUE IS FULL
        """"""
        if self.size >= self.n:
            raise Exception(""QUEUE IS FULL"")

        self.array[self.rear] = data
        self.rear = (self.rear + 1) % self.n
        self.size += 1
        return self",data\repos\Python\data_structures\queues\circular_queue.py,enqueue,278
3102,circular_queue.py::dequeue::81,"    def dequeue(self):
        """"""
        This function removes an element from the queue using on self.front value as an
        index and returns it

        >>> cq = CircularQueue(5)
        >>> cq.dequeue()
        Traceback (most recent call last):
           ...
        Exception: UNDERFLOW
        >>> cq.enqueue(""A"").enqueue(""B"").dequeue()
        'A'
        >>> (cq.size, cq.first())
        (1, 'B')
        >>> cq.dequeue()
        'B'
        >>> cq.dequeue()
        Traceback (most recent call last):
           ...
        Exception: UNDERFLOW
        """"""
        if self.size == 0:
            raise Exception(""UNDERFLOW"")

        temp = self.array[self.front]
        self.array[self.front] = None
        self.front = (self.front + 1) % self.n
        self.size -= 1
        return temp",data\repos\Python\data_structures\queues\circular_queue.py,dequeue,185
3103,circular_queue_linked_list.py::create_linked_list::27,"    def create_linked_list(self, initial_capacity: int) -> None:
        current_node = Node()
        self.front = current_node
        self.rear = current_node
        previous_node = current_node
        for _ in range(1, initial_capacity):
            current_node = Node()
            previous_node.next = current_node
            current_node.prev = previous_node
            previous_node = current_node
        previous_node.next = self.front
        self.front.prev = previous_node",data\repos\Python\data_structures\queues\circular_queue_linked_list.py,create_linked_list,98
3104,circular_queue_linked_list.py::is_empty::40,"    def is_empty(self) -> bool:
        """"""
        Checks whether the queue is empty or not
        >>> cq = CircularQueueLinkedList()
        >>> cq.is_empty()
        True
        >>> cq.enqueue('a')
        >>> cq.is_empty()
        False
        >>> cq.dequeue()
        'a'
        >>> cq.is_empty()
        True
        """"""

        return (
            self.front == self.rear
            and self.front is not None
            and self.front.data is None
        )",data\repos\Python\data_structures\queues\circular_queue_linked_list.py,is_empty,103
3105,circular_queue_linked_list.py::first::61,"    def first(self) -> Any | None:
        """"""
        Returns the first element of the queue
        >>> cq = CircularQueueLinkedList()
        >>> cq.first()
        Traceback (most recent call last):
           ...
        Exception: Empty Queue
        >>> cq.enqueue('a')
        >>> cq.first()
        'a'
        >>> cq.dequeue()
        'a'
        >>> cq.first()
        Traceback (most recent call last):
           ...
        Exception: Empty Queue
        >>> cq.enqueue('b')
        >>> cq.enqueue('c')
        >>> cq.first()
        'b'
        """"""
        self.check_can_perform_operation()
        return self.front.data if self.front else None",data\repos\Python\data_structures\queues\circular_queue_linked_list.py,first,141
3106,circular_queue_linked_list.py::enqueue::86,"    def enqueue(self, data: Any) -> None:
        """"""
        Saves data at the end of the queue

        >>> cq = CircularQueueLinkedList()
        >>> cq.enqueue('a')
        >>> cq.enqueue('b')
        >>> cq.dequeue()
        'a'
        >>> cq.dequeue()
        'b'
        >>> cq.dequeue()
        Traceback (most recent call last):
           ...
        Exception: Empty Queue
        """"""
        if self.rear is None:
            return

        self.check_is_full()
        if not self.is_empty():
            self.rear = self.rear.next
        if self.rear:
            self.rear.data = data",data\repos\Python\data_structures\queues\circular_queue_linked_list.py,enqueue,135
3107,circular_queue_linked_list.py::dequeue::111,"    def dequeue(self) -> Any:
        """"""
        Removes and retrieves the first element of the queue

        >>> cq = CircularQueueLinkedList()
        >>> cq.dequeue()
        Traceback (most recent call last):
           ...
        Exception: Empty Queue
        >>> cq.enqueue('a')
        >>> cq.dequeue()
        'a'
        >>> cq.dequeue()
        Traceback (most recent call last):
           ...
        Exception: Empty Queue
        """"""
        self.check_can_perform_operation()
        if self.rear is None or self.front is None:
            return None
        if self.front == self.rear:
            data = self.front.data
            self.front.data = None
            return data

        old_front = self.front
        self.front = old_front.next
        data = old_front.data
        old_front.data = None
        return data",data\repos\Python\data_structures\queues\circular_queue_linked_list.py,dequeue,175
3108,circular_queue_linked_list.py::check_is_full::146,"    def check_is_full(self) -> None:
        if self.rear and self.rear.next == self.front:
            raise Exception(""Full Queue"")",data\repos\Python\data_structures\queues\circular_queue_linked_list.py,check_is_full,31
3109,double_ended_queue.py::append::99,"    def append(self, val: Any) -> None:
        """"""
        Adds val to the end of the deque.
        Time complexity: O(1)
        >>> our_deque_1 = Deque([1, 2, 3])
        >>> our_deque_1.append(4)
        >>> our_deque_1
        [1, 2, 3, 4]
        >>> our_deque_2 = Deque('ab')
        >>> our_deque_2.append('c')
        >>> our_deque_2
        ['a', 'b', 'c']
        >>> from collections import deque
        >>> deque_collections_1 = deque([1, 2, 3])
        >>> deque_collections_1.append(4)
        >>> deque_collections_1
        deque([1, 2, 3, 4])
        >>> deque_collections_2 = deque('ab')
        >>> deque_collections_2.append('c')
        >>> deque_collections_2
        deque(['a', 'b', 'c'])
        >>> list(our_deque_1) == list(deque_collections_1)
        True
        >>> list(our_deque_2) == list(deque_collections_2)
        True
        """"""
        node = self._Node(val, None, None)
        if self.is_empty():
            # front = back
            self._front = self._back = node
            self._len = 1
        else:
            # connect nodes
            self._back.next_node = node
            node.prev_node = self._back
            self._back = node  # assign new back to the new node

            self._len += 1

            # make sure there were no errors
            assert not self.is_empty(), ""Error on appending value.""",data\repos\Python\data_structures\queues\double_ended_queue.py,append,378
3110,double_ended_queue.py::appendleft::141,"    def appendleft(self, val: Any) -> None:
        """"""
        Adds val to the beginning of the deque.
        Time complexity: O(1)
        >>> our_deque_1 = Deque([2, 3])
        >>> our_deque_1.appendleft(1)
        >>> our_deque_1
        [1, 2, 3]
        >>> our_deque_2 = Deque('bc')
        >>> our_deque_2.appendleft('a')
        >>> our_deque_2
        ['a', 'b', 'c']
        >>> from collections import deque
        >>> deque_collections_1 = deque([2, 3])
        >>> deque_collections_1.appendleft(1)
        >>> deque_collections_1
        deque([1, 2, 3])
        >>> deque_collections_2 = deque('bc')
        >>> deque_collections_2.appendleft('a')
        >>> deque_collections_2
        deque(['a', 'b', 'c'])
        >>> list(our_deque_1) == list(deque_collections_1)
        True
        >>> list(our_deque_2) == list(deque_collections_2)
        True
        """"""
        node = self._Node(val, None, None)
        if self.is_empty():
            # front = back
            self._front = self._back = node
            self._len = 1
        else:
            # connect nodes
            node.next_node = self._front
            self._front.prev_node = node
            self._front = node  # assign new front to the new node

            self._len += 1

            # make sure there were no errors
            assert not self.is_empty(), ""Error on appending value.""",data\repos\Python\data_structures\queues\double_ended_queue.py,appendleft,371
3111,double_ended_queue.py::extend::183,"    def extend(self, iterable: Iterable[Any]) -> None:
        """"""
        Appends every value of iterable to the end of the deque.
        Time complexity: O(n)
        >>> our_deque_1 = Deque([1, 2, 3])
        >>> our_deque_1.extend([4, 5])
        >>> our_deque_1
        [1, 2, 3, 4, 5]
        >>> our_deque_2 = Deque('ab')
        >>> our_deque_2.extend('cd')
        >>> our_deque_2
        ['a', 'b', 'c', 'd']
        >>> from collections import deque
        >>> deque_collections_1 = deque([1, 2, 3])
        >>> deque_collections_1.extend([4, 5])
        >>> deque_collections_1
        deque([1, 2, 3, 4, 5])
        >>> deque_collections_2 = deque('ab')
        >>> deque_collections_2.extend('cd')
        >>> deque_collections_2
        deque(['a', 'b', 'c', 'd'])
        >>> list(our_deque_1) == list(deque_collections_1)
        True
        >>> list(our_deque_2) == list(deque_collections_2)
        True
        """"""
        for val in iterable:
            self.append(val)",data\repos\Python\data_structures\queues\double_ended_queue.py,extend,296
3112,double_ended_queue.py::extendleft::212,"    def extendleft(self, iterable: Iterable[Any]) -> None:
        """"""
        Appends every value of iterable to the beginning of the deque.
        Time complexity: O(n)
        >>> our_deque_1 = Deque([1, 2, 3])
        >>> our_deque_1.extendleft([0, -1])
        >>> our_deque_1
        [-1, 0, 1, 2, 3]
        >>> our_deque_2 = Deque('cd')
        >>> our_deque_2.extendleft('ba')
        >>> our_deque_2
        ['a', 'b', 'c', 'd']
        >>> from collections import deque
        >>> deque_collections_1 = deque([1, 2, 3])
        >>> deque_collections_1.extendleft([0, -1])
        >>> deque_collections_1
        deque([-1, 0, 1, 2, 3])
        >>> deque_collections_2 = deque('cd')
        >>> deque_collections_2.extendleft('ba')
        >>> deque_collections_2
        deque(['a', 'b', 'c', 'd'])
        >>> list(our_deque_1) == list(deque_collections_1)
        True
        >>> list(our_deque_2) == list(deque_collections_2)
        True
        """"""
        for val in iterable:
            self.appendleft(val)",data\repos\Python\data_structures\queues\double_ended_queue.py,extendleft,302
3113,double_ended_queue.py::pop::241,"    def pop(self) -> Any:
        """"""
        Removes the last element of the deque and returns it.
        Time complexity: O(1)
        @returns topop.val: the value of the node to pop.
        >>> our_deque1 = Deque([1])
        >>> our_popped1 = our_deque1.pop()
        >>> our_popped1
        1
        >>> our_deque1
        []

        >>> our_deque2 = Deque([1, 2, 3, 15182])
        >>> our_popped2 = our_deque2.pop()
        >>> our_popped2
        15182
        >>> our_deque2
        [1, 2, 3]

        >>> from collections import deque
        >>> deque_collections = deque([1, 2, 3, 15182])
        >>> collections_popped = deque_collections.pop()
        >>> collections_popped
        15182
        >>> deque_collections
        deque([1, 2, 3])
        >>> list(our_deque2) == list(deque_collections)
        True
        >>> our_popped2 == collections_popped
        True
        """"""
        # make sure the deque has elements to pop
        assert not self.is_empty(), ""Deque is empty.""

        topop = self._back
        # if only one element in the queue: point the front and back to None
        # else remove one element from back
        if self._front == self._back:
            self._front = None
            self._back = None
        else:
            self._back = self._back.prev_node  # set new back
            # drop the last node, python will deallocate memory automatically
            self._back.next_node = None

        self._len -= 1

        return topop.val",data\repos\Python\data_structures\queues\double_ended_queue.py,pop,388
3114,double_ended_queue.py::popleft::290,"    def popleft(self) -> Any:
        """"""
        Removes the first element of the deque and returns it.
        Time complexity: O(1)
        @returns topop.val: the value of the node to pop.
        >>> our_deque1 = Deque([1])
        >>> our_popped1 = our_deque1.pop()
        >>> our_popped1
        1
        >>> our_deque1
        []
        >>> our_deque2 = Deque([15182, 1, 2, 3])
        >>> our_popped2 = our_deque2.popleft()
        >>> our_popped2
        15182
        >>> our_deque2
        [1, 2, 3]
        >>> from collections import deque
        >>> deque_collections = deque([15182, 1, 2, 3])
        >>> collections_popped = deque_collections.popleft()
        >>> collections_popped
        15182
        >>> deque_collections
        deque([1, 2, 3])
        >>> list(our_deque2) == list(deque_collections)
        True
        >>> our_popped2 == collections_popped
        True
        """"""
        # make sure the deque has elements to pop
        assert not self.is_empty(), ""Deque is empty.""

        topop = self._front
        # if only one element in the queue: point the front and back to None
        # else remove one element from front
        if self._front == self._back:
            self._front = None
            self._back = None
        else:
            self._front = self._front.next_node  # set new front and drop the first node
            self._front.prev_node = None

        self._len -= 1

        return topop.val",data\repos\Python\data_structures\queues\double_ended_queue.py,popleft,382
3115,double_ended_queue.py::is_empty::336,"    def is_empty(self) -> bool:
        """"""
        Checks if the deque is empty.
        Time complexity: O(1)
        >>> our_deque = Deque([1, 2, 3])
        >>> our_deque.is_empty()
        False
        >>> our_empty_deque = Deque()
        >>> our_empty_deque.is_empty()
        True
        >>> from collections import deque
        >>> empty_deque_collections = deque()
        >>> list(our_empty_deque) == list(empty_deque_collections)
        True
        """"""
        return self._front is None",data\repos\Python\data_structures\queues\double_ended_queue.py,is_empty,121
3116,linked_queue.py::is_empty::83,"    def is_empty(self) -> bool:
        """"""
        >>> queue = LinkedQueue()
        >>> queue.is_empty()
        True
        >>> for i in range(1, 6):
        ...     queue.put(i)
        >>> queue.is_empty()
        False
        """"""
        return len(self) == 0",data\repos\Python\data_structures\queues\linked_queue.py,is_empty,65
3117,linked_queue.py::put::95,"    def put(self, item: Any) -> None:
        """"""
        >>> queue = LinkedQueue()
        >>> queue.get()
        Traceback (most recent call last):
            ...
        IndexError: dequeue from empty queue
        >>> for i in range(1, 6):
        ...     queue.put(i)
        >>> str(queue)
        '1 <- 2 <- 3 <- 4 <- 5'
        """"""
        node = Node(item)
        if self.is_empty():
            self.front = self.rear = node
        else:
            assert isinstance(self.rear, Node)
            self.rear.next = node
            self.rear = node",data\repos\Python\data_structures\queues\linked_queue.py,put,135
3118,linked_queue.py::get::115,"    def get(self) -> Any:
        """"""
        >>> queue = LinkedQueue()
        >>> queue.get()
        Traceback (most recent call last):
            ...
        IndexError: dequeue from empty queue
        >>> queue = LinkedQueue()
        >>> for i in range(1, 6):
        ...     queue.put(i)
        >>> for i in range(1, 6):
        ...     assert queue.get() == i
        >>> len(queue)
        0
        """"""
        if self.is_empty():
            raise IndexError(""dequeue from empty queue"")
        assert isinstance(self.front, Node)
        node = self.front
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        return node.data",data\repos\Python\data_structures\queues\linked_queue.py,get,156
3119,linked_queue.py::clear::139,"    def clear(self) -> None:
        """"""
        >>> queue = LinkedQueue()
        >>> for i in range(1, 6):
        ...     queue.put(i)
        >>> queue.clear()
        >>> len(queue)
        0
        >>> str(queue)
        ''
        """"""
        self.front = self.rear = None",data\repos\Python\data_structures\queues\linked_queue.py,clear,68
3120,priority_queue_using_list.py::fixed_priority_queue::180,"def fixed_priority_queue():
    fpq = FixedPriorityQueue()
    fpq.enqueue(0, 10)
    fpq.enqueue(1, 70)
    fpq.enqueue(0, 100)
    fpq.enqueue(2, 1)
    fpq.enqueue(2, 5)
    fpq.enqueue(1, 7)
    fpq.enqueue(2, 4)
    fpq.enqueue(1, 64)
    fpq.enqueue(0, 128)
    print(fpq)
    print(fpq.dequeue())
    print(fpq.dequeue())
    print(fpq.dequeue())
    print(fpq.dequeue())
    print(fpq.dequeue())
    print(fpq)
    print(fpq.dequeue())
    print(fpq.dequeue())
    print(fpq.dequeue())
    print(fpq.dequeue())
    print(fpq.dequeue())",data\repos\Python\data_structures\queues\priority_queue_using_list.py,fixed_priority_queue,173
3121,priority_queue_using_list.py::element_priority_queue::205,"def element_priority_queue():
    epq = ElementPriorityQueue()
    epq.enqueue(10)
    epq.enqueue(70)
    epq.enqueue(100)
    epq.enqueue(1)
    epq.enqueue(5)
    epq.enqueue(7)
    epq.enqueue(4)
    epq.enqueue(64)
    epq.enqueue(128)
    print(epq)
    print(epq.dequeue())
    print(epq.dequeue())
    print(epq.dequeue())
    print(epq.dequeue())
    print(epq.dequeue())
    print(epq)
    print(epq.dequeue())
    print(epq.dequeue())
    print(epq.dequeue())
    print(epq.dequeue())
    print(epq.dequeue())",data\repos\Python\data_structures\queues\priority_queue_using_list.py,element_priority_queue,146
3122,priority_queue_using_list.py::enqueue::76,"    def enqueue(self, priority: int, data: int) -> None:
        """"""
        Add an element to a queue based on its priority.
        If the priority is invalid ValueError is raised.
        If the queue is full an OverFlowError is raised.
        """"""
        try:
            if len(self.queues[priority]) >= 100:
                raise OverflowError(""Maximum queue size is 100"")
            self.queues[priority].append(data)
        except IndexError:
            raise ValueError(""Valid priorities are 0, 1, and 2"")",data\repos\Python\data_structures\queues\priority_queue_using_list.py,enqueue,114
3123,priority_queue_using_list.py::dequeue::89,"    def dequeue(self) -> int:
        """"""
        Return the highest priority element in FIFO order.
        If the queue is empty then an under flow exception is raised.
        """"""
        for queue in self.queues:
            if queue:
                return queue.pop(0)
        raise UnderFlowError(""All queues are empty"")",data\repos\Python\data_structures\queues\priority_queue_using_list.py,dequeue,66
3124,priority_queue_using_list.py::enqueue::152,"    def enqueue(self, data: int) -> None:
        """"""
        This function enters the element into the queue
        If the queue is full an Exception is raised saying Over Flow!
        """"""
        if len(self.queue) == 100:
            raise OverFlowError(""Maximum queue size is 100"")
        self.queue.append(data)",data\repos\Python\data_structures\queues\priority_queue_using_list.py,enqueue,69
3125,priority_queue_using_list.py::dequeue::161,"    def dequeue(self) -> int:
        """"""
        Return the highest priority element in FIFO order.
        If the queue is empty then an under flow exception is raised.
        """"""
        if not self.queue:
            raise UnderFlowError(""The queue is empty"")
        else:
            data = min(self.queue)
            self.queue.remove(data)
            return data",data\repos\Python\data_structures\queues\priority_queue_using_list.py,dequeue,72
3126,queue_by_list.py::put::58,"    def put(self, item: T) -> None:
        """"""Put `item` to the Queue

        >>> queue = QueueByList()
        >>> queue.put(10)
        >>> queue.put(20)
        >>> len(queue)
        2
        >>> queue
        Queue((10, 20))
        """"""

        self.entries.append(item)",data\repos\Python\data_structures\queues\queue_by_list.py,put,73
3127,queue_by_list.py::get::72,"    def get(self) -> T:
        """"""
        Get `item` from the Queue

        >>> queue = QueueByList((10, 20, 30))
        >>> queue.get()
        10
        >>> queue.put(40)
        >>> queue.get()
        20
        >>> queue.get()
        30
        >>> len(queue)
        1
        >>> queue.get()
        40
        >>> queue.get()
        Traceback (most recent call last):
            ...
        IndexError: Queue is empty
        """"""

        if not self.entries:
            raise IndexError(""Queue is empty"")
        return self.entries.pop(0)",data\repos\Python\data_structures\queues\queue_by_list.py,get,134
3128,queue_by_list.py::rotate::98,"    def rotate(self, rotation: int) -> None:
        """"""Rotate the items of the Queue `rotation` times

        >>> queue = QueueByList([10, 20, 30, 40])
        >>> queue
        Queue((10, 20, 30, 40))
        >>> queue.rotate(1)
        >>> queue
        Queue((20, 30, 40, 10))
        >>> queue.rotate(2)
        >>> queue
        Queue((40, 10, 20, 30))
        """"""

        put = self.entries.append
        get = self.entries.pop

        for _ in range(rotation):
            put(get(0))",data\repos\Python\data_structures\queues\queue_by_list.py,rotate,141
3129,queue_by_list.py::get_front::118,"    def get_front(self) -> T:
        """"""Get the front item from the Queue

        >>> queue = QueueByList((10, 20, 30))
        >>> queue.get_front()
        10
        >>> queue
        Queue((10, 20, 30))
        >>> queue.get()
        10
        >>> queue.get_front()
        20
        """"""

        return self.entries[0]",data\repos\Python\data_structures\queues\queue_by_list.py,get_front,88
3130,queue_by_two_stacks.py::put::59,"    def put(self, item: T) -> None:
        """"""
        Put `item` into the Queue

        >>> queue = QueueByTwoStacks()
        >>> queue.put(10)
        >>> queue.put(20)
        >>> len(queue)
        2
        >>> queue
        Queue((10, 20))
        """"""

        self._stack1.append(item)",data\repos\Python\data_structures\queues\queue_by_two_stacks.py,put,78
3131,queue_by_two_stacks.py::get::74,"    def get(self) -> T:
        """"""
        Get `item` from the Queue

        >>> queue = QueueByTwoStacks((10, 20, 30))
        >>> queue.get()
        10
        >>> queue.put(40)
        >>> queue.get()
        20
        >>> queue.get()
        30
        >>> len(queue)
        1
        >>> queue.get()
        40
        >>> queue.get()
        Traceback (most recent call last):
            ...
        IndexError: Queue is empty
        """"""

        # To reduce number of attribute look-ups in `while` loop.
        stack1_pop = self._stack1.pop
        stack2_append = self._stack2.append

        if not self._stack2:
            while self._stack1:
                stack2_append(stack1_pop())

        if not self._stack2:
            raise IndexError(""Queue is empty"")
        return self._stack2.pop()",data\repos\Python\data_structures\queues\queue_by_two_stacks.py,get,198
3132,queue_on_pseudo_stack.py::get::28,"    def get(self) -> Any:
        self.rotate(1)
        dequeued = self.stack[self.length - 1]
        self.stack = self.stack[:-1]
        self.rotate(self.length - 1)
        self.length = self.length - 1
        return dequeued",data\repos\Python\data_structures\queues\queue_on_pseudo_stack.py,get,58
3133,queue_on_pseudo_stack.py::rotate::40,"    def rotate(self, rotation: int) -> None:
        for _ in range(rotation):
            temp = self.stack[0]
            self.stack = self.stack[1:]
            self.put(temp)
            self.length = self.length - 1",data\repos\Python\data_structures\queues\queue_on_pseudo_stack.py,rotate,50
3134,queue_on_pseudo_stack.py::front::50,"    def front(self) -> Any:
        front = self.get()
        self.put(front)
        self.rotate(self.length - 1)
        return front",data\repos\Python\data_structures\queues\queue_on_pseudo_stack.py,front,31
3135,balanced_parentheses.py::balanced_parentheses::4,"def balanced_parentheses(parentheses: str) -> bool:
    """"""Use a stack to check if a string of parentheses is balanced.
    >>> balanced_parentheses(""([]{})"")
    True
    >>> balanced_parentheses(""[()]{}{[()()]()}"")
    True
    >>> balanced_parentheses(""[(])"")
    False
    >>> balanced_parentheses(""1+2*3-4"")
    True
    >>> balanced_parentheses("""")
    True
    """"""
    stack: Stack[str] = Stack()
    bracket_pairs = {""("": "")"", ""["": ""]"", ""{"": ""}""}
    for bracket in parentheses:
        if bracket in bracket_pairs:
            stack.push(bracket)
        elif bracket in ("")"", ""]"", ""}"") and (
            stack.is_empty() or bracket_pairs[stack.pop()] != bracket
        ):
            return False
    return stack.is_empty()",data\repos\Python\data_structures\stacks\balanced_parentheses.py,balanced_parentheses,187
3136,dijkstras_two_stack_algorithm.py::dijkstras_two_stack_algorithm::40,"def dijkstras_two_stack_algorithm(equation: str) -> int:
    """"""
    DocTests
    >>> dijkstras_two_stack_algorithm(""(5 + 3)"")
    8
    >>> dijkstras_two_stack_algorithm(""((9 - (2 + 9)) + (8 - 1))"")
    5
    >>> dijkstras_two_stack_algorithm(""((((3 - 2) - (2 + 3)) + (2 - 4)) + 3)"")
    -3

    :param equation: a string
    :return: result: an integer
    """"""
    operators = {""*"": op.mul, ""/"": op.truediv, ""+"": op.add, ""-"": op.sub}

    operand_stack: Stack[int] = Stack()
    operator_stack: Stack[str] = Stack()

    for i in equation:
        if i.isdigit():
            # RULE 1
            operand_stack.push(int(i))
        elif i in operators:
            # RULE 2
            operator_stack.push(i)
        elif i == "")"":
            # RULE 4
            opr = operator_stack.peek()
            operator_stack.pop()
            num1 = operand_stack.peek()
            operand_stack.pop()
            num2 = operand_stack.peek()
            operand_stack.pop()

            total = operators[opr](num2, num1)
            operand_stack.push(total)

    # RULE 5
    return operand_stack.peek()",data\repos\Python\data_structures\stacks\dijkstras_two_stack_algorithm.py,dijkstras_two_stack_algorithm,295
3137,infix_to_postfix_conversion.py::precedence::28,"def precedence(char: str) -> int:
    """"""
    Return integer value representing an operator's precedence, or
    order of operation.
    https://en.wikipedia.org/wiki/Order_of_operations
    """"""
    return PRECEDENCES.get(char, -1)",data\repos\Python\data_structures\stacks\infix_to_postfix_conversion.py,precedence,53
3138,infix_to_postfix_conversion.py::associativity::37,"def associativity(char: str) -> Literal[""LR"", ""RL""]:
    """"""
    Return the associativity of the operator `char`.
    https://en.wikipedia.org/wiki/Operator_associativity
    """"""
    return ASSOCIATIVITIES[char]",data\repos\Python\data_structures\stacks\infix_to_postfix_conversion.py,associativity,51
3139,infix_to_postfix_conversion.py::infix_to_postfix::45,"def infix_to_postfix(expression_str: str) -> str:
    """"""
    >>> infix_to_postfix(""(1*(2+3)+4))"")
    Traceback (most recent call last):
        ...
    ValueError: Mismatched parentheses
    >>> infix_to_postfix("""")
    ''
    >>> infix_to_postfix(""3+2"")
    '3 2 +'
    >>> infix_to_postfix(""(3+4)*5-6"")
    '3 4 + 5 * 6 -'
    >>> infix_to_postfix(""(1+2)*3/4-5"")
    '1 2 + 3 * 4 / 5 -'
    >>> infix_to_postfix(""a+b*c+(d*e+f)*g"")
    'a b c * + d e * f + g * +'
    >>> infix_to_postfix(""x^y/(5*z)+2"")
    'x y ^ 5 z * / 2 +'
    >>> infix_to_postfix(""2^3^2"")
    '2 3 2 ^ ^'
    """"""
    if not balanced_parentheses(expression_str):
        raise ValueError(""Mismatched parentheses"")
    stack: Stack[str] = Stack()
    postfix = []
    for char in expression_str:
        if char.isalpha() or char.isdigit():
            postfix.append(char)
        elif char == ""("":
            stack.push(char)
        elif char == "")"":
            while not stack.is_empty() and stack.peek() != ""("":
                postfix.append(stack.pop())
            stack.pop()
        else:
            while True:
                if stack.is_empty():
                    stack.push(char)
                    break

                char_precedence = precedence(char)
                tos_precedence = precedence(stack.peek())

                if char_precedence > tos_precedence:
                    stack.push(char)
                    break
                if char_precedence < tos_precedence:
                    postfix.append(stack.pop())
                    continue
                # Precedences are equal
                if associativity(char) == ""RL"":
                    stack.push(char)
                    break
                postfix.append(stack.pop())

    while not stack.is_empty():
        postfix.append(stack.pop())
    return "" "".join(postfix)",data\repos\Python\data_structures\stacks\infix_to_postfix_conversion.py,infix_to_postfix,457
3140,infix_to_prefix_conversion.py::infix_2_postfix::18,"def infix_2_postfix(infix: str) -> str:
    """"""
    >>> infix_2_postfix(""a+b^c"")  # doctest: +NORMALIZE_WHITESPACE
     Symbol  |  Stack  | Postfix
    ----------------------------
       a     |         | a
       +     | +       | a
       b     | +       | ab
       ^     | +^      | ab
       c     | +^      | abc
             | +       | abc^
             |         | abc^+
    'abc^+'

    >>> infix_2_postfix(""1*((-a)*2+b)"")   # doctest: +NORMALIZE_WHITESPACE
      Symbol  |    Stack     |   Postfix
    -------------------------------------------
       1     |              | 1
       *     | *            | 1
       (     | *(           | 1
       (     | *((          | 1
       -     | *((-         | 1
       a     | *((-         | 1a
       )     | *(           | 1a-
       *     | *(*          | 1a-
       2     | *(*          | 1a-2
       +     | *(+          | 1a-2*
       b     | *(+          | 1a-2*b
       )     | *            | 1a-2*b+
             |              | 1a-2*b+*
    '1a-2*b+*'

    >>> infix_2_postfix("""")
     Symbol  |  Stack  | Postfix
    ----------------------------
    ''

    >>> infix_2_postfix(""(()"")
    Traceback (most recent call last):
        ...
    ValueError: invalid expression

    >>> infix_2_postfix(""())"")
    Traceback (most recent call last):
        ...
    IndexError: list index out of range
    """"""
    stack = []
    post_fix = []
    priority = {
        ""^"": 3,
        ""*"": 2,
        ""/"": 2,
        ""%"": 2,
        ""+"": 1,
        ""-"": 1,
    }  # Priority of each operator
    print_width = max(len(infix), 7)

    # Print table header for output
    print(
        ""Symbol"".center(8),
        ""Stack"".center(print_width),
        ""Postfix"".center(print_width),
        sep="" | "",
    )
    print(""-"" * (print_width * 3 + 7))

    for x in infix:
        if x.isalpha() or x.isdigit():
            post_fix.append(x)  # if x is Alphabet / Digit, add it to Postfix
        elif x == ""("":
            stack.append(x)  # if x is ""("" push to Stack
        elif x == "")"":  # if x is "")"" pop stack until ""("" is encountered
            if len(stack) == 0:  # close bracket without open bracket
                raise IndexError(""list index out of range"")

            while stack[-1] != ""("":
                post_fix.append(stack.pop())  # Pop stack & add the content to Postfix
            stack.pop()
        elif len(stack) == 0:
            stack.append(x)  # If stack is empty, push x to stack
        else:  # while priority of x is not > priority of element in the stack
            while stack and stack[-1] != ""("" and priority[x] <= priority[stack[-1]]:
                post_fix.append(stack.pop())  # pop stack & add to Postfix
            stack.append(x)  # push x to stack

        print(
            x.center(8),
            ("""".join(stack)).ljust(print_width),
            ("""".join(post_fix)).ljust(print_width),
            sep="" | "",
        )  # Output in tabular format

    while len(stack) > 0:  # while stack is not empty
        if stack[-1] == ""("":  # open bracket with no close bracket
            raise ValueError(""invalid expression"")

        post_fix.append(stack.pop())  # pop stack & add to Postfix
        print(
            "" "".center(8),
            ("""".join(stack)).ljust(print_width),
            ("""".join(post_fix)).ljust(print_width),
            sep="" | "",
        )  # Output in tabular format

    return """".join(post_fix)  # return Postfix as str",data\repos\Python\data_structures\stacks\infix_to_prefix_conversion.py,infix_2_postfix,939
3141,infix_to_prefix_conversion.py::infix_2_prefix::127,"def infix_2_prefix(infix: str) -> str:
    """"""
    >>> infix_2_prefix(""a+b^c"")  # doctest: +NORMALIZE_WHITESPACE
     Symbol  |  Stack  | Postfix
    ----------------------------
       c     |         | c
       ^     | ^       | c
       b     | ^       | cb
       +     | +       | cb^
       a     | +       | cb^a
             |         | cb^a+
    '+a^bc'

    >>> infix_2_prefix(""1*((-a)*2+b)"") # doctest: +NORMALIZE_WHITESPACE
     Symbol  |    Stack     |   Postfix
    -------------------------------------------
       (     | (            |
       b     | (            | b
       +     | (+           | b
       2     | (+           | b2
       *     | (+*          | b2
       (     | (+*(         | b2
       a     | (+*(         | b2a
       -     | (+*(-        | b2a
       )     | (+*          | b2a-
       )     |              | b2a-*+
       *     | *            | b2a-*+
       1     | *            | b2a-*+1
             |              | b2a-*+1*
    '*1+*-a2b'

    >>> infix_2_prefix('')
     Symbol  |  Stack  | Postfix
    ----------------------------
    ''

    >>> infix_2_prefix('(()')
    Traceback (most recent call last):
        ...
    IndexError: list index out of range

    >>> infix_2_prefix('())')
    Traceback (most recent call last):
        ...
    ValueError: invalid expression
    """"""
    reversed_infix = list(infix[::-1])  # reverse the infix equation

    for i in range(len(reversed_infix)):
        if reversed_infix[i] == ""("":
            reversed_infix[i] = "")""  # change ""("" to "")""
        elif reversed_infix[i] == "")"":
            reversed_infix[i] = ""(""  # change "")"" to ""(""

    # call infix_2_postfix on Infix, return reverse of Postfix
    return (infix_2_postfix("""".join(reversed_infix)))[::-1]",data\repos\Python\data_structures\stacks\infix_to_prefix_conversion.py,infix_2_prefix,504
3142,largest_rectangle_histogram.py::largest_rectangle_area::1,"def largest_rectangle_area(heights: list[int]) -> int:
    """"""
    Inputs an array of integers representing the heights of bars,
    and returns the area of the largest rectangle that can be formed

    >>> largest_rectangle_area([2, 1, 5, 6, 2, 3])
    10

    >>> largest_rectangle_area([2, 4])
    4

    >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6])
    12

    >>> largest_rectangle_area([1])
    1
    """"""
    stack: list[int] = []
    max_area = 0
    heights = [*heights, 0]  # make a new list by appending the sentinel 0
    n = len(heights)

    for i in range(n):
        # make sure the stack remains in increasing order
        while stack and heights[i] < heights[stack[-1]]:
            h = heights[stack.pop()]  # height of the bar
            # if stack is empty, it means entire width can be taken from index 0 to i-1
            w = i if not stack else i - stack[-1] - 1  # calculate width
            max_area = max(max_area, h * w)

        stack.append(i)

    return max_area",data\repos\Python\data_structures\stacks\largest_rectangle_histogram.py,largest_rectangle_area,285
3143,lexicographical_numbers.py::lexical_order::4,"def lexical_order(max_number: int) -> Iterator[int]:
    """"""
    Generate numbers in lexical order from 1 to max_number.

    >>> "" "".join(map(str, lexical_order(13)))
    '1 10 11 12 13 2 3 4 5 6 7 8 9'
    >>> list(lexical_order(1))
    [1]
    >>> "" "".join(map(str, lexical_order(20)))
    '1 10 11 12 13 14 15 16 17 18 19 2 20 3 4 5 6 7 8 9'
    >>> "" "".join(map(str, lexical_order(25)))
    '1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 3 4 5 6 7 8 9'
    >>> list(lexical_order(12))
    [1, 10, 11, 12, 2, 3, 4, 5, 6, 7, 8, 9]
    """"""

    stack = [1]

    while stack:
        num = stack.pop()
        if num > max_number:
            continue

        yield num
        if (num % 10) != 9:
            stack.append(num + 1)

        stack.append(num * 10)",data\repos\Python\data_structures\stacks\lexicographical_numbers.py,lexical_order,307
3144,next_greater_element.py::next_greatest_element_slow::7,"def next_greatest_element_slow(arr: list[float]) -> list[float]:
    """"""
    Get the Next Greatest Element (NGE) for each element in the array
    by checking all subsequent elements to find the next greater one.

    This is a brute-force implementation, and it has a time complexity
    of O(n^2), where n is the size of the array.

    Args:
        arr: List of numbers for which the NGE is calculated.

    Returns:
        List containing the next greatest elements. If no
        greater element is found, -1 is placed in the result.

    Example:
    >>> next_greatest_element_slow(arr) == expect
    True
    """"""

    result = []
    arr_size = len(arr)

    for i in range(arr_size):
        next_element: float = -1
        for j in range(i + 1, arr_size):
            if arr[i] < arr[j]:
                next_element = arr[j]
                break
        result.append(next_element)
    return result",data\repos\Python\data_structures\stacks\next_greater_element.py,next_greatest_element_slow,212
3145,next_greater_element.py::next_greatest_element_fast::40,"def next_greatest_element_fast(arr: list[float]) -> list[float]:
    """"""
    Find the Next Greatest Element (NGE) for each element in the array
    using a more readable approach. This implementation utilizes
    enumerate() for the outer loop and slicing for the inner loop.

    While this improves readability over next_greatest_element_slow(),
    it still has a time complexity of O(n^2).

    Args:
        arr: List of numbers for which the NGE is calculated.

    Returns:
        List containing the next greatest elements. If no
        greater element is found, -1 is placed in the result.

    Example:
    >>> next_greatest_element_fast(arr) == expect
    True
    """"""
    result = []
    for i, outer in enumerate(arr):
        next_item: float = -1
        for inner in arr[i + 1 :]:
            if outer < inner:
                next_item = inner
                break
        result.append(next_item)
    return result",data\repos\Python\data_structures\stacks\next_greater_element.py,next_greatest_element_fast,206
3146,next_greater_element.py::next_greatest_element::71,"def next_greatest_element(arr: list[float]) -> list[float]:
    """"""
    Efficient solution to find the Next Greatest Element (NGE) for all elements
    using a stack. The time complexity is reduced to O(n), making it suitable
    for larger arrays.

    The stack keeps track of elements for which the next greater element hasn't
    been found yet. By iterating through the array in reverse (from the last
    element to the first), the stack is used to efficiently determine the next
    greatest element for each element.

    Args:
        arr: List of numbers for which the NGE is calculated.

    Returns:
        List containing the next greatest elements. If no
        greater element is found, -1 is placed in the result.

    Example:
    >>> next_greatest_element(arr) == expect
    True
    """"""
    arr_size = len(arr)
    stack: list[float] = []
    result: list[float] = [-1] * arr_size

    for index in reversed(range(arr_size)):
        if stack:
            while stack[-1] <= arr[index]:
                stack.pop()
                if not stack:
                    break
        if stack:
            result[index] = stack[-1]
        stack.append(arr[index])
    return result",data\repos\Python\data_structures\stacks\next_greater_element.py,next_greatest_element,262
3147,postfix_evaluation.py::parse_token::40,"def parse_token(token: str | float) -> float | str:
    """"""
    Converts the given data to the appropriate number if it is indeed a number, else
    returns the data as it is with a False flag. This function also serves as a check
    of whether the input is a number or not.

    Parameters
    ----------
    token: The data that needs to be converted to the appropriate operator or number.

    Returns
    -------
    float or str
        Returns a float if `token` is a number or a str if `token` is an operator
    """"""
    if token in OPERATORS:
        return token
    try:
        return float(token)
    except ValueError:
        msg = f""{token} is neither a number nor a valid operator""
        raise ValueError(msg)",data\repos\Python\data_structures\stacks\postfix_evaluation.py,parse_token,165
3148,postfix_evaluation.py::evaluate::64,"def evaluate(post_fix: list[str], verbose: bool = False) -> float:
    """"""
    Evaluate postfix expression using a stack.
    >>> evaluate([""0""])
    0.0
    >>> evaluate([""-0""])
    -0.0
    >>> evaluate([""1""])
    1.0
    >>> evaluate([""-1""])
    -1.0
    >>> evaluate([""-1.1""])
    -1.1
    >>> evaluate([""2"", ""1"", ""+"", ""3"", ""*""])
    9.0
    >>> evaluate([""2"", ""1.9"", ""+"", ""3"", ""*""])
    11.7
    >>> evaluate([""2"", ""-1.9"", ""+"", ""3"", ""*""])
    0.30000000000000027
    >>> evaluate([""4"", ""13"", ""5"", ""/"", ""+""])
    6.6
    >>> evaluate([""2"", ""-"", ""3"", ""+""])
    1.0
    >>> evaluate([""-4"", ""5"", ""*"", ""6"", ""-""])
    -26.0
    >>> evaluate([])
    0
    >>> evaluate([""4"", ""-"", ""6"", ""7"", ""/"", ""9"", ""8""])
    Traceback (most recent call last):
    ...
    ArithmeticError: Input is not a valid postfix expression

    Parameters
    ----------
    post_fix:
        The postfix expression is tokenized into operators and operands and stored
        as a Python list

    verbose:
        Display stack contents while evaluating the expression if verbose is True

    Returns
    -------
    float
        The evaluated value
    """"""
    if not post_fix:
        return 0
    # Checking the list to find out whether the postfix expression is valid
    valid_expression = [parse_token(token) for token in post_fix]
    if verbose:
        # print table header
        print(""Symbol"".center(8), ""Action"".center(12), ""Stack"", sep="" | "")
        print(""-"" * (30 + len(post_fix)))
    stack = []
    for x in valid_expression:
        if x not in OPERATORS:
            stack.append(x)  # append x to stack
            if verbose:
                # output in tabular format
                print(
                    f""{x}"".rjust(8),
                    f""push({x})"".ljust(12),
                    stack,
                    sep="" | "",
                )
            continue
        # If x is operator
        # If only 1 value is inside the stack and + or - is encountered
        # then this is unary + or - case
        if x in UNARY_OP_SYMBOLS and len(stack) < 2:
            b = stack.pop()  # pop stack
            if x == ""-"":
                b *= -1  # negate b
            stack.append(b)
            if verbose:
                # output in tabular format
                print(
                    """".rjust(8),
                    f""pop({b})"".ljust(12),
                    stack,
                    sep="" | "",
                )
                print(
                    str(x).rjust(8),
                    f""push({x}{b})"".ljust(12),
                    stack,
                    sep="" | "",
                )
            continue
        b = stack.pop()  # pop stack
        if verbose:
            # output in tabular format
            print(
                """".rjust(8),
                f""pop({b})"".ljust(12),
                stack,
                sep="" | "",
            )

        a = stack.pop()  # pop stack
        if verbose:
            # output in tabular format
            print(
                """".rjust(8),
                f""pop({a})"".ljust(12),
                stack,
                sep="" | "",
            )
        # evaluate the 2 values popped from stack & push result to stack
        stack.append(OPERATORS[x](a, b))  # type: ignore[index]
        if verbose:
            # output in tabular format
            print(
                f""{x}"".rjust(8),
                f""push({a}{x}{b})"".ljust(12),
                stack,
                sep="" | "",
            )
    # If everything is executed correctly, the stack will contain
    # only one element which is the result
    if len(stack) != 1:
        raise ArithmeticError(""Input is not a valid postfix expression"")
    return float(stack[0])",data\repos\Python\data_structures\stacks\postfix_evaluation.py,evaluate,928
3149,prefix_evaluation.py::is_operand::14,"def is_operand(c):
    """"""
    Return True if the given char c is an operand, e.g. it is a number

    >>> is_operand(""1"")
    True
    >>> is_operand(""+"")
    False
    """"""
    return c.isdigit()",data\repos\Python\data_structures\stacks\prefix_evaluation.py,is_operand,53
3150,prefix_evaluation.py::evaluate::26,"def evaluate(expression):
    """"""
    Evaluate a given expression in prefix notation.
    Asserts that the given expression is valid.

    >>> evaluate(""+ 9 * 2 6"")
    21
    >>> evaluate(""/ * 10 2 + 4 1 "")
    4.0
    >>> evaluate(""2"")
    2
    >>> evaluate(""+ * 2 3 / 8 4"")
    8.0
    """"""
    stack = []

    # iterate over the string in reverse order
    for c in expression.split()[::-1]:
        # push operand to stack
        if is_operand(c):
            stack.append(int(c))

        else:
            # pop values from stack can calculate the result
            # push the result onto the stack again
            o1 = stack.pop()
            o2 = stack.pop()
            stack.append(operators[c](o1, o2))

    return stack.pop()",data\repos\Python\data_structures\stacks\prefix_evaluation.py,evaluate,194
3151,prefix_evaluation.py::evaluate_recursive::58,"def evaluate_recursive(expression: list[str]):
    """"""
    Alternative recursive implementation

    >>> evaluate_recursive(['2'])
    2
    >>> expression = ['+', '*', '2', '3', '/', '8', '4']
    >>> evaluate_recursive(expression)
    8.0
    >>> expression
    []
    >>> evaluate_recursive(['+', '9', '*', '2', '6'])
    21
    >>> evaluate_recursive(['/', '*', '10', '2', '+', '4', '1'])
    4.0
    """"""

    op = expression.pop(0)
    if is_operand(op):
        return int(op)

    operation = operators[op]

    a = evaluate_recursive(expression)
    b = evaluate_recursive(expression)
    return operation(a, b)",data\repos\Python\data_structures\stacks\prefix_evaluation.py,evaluate_recursive,159
3152,stack.py::test_stack::161,"def test_stack() -> None:
    """"""
    >>> test_stack()
    """"""
    stack: Stack[int] = Stack(10)
    assert bool(stack) is False
    assert stack.is_empty() is True
    assert stack.is_full() is False
    assert str(stack) == ""[]""

    try:
        _ = stack.pop()
        raise AssertionError  # This should not happen
    except StackUnderflowError:
        assert True  # This should happen

    try:
        _ = stack.peek()
        raise AssertionError  # This should not happen
    except StackUnderflowError:
        assert True  # This should happen

    for i in range(10):
        assert stack.size() == i
        stack.push(i)

    assert bool(stack)
    assert not stack.is_empty()
    assert stack.is_full()
    assert str(stack) == str(list(range(10)))
    assert stack.pop() == 9
    assert stack.peek() == 8

    stack.push(100)
    assert str(stack) == str([0, 1, 2, 3, 4, 5, 6, 7, 8, 100])

    try:
        stack.push(200)
        raise AssertionError  # This should not happen
    except StackOverflowError:
        assert True  # This should happen

    assert not stack.is_empty()
    assert stack.size() == 10

    assert 5 in stack
    assert 55 not in stack",data\repos\Python\data_structures\stacks\stack.py,test_stack,308
3153,stack.py::push::35,"    def push(self, data: T) -> None:
        """"""
        Push an element to the top of the stack.

        >>> S = Stack(2) # stack size = 2
        >>> S.push(10)
        >>> S.push(20)
        >>> print(S)
        [10, 20]

        >>> S = Stack(1) # stack size = 1
        >>> S.push(10)
        >>> S.push(20)
        Traceback (most recent call last):
        ...
        data_structures.stacks.stack.StackOverflowError

        """"""
        if len(self.stack) >= self.limit:
            raise StackOverflowError
        self.stack.append(data)",data\repos\Python\data_structures\stacks\stack.py,push,141
3154,stack.py::pop::57,"    def pop(self) -> T:
        """"""
        Pop an element off of the top of the stack.

        >>> S = Stack()
        >>> S.push(-5)
        >>> S.push(10)
        >>> S.pop()
        10

        >>> Stack().pop()
        Traceback (most recent call last):
            ...
        data_structures.stacks.stack.StackUnderflowError
        """"""
        if not self.stack:
            raise StackUnderflowError
        return self.stack.pop()",data\repos\Python\data_structures\stacks\stack.py,pop,101
3155,stack.py::peek::76,"    def peek(self) -> T:
        """"""
        Peek at the top-most element of the stack.

        >>> S = Stack()
        >>> S.push(-5)
        >>> S.push(10)
        >>> S.peek()
        10

        >>> Stack().peek()
        Traceback (most recent call last):
            ...
        data_structures.stacks.stack.StackUnderflowError
        """"""
        if not self.stack:
            raise StackUnderflowError
        return self.stack[-1]",data\repos\Python\data_structures\stacks\stack.py,peek,101
3156,stack.py::is_empty::95,"    def is_empty(self) -> bool:
        """"""
        Check if a stack is empty.

        >>> S = Stack()
        >>> S.is_empty()
        True

        >>> S = Stack()
        >>> S.push(10)
        >>> S.is_empty()
        False
        """"""
        return not bool(self.stack)",data\repos\Python\data_structures\stacks\stack.py,is_empty,65
3157,stack.py::is_full::110,"    def is_full(self) -> bool:
        """"""
        >>> S = Stack()
        >>> S.is_full()
        False

        >>> S = Stack(1)
        >>> S.push(10)
        >>> S.is_full()
        True
        """"""
        return self.size() == self.limit",data\repos\Python\data_structures\stacks\stack.py,is_full,60
3158,stack.py::size::123,"    def size(self) -> int:
        """"""
        Return the size of the stack.

        >>> S = Stack(3)
        >>> S.size()
        0

        >>> S = Stack(3)
        >>> S.push(10)
        >>> S.size()
        1

        >>> S = Stack(3)
        >>> S.push(10)
        >>> S.push(20)
        >>> S.size()
        2
        """"""
        return len(self.stack)",data\repos\Python\data_structures\stacks\stack.py,size,98
3159,stack_using_two_queues.py::push::37,"    def push(self, item: int) -> None:
        self.temp_queue.append(item)
        while self.main_queue:
            self.temp_queue.append(self.main_queue.popleft())
        self.main_queue, self.temp_queue = self.temp_queue, self.main_queue",data\repos\Python\data_structures\stacks\stack_using_two_queues.py,push,52
3160,stack_with_doubly_linked_list.py::push::47,"    def push(self, data: T) -> None:
        """"""add a Node to the stack""""""
        if self.head is None:
            self.head = Node(data)
        else:
            new_node = Node(data)
            self.head.prev = new_node
            new_node.next = self.head
            new_node.prev = None
            self.head = new_node",data\repos\Python\data_structures\stacks\stack_with_doubly_linked_list.py,push,74
3161,stack_with_doubly_linked_list.py::pop::58,"    def pop(self) -> T | None:
        """"""pop the top element off the stack""""""
        if self.head is None:
            return None
        else:
            assert self.head is not None
            temp = self.head.data
            self.head = self.head.next
            if self.head is not None:
                self.head.prev = None
            return temp",data\repos\Python\data_structures\stacks\stack_with_doubly_linked_list.py,pop,75
3162,stack_with_doubly_linked_list.py::top::70,"    def top(self) -> T | None:
        """"""return the top element of the stack""""""
        return self.head.data if self.head is not None else None",data\repos\Python\data_structures\stacks\stack_with_doubly_linked_list.py,top,33
3163,stack_with_doubly_linked_list.py::print_stack::85,"    def print_stack(self) -> None:
        print(""stack elements are:"")
        temp = self.head
        while temp is not None:
            print(temp.data, end=""->"")
            temp = temp.next",data\repos\Python\data_structures\stacks\stack_with_doubly_linked_list.py,print_stack,43
3164,stack_with_singly_linked_list.py::is_empty::83,"    def is_empty(self) -> bool:
        """"""
        >>> stack = LinkedStack()
        >>> stack.is_empty()
        True
        >>> stack.push(1)
        >>> stack.is_empty()
        False
        """"""
        return self.top is None",data\repos\Python\data_structures\stacks\stack_with_singly_linked_list.py,is_empty,51
3165,stack_with_singly_linked_list.py::push::94,"    def push(self, item: T) -> None:
        """"""
        >>> stack = LinkedStack()
        >>> stack.push(""Python"")
        >>> stack.push(""Java"")
        >>> stack.push(""C"")
        >>> str(stack)
        'C->Java->Python'
        """"""
        node = Node(item)
        if not self.is_empty():
            node.next = self.top
        self.top = node",data\repos\Python\data_structures\stacks\stack_with_singly_linked_list.py,push,82
3166,stack_with_singly_linked_list.py::pop::108,"    def pop(self) -> T:
        """"""
        >>> stack = LinkedStack()
        >>> stack.pop()
        Traceback (most recent call last):
            ...
        IndexError: pop from empty stack
        >>> stack.push(""c"")
        >>> stack.push(""b"")
        >>> stack.push(""a"")
        >>> stack.pop() == 'a'
        True
        >>> stack.pop() == 'b'
        True
        >>> stack.pop() == 'c'
        True
        """"""
        if self.is_empty():
            raise IndexError(""pop from empty stack"")
        assert isinstance(self.top, Node)
        pop_node = self.top
        self.top = self.top.next
        return pop_node.data",data\repos\Python\data_structures\stacks\stack_with_singly_linked_list.py,pop,143
3167,stack_with_singly_linked_list.py::peek::132,"    def peek(self) -> T:
        """"""
        >>> stack = LinkedStack()
        >>> stack.push(""Java"")
        >>> stack.push(""C"")
        >>> stack.push(""Python"")
        >>> stack.peek()
        'Python'
        """"""
        if self.is_empty():
            raise IndexError(""peek from empty stack"")

        assert self.top is not None
        return self.top.data",data\repos\Python\data_structures\stacks\stack_with_singly_linked_list.py,peek,77
3168,stack_with_singly_linked_list.py::clear::147,"    def clear(self) -> None:
        """"""
        >>> stack = LinkedStack()
        >>> stack.push(""Java"")
        >>> stack.push(""C"")
        >>> stack.push(""Python"")
        >>> str(stack)
        'Python->C->Java'
        >>> stack.clear()
        >>> len(stack) == 0
        True
        """"""
        self.top = None",data\repos\Python\data_structures\stacks\stack_with_singly_linked_list.py,clear,75
3169,stock_span_problem.py::calculate_span::11,"def calculate_span(price: list[int]) -> list[int]:
    """"""
    Calculate the span values for a given list of stock prices.
    Args:
        price: List of stock prices.
    Returns:
        List of span values.

    >>> calculate_span([10, 4, 5, 90, 120, 80])
    [1, 1, 2, 4, 5, 1]
    >>> calculate_span([100, 50, 60, 70, 80, 90])
    [1, 1, 2, 3, 4, 5]
    >>> calculate_span([5, 4, 3, 2, 1])
    [1, 1, 1, 1, 1]
    >>> calculate_span([1, 2, 3, 4, 5])
    [1, 2, 3, 4, 5]
    >>> calculate_span([10, 20, 30, 40, 50])
    [1, 2, 3, 4, 5]
    >>> calculate_span([100, 80, 60, 70, 60, 75, 85])
    [1, 1, 1, 2, 1, 4, 6]
    """"""
    n = len(price)
    s = [0] * n
    # Create a stack and push index of fist element to it
    st = []
    st.append(0)

    # Span value of first element is always 1
    s[0] = 1

    # Calculate span values for rest of the elements
    for i in range(1, n):
        # Pop elements from stack while stack is not
        # empty and top of stack is smaller than price[i]
        while len(st) > 0 and price[st[-1]] <= price[i]:
            st.pop()

        # If stack becomes empty, then price[i] is greater
        # than all elements on left of it, i.e. price[0],
        # price[1], ..price[i-1]. Else the price[i]  is
        # greater than elements after top of stack
        s[i] = i + 1 if len(st) <= 0 else (i - st[-1])

        # Push this element to stack
        st.append(i)

    return s",data\repos\Python\data_structures\stacks\stock_span_problem.py,calculate_span,512
3170,suffix_tree.py::build_suffix_tree::24,"    def build_suffix_tree(self) -> None:
        """"""
        Builds the suffix tree for the given text by adding all suffixes.
        """"""
        text = self.text
        n = len(text)
        for i in range(n):
            suffix = text[i:]
            self._add_suffix(suffix, i)",data\repos\Python\data_structures\suffix_tree\suffix_tree.py,build_suffix_tree,63
3171,suffix_tree.py::search::51,"    def search(self, pattern: str) -> bool:
        """"""
        Searches for a pattern in the suffix tree.

        Args:
            pattern (str): The pattern to search for.

        Returns:
            bool: True if the pattern is found, False otherwise.
        """"""
        node = self.root
        for char in pattern:
            if char not in node.children:
                return False
            node = node.children[char]
        return True",data\repos\Python\data_structures\suffix_tree\suffix_tree.py,search,90
3172,radix_tree.py::test_trie::194,"def test_trie() -> bool:
    words = ""banana bananas bandana band apple all beast"".split()
    root = RadixNode()
    root.insert_many(words)

    assert all(root.find(word) for word in words)
    assert not root.find(""bandanas"")
    assert not root.find(""apps"")
    root.delete(""all"")
    assert not root.find(""all"")
    root.delete(""banana"")
    assert not root.find(""banana"")
    assert root.find(""bananas"")

    return True",data\repos\Python\data_structures\trie\radix_tree.py,test_trie,104
3173,radix_tree.py::main::215,"def main() -> None:
    """"""
    >>> pytests()
    """"""
    root = RadixNode()
    words = ""banana bananas bandanas bandana band apple all beast"".split()
    root.insert_many(words)

    print(""Words:"", words)
    print(""Tree:"")
    root.print_tree()",data\repos\Python\data_structures\trie\radix_tree.py,main,62
3174,radix_tree.py::match::18,"    def match(self, word: str) -> tuple[str, str, str]:
        """"""Compute the common substring of the prefix of the node and a word

        Args:
            word (str): word to compare

        Returns:
            (str, str, str): common substring, remaining prefix, remaining word

        >>> RadixNode(""myprefix"").match(""mystring"")
        ('my', 'prefix', 'string')
        """"""
        x = 0
        for q, w in zip(self.prefix, word):
            if q != w:
                break

            x += 1

        return self.prefix[:x], self.prefix[x:], word[x:]",data\repos\Python\data_structures\trie\radix_tree.py,match,138
3175,radix_tree.py::insert_many::39,"    def insert_many(self, words: list[str]) -> None:
        """"""Insert many words in the tree

        Args:
            words (list[str]): list of words

        >>> RadixNode(""myprefix"").insert_many([""mystring"", ""hello""])
        """"""
        for word in words:
            self.insert(word)",data\repos\Python\data_structures\trie\radix_tree.py,insert_many,67
3176,radix_tree.py::insert::50,"    def insert(self, word: str) -> None:
        """"""Insert a word into the tree

        Args:
            word (str): word to insert

        >>> RadixNode(""myprefix"").insert(""mystring"")

        >>> root = RadixNode()
        >>> root.insert_many(['myprefix', 'myprefixA', 'myprefixAA'])
        >>> root.print_tree()
        - myprefix   (leaf)
        -- A   (leaf)
        --- A   (leaf)
        """"""
        # Case 1: If the word is the prefix of the node
        # Solution: We set the current node as leaf
        if self.prefix == word and not self.is_leaf:
            self.is_leaf = True

        # Case 2: The node has no edges that have a prefix to the word
        # Solution: We create an edge from the current node to a new one
        # containing the word
        elif word[0] not in self.nodes:
            self.nodes[word[0]] = RadixNode(prefix=word, is_leaf=True)

        else:
            incoming_node = self.nodes[word[0]]
            matching_string, remaining_prefix, remaining_word = incoming_node.match(
                word
            )

            # Case 3: The node prefix is equal to the matching
            # Solution: We insert remaining word on the next node
            if remaining_prefix == """":
                self.nodes[matching_string[0]].insert(remaining_word)

            # Case 4: The word is greater equal to the matching
            # Solution: Create a node in between both nodes, change
            # prefixes and add the new node for the remaining word
            else:
                incoming_node.prefix = remaining_prefix

                aux_node = self.nodes[matching_string[0]]
                self.nodes[matching_string[0]] = RadixNode(matching_string, False)
                self.nodes[matching_string[0]].nodes[remaining_prefix[0]] = aux_node

                if remaining_word == """":
                    self.nodes[matching_string[0]].is_leaf = True
                else:
                    self.nodes[matching_string[0]].insert(remaining_word)",data\repos\Python\data_structures\trie\radix_tree.py,insert,444
3177,radix_tree.py::find::102,"    def find(self, word: str) -> bool:
        """"""Returns if the word is on the tree

        Args:
            word (str): word to check

        Returns:
            bool: True if the word appears on the tree

        >>> RadixNode(""myprefix"").find(""mystring"")
        False
        """"""
        incoming_node = self.nodes.get(word[0], None)
        if not incoming_node:
            return False
        else:
            _matching_string, remaining_prefix, remaining_word = incoming_node.match(
                word
            )
            # If there is remaining prefix, the word can't be on the tree
            if remaining_prefix != """":
                return False
            # This applies when the word and the prefix are equal
            elif remaining_word == """":
                return incoming_node.is_leaf
            # We have word remaining so we check the next node
            else:
                return incoming_node.find(remaining_word)",data\repos\Python\data_structures\trie\radix_tree.py,find,193
3178,radix_tree.py::delete::131,"    def delete(self, word: str) -> bool:
        """"""Deletes a word from the tree if it exists

        Args:
            word (str): word to be deleted

        Returns:
            bool: True if the word was found and deleted. False if word is not found

        >>> RadixNode(""myprefix"").delete(""mystring"")
        False
        """"""
        incoming_node = self.nodes.get(word[0], None)
        if not incoming_node:
            return False
        else:
            _matching_string, remaining_prefix, remaining_word = incoming_node.match(
                word
            )
            # If there is remaining prefix, the word can't be on the tree
            if remaining_prefix != """":
                return False
            # We have word remaining so we check the next node
            elif remaining_word != """":
                return incoming_node.delete(remaining_word)
            # If it is not a leaf, we don't have to delete
            elif not incoming_node.is_leaf:
                return False
            else:
                # We delete the nodes if no edges go from it
                if len(incoming_node.nodes) == 0:
                    del self.nodes[word[0]]
                    # We merge the current node with its only child
                    if len(self.nodes) == 1 and not self.is_leaf:
                        merging_node = next(iter(self.nodes.values()))
                        self.is_leaf = merging_node.is_leaf
                        self.prefix += merging_node.prefix
                        self.nodes = merging_node.nodes
                # If there is more than 1 edge, we just mark it as non-leaf
                elif len(incoming_node.nodes) > 1:
                    incoming_node.is_leaf = False
                # If there is 1 edge, we merge it with its child
                else:
                    merging_node = next(iter(incoming_node.nodes.values()))
                    incoming_node.is_leaf = merging_node.is_leaf
                    incoming_node.prefix += merging_node.prefix
                    incoming_node.nodes = merging_node.nodes

                return True",data\repos\Python\data_structures\trie\radix_tree.py,delete,409
3179,radix_tree.py::print_tree::181,"    def print_tree(self, height: int = 0) -> None:
        """"""Print the tree

        Args:
            height (int, optional): Height of the printed node
        """"""
        if self.prefix != """":
            print(""-"" * height, self.prefix, ""  (leaf)"" if self.is_leaf else """")

        for value in self.nodes.values():
            value.print_tree(height + 1)",data\repos\Python\data_structures\trie\radix_tree.py,print_tree,84
3180,trie.py::print_words::78,"def print_words(node: TrieNode, word: str) -> None:
    """"""
    Prints all the words in a Trie
    :param node: root node of Trie
    :param word: Word variable should be empty at start
    :return: None
    """"""
    if node.is_leaf:
        print(word, end="" "")

    for key, value in node.nodes.items():
        print_words(value, word + key)",data\repos\Python\data_structures\trie\trie.py,print_words,89
3181,trie.py::test_trie::92,"def test_trie() -> bool:
    words = ""banana bananas bandana band apple all beast"".split()
    root = TrieNode()
    root.insert_many(words)
    # print_words(root, """")
    assert all(root.find(word) for word in words)
    assert root.find(""banana"")
    assert not root.find(""bandanas"")
    assert not root.find(""apps"")
    assert root.find(""apple"")
    assert root.find(""all"")
    root.delete(""all"")
    assert not root.find(""all"")
    root.delete(""banana"")
    assert not root.find(""banana"")
    assert root.find(""bananas"")
    return True",data\repos\Python\data_structures\trie\trie.py,test_trie,131
3182,trie.py::print_results::111,"def print_results(msg: str, passes: bool) -> None:
    print(str(msg), ""works!"" if passes else ""doesn't work :("")",data\repos\Python\data_structures\trie\trie.py,print_results,32
3183,trie.py::insert_many::14,"    def insert_many(self, words: list[str]) -> None:
        """"""
        Inserts a list of words into the Trie
        :param words: list of string words
        :return: None
        """"""
        for word in words:
            self.insert(word)",data\repos\Python\data_structures\trie\trie.py,insert_many,55
3184,trie.py::insert::23,"    def insert(self, word: str) -> None:
        """"""
        Inserts a word into the Trie
        :param word: word to be inserted
        :return: None
        """"""
        curr = self
        for char in word:
            if char not in curr.nodes:
                curr.nodes[char] = TrieNode()
            curr = curr.nodes[char]
        curr.is_leaf = True",data\repos\Python\data_structures\trie\trie.py,insert,81
3185,trie.py::find::36,"    def find(self, word: str) -> bool:
        """"""
        Tries to find word in a Trie
        :param word: word to look for
        :return: Returns True if word is found, False otherwise
        """"""
        curr = self
        for char in word:
            if char not in curr.nodes:
                return False
            curr = curr.nodes[char]
        return curr.is_leaf",data\repos\Python\data_structures\trie\trie.py,find,85
3186,trie.py::delete::49,"    def delete(self, word: str) -> None:
        """"""
        Deletes a word in a Trie
        :param word: word to delete
        :return: None
        """"""

        def _delete(curr: TrieNode, word: str, index: int) -> bool:
            if index == len(word):
                # If word does not exist
                if not curr.is_leaf:
                    return False
                curr.is_leaf = False
                return len(curr.nodes) == 0
            char = word[index]
            char_node = curr.nodes.get(char)
            # If char not in current trie node
            if not char_node:
                return False
            # Flag to check if node can be deleted
            delete_curr = _delete(char_node, word, index + 1)
            if delete_curr:
                del curr.nodes[char]
                return len(curr.nodes) == 0
            return delete_curr

        _delete(self, word, 0)",data\repos\Python\data_structures\trie\trie.py,delete,200
3187,example_usage.py::main::12,"def main() -> None:
    """"""
    Demonstrate the usage of the SuffixTree class.

    - Initializes a SuffixTree with a predefined text.
    - Defines a list of patterns to search for within the suffix tree.
    - Searches for each pattern in the suffix tree.

    Patterns tested:
        - ""ana"" (found) --> True
        - ""ban"" (found) --> True
        - ""na"" (found) --> True
        - ""xyz"" (not found) --> False
        - ""mon"" (found) --> True
    """"""
    text = ""monkey banana""
    suffix_tree = SuffixTree(text)

    patterns = [""ana"", ""ban"", ""na"", ""xyz"", ""mon""]
    for pattern in patterns:
        found = suffix_tree.search(pattern)
        print(f""Pattern '{pattern}' found: {found}"")",data\repos\Python\data_structures\suffix_tree\example\example_usage.py,main,181
3188,test_suffix_tree.py::setUp::15,"    def setUp(self) -> None:
        """"""Set up the initial conditions for each test.""""""
        self.text = ""banana""
        self.suffix_tree = SuffixTree(self.text)",data\repos\Python\data_structures\suffix_tree\tests\test_suffix_tree.py,setUp,38
3189,test_suffix_tree.py::test_search_existing_patterns::20,"    def test_search_existing_patterns(self) -> None:
        """"""Test searching for patterns that exist in the suffix tree.""""""
        patterns = [""ana"", ""ban"", ""na""]
        for pattern in patterns:
            with self.subTest(pattern=pattern):
                assert self.suffix_tree.search(pattern), (
                    f""Pattern '{pattern}' should be found.""
                )",data\repos\Python\data_structures\suffix_tree\tests\test_suffix_tree.py,test_search_existing_patterns,74
3190,test_suffix_tree.py::test_search_non_existing_patterns::29,"    def test_search_non_existing_patterns(self) -> None:
        """"""Test searching for patterns that do not exist in the suffix tree.""""""
        patterns = [""xyz"", ""apple"", ""cat""]
        for pattern in patterns:
            with self.subTest(pattern=pattern):
                assert not self.suffix_tree.search(pattern), (
                    f""Pattern '{pattern}' should not be found.""
                )",data\repos\Python\data_structures\suffix_tree\tests\test_suffix_tree.py,test_search_non_existing_patterns,79
3191,test_suffix_tree.py::test_search_empty_pattern::38,"    def test_search_empty_pattern(self) -> None:
        """"""Test searching for an empty pattern.""""""
        assert self.suffix_tree.search(""""), ""An empty pattern should be found.""",data\repos\Python\data_structures\suffix_tree\tests\test_suffix_tree.py,test_search_empty_pattern,36
3192,test_suffix_tree.py::test_search_full_text::42,"    def test_search_full_text(self) -> None:
        """"""Test searching for the full text.""""""
        assert self.suffix_tree.search(self.text), (
            ""The full text should be found in the suffix tree.""
        )",data\repos\Python\data_structures\suffix_tree\tests\test_suffix_tree.py,test_search_full_text,46
3193,test_suffix_tree.py::test_search_substrings::48,"    def test_search_substrings(self) -> None:
        """"""Test searching for substrings of the full text.""""""
        substrings = [""ban"", ""ana"", ""a"", ""na""]
        for substring in substrings:
            with self.subTest(substring=substring):
                assert self.suffix_tree.search(substring), (
                    f""Substring '{substring}' should be found.""
                )",data\repos\Python\data_structures\suffix_tree\tests\test_suffix_tree.py,test_search_substrings,80
3194,example_usage.py::main::16,"def main() -> None:
    """"""
    Demonstrates the use of KD-Tree by building it from random points
    in a 10-dimensional hypercube and performing a nearest neighbor search.
    """"""
    num_points: int = 5000
    cube_size: float = 10.0  # Size of the hypercube (edge length)
    num_dimensions: int = 10

    # Generate random points within the hypercube
    points: np.ndarray = hypercube_points(num_points, cube_size, num_dimensions)
    hypercube_kdtree = build_kdtree(points.tolist())

    # Generate a random query point within the same space
    rng = np.random.default_rng()
    query_point: list[float] = rng.random(num_dimensions).tolist()

    # Perform nearest neighbor search
    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(
        hypercube_kdtree, query_point
    )

    # Print the results
    print(f""Query point: {query_point}"")
    print(f""Nearest point: {nearest_point}"")
    print(f""Distance: {nearest_dist:.4f}"")
    print(f""Nodes visited: {nodes_visited}"")",data\repos\Python\data_structures\kd_tree\example\example_usage.py,main,245
3195,hypercube_points.py::hypercube_points::12,"def hypercube_points(
    num_points: int, hypercube_size: float, num_dimensions: int
) -> np.ndarray:
    """"""
    Generates random points uniformly distributed within an n-dimensional hypercube.

    Args:
        num_points: Number of points to generate.
        hypercube_size: Size of the hypercube.
        num_dimensions: Number of dimensions of the hypercube.

    Returns:
        An array of shape (num_points, num_dimensions)
                    with generated points.
    """"""
    rng = np.random.default_rng()
    shape = (num_points, num_dimensions)
    return hypercube_size * rng.random(shape)",data\repos\Python\data_structures\kd_tree\example\hypercube_points.py,hypercube_points,128
3196,test_kdtree.py::test_build_kdtree::26,"def test_build_kdtree(num_points, cube_size, num_dimensions, depth, expected_result):
    """"""
    Test that KD-Tree is built correctly.

    Cases:
        - Empty points list.
        - Positive depth value.
        - Negative depth value.
    """"""
    points = (
        hypercube_points(num_points, cube_size, num_dimensions).tolist()
        if num_points > 0
        else []
    )

    kdtree = build_kdtree(points, depth=depth)

    if expected_result is None:
        # Empty points list case
        assert kdtree is None, f""Expected None for empty points list, got {kdtree}""
    else:
        # Check if root node is not None
        assert kdtree is not None, ""Expected a KDNode, got None""

        # Check if root has correct dimensions
        assert len(kdtree.point) == num_dimensions, (
            f""Expected point dimension {num_dimensions}, got {len(kdtree.point)}""
        )

        # Check that the tree is balanced to some extent (simplistic check)
        assert isinstance(kdtree, KDNode), (
            f""Expected KDNode instance, got {type(kdtree)}""
        )",data\repos\Python\data_structures\kd_tree\tests\test_kdtree.py,test_build_kdtree,257
3197,test_kdtree.py::test_nearest_neighbour_search::61,"def test_nearest_neighbour_search():
    """"""
    Test the nearest neighbor search function.
    """"""
    num_points = 10
    cube_size = 10.0
    num_dimensions = 2
    points = hypercube_points(num_points, cube_size, num_dimensions)
    kdtree = build_kdtree(points.tolist())

    rng = np.random.default_rng()
    query_point = rng.random(num_dimensions).tolist()

    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(
        kdtree, query_point
    )

    # Check that nearest point is not None
    assert nearest_point is not None

    # Check that distance is a non-negative number
    assert nearest_dist >= 0

    # Check that nodes visited is a non-negative integer
    assert nodes_visited >= 0",data\repos\Python\data_structures\kd_tree\tests\test_kdtree.py,test_nearest_neighbour_search,170
3198,test_kdtree.py::test_edge_cases::88,"def test_edge_cases():
    """"""
    Test edge cases such as an empty KD-Tree.
    """"""
    empty_kdtree = build_kdtree([])
    query_point = [0.0] * 2  # Using a default 2D query point

    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(
        empty_kdtree, query_point
    )

    # With an empty KD-Tree, nearest_point should be None
    assert nearest_point is None
    assert nearest_dist == float(""inf"")
    assert nodes_visited == 0",data\repos\Python\data_structures\kd_tree\tests\test_kdtree.py,test_edge_cases,119
3199,prime_numbers.py::is_prime::9,"def is_prime(number: int) -> bool:
    """"""Checks to see if a number is a prime in O(sqrt(n)).

    A number is prime if it has exactly two factors: 1 and itself.

    >>> is_prime(0)
    False
    >>> is_prime(1)
    False
    >>> is_prime(2)
    True
    >>> is_prime(3)
    True
    >>> is_prime(27)
    False
    >>> is_prime(87)
    False
    >>> is_prime(563)
    True
    >>> is_prime(2999)
    True
    >>> is_prime(67483)
    False
    """"""

    # precondition
    assert isinstance(number, int) and (number >= 0), (
        ""'number' must been an int and positive""
    )

    if 1 < number < 4:
        # 2 and 3 are primes
        return True
    elif number < 2 or not number % 2:
        # Negatives, 0, 1 and all even numbers are not primes
        return False

    odd_numbers = range(3, int(math.sqrt(number) + 1), 2)
    return not any(not number % i for i in odd_numbers)",data\repos\Python\data_structures\hashing\number_theory\prime_numbers.py,is_prime,263
3200,prime_numbers.py::next_prime::50,"def next_prime(value, factor=1, **kwargs):
    value = factor * value
    first_value_val = value

    while not is_prime(value):
        value += 1 if not (""desc"" in kwargs and kwargs[""desc""] is True) else -1

    if value == first_value_val:
        return next_prime(value + 1, **kwargs)
    return value",data\repos\Python\data_structures\hashing\number_theory\prime_numbers.py,next_prime,80
3201,test_hash_map.py::test_hash_map_is_the_same_as_dict::77,"def test_hash_map_is_the_same_as_dict(operations):
    my = HashMap(initial_block_size=4)
    py = {}
    for _, (fun, *args) in enumerate(operations):
        my_res, my_exc = _run_operation(my, fun, *args)
        py_res, py_exc = _run_operation(py, fun, *args)
        assert my_res == py_res
        assert str(my_exc) == str(py_exc)
        assert set(py) == set(my)
        assert len(py) == len(my)
        assert set(my.items()) == set(py.items())",data\repos\Python\data_structures\hashing\tests\test_hash_map.py,test_hash_map_is_the_same_as_dict,122
3202,test_hash_map.py::test_no_new_methods_was_added_to_api::90,"def test_no_new_methods_was_added_to_api():
    def is_public(name: str) -> bool:
        return not name.startswith(""_"")

    dict_public_names = {name for name in dir({}) if is_public(name)}
    hash_public_names = {name for name in dir(HashMap()) if is_public(name)}

    assert dict_public_names > hash_public_names",data\repos\Python\data_structures\hashing\tests\test_hash_map.py,test_no_new_methods_was_added_to_api,74
3203,heap-sort.py::heapify::2,"def heapify(A, N, i):
	largest = i
	l = i*2+1
	r = i*2+2

	if l<N and A[l]>A[largest]: largest = l
	if r<N and A[r]>A[largest]: largest = r
	if largest!=i:
		A[largest], A[i] = A[i], A[largest]
		heapify(A, N, largest)",data\repos\leetcode-python\common\heap-sort.py,heapify,91
3204,heap-sort.py::heapSort::14,"def heapSort(A):
	N = len(A)

	#build max heap, O(NLogN). Can be optimized to the O(N).
	for i in range(N//2-1, -1, -1):
		heapify(A, N, i)
	
	#keep swapping the largest
	for i in range(N-1, -1, -1):
		A[0], A[i] = A[i], A[0]
		heapify(A, i, 0)",data\repos\leetcode-python\common\heap-sort.py,heapSort,104
3205,01-matrix.py::updateMatrix::18,"    def updateMatrix(self, matrix):
        def setDistance(i, j, dis):
            if i<0 or i>=M: return False
            if j<0 or j>=N: return False
            if opt[i][j]!=-1: return False #opt[i][j]==-1 means the value is set already, skip.
            opt[i][j] = dis
            return True

        M, N = len(matrix), len(matrix[0])
        opt = [[-1]*N for _ in xrange(M)]
        dis = 0
        count = 0

        #[0]
        for i in xrange(M):
            for j in xrange(N):
                if matrix[i][j]==0:
                    count+=1
                    opt[i][j] = 0

        while count<M*N:
            for i in xrange(M):
                for j in xrange(N):
                    if opt[i][j]==dis:
                        if setDistance(i+1, j, dis+1): count+=1
                        if setDistance(i-1, j, dis+1): count+=1
                        if setDistance(i, j+1, dis+1): count+=1
                        if setDistance(i, j-1, dis+1): count+=1
            dis+=1
        return opt",data\repos\leetcode-python\problems\python\01-matrix.py,updateMatrix,276
3206,01-matrix.py::updateMatrix::56,"    def updateMatrix(self, matrix):
        M, N = len(matrix), len(matrix[0])
        opt = [[-1]*N for _ in xrange(M)]
        q = collections.deque([])

        for i in xrange(M):
            for j in xrange(N):
                if matrix[i][j]==0:
                    q.append((i, j, 0))

        while q:
            i, j, dis = q.popleft()
            if i<0 or i>=M: continue
            if j<0 or j>=N: continue
            if opt[i][j]!=-1: continue
            opt[i][j] = dis

            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                q.append((ni, nj, dis+1))

        return opt",data\repos\leetcode-python\problems\python\01-matrix.py,updateMatrix,187
3207,01-matrix.py::setDistance::19,"        def setDistance(i, j, dis):
            if i<0 or i>=M: return False
            if j<0 or j>=N: return False
            if opt[i][j]!=-1: return False #opt[i][j]==-1 means the value is set already, skip.
            opt[i][j] = dis
            return True",data\repos\leetcode-python\problems\python\01-matrix.py,setDistance,77
3208,3sum-closest.py::threeSumClosest::2,"    def threeSumClosest(self, nums, target):
        ans = float('inf')
        N = len(nums)
        
        nums.sort()
        
        for i in xrange(N):
            l = i+1
            r = N-1
            
            while l<r:
                s = nums[i]+nums[l]+nums[r]
                
                if abs(target-s)<abs(target-ans): ans = s
                
                if s>target:
                    r -= 1
                elif s<target:
                    l += 1
                else:
                    return s
        
        return ans",data\repos\leetcode-python\problems\python\3sum-closest.py,threeSumClosest,119
3209,3sum.py::threeSum::38,"	def threeSum(self, nums):
		res = []
		nums.sort()
		length = len(nums)
		for i in xrange(length-2): #[8]
			if nums[i]>0: break #[7]
			if i>0 and nums[i]==nums[i-1]: continue #[1]

			l, r = i+1, length-1 #[2]
			while l<r:
				total = nums[i]+nums[l]+nums[r]

				if total<0: #[3]
					l+=1
				elif total>0: #[4]
					r-=1
				else: #[5]
					res.append([nums[i], nums[l], nums[r]])
					while l<r and nums[l]==nums[l+1]: #[6]
						l+=1
					while l<r and nums[r]==nums[r-1]: #[6]
						r-=1
					l+=1
					r-=1
		return res",data\repos\leetcode-python\problems\python\3sum.py,threeSum,197
3210,3sum.py::threeSum::119,"    def threeSum(self, nums):
        memo = collections.defaultdict(list)
        N = len(nums)
        ans = set()
        
        for k in xrange(N):
            memo[nums[k]].append(k)
        
        for i in xrange(N):
            for j in xrange(i+1, N):
                t = (nums[i]+nums[j])*-1
                
                for k in memo[t]:
                    if k!=i and k!=j:
                        ans.add(tuple(sorted([nums[i], nums[j], nums[k]])))
                        break
        return ans",data\repos\leetcode-python\problems\python\3sum.py,threeSum,115
3211,3sum.py::threeSum::149,"    def threeSum(self, nums):
        nums.sort()
        ans = set()
        N = len(nums)
        
        for i in xrange(N):
            j = i+1
            k = N-1
            
            while j<k:
                s = nums[i]+nums[j]+nums[k]
                if s>0:
                    k -= 1
                elif s<0:
                    j += 1
                else:
                    ans.add(tuple(sorted([nums[i], nums[j], nums[k]])))
                    k -= 1
                    j += 1
                    
        return ans",data\repos\leetcode-python\problems\python\3sum.py,threeSum,120
3212,3sum.py::threeSum::179,"    def threeSum(self, nums):
        nums.sort()
        ans = []
        N = len(nums)
        
        for i in xrange(N):
            j = i+1
            k = N-1
            
            if i>0 and nums[i]==nums[i-1]: continue #[1]
            
            while j<k:
                s = nums[i]+nums[j]+nums[k]
                
                if s>0:
                    k -= 1
                elif s<0:
                    j += 1
                else:
                    ans.append([nums[i], nums[j], nums[k]])
                    
                    while j<k and nums[k]==nums[k-1]: k -= 1 #[2]
                    while j<k and nums[j]==nums[j+1]: j += 1 #[3]
                    k -= 1
                    j += 1
                    
        return ans",data\repos\leetcode-python\problems\python\3sum.py,threeSum,177
3213,4sum.py::fourSum::9,"    def fourSum(self, nums, target):
        nums.sort()
        N = len(nums)
        ans = set()
        
        for a in xrange(N):
            for b in xrange(a+1, N):
                c = b+1
                d = N-1
                
                while c<d:
                    s = nums[a]+nums[b]+nums[c]+nums[d]
                    
                    if s>target:
                        d -= 1
                    elif s<target:
                        c += 1
                    else:
                        ans.add(tuple(sorted([nums[a], nums[b], nums[c], nums[d]])))
                        d -= 1
                        c += 1
        return ans",data\repos\leetcode-python\problems\python\4sum.py,fourSum,140
3214,4sum.py::fourSum::37,"    def fourSum(self, nums, target):
        nums.sort()
        N = len(nums)
        ans = []
        
        for a in xrange(N):
            if a>0 and nums[a]==nums[a-1]: continue
            for b in xrange(a+1, N):
                if b>0 and nums[b]==nums[b-1] and a!=b-1: continue
                c = b+1
                d = N-1
                
                while c<d:
                    s = nums[a]+nums[b]+nums[c]+nums[d]
                    
                    if s>target:
                        d -= 1
                    elif s<target:
                        c += 1
                    else:
                        ans.append([nums[a], nums[b], nums[c], nums[d]])
                        
                        while c<d and nums[c]==nums[c+1]: c+=1
                        while c<d and nums[d]==nums[d-1]: d-=1
                        
                        d -= 1
                        c += 1
        return ans",data\repos\leetcode-python\problems\python\4sum.py,fourSum,210
3215,accounts-merge.py::accountsMerge::23,"    def accountsMerge(self, accounts):
        graph = defaultdict(list)
        merged = set()
        ans = []

        #[0]
        for data in accounts:
            emails = data[1:]
            for i, email in enumerate(emails):
                graph[email].extend(emails[:i])
                graph[email].extend(emails[i+1:])
        
        for data in accounts:
            name = data[0]
            visited = set()
            stack = [data[1]] #[2]

            if data[1] in merged: continue #[1]
            
            while stack:
                e = stack.pop()
                if e in visited: continue
                visited.add(e)
                stack.extend(graph[e])
            
            merged.update(visited)
            ans.append([name]+sorted(list(visited))) #[3]
        
        return ans",data\repos\leetcode-python\problems\python\accounts-merge.py,accountsMerge,169
3216,accounts-merge.py::accountsMerge::56,"    def accountsMerge(self, accounts):
        def find(x):
            p = parents[x]
            while p!=parents[p]:
                p = find(p)
            parents[x] = p
            return p
        
        def union(x, y):
            p1, p2 = find(x), find(y)
            if p1==p2: return
            parents[p2] = p1
        
        parents = {}
        mailToName = {}
        
        for account in accounts:
            name = account[0]
            root = account[1]
            if root not in parents: parents[root] = root
            root = find(root)
            mailToName[root] = name
            
            for i in xrange(2, len(account)):
                email = account[i]
                if email in parents:
                    union(parents[email], root)
                    root = find(root)
                parents[email] = root
        
        rootToMails = collections.defaultdict(list)
        for email in parents:
            rootToMails[find(email)].append(email)
        
        ans = []
        for root in rootToMails:
            name = mailToName[root]
            mails = rootToMails[root]
            ans.append([name]+sorted(mails))
        
        return ans",data\repos\leetcode-python\problems\python\accounts-merge.py,accountsMerge,259
3217,accounts-merge.py::accountsMerge::100,"    def accountsMerge(self, accounts):
        
        #build adjacency list
        adj = collections.defaultdict(list)
        for account in accounts:
            name = account[0]
            email0 = account[1]
            for i in xrange(2, len(account)):
                email = account[i]
                adj[email0].append(email)
                adj[email].append(email0)
        
        #iterate accounts and dfs each email group
        ans = []
        visited = set() #store all the visited email
        for account in accounts:
            name = account[0]
            email0 = account[1]
            if email0 in visited: continue
            
            #dfs
            group = set() #store the email group related to email0
            stack = [email0]
            while stack:
                email = stack.pop()
                if email in group or email in visited: continue
                group.add(email)
                visited.add(email)
                for nei in adj[email]:
                    stack.append(nei)
            
            ans.append([name]+sorted(list(group)))
        
        return ans",data\repos\leetcode-python\problems\python\accounts-merge.py,accountsMerge,220
3218,accounts-merge.py::find::57,"        def find(x):
            p = parents[x]
            while p!=parents[p]:
                p = find(p)
            parents[x] = p
            return p",data\repos\leetcode-python\problems\python\accounts-merge.py,find,34
3219,accounts-merge.py::union::64,"        def union(x, y):
            p1, p2 = find(x), find(y)
            if p1==p2: return
            parents[p2] = p1",data\repos\leetcode-python\problems\python\accounts-merge.py,union,38
3220,add-digits.py::addDigits::3,"    def addDigits(self, num):
        if num<10: return num
        total = 0
        while num>9:
            total = 0
            for d in str(num):
                total+=int(d)
            num = total
        return num",data\repos\leetcode-python\problems\python\add-digits.py,addDigits,56
3221,add-strings.py::addStrings::2,"    def addStrings(self, nums1, nums2):
        ans = ''
        i = len(nums1)-1
        j = len(nums2)-1
        
        carry = 0
        while 0<=i and 0<=j:
            n1 = int(nums1[i])
            n2 = int(nums2[j])
            total = n1+n2+carry
            n = total%10
            carry = 1 if total>=10 else 0
            ans = str(n)+ans
            i -= 1
            j -= 1
        
        while 0<=i:
            total = int(nums1[i])+carry
            n = total%10
            carry = 1 if total>=10 else 0
            ans = str(n)+ans
            i -= 1
        
        while 0<=j:
            total = int(nums2[j])+carry
            n = total%10
            carry = 1 if total>=10 else 0
            ans = str(n)+ans
            j -= 1
        
        if carry: ans = str(carry)+ans
        
        return ans",data\repos\leetcode-python\problems\python\add-strings.py,addStrings,237
3222,add-two-numbers-ii.py::addTwoNumbers::20,"    def addTwoNumbers(self, A, B):
        l1 = self.getLength(A)
        l2 = self.getLength(B)
        head = ListNode(0)
        curr = head
        while A or B:
            if l1>l2:
                self.addDigit(curr, A.val)
                l1-=1
                A = A.next
            elif l2>l1:
                self.addDigit(curr, B.val)
                l2-=1
                B = B.next
            else:
                val = (A.val if A else 0) + (B.val if B else 0)
                self.addDigit(curr, val)
                if l1: l1-=1
                if l2: l2-=1
                if A: A = A.next
                if B: B = B.next
            curr = curr.next
        return head if head.val else head.next #remove leading zero",data\repos\leetcode-python\problems\python\add-two-numbers-ii.py,addTwoNumbers,193
3223,add-two-numbers-ii.py::getLength::44,"    def getLength(self, L):
        length = 0
        while L:
            length+=1
            L = L.next
        return length",data\repos\leetcode-python\problems\python\add-two-numbers-ii.py,getLength,32
3224,add-two-numbers-ii.py::addDigit::51,"    def addDigit(self, node, val):
        if val<10:
            node.next = ListNode(val)
            node.next.prev = node
        else:
            node.next = ListNode(val-10)
            node.next.prev = node
            node.val+=1
            while node.val>=10:
                node.prev.val+=1
                node.val-=10
                node = node.prev",data\repos\leetcode-python\problems\python\add-two-numbers-ii.py,addDigit,80
3225,add-two-numbers.py::addTwoNumbers::15,"    def addTwoNumbers(self, l1, l2):
        temp = 0
        pre_head = ListNode(-1)
        curr = pre_head
        while l1 or l2 or temp:
            val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + temp

            if val>=10:
                temp = 1
                val = val-10
            else:
                temp = 0

            curr.next = ListNode(val)

            if l1: l1 = l1.next
            if l2: l2 = l2.next
            curr = curr.next
        return pre_head.next",data\repos\leetcode-python\problems\python\add-two-numbers.py,addTwoNumbers,142
3226,add-two-numbers.py::addTwoNumbers::41,"    def addTwoNumbers(self, l1, l2):

        #get number from the whole linked list
        def getTotal(l):
            total = 0
            x = 0
            while l:
                total+=l.val*(10**x)
                x+=1
                l = l.next
            return total

        total = getTotal(l1)+getTotal(l2)

        #put the number back into linked list
        num_string = str(total)[::-1]
        pre = ListNode(None)
        curr = pre

        for n in num_string:
            curr.next = ListNode(int(n))
            curr = curr.next

        return pre.next",data\repos\leetcode-python\problems\python\add-two-numbers.py,addTwoNumbers,137
3227,add-two-numbers.py::addTwoNumbers::70,"    def addTwoNumbers(self, l1, l2):
        pre = ListNode(None)
        curr = pre

        #carry is either 0 or 1
        #because the max value of l1 and l2 is 18, for example
        #3+4=7, 7 has only one digit, so carry is 0, we put 7 in the node
        #8+7=15, 15 has two digits, so carry is 1, we put 5 in the node
        #we take carry into the next round calculation
        carry = 0

        while l1 or l2:
            total = carry

            if l1:
                total+=l1.val
                l1 = l1.next
            if l2:
                total+=l2.val
                l2 = l2.next

            if total>=10:
                carry=1
                curr.next = ListNode(total%10)
            else:
                carry = 0
                curr.next = ListNode(total)

            curr = curr.next

        #check if there is carry left behind, for example
        #[5]+[5]=[0,1]
        #both linked list are done iterate, but still haven't finish adding
        if carry!=0:
            curr.next = ListNode(carry)

        return pre.next",data\repos\leetcode-python\problems\python\add-two-numbers.py,addTwoNumbers,281
3228,add-two-numbers.py::getTotal::44,"        def getTotal(l):
            total = 0
            x = 0
            while l:
                total+=l.val*(10**x)
                x+=1
                l = l.next
            return total",data\repos\leetcode-python\problems\python\add-two-numbers.py,getTotal,45
3229,alien-dictionary.py::alienOrder::5,"    def alienOrder(self, words):
        #return true if cycles are detected.
        def dfs(c):
            if c in path: return True
            if c in visited: return False
            path.add(c)
            for nei in adj[c]:
                if dfs(nei): return True
            res.append(c)
            path.remove(c)
            visited.add(c)
            return False
        
        #build adjacency list
        adj = {c: set() for word in words for c in word}
        for i in xrange(len(words)-1):
            w1, w2 = words[i], words[i+1]
            minLen = min(len(w1), len(w2))
            if w1[:minLen]==w2[:minLen] and len(w1)>len(w2): return """"
            
            for j in xrange(minLen):
                if w1[j]!=w2[j]:
                    adj[w1[j]].add(w2[j])
                    break
        
        #topological sort
        path = set() #path currently being reversed
        visited = set() #done processing
        res = []
        for c in adj:
            if dfs(c): return """"
            
        return """".join(reversed(res))",data\repos\leetcode-python\problems\python\alien-dictionary.py,alienOrder,251
3230,alien-dictionary.py::dfs::7,"        def dfs(c):
            if c in path: return True
            if c in visited: return False
            path.add(c)
            for nei in adj[c]:
                if dfs(nei): return True
            res.append(c)
            path.remove(c)
            visited.add(c)
            return False",data\repos\leetcode-python\problems\python\alien-dictionary.py,dfs,62
3231,all-nodes-distance-k-in-binary-tree.py::distanceK::2,"    def distanceK(self, root, target, k):
        graph = collections.defaultdict(list)
        q = collections.deque([root]) #for traverse binary tree
        q2 = collections.deque([(target, k)]) #for bfs the graph
        visited = set() #for bfs the graph
        ans = []
        
        #build graph
        while q:
            node = q.popleft()
            
            if node.left:
                graph[node].append(node.left)
                graph[node.left].append(node)
                q.append(node.left)
            
            if node.right:
                graph[node].append(node.right)
                graph[node.right].append(node)
                q.append(node.right)
        
        
        #bfs graph
        while q2:
            node, distance = q2.popleft()
            if node.val in visited: continue
            visited.add(node.val)
            if distance==0: ans.append(node.val)
            if distance<0 or distance>k: continue
            
            for nei in graph[node]:
                q2.append((nei, distance-1))
        
        return ans",data\repos\leetcode-python\problems\python\all-nodes-distance-k-in-binary-tree.py,distanceK,223
3232,amount-of-new-area-painted-each-day.py::amountPainted::14,"    def amountPainted(self, paint):
        ans = [0]*len(paint)
        box = SortedList()
        records = []
        maxPos = float('-inf')
        
        #[1]
        for i, (start, end) in enumerate(paint):
            records.append((start, i, -1))
            records.append((end, i, 1))
            maxPos = max(maxPos, end)
        
        records.sort()
        
        #[2]
        i = 0
        for pos in xrange(maxPos+1):
            while i<len(records) and records[i][0]==pos:
                _, index, t = records[i]
                if t==-1:
                    box.add(index)
                else:
                    box.remove(index)
                i += 1
            
            if box: ans[box[0]] += 1 #[3]
        return ans",data\repos\leetcode-python\problems\python\amount-of-new-area-painted-each-day.py,amountPainted,181
3233,analyze-user-website-visit-pattern.py::mostVisitedPattern::2,"    def mostVisitedPattern(self, usernames, timestamps, websites):
        
        data = []
        history = collections.defaultdict(list)
        counter = collections.Counter()
        maxCount = 0
        
        for i in xrange(len(usernames)):
            username = usernames[i]
            timestamp = timestamps[i]
            website = websites[i]
            data.append((timestamp, website, username))
            
        data = sorted(data)
        
        for _, website, username in data:
            history[username].append(website)
        
        for username in history:
            for comb in self.getCombination(history[username]):
                counter[comb] += 1
                maxCount = max(maxCount, counter[comb])
        
        for comb in sorted(counter.keys()):
            if counter[comb]==maxCount: return comb",data\repos\leetcode-python\problems\python\analyze-user-website-visit-pattern.py,mostVisitedPattern,162
3234,analyze-user-website-visit-pattern.py::getCombination::28,"    def getCombination(self, websites):
        def helper(comb, i):
            if len(comb)==3:
                combs.add(tuple(comb[:]))
            elif len(comb)>3 or i>=len(websites):
                return
            else:
                helper(comb+[websites[i]], i+1)
                helper(comb[:], i+1)
                
        combs = set()
        helper([], 0)
        return combs",data\repos\leetcode-python\problems\python\analyze-user-website-visit-pattern.py,getCombination,89
3235,analyze-user-website-visit-pattern.py::helper::29,"        def helper(comb, i):
            if len(comb)==3:
                combs.add(tuple(comb[:]))
            elif len(comb)>3 or i>=len(websites):
                return
            else:
                helper(comb+[websites[i]], i+1)
                helper(comb[:], i+1)",data\repos\leetcode-python\problems\python\analyze-user-website-visit-pattern.py,helper,63
3236,backspace-string-compare.py::backspaceCompare::8,"    def backspaceCompare(self, S1, S2):
		#index compared so far
        i = len(S1)-1
        j = len(S2)-1
		
        while i>=0 or j>=0:
			#the first char that are not canceled by the hashtags
            c1 = ''
            c2 = ''
            
            if i>=0:
                c1, i = self.getChar(S1, i)
            if j>=0:
                c2, j = self.getChar(S2, j)
            if c1!=c2:
                return False
        return True",data\repos\leetcode-python\problems\python\backspace-string-compare.py,backspaceCompare,128
3237,backspace-string-compare.py::getChar::26,"    def getChar(self, s, i):
		#return the first character that are not canceled by the hashtag
		#return inedx compared so far so we don't have to do that again
        c = ''
        hashtag = 0
        
        while i>=0 and c=='':
            char = s[i]
            if char=='#':
                hashtag+=1
            elif hashtag==0:
                c = char
            else:
                hashtag-=1
            i-=1
        return c, i",data\repos\leetcode-python\problems\python\backspace-string-compare.py,getChar,109
3238,backspace-string-compare.py::backspaceCompare::47,"    def backspaceCompare(self, s1, s2):
        i = len(s1)-1
        j = len(s2)-1
        c1 = 0 #s1 unprocessed backspace count
        c2 = 0 #s2 unprocessed backspace count
        
        while i>=0 or j>=0:
            while i>=0:
                if s1[i]=='#':
                    c1 += 1
                    i -= 1
                elif c1>0:
                    c1 -= 1
                    i -= 1
                else:
                    break
            
            while j>=0:
                if s2[j]=='#':
                    c2 += 1
                    j -= 1
                elif c2>0:
                    c2 -= 1
                    j -= 1
                else:
                    break
            
            # if one of the string is finished, the other one should be finished, too.
            if i<0: return j<0
            if j<0: return i<0
            
            
            if s1[i]!=s2[j]: return False
            
            i -= 1
            j -= 1
            
        return True",data\repos\leetcode-python\problems\python\backspace-string-compare.py,backspaceCompare,247
3239,backspace-string-compare.py::backspaceCompare::88,"    def backspaceCompare(self, s, t):
        def helper(S):
            ans = ''
            i = len(S)-1
            backspaceCount = 0
            
            while i>=0:
                if S[i]=='#':
                    backspaceCount += 1
                else:
                    if backspaceCount>0:
                        backspaceCount -= 1
                    else:
                        ans += S[i]
                i -= 1
            return ans
        
        return helper(s)==helper(t)",data\repos\leetcode-python\problems\python\backspace-string-compare.py,backspaceCompare,103
3240,backspace-string-compare.py::helper::89,"        def helper(S):
            ans = ''
            i = len(S)-1
            backspaceCount = 0
            
            while i>=0:
                if S[i]=='#':
                    backspaceCount += 1
                else:
                    if backspaceCount>0:
                        backspaceCount -= 1
                    else:
                        ans += S[i]
                i -= 1
            return ans",data\repos\leetcode-python\problems\python\backspace-string-compare.py,helper,83
3241,balance-a-binary-search-tree.py::balanceBST::10,"    def balanceBST(self, root):
        def getInorderNodes(root):
            nodes = []
            stack = []
            node = root
            
            while node or stack:
                while node:
                    stack.append(node)
                    node = node.left
                
                node = stack.pop()
                nodes.append(node)
                node = node.right
            
            return nodes
                
        def getRoot(l, r):
            if l>r: return None
            m = (l+r)/2
            root = inorderNodes[m]
            root.left = getRoot(l, m-1)
            root.right = getRoot(m+1, r)
            return root
            
        inorderNodes = getInorderNodes(root)
        return getRoot(0, len(inorderNodes)-1)",data\repos\leetcode-python\problems\python\balance-a-binary-search-tree.py,balanceBST,155
3242,balance-a-binary-search-tree.py::getInorderNodes::11,"        def getInorderNodes(root):
            nodes = []
            stack = []
            node = root
            
            while node or stack:
                while node:
                    stack.append(node)
                    node = node.left
                
                node = stack.pop()
                nodes.append(node)
                node = node.right
            
            return nodes",data\repos\leetcode-python\problems\python\balance-a-binary-search-tree.py,getInorderNodes,62
3243,balance-a-binary-search-tree.py::getRoot::27,"        def getRoot(l, r):
            if l>r: return None
            m = (l+r)/2
            root = inorderNodes[m]
            root.left = getRoot(l, m-1)
            root.right = getRoot(m+1, r)
            return root",data\repos\leetcode-python\problems\python\balance-a-binary-search-tree.py,getRoot,59
3244,balanced-binary-tree.py::isBalanced::11,"    def isBalanced(self, root):

        def helper(node, depth):
            if not node.left and not node.right: return depth
            
            l = r = depth #l: left_max_depth, r: right_max_depth
            if node.left:
                l = helper(node.left, depth+1)
            if node.right:
                r = helper(node.right, depth+1)

            if l!=-1 and r!=-1 and abs(l-r)<=1:
                return max(l, r)
            return -1
        
        if not root: return True
        return helper(root, 0)!=-1",data\repos\leetcode-python\problems\python\balanced-binary-tree.py,isBalanced,126
3245,balanced-binary-tree.py::isBalanced::35,"    def isBalanced(self, root):
        
        #return (if the node isBalanced, the height of the node)
        def helper(node):
            if not node: return True, -1
            
            isLeftBalanced, leftHeight = helper(node.left)
            isRightBalanced, rightHeight = helper(node.right)
            
            height = max(leftHeight, rightHeight)+1
            
            return isLeftBalanced and isRightBalanced and abs(leftHeight-rightHeight)<=1, height
        
        return helper(root)[0]",data\repos\leetcode-python\problems\python\balanced-binary-tree.py,isBalanced,111
3246,balanced-binary-tree.py::helper::13,"        def helper(node, depth):
            if not node.left and not node.right: return depth
            
            l = r = depth #l: left_max_depth, r: right_max_depth
            if node.left:
                l = helper(node.left, depth+1)
            if node.right:
                r = helper(node.right, depth+1)

            if l!=-1 and r!=-1 and abs(l-r)<=1:
                return max(l, r)
            return -1",data\repos\leetcode-python\problems\python\balanced-binary-tree.py,helper,98
3247,balanced-binary-tree.py::helper::38,"        def helper(node):
            if not node: return True, -1
            
            isLeftBalanced, leftHeight = helper(node.left)
            isRightBalanced, rightHeight = helper(node.right)
            
            height = max(leftHeight, rightHeight)+1
            
            return isLeftBalanced and isRightBalanced and abs(leftHeight-rightHeight)<=1, height",data\repos\leetcode-python\problems\python\balanced-binary-tree.py,helper,76
3248,basic-calculator-ii.py::calculate::2,"    def calculate(self, s):
        s += '+' #edge case, for last operation to be executed.
        lastOperation = '+' #edge case, for the first currNum
        operations = set(['+', '-', '*', '/'])
        
        stack = []
        currNum = 0

        for c in s:
            if c.isdigit():
                currNum = currNum*10 + int(c)
            elif c in operations:
                if lastOperation=='+':
                    stack.append(currNum)
                    currNum = 0
                elif lastOperation=='-':
                    stack.append(-currNum)
                    currNum = 0
                elif lastOperation=='*':
                    currNum = stack.pop() * currNum
                    stack.append(currNum)
                    currNum = 0
                elif lastOperation=='/':
                    currNum = stack.pop() / currNum
                    if currNum<0: currNum += 1
                    stack.append(currNum)
                    currNum = 0
                lastOperation = c
        
        return sum(stack)",data\repos\leetcode-python\problems\python\basic-calculator-ii.py,calculate,215
3249,best-time-to-buy-an-stock.py::maxProfit::11,"    def maxProfit(self, prices):
        if prices is None or len(prices)==0: return 0
        
        memo = [0]*len(prices)
        min_price = float('inf')
        
        for i in xrange(len(prices)):
            min_price = min(min_price, prices[i])
            if i==0: continue
            memo[i] = max(prices[i]-min_price, memo[i-1])
        return memo[-1]",data\repos\leetcode-python\problems\python\best-time-to-buy-an-stock.py,maxProfit,95
3250,best-time-to-buy-and-sell-stock-iii.py::maxProfit::18,"    def maxProfit(self, prices):
        dp = [[0, 0, 0, 0] for _ in xrange(len(prices))]
        dp[0] = [-prices[0], 0, -prices[0], 0]
        
        for i in xrange(1, len(prices)):
            dp[i][0] = max(-prices[i], dp[i-1][0])
            dp[i][1] = max(dp[i-1][0]+prices[i], dp[i-1][1])
            dp[i][2] = max(dp[i-1][1]-prices[i], dp[i-1][2])
            dp[i][3] = max(dp[i-1][2]+prices[i], dp[i-1][3])
                
        return max(dp[-1]) ",data\repos\leetcode-python\problems\python\best-time-to-buy-and-sell-stock-iii.py,maxProfit,169
3251,best-time-to-buy-and-sell-stock-with-cooldown.py::maxProfit::2,"    def maxProfit(self, prices):
        if not prices or len(prices)<=1: return 0
        N = len(prices)

        buy = [-prices[0], max(-prices[1], -prices[0])]
        sell = [0, max(prices[1]+buy[0], 0)]
        
        for i in xrange(2, N):
            buy.append(max(sell[i-2]-prices[i], buy[i-1]))
            sell.append(max(prices[i]+buy[i-1], sell[i-1]))
            
        return max(buy[-1], sell[-1], 0)",data\repos\leetcode-python\problems\python\best-time-to-buy-and-sell-stock-with-cooldown.py,maxProfit,131
3252,best-time-to-buy-and-sell-stock.py::maxProfit::7,"    def maxProfit(self, prices):
        if not prices: return 0
        max_profit = 0
        lowest = prices[0]
        
        for i in xrange(len(prices)):
            if i==0: continue
            max_profit = max(max_profit, prices[i]-lowest)
            lowest = min(lowest, prices[i])
        return max_profit",data\repos\leetcode-python\problems\python\best-time-to-buy-and-sell-stock.py,maxProfit,76
3253,binary-search.py::search::16,"    def search(self, nums, target):
        if nums is None or len(nums)==0: return -1
        if target<nums[0] or nums[-1]<target: return -1 #test is out of range
        l = 0
        r = len(nums)-1

        while r>=l:
            if nums[l]==target: return l
            if nums[r]==target: return r
            p = (l+r)/2
            if nums[p]==target:
                return p
            elif nums[p]>target:
                r = p-1
            else:
                l = p+1
        return -1",data\repos\leetcode-python\problems\python\binary-search.py,search,137
3254,binary-search.py::search::36,"    def search(self, nums, target):
        if nums is None or len(nums)==0: return -1
        if target<nums[0] or nums[-1]<target: return -1 #check if out of range

        i = bisect.bisect_left(nums, target)

        #check if target in `nums`
        if nums[i]==target: return i
        else: return -1",data\repos\leetcode-python\problems\python\binary-search.py,search,87
3255,binary-search.py::search::49,"    def search(self, nums, target):
        if not nums: return -1

        l = 0
        r = len(nums)-1

        while True:
            if l>r: break
            if target<nums[l]: return -1
            if nums[r]<target: return -1

            if target==nums[l]: return l
            if target==nums[r]: return r

            m = (l+r)/2
            if target==nums[m]:
                return m
            elif target<nums[m]:
                r = m-1
            else:
                l = m+1
        return -1",data\repos\leetcode-python\problems\python\binary-search.py,search,133
3256,binary-subarrays-with-sum.py::numSubarraysWithSum::2,"    def numSubarraysWithSum(self, nums, goal):
        #number of subarrays with sum at most ""goal""
        def atMost(goal):
            ans = 0
            total = 0
            i = 0
            
            for j, num in enumerate(nums):
                if num==1: total += 1
                
                while i<len(nums) and total>goal:
                    if nums[i]==1: total -= 1
                    i += 1
                
                ans += j-i+1 #number of subarrays that can generate from nums[i~j]
            return ans
        
        return atMost(goal)-atMost(goal-1) if goal>0 else atMost(goal)",data\repos\leetcode-python\problems\python\binary-subarrays-with-sum.py,numSubarraysWithSum,145
3257,binary-subarrays-with-sum.py::atMost::4,"        def atMost(goal):
            ans = 0
            total = 0
            i = 0
            
            for j, num in enumerate(nums):
                if num==1: total += 1
                
                while i<len(nums) and total>goal:
                    if nums[i]==1: total -= 1
                    i += 1
                
                ans += j-i+1 #number of subarrays that can generate from nums[i~j]
            return ans",data\repos\leetcode-python\problems\python\binary-subarrays-with-sum.py,atMost,97
3258,binary-tree-inorder-traversal.py::inorderTraversal::8,"    def inorderTraversal(self, root):
        def helper(node):
            if not node: return
            helper(node.left)
            opt.append(node.val)
            helper(node.right)
            
        opt = []
        helper(root)
        return opt",data\repos\leetcode-python\problems\python\binary-tree-inorder-traversal.py,inorderTraversal,48
3259,binary-tree-level-order-traversal-ii.py::levelOrderBottom::4,"    def levelOrderBottom(self, root):
        opt = []

        if not root: return opt

        q = deque()
        q.append((root, 0))

        while q:
            node, depth = q.popleft()
            if depth<len(opt):
                opt[depth].append(node.val)
            else:
                opt.append([node.val])
            if node.left: q.append((node.left, depth+1))
            if node.right: q.append((node.right, depth+1))
        return reversed(opt)",data\repos\leetcode-python\problems\python\binary-tree-level-order-traversal-ii.py,levelOrderBottom,108
3260,binary-tree-level-order-traversal-ii.py::levelOrderBottom::31,"    def levelOrderBottom(self, root):
        if not root: return []
        ans = []
        q = collections.deque([(root, 0)])
        
        while q:
            node, level = q.popleft()
            if len(ans)<level+1: ans.append([])
            ans[level].append(node.val)
            
            if node.left: q.append((node.left, level+1))
            if node.right: q.append((node.right, level+1))
        
        return reversed(ans)",data\repos\leetcode-python\problems\python\binary-tree-level-order-traversal-ii.py,levelOrderBottom,103
3261,binary-tree-level-order-traversal-ii.py::levelOrderBottom::54,"    def levelOrderBottom(self, root):
        if not root: return []
        ans = []
        q = collections.deque([root])
        
        while q:
            ans.append([])
            currLevelCount = len(q)
            for _ in xrange(currLevelCount):
                node = q.popleft()
                ans[-1].append(node.val)
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
        return reversed(ans)",data\repos\leetcode-python\problems\python\binary-tree-level-order-traversal-ii.py,levelOrderBottom,96
3262,binary-tree-level-order-traversal.py::levelOrder::4,"    def levelOrder(self, root):
        opt = []

        if not root: return opt

        q = deque()
        q.append((root, 0))

        while q:
            node, depth = q.popleft()
            if depth<len(opt):
                opt[depth].append(node.val)
            else:
                opt.append([node.val])
            if node.left: q.append((node.left, depth+1))
            if node.right: q.append((node.right, depth+1))
        return opt",data\repos\leetcode-python\problems\python\binary-tree-level-order-traversal.py,levelOrder,105
3263,binary-tree-level-order-traversal.py::levelOrder::35,"    def levelOrder(self, root):
        if not root: return []
        ans = []
        q = collections.deque([(root, 0)])
        
        while q:
            node, level = q.popleft()
            if len(ans)<level+1: ans.append([])
            ans[level].append(node.val)
            
            if node.left: q.append((node.left, level+1))
            if node.right: q.append((node.right, level+1))
        
        return ans",data\repos\leetcode-python\problems\python\binary-tree-level-order-traversal.py,levelOrder,100
3264,binary-tree-level-order-traversal.py::levelOrder::58,"    def levelOrder(self, root):
        if not root: return []
        ans = []
        q = collections.deque([root])
        
        while q:
            ans.append([])
            currLevelCount = len(q)
            for _ in xrange(currLevelCount):
                node = q.popleft()
                ans[-1].append(node.val)
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
        return ans",data\repos\leetcode-python\problems\python\binary-tree-level-order-traversal.py,levelOrder,93
3265,binary-tree-longest-consecutive-sequence.py::longestConsecutive::8,"    def longestConsecutive(self, root):
        if not root: return 0
        ans = 1
        stack = [(root, 1)]
        
        while stack:
            node, count = stack.pop()
            ans = max(ans, count)
            
            if node.left:
                stack.append((node.left, count+1 if node.val+1==node.left.val else 1))
            if node.right:
                stack.append((node.right, count+1 if node.val+1==node.right.val else 1))
                
        return ans",data\repos\leetcode-python\problems\python\binary-tree-longest-consecutive-sequence.py,longestConsecutive,115
3266,binary-tree-maximum-path-sum.py::maxPathSum::21,"    def maxPathSum(self, root):
        def helper(node):
            left_a = left_na = right_a = right_na = float('-inf')

            if node.left:
                left_a, left_na = helper(node.left)
            if node.right:
                right_a, right_na = helper(node.right)

            a = max(node.val, node.val+left_a, node.val+right_a)
            na = max(left_na, right_na, node.val+left_a+right_a, a)
            return a, na

        return max(helper(root))",data\repos\leetcode-python\problems\python\binary-tree-maximum-path-sum.py,maxPathSum,115
3267,binary-tree-maximum-path-sum.py::maxPathSum::38,"    def maxPathSum(self, root):
        pre_stack = [root]
        stack = []
        memo = {}

        while pre_stack:
            node = pre_stack.pop()
            stack.append(node)
            if node.left:
                pre_stack.append(node.left)
            if node.right:
                pre_stack.append(node.right)

        while stack:
            node = stack.pop()

            left_a = left_na = right_a = right_na = float('-inf')

            if node.left:
                left_a, left_na = memo[node.left]
            if node.right:
                right_a, right_na = memo[node.right]

            a = max(node.val, node.val+left_a, node.val+right_a)
            na = max(left_na, right_na, node.val+left_a+right_a, a)

            memo[node] = (a, na)

        return max(memo[root])",data\repos\leetcode-python\problems\python\binary-tree-maximum-path-sum.py,maxPathSum,181
3268,binary-tree-maximum-path-sum.py::helper::22,"        def helper(node):
            left_a = left_na = right_a = right_na = float('-inf')

            if node.left:
                left_a, left_na = helper(node.left)
            if node.right:
                right_a, right_na = helper(node.right)

            a = max(node.val, node.val+left_a, node.val+right_a)
            na = max(left_na, right_na, node.val+left_a+right_a, a)
            return a, na",data\repos\leetcode-python\problems\python\binary-tree-maximum-path-sum.py,helper,99
3269,binary-tree-paths.py::binaryTreePaths::2,"    def binaryTreePaths(self, root):
        if not root: return []
        
        arrow = '->'

        ans = []
        stack = []
        stack.append((root, ''))

        while stack:
            node, path = stack.pop()
            path += arrow+str(node.val) if path else str(node.val) #add arrow except beginnings
            if not node.left and not node.right: ans.append(path) #if isLeaf, append path.
            if node.left: stack.append((node.left, path))
            if node.right: stack.append((node.right, path))

        return ans",data\repos\leetcode-python\problems\python\binary-tree-paths.py,binaryTreePaths,124
3270,binary-tree-paths.py::binaryTreePaths::28,"    def binaryTreePaths(self, root):
        q = collections.deque([(root, '')])
        ans = []
        
        while q:
            node, path = q.popleft()
            
            path = (path+'->'+str(node.val)) if path else str(node.val)
            
            if node.left: q.append((node.left, path))
            if node.right: q.append((node.right, path))

            if not node.left and not node.right: ans.append(path)
            
        return ans",data\repos\leetcode-python\problems\python\binary-tree-paths.py,binaryTreePaths,103
3271,binary-tree-pruning.py::pruneTree::2,"    def pruneTree(self, root):
        def hasOne(node):
            if not node: return False

            left_has_one = hasOne(node.left)
            right_has_one = hasOne(node.right)

            if not left_has_one: node.left = None
            if not right_has_one: node.right = None

            return node.val==1 or left_has_one or right_has_one
        
        return root if hasOne(root) else None",data\repos\leetcode-python\problems\python\binary-tree-pruning.py,pruneTree,91
3272,binary-tree-pruning.py::pruneTree::17,"    def pruneTree(self, node):
        if not node: return None
        node.left = self.pruneTree(node.left)
        node.right = self.pruneTree(node.right)
        if not node.left and not node.right and node.val==0: return None
        return node",data\repos\leetcode-python\problems\python\binary-tree-pruning.py,pruneTree,59
3273,binary-tree-pruning.py::hasOne::3,"        def hasOne(node):
            if not node: return False

            left_has_one = hasOne(node.left)
            right_has_one = hasOne(node.right)

            if not left_has_one: node.left = None
            if not right_has_one: node.right = None

            return node.val==1 or left_has_one or right_has_one",data\repos\leetcode-python\problems\python\binary-tree-pruning.py,hasOne,72
3274,binary-tree-right-side-view.py::rightSideView::19,"    def rightSideView(self, root):
        queue = deque([(root, 0)])
        max_level = -1
        view = []
        while queue:
            node, level = queue.popleft()
            if node==None: continue
            if level>max_level:
                max_level = level
                view.append(node.val)
            queue.append((node.right, level+1))
            queue.append((node.left, level+1))
        return view",data\repos\leetcode-python\problems\python\binary-tree-right-side-view.py,rightSideView,95
3275,binary-tree-right-side-view.py::rightSideView::40,"    def rightSideView(self, root):
        if not root: return []
        
        ans = []
        currLevel = -1
        stack = [(root, 0)]
        
        while stack:
            node, level = stack.pop()
            if level>currLevel:
                ans.append(node.val)
                currLevel = level
            if node.left: stack.append((node.left, level+1))
            if node.right: stack.append((node.right, level+1))
                
        return ans",data\repos\leetcode-python\problems\python\binary-tree-right-side-view.py,rightSideView,103
3276,binary-tree-vertical-order-traversal.py::verticalOrder::10,"    def verticalOrder(self, root):
        if not root: return []
        
        q = collections.deque([(root, 0)])
        minX = 0
        maxX = 0
        ans = collections.defaultdict(list)
        
        while q:
            node, x = q.popleft()
            ans[x].append(node.val)
            minX = min(minX, x)
            maxX = max(maxX, x)
            
            if node.left: q.append((node.left, x-1))
            if node.right: q.append((node.right, x+1))
            
        return [ans[x] for x in xrange(minX, maxX+1)]",data\repos\leetcode-python\problems\python\binary-tree-vertical-order-traversal.py,verticalOrder,137
3277,binary-tree-vertical-order-traversal.py::verticalOrder::31,"    def verticalOrder(self, root):
        if not root: return []
        ans = []
        minX = float('inf')
        maxX = float('-inf')
        locations = collections.defaultdict(list)
        q = collections.deque([(root, 0)])
        
        while q:
            node, x = q.popleft()
            locations[x].append(node.val)
            minX = min(minX, x)
            maxX = max(maxX, x)
            if node.left: q.append((node.left, x-1))
            if node.right: q.append((node.right, x+1))
        
        for x in xrange(minX, maxX+1):
            if locations[x]: ans.append(locations[x])
                
        return ans",data\repos\leetcode-python\problems\python\binary-tree-vertical-order-traversal.py,verticalOrder,150
3278,binary-watch.py::readBinaryWatch::6,"    def readBinaryWatch(self, turnedOn):
        ans = []
        if turnedOn>8: return ans #at most 8 LED are turned on for a valid time.

        for h in xrange(12):
            for m in xrange(60):
                if (bin(h) + bin(m)).count('1')==turnedOn:
                    ans.append('%d:%02d' % (h, m))
        return ans",data\repos\leetcode-python\problems\python\binary-watch.py,readBinaryWatch,88
3279,buildings-with-an-ocean-view.py::findBuildings::8,"    def findBuildings(self, heights):
        ans = []
        currMaxHeight = 0
        for i in xrange(len(heights)-1, -1, -1):
            h = heights[i]
            if h>currMaxHeight: ans.append(i)
            currMaxHeight = max(currMaxHeight, h)
        
        return reversed(ans)",data\repos\leetcode-python\problems\python\buildings-with-an-ocean-view.py,findBuildings,74
3280,burst-balloons.py::maxCoins::11,"    def maxCoins(self, nums):
        N = len(nums)
        
        dp = [[0 for _ in xrange(N)] for _ in xrange(N)]
        for i in xrange(N): dp[i][i] = (nums[i-1] if 0<=i-1 else 1) * nums[i] * (nums[i+1] if i+1<N else 1)
            
        for l in xrange(2, N+1):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                for k in xrange(i, j+1):
                    dp[i][j] = max(dp[i][j],
                        (dp[i][k-1] if k-1>=0 else 0) +
                        (nums[i-1] if 0<=i-1 else 1) * nums[k] * (nums[j+1] if j+1<N else 1) +
                        (dp[k+1][j] if k+1<N else 0)
                    )
        
        return dp[0][N-1]",data\repos\leetcode-python\problems\python\burst-balloons.py,maxCoins,232
3281,campus-bikes-ii.py::assignBikes::9,"    def assignBikes(self, workers, bikes):
        M = len(bikes)
        N = len(workers)
        costs = [[0]*N for _ in xrange(M)]
        
        for i in xrange(M):
            for j in xrange(N):
                costs[i][j] = abs(workers[j][0]-bikes[i][0])+abs(workers[j][1]-bikes[i][1])
        
        pq = [(0, '0'*M)]
        visited = set()
        while pq:
            cost, state = heapq.heappop(pq)
            if state in visited: continue
            visited.add(state)
            
            j = state.count('1') #j users have selected bikes
            if j>=N: return cost
            
            for i in xrange(M):
                if state[i]=='1': continue
                
                nextState = state[:i] + '1' + state[i+1:]
                if nextState in visited: continue
                heapq.heappush(pq, (cost+costs[i][j], nextState))
        
        return float('inf')",data\repos\leetcode-python\problems\python\campus-bikes-ii.py,assignBikes,224
3282,candy.py::candy::2,"    def candy(self, ratings):
        N = len(ratings)
        
        l2r = [1]*N
        r2l = [1]*N
        
        for i in xrange(1, N):
            if ratings[i]>ratings[i-1]:
                l2r[i] = l2r[i-1]+1
        
        for i in xrange(N-2, -1, -1):
            if ratings[i]>ratings[i+1]:
                r2l[i] = r2l[i+1]+1
        
        ans = 0
        for i in xrange(N):
            ans += max(l2r[i], r2l[i])
        
        return ans",data\repos\leetcode-python\problems\python\candy.py,candy,143
3283,capacity-to-ship-packages-within-d-days.py::shipWithinDays::2,"    def shipWithinDays(self, weights, D):
        l = max(weights)
        r = sum(weights)
        
        while l<r:
            c = (l+r)/2
            
            #calculate with weight capacity c, how many days we need, d.
            d = 0
            daily_weight = 0
            for w in weights:
                if daily_weight+w<=c:
                    daily_weight+=w
                else:
                    daily_weight = w
                    d += 1
            if daily_weight: d += 1

            if d>D:
                #c cannot be the answer.
                #next round we don't need to put c in l~r.
                l = c+1
            else:
                #c might ot might not be the answer.
                #next round we still need to put c in l~r.
                r = c
        return l",data\repos\leetcode-python\problems\python\capacity-to-ship-packages-within-d-days.py,shipWithinDays,185
3284,cheapest-flights-within-k-stops.py::findCheapestPrice::23,"	def findCheapestPrice(self, n, flights, src, dst, K):
		graph = collections.defaultdict(list)
		pq = []
		visited = set()

		for u, v, w in flights: graph[u].append((w, v))

		heapq.heappush(pq, (0, K+1, src))
		while pq:
			price, stops, city = heapq.heappop(pq)
			visited.add(city)

			if city is dst: return price
			if stops>0:
				for price_to_nei, nei in graph[city]:
					if nei in visited: continue
					heapq.heappush(pq, (price+price_to_nei, stops-1, nei))
		return -1",data\repos\leetcode-python\problems\python\cheapest-flights-within-k-stops.py,findCheapestPrice,162
3285,cheapest-flights-within-k-stops.py::findCheapestPrice::53,"	def findCheapestPrice(self, n, flights, src, dst, K):
		graph = collections.defaultdict(list)
		q = collections.deque()
		min_price = float('inf')

		for u, v, w in flights: graph[u].append((w, v))
		q.append((src, 0, 0))
		while q:
			city, stops, price = q.popleft()
			if city==dst:
				min_price = min(min_price, price)
				continue

			if stops<=K and price<=min_price:
				for price_to_nei, nei in graph[city]:
					q.append((nei, stops+1, price+price_to_nei))

		return min_price if min_price!=float('inf') else -1",data\repos\leetcode-python\problems\python\cheapest-flights-within-k-stops.py,findCheapestPrice,163
3286,cheapest-flights-within-k-stops.py::findCheapestPrice::81,"    def findCheapestPrice(self, n, flights, src, dst, K):
        priceFromSrc = {}
        stepFromSrc = {}
        h = [(0, 0, src)]
        G = collections.defaultdict(list)
        
        #build graph
        for s, d, p in flights:
            G[s].append((d, p))
        
        #dijkstra
        while h:
            price, k, node = heapq.heappop(h)
            
            if node==dst: return price
            if k>K: continue
            
            for nei, price2 in G[node]:
				#explore next destination with less price or less steps
                if nei not in priceFromSrc or price+price2<=priceFromSrc[nei] or k<stepFromSrc[nei]:
                    priceFromSrc[nei] = price+price2
                    stepFromSrc[nei] = k
                    heapq.heappush(h, (price+price2, k+1, nei))
                    
        return -1",data\repos\leetcode-python\problems\python\cheapest-flights-within-k-stops.py,findCheapestPrice,219
3287,climbing-stairs.py::climbStairs::25,"    def climbStairs(self, n):
        counter = 0
        max_two_step = n/2
        for two_step in range(max_two_step+1):
            one_step = n-two_step*2
            combination = self.combination(two_step+one_step, one_step)
            counter+=combination
        return counter",data\repos\leetcode-python\problems\python\climbing-stairs.py,climbStairs,71
3288,climbing-stairs.py::combination::36,"    def combination(self, m, n):
        def factorial(int_num):
            if int_num<0: return None
            if int_num==0: return 1
            counter = 1
            while int_num>=1:
                counter*=int_num
                int_num-=1
            return counter
        
        return factorial(m)/(factorial(n)*factorial(m-n))",data\repos\leetcode-python\problems\python\climbing-stairs.py,combination,79
3289,climbing-stairs.py::climbStairs::50,"    def climbStairs(self, n):
        def helper(n):
            if n in history: return history[n]
            
            if n==0 or n==1:
                history[n] = 1
            elif n==2:
                return 2
            elif n>2:
				#combination count of n stairs equals to
				#(the combination after you make 1 step as first move) + (the combination after you make 2 steps as first move)
                history[n] = helper(n-1) + helper(n-2)
            
            return history[n]
            
        history = {}
        return helper(n)",data\repos\leetcode-python\problems\python\climbing-stairs.py,climbStairs,133
3290,climbing-stairs.py::factorial::37,"        def factorial(int_num):
            if int_num<0: return None
            if int_num==0: return 1
            counter = 1
            while int_num>=1:
                counter*=int_num
                int_num-=1
            return counter",data\repos\leetcode-python\problems\python\climbing-stairs.py,factorial,55
3291,climbing-stairs.py::helper::51,"        def helper(n):
            if n in history: return history[n]
            
            if n==0 or n==1:
                history[n] = 1
            elif n==2:
                return 2
            elif n>2:
				#combination count of n stairs equals to
				#(the combination after you make 1 step as first move) + (the combination after you make 2 steps as first move)
                history[n] = helper(n-1) + helper(n-2)
            
            return history[n]",data\repos\leetcode-python\problems\python\climbing-stairs.py,helper,114
3292,clone-graph.py::cloneGraph::21,"    def cloneGraph(self, start):
        if start==None: return start
        clone = {} #[0]
        stack = [] #[1]
        
        clone[start] = Node(start.val, [])
        stack.append(start)
        
        while stack:
            node = stack.pop()
            for nb in node.neighbors:
                if nb not in clone: #[3]
                    clone[nb] = Node(nb.val, [])
                    stack.append(nb)
                clone[node].neighbors.append(clone[nb]) #[2]
                
        return clone[start]",data\repos\leetcode-python\problems\python\clone-graph.py,cloneGraph,110
3293,clone-graph.py::cloneGraph::40,"    def cloneGraph(self, start):
        clone = {}
        stack = [start]
        
        while stack: #[0]
            node = stack.pop()
            if node not in clone:
                clone[node] = Node(node.val, [])
                for nb in node.neighbors:
                    stack.append(nb)
                
        for node in clone: #[1]
            for nb in node.neighbors:
                clone[node].neighbors.append(clone[nb])
                
        return clone[start]",data\repos\leetcode-python\problems\python\clone-graph.py,cloneGraph,94
3294,clone-graph.py::cloneGraph::59,"    def cloneGraph(self, node):
        if not node: return node
        
        visited = set()
        clones = {}
        stack = []
        
        stack.append(node)
        while stack:
            curr = stack.pop()
            if curr in visited: continue
            visited.add(curr)
            clones[curr] = Node(curr.val)
            stack.extend(curr.neighbors)
        
        for curr in clones:
            clones[curr].neighbors = [clones[c] for c in curr.neighbors]
        
        return clones[node]",data\repos\leetcode-python\problems\python\clone-graph.py,cloneGraph,103
3295,closest-binary-search-tree-value.py::closestValue::9,"    def closestValue(self, root, target):
        node = root
        ans = float('inf')
        
        while node:
            if not node: break
            
            if abs(ans-target)>abs(node.val-target):
                ans = node.val
            
            if target>node.val:
                node = node.right
            else:
                node = node.left
                
        return ans",data\repos\leetcode-python\problems\python\closest-binary-search-tree-value.py,closestValue,76
3296,coin-change.py::coinChange::3,"    def coinChange(self, coins, amount):
        dp = [float('inf')]*(amount+1)
        
        if amount==0: return 0
        
        dp[0] = 0
        for coin in coins:
            if coin<=amount:
                dp[coin] = 1
            
        for a in xrange(amount+1):
            for coin in coins:
                if a-coin>=0:
                    dp[a] = min(dp[a], dp[a-coin]+1)
                    
        return dp[amount] if dp[amount]!=float('inf') else -1",data\repos\leetcode-python\problems\python\coin-change.py,coinChange,122
3297,coin-change.py::coinChange::23,"    def coinChange(self, coins, amount):
        visited = set()
        
        coins.sort(reverse=True)
        q = collections.deque([(0, 0)])
        
        while q:
            current_amount, count = q.popleft()
            
            if current_amount==amount: return count
            if current_amount>amount: continue
            if current_amount in visited: continue
            visited.add(current_amount)
            
            for coin in coins:
                q.append((current_amount+coin, count+1))
        return -1",data\repos\leetcode-python\problems\python\coin-change.py,coinChange,108
3298,coloring-a-border.py::colorBorder::14,"    def colorBorder(self, grid, row, col, color):
        def isValid(i, j):
            return i>=0 and j>=0 and i<len(grid) and j<len(grid[0])
        
        def isBorder(i, j, color):
            if i==0 or i==len(grid)-1 or j==0 or j==len(grid[0])-1: return True
            if any(grid[iNei][jNei]!=color for iNei, jNei in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]): return True
            return False
            
        q = collections.deque([(row, col)])
        nodesToColor = []
        visited = set()
        
        while q:
            i, j = q.popleft()
            
            if not isValid(i, j): continue
            if grid[i][j]!=grid[row][col]: continue
            if (i, j) in visited: continue
            visited.add((i, j))
            
            if isBorder(i, j, grid[row][col]): nodesToColor.append((i, j))
            
            for iNext, jNext in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                q.append((iNext, jNext))
        
        for i, j in nodesToColor:
            grid[i][j] = color
        
        return grid",data\repos\leetcode-python\problems\python\coloring-a-border.py,colorBorder,315
3299,coloring-a-border.py::isBorder::18,"        def isBorder(i, j, color):
            if i==0 or i==len(grid)-1 or j==0 or j==len(grid[0])-1: return True
            if any(grid[iNei][jNei]!=color for iNei, jNei in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]): return True
            return False",data\repos\leetcode-python\problems\python\coloring-a-border.py,isBorder,96
3300,combination-sum-ii.py::combinationSum2::26,"    def combinationSum2(self, candidates, target):
        def helper(combination, start, target_remain):
            if target_remain==0:
                answer.add(tuple(combination))
            for i in xrange(start, len(candidates)):
                num = candidates[i]
                if num>target_remain: break
                helper(combination+[num], i+1, target_remain-num)

        answer = set()
        candidates.sort()
        helper([], 0, target)
        return [list(combination) for combination in answer]",data\repos\leetcode-python\problems\python\combination-sum-ii.py,combinationSum2,106
3301,combination-sum-ii.py::combinationSum2::42,"    def combinationSum2(self, candidates, T):
        def dfs(index, target, path):
            if target<0:
                return
            elif target==0:
                opt.append(path)
            else:
                for i in xrange(index, len(candidates)):
                    if i>index and candidates[i]==candidates[i-1]: continue
                    num = candidates[i]
                    dfs(i+1, target-num, path+[num])
        opt = []
        candidates.sort()
        dfs(0, T, [])
        return opt",data\repos\leetcode-python\problems\python\combination-sum-ii.py,combinationSum2,108
3302,combination-sum-ii.py::combinationSum2::60,"    def combinationSum2(self, candidates, target):
        def helper(remain, comb, start):
            if remain==0:
                ans.append(comb[:])
            elif remain<0:
                return
            else:
                for i in xrange(start, len(candidates)):
                    if i>start and candidates[i]==candidates[i-1]: continue
                    candidate = candidates[i]
                    comb.append(candidate)
                    helper(remain-candidate, comb, i+1)
                    comb.pop()
        
        ans = []
        candidates.sort()
        helper(target, [], 0)
        return ans",data\repos\leetcode-python\problems\python\combination-sum-ii.py,combinationSum2,120
3303,combination-sum-ii.py::helper::27,"        def helper(combination, start, target_remain):
            if target_remain==0:
                answer.add(tuple(combination))
            for i in xrange(start, len(candidates)):
                num = candidates[i]
                if num>target_remain: break
                helper(combination+[num], i+1, target_remain-num)",data\repos\leetcode-python\problems\python\combination-sum-ii.py,helper,66
3304,combination-sum-ii.py::dfs::43,"        def dfs(index, target, path):
            if target<0:
                return
            elif target==0:
                opt.append(path)
            else:
                for i in xrange(index, len(candidates)):
                    if i>index and candidates[i]==candidates[i-1]: continue
                    num = candidates[i]
                    dfs(i+1, target-num, path+[num])",data\repos\leetcode-python\problems\python\combination-sum-ii.py,dfs,78
3305,combination-sum-ii.py::helper::61,"        def helper(remain, comb, start):
            if remain==0:
                ans.append(comb[:])
            elif remain<0:
                return
            else:
                for i in xrange(start, len(candidates)):
                    if i>start and candidates[i]==candidates[i-1]: continue
                    candidate = candidates[i]
                    comb.append(candidate)
                    helper(remain-candidate, comb, i+1)
                    comb.pop()",data\repos\leetcode-python\problems\python\combination-sum-ii.py,helper,89
3306,combination-sum-iii.py::combinationSum3::10,"    def combinationSum3(self, K, N):
        answer = []
        ans = []
        first = 1
        total = 0
        while True:
            if len(ans)==K and total==N: #[0]
                answer.append(ans[:])

            if len(ans)==K or total>N or first>9: #[1]
                if not ans: return answer
                first = ans.pop() #backtrack
                total-=first
                first+=1
            else:
                ans.append(first)
                total+=first
                first+=1",data\repos\leetcode-python\problems\python\combination-sum-iii.py,combinationSum3,117
3307,combination-sum-iii.py::combinationSum3::31,"    def combinationSum3(self, K, N):
        def dfs(path, min_num):
            if len(path)==K and sum(path)==N:
                opt.append(path)
            for num in xrange(min_num, 10):
                dfs(path+[num], num+1)
        opt = []
        dfs([], 1)
        return opt",data\repos\leetcode-python\problems\python\combination-sum-iii.py,combinationSum3,70
3308,combination-sum-iii.py::combinationSum3::53,"    def combinationSum3(self, k, n):
        def helper(remain, comb, k, start):
            if remain==0 and len(comb)==k:
                ans.append(comb[:])
            elif remain<0 or len(comb)>k:
                return
            else:
                for i in xrange(start, len(nums)):
                    used = nums[i]
                    num = i+1
                    
                    if used: continue
                        
                    comb.append(num)
                    nums[i] = True
                    
                    helper(remain-num, comb, k, i+1)
                    
                    comb.pop()
                    nums[i] = False
        
        nums = [False]*9
        ans = []
        helper(n, [], k, 0)
        return ans",data\repos\leetcode-python\problems\python\combination-sum-iii.py,combinationSum3,149
3309,combination-sum-iii.py::dfs::32,"        def dfs(path, min_num):
            if len(path)==K and sum(path)==N:
                opt.append(path)
            for num in xrange(min_num, 10):
                dfs(path+[num], num+1)",data\repos\leetcode-python\problems\python\combination-sum-iii.py,dfs,46
3310,combination-sum-iii.py::helper::54,"        def helper(remain, comb, k, start):
            if remain==0 and len(comb)==k:
                ans.append(comb[:])
            elif remain<0 or len(comb)>k:
                return
            else:
                for i in xrange(start, len(nums)):
                    used = nums[i]
                    num = i+1
                    
                    if used: continue
                        
                    comb.append(num)
                    nums[i] = True
                    
                    helper(remain-num, comb, k, i+1)
                    
                    comb.pop()
                    nums[i] = False",data\repos\leetcode-python\problems\python\combination-sum-iii.py,helper,112
3311,combination-sum-iv.py::combinationSum4::2,"    def combinationSum4(self, nums, target):
        def helper(t):
            if t<0: return 0
            if dp[t]>=0: return dp[t]
            
            ans = 0
            for num in nums:
                ans += helper(t-num)
            
            dp[t] = ans
            return ans
        
        dp = [-1]*(target+1)
        dp[0] = 1
        
        for i in xrange(target+1):
            helper(i)
        return dp[target]",data\repos\leetcode-python\problems\python\combination-sum-iv.py,combinationSum4,106
3312,combination-sum-iv.py::combinationSum4::51,"    def combinationSum4(self, nums, target):
        dp = [0]*(target+1)
        dp[0] = 1
        
        t = 1
        
        while t<=target:
            combs = 0
            for num in nums:
                if t-num<0: continue
                combs += dp[t-num]
            
            dp[t] = combs
            t += 1
            
        return dp[target]",data\repos\leetcode-python\problems\python\combination-sum-iv.py,combinationSum4,92
3313,combination-sum-iv.py::helper::3,"        def helper(t):
            if t<0: return 0
            if dp[t]>=0: return dp[t]
            
            ans = 0
            for num in nums:
                ans += helper(t-num)
            
            dp[t] = ans
            return ans",data\repos\leetcode-python\problems\python\combination-sum-iv.py,helper,57
3314,combination-sum.py::combinationSum::48,"    def combinationSum(self, candidates, target):
        def helper(combination, start, target_remain):
            if target_remain==0:
                answer.append(combination)
            for i in xrange(start, len(candidates)):
                num = candidates[i] #try out if with num adding into combination can make target_remain 0
                if num>target_remain: break
                helper(combination+[num], i, target_remain-num)

        candidates.sort()
        answer = []
        helper([], 0, target)
        return answer",data\repos\leetcode-python\problems\python\combination-sum.py,combinationSum,108
3315,combination-sum.py::combinationSum::66,"    def combinationSum(self, candidates, target):
        def helper(candidates, target, combination):
            if not candidates: return []
            n = candidates[0]
            if n>target:
                return []
            elif n==target:
                return [combination+[n]]
            else:
                return helper(candidates, target-n, combination+[n]) + helper(candidates[1:], target, combination)
        return helper(sorted(candidates), target, [])",data\repos\leetcode-python\problems\python\combination-sum.py,combinationSum,93
3316,combination-sum.py::combinationSum::81,"    def combinationSum(self, candidates, T):
        answer = []
        ans = []
        first = 0
        total = 0

        candidates.sort()

        memo = {}
        for i, num in enumerate(candidates):
            memo[num] = i

        while True:
            if total==T:
                answer.append(ans[:])
            if total>=T or first>=len(candidates):
                if not ans: return answer
                num = ans.pop()
                first = memo[num]+1
                total-=num
            else:
                ans.append(candidates[first])
                total+=candidates[first]",data\repos\leetcode-python\problems\python\combination-sum.py,combinationSum,126
3317,combination-sum.py::combinationSum::107,"    def combinationSum(self, candidates, T):
        def dfs(index, target, path):
            if target<0:
                return
            elif target==0:
                opt.append(path)
            else:
                for i in xrange(index, len(candidates)):
                    num = candidates[i]
                    dfs(i, target-num, path+[num])
        opt = []
        candidates.sort()
        dfs(0, T, [])
        return opt",data\repos\leetcode-python\problems\python\combination-sum.py,combinationSum,89
3318,combination-sum.py::combinationSum::128,"    def combinationSum(self, candidates, target):
        def helper(remain, comb, start=0):
            if remain==0:
                ans.append(comb[:])
            elif remain<0:
                return
            elif remain>0:
                for i in xrange(start, len(candidates)):
                    candidate = candidates[i]
                    comb.append(candidate)
                    helper(remain-candidate, comb, i)
                    comb.pop()
        
        ans = []
        helper(target, [])
        return ans",data\repos\leetcode-python\problems\python\combination-sum.py,combinationSum,99
3319,combination-sum.py::helper::49,"        def helper(combination, start, target_remain):
            if target_remain==0:
                answer.append(combination)
            for i in xrange(start, len(candidates)):
                num = candidates[i] #try out if with num adding into combination can make target_remain 0
                if num>target_remain: break
                helper(combination+[num], i, target_remain-num)",data\repos\leetcode-python\problems\python\combination-sum.py,helper,79
3320,combination-sum.py::helper::67,"        def helper(candidates, target, combination):
            if not candidates: return []
            n = candidates[0]
            if n>target:
                return []
            elif n==target:
                return [combination+[n]]
            else:
                return helper(candidates, target-n, combination+[n]) + helper(candidates[1:], target, combination)",data\repos\leetcode-python\problems\python\combination-sum.py,helper,73
3321,combination-sum.py::dfs::108,"        def dfs(index, target, path):
            if target<0:
                return
            elif target==0:
                opt.append(path)
            else:
                for i in xrange(index, len(candidates)):
                    num = candidates[i]
                    dfs(i, target-num, path+[num])",data\repos\leetcode-python\problems\python\combination-sum.py,dfs,60
3322,combination-sum.py::helper::129,"        def helper(remain, comb, start=0):
            if remain==0:
                ans.append(comb[:])
            elif remain<0:
                return
            elif remain>0:
                for i in xrange(start, len(candidates)):
                    candidate = candidates[i]
                    comb.append(candidate)
                    helper(remain-candidate, comb, i)
                    comb.pop()",data\repos\leetcode-python\problems\python\combination-sum.py,helper,76
3323,combinations.py::combine::2,"    def combine(self, N, K):
        def helper(first, combination):
            if len(combination)==K:
                answer.append(combination)
            else:
                for num in xrange(first, N+1):
                    helper(num+1, combination+[num])
        answer = []
        helper(1, [])
        return answer",data\repos\leetcode-python\problems\python\combinations.py,combine,67
3324,combinations.py::combine::43,"    def combine(self, N, K):
        answer = []
        combination = []
        first = 1
        while True:
            if len(combination)==K:
                answer.append(combination[:])

            if len(combination)==K or first>N:
                if not combination: return answer
                first = combination.pop()+1 #backtrack
            else:
                combination.append(first)
                first+=1",data\repos\leetcode-python\problems\python\combinations.py,combine,84
3325,combinations.py::combine::71,"    def combine(self, N, K):
        def dfs(n_min, path):
            if len(path)==K:
                opt.append(path)
                return
            else:
                for n in xrange(n_min, N+1):
                    dfs(n+1, path+[n])
        opt = []
        dfs(1, [])
        return opt",data\repos\leetcode-python\problems\python\combinations.py,combine,70
3326,combinations.py::combine::87,"    def combine(self, N, K):
        def dfs(comb, start, N, K):
            if len(comb)==K: ans.append(comb[:])
            
            for n in xrange(start, N+1):
                comb.append(n)
                dfs(comb, n+1, N, K)
                comb.pop()
        
        ans = []
        dfs([], 1, N, K)
        return ans",data\repos\leetcode-python\problems\python\combinations.py,combine,83
3327,combinations.py::helper::3,"        def helper(first, combination):
            if len(combination)==K:
                answer.append(combination)
            else:
                for num in xrange(first, N+1):
                    helper(num+1, combination+[num])",data\repos\leetcode-python\problems\python\combinations.py,helper,45
3328,combinations.py::dfs::72,"        def dfs(n_min, path):
            if len(path)==K:
                opt.append(path)
                return
            else:
                for n in xrange(n_min, N+1):
                    dfs(n+1, path+[n])",data\repos\leetcode-python\problems\python\combinations.py,dfs,48
3329,combinations.py::dfs::88,"        def dfs(comb, start, N, K):
            if len(comb)==K: ans.append(comb[:])
            
            for n in xrange(start, N+1):
                comb.append(n)
                dfs(comb, n+1, N, K)
                comb.pop()",data\repos\leetcode-python\problems\python\combinations.py,dfs,56
3330,compare-version-numbers.py::compareVersion::17,"    def compareVersion(self, version1, version2):
        def getVersion(version, start):
            if start==-1: return 0, -1
            for i in xrange(start, len(version)):
                if version[i]=='.':
                    return int(version[start:i]), i+1
            return int(version[start:]), -1 #[0]
            
        i1 = i2 = 0
        
        while True:
            sub_version1, i1 = getVersion(version1, i1)
            sub_version2, i2 = getVersion(version2, i2)
            
            if sub_version1>sub_version2:
                return 1
            elif sub_version1<sub_version2:
                return -1
            elif i1==-1 and i2==-1: #[1]
                return 0",data\repos\leetcode-python\problems\python\compare-version-numbers.py,compareVersion,167
3331,compare-version-numbers.py::getVersion::18,"        def getVersion(version, start):
            if start==-1: return 0, -1
            for i in xrange(start, len(version)):
                if version[i]=='.':
                    return int(version[start:i]), i+1
            return int(version[start:]), -1 #[0]",data\repos\leetcode-python\problems\python\compare-version-numbers.py,getVersion,60
3332,connecting-cities-with-minimum-cost.py::minimumCost::2,"    def minimumCost(self, N, connections):
        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2: return False
                
            if ranks[p1]>ranks[p2]:
                parents[p2] = p1
                ranks[p1] += 1
            else:
                parents[p1] = p2
                ranks[p2] += 1
            return True

        def find(n):
            p = parents[n]
            while p!=parents[p]: p = find(p)
            parents[n] = p
            return p
        
        if not connections: return 0
        
        parents = [n for n in xrange(N+1)]
        ranks = [0]*(N+1)
        totalCost = 0
        count = N # the count of nodes not yet union
        
		# sort by cost, union the ones with less cost first
        sortedConnections = sorted([(cost, x, y) for x, y, cost in connections])
        
        for cost, x, y in sortedConnections:
            if union(x, y):
                totalCost += cost
                count -= 1
                 
        return totalCost if count==1 else -1",data\repos\leetcode-python\problems\python\connecting-cities-with-minimum-cost.py,minimumCost,266
3333,connecting-cities-with-minimum-cost.py::union::3,"        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2: return False
                
            if ranks[p1]>ranks[p2]:
                parents[p2] = p1
                ranks[p1] += 1
            else:
                parents[p1] = p2
                ranks[p2] += 1
            return True",data\repos\leetcode-python\problems\python\connecting-cities-with-minimum-cost.py,union,90
3334,connecting-cities-with-minimum-cost.py::find::17,"        def find(n):
            p = parents[n]
            while p!=parents[p]: p = find(p)
            parents[n] = p
            return p",data\repos\leetcode-python\problems\python\connecting-cities-with-minimum-cost.py,find,33
3335,consecutive-numbers-sum.py::consecutiveNumbersSum::4,"    def consecutiveNumbersSum(self, N):
        i = 1
        j = 2
        s = 1 #sum(range(i, j))
        ans = 0
        
        while i<=j and j<=N+1:
            if s==N:
                ans += 1
                s += j
                j += 1
            elif s>N:
                s -= i
                i += 1
            else:
                s += j
                j += 1
        return ans",data\repos\leetcode-python\problems\python\consecutive-numbers-sum.py,consecutiveNumbersSum,107
3336,consecutive-numbers-sum.py::consecutiveNumbersSum::26,"    def consecutiveNumbersSum(self, N):
        ans = 0
        upperLimit = int((2 * N + 0.25)**0.5 - 0.5) + 2
        
        for x in xrange(1, upperLimit):
            if x%2==0:
                if float(N)/x-N/x==0.5:
                    upper = N/x + x/2
                    lower = N/x - x/2 + 1
                    if 1<=lower and upper<=N:
                        ans += 1
            else:
                if N%x==0:
                    upper = N/x + (x-1)/2
                    lower = N/x - (x-1)/2
                    if 1<=lower and upper<=N: 
                        ans += 1
        return ans",data\repos\leetcode-python\problems\python\consecutive-numbers-sum.py,consecutiveNumbersSum,172
3337,construct-binary-tree-from-inorder-and-postorder-traversal.py::buildTree::11,"    def buildTree(self, inorder, postorder):
        if not inorder or not postorder: return None
        
        root = TreeNode(postorder[-1])
        if len(inorder)==1: return root
        
        r = inorder.index(root.val)
        
        leftInOrder = inorder[:r]
        leftPostOrder = postorder[:r]
        rightInOrder = inorder[r+1:]
        rightPostOrder = postorder[r:len(postorder)-1]
        
        root.left = self.buildTree(leftInOrder, leftPostOrder)
        root.right = self.buildTree(rightInOrder, rightPostOrder)
        
        return root",data\repos\leetcode-python\problems\python\construct-binary-tree-from-inorder-and-postorder-traversal.py,buildTree,130
3338,construct-binary-tree-from-inorder-and-postorder-traversal.py::buildTree::55,"    def buildTree(self, inorder, postorder):
        def helper(i, j, k, l):
            if j-i<=0: return None
            if l-k<=0: return None
            
            root = TreeNode(postorder[l-1])
            if j-i==1: return root

            r = index[root.val]
            
            root.left = helper(i, r, k, k+r-i)
            root.right = helper(r+1, j, k+r-i, l-1)
            return root
        
        index = {} #the index of inorder
        for i, n in enumerate(inorder): index[n] = i
        return helper(0, len(inorder), 0, len(postorder))",data\repos\leetcode-python\problems\python\construct-binary-tree-from-inorder-and-postorder-traversal.py,buildTree,151
3339,construct-binary-tree-from-inorder-and-postorder-traversal.py::buildTree::88,"    def buildTree(self, inorder, postorder):
        def helper(i, j, k, l):
            if i>j or k>l: return None
            rootVal = postorder[l]
            root = TreeNode(rootVal)
            r = inorderIndex[rootVal]
            leftLength = r-i
            rightLength = j-r
            root.left = helper(i, r-1, k, k+leftLength-1)
            root.right = helper(r+1, j, k+leftLength, k+leftLength+rightLength-1)
            return root
            
        inorderIndex = {}
        for i, n in enumerate(inorder): inorderIndex[n] = i
        return helper(0, len(inorder)-1, 0, len(postorder)-1)",data\repos\leetcode-python\problems\python\construct-binary-tree-from-inorder-and-postorder-traversal.py,buildTree,164
3340,construct-binary-tree-from-inorder-and-postorder-traversal.py::helper::56,"        def helper(i, j, k, l):
            if j-i<=0: return None
            if l-k<=0: return None
            
            root = TreeNode(postorder[l-1])
            if j-i==1: return root

            r = index[root.val]
            
            root.left = helper(i, r, k, k+r-i)
            root.right = helper(r+1, j, k+r-i, l-1)
            return root",data\repos\leetcode-python\problems\python\construct-binary-tree-from-inorder-and-postorder-traversal.py,helper,96
3341,construct-binary-tree-from-inorder-and-postorder-traversal.py::helper::89,"        def helper(i, j, k, l):
            if i>j or k>l: return None
            rootVal = postorder[l]
            root = TreeNode(rootVal)
            r = inorderIndex[rootVal]
            leftLength = r-i
            rightLength = j-r
            root.left = helper(i, r-1, k, k+leftLength-1)
            root.right = helper(r+1, j, k+leftLength, k+leftLength+rightLength-1)
            return root",data\repos\leetcode-python\problems\python\construct-binary-tree-from-inorder-and-postorder-traversal.py,helper,109
3342,construct-binary-tree-from-preorder-and-inorder-traversal.py::buildTree::16,"    def buildTree(self, preorder, inorder):
        def helper(i, j, k, l):
            root = TreeNode(preorder[i])
            
            r = inorderIndex[root.val] #the index of the root val in inorder
            leftLength = r-k
            rightLength = l-(r+1)
            
            if leftLength>0: root.left = helper(i+1, i+1+leftLength, k, k+leftLength)
            if rightLength>0: root.right = helper(i+1+leftLength, i+1+leftLength+rightLength, r+1, r+1+rightLength)
            return root
        
        inorderIndex = {}
        for i, n in enumerate(inorder): inorderIndex[n] = i
        return helper(0, len(preorder), 0, len(inorder))",data\repos\leetcode-python\problems\python\construct-binary-tree-from-preorder-and-inorder-traversal.py,buildTree,177
3343,construct-binary-tree-from-preorder-and-inorder-traversal.py::helper::17,"        def helper(i, j, k, l):
            root = TreeNode(preorder[i])
            
            r = inorderIndex[root.val] #the index of the root val in inorder
            leftLength = r-k
            rightLength = l-(r+1)
            
            if leftLength>0: root.left = helper(i+1, i+1+leftLength, k, k+leftLength)
            if rightLength>0: root.right = helper(i+1+leftLength, i+1+leftLength+rightLength, r+1, r+1+rightLength)
            return root",data\repos\leetcode-python\problems\python\construct-binary-tree-from-preorder-and-inorder-traversal.py,helper,127
3344,container-with-most-water.py::maxArea::23,"    def maxArea(self, H):
        r, l = len(H)-1, 0
        ans = float('-inf')

        while r>l:
            ans = max(ans, (r-l)*min(H[r], H[l]))
            if H[r]>H[l]:
                l = l+1
            else:
                r = r-1
        return ans",data\repos\leetcode-python\problems\python\container-with-most-water.py,maxArea,79
3345,container-with-most-water.py::maxArea::37,"    def maxArea(self, height):
        i = 0
        j = len(height)-1
        ans = 0
        
        while i<j:
            ans = max(ans, min(height[i], height[j])*(j-i))
            if height[i]<height[j]:
                """"""
                If we try to move the pointer at the longer line inwards, we won't gain any increase in area, since it is limited by the shorter line.
                """"""
                i += 1
            else:
                j -= 1
        return ans",data\repos\leetcode-python\problems\python\container-with-most-water.py,maxArea,113
3346,contains-duplicate-ii.py::containsNearbyDuplicate::6,"    def containsNearbyDuplicate(self, nums, k):
        lastSeen = {}
        
        for i, num in enumerate(nums):
            if num in lastSeen:
                if i-lastSeen[num]<=k: return True
            lastSeen[num] = i
            
        return False",data\repos\leetcode-python\problems\python\contains-duplicate-ii.py,containsNearbyDuplicate,57
3347,contains-duplicate-iii.py::containsNearbyAlmostDuplicate::20,"    def containsNearbyAlmostDuplicate(self, nums, k, t):
        bucket = {}
        
        for i, num in enumerate(nums):
            if len(bucket)>k:
                bidToRemove = nums[i-k-1]//(t+1)
                del bucket[bidToRemove]
            
            bid = num//(t+1)
            if bid in bucket: return True
            if bid+1 in bucket and abs(bucket[bid+1]-num)<=t: return True
            if bid-1 in bucket and abs(bucket[bid-1]-num)<=t: return True
            bucket[bid] = num
        
        return False",data\repos\leetcode-python\problems\python\contains-duplicate-iii.py,containsNearbyAlmostDuplicate,132
3348,contains-duplicate.py::containsDuplicate::6,"    def containsDuplicate(self, nums):
        seen = set()
        
        for num in nums:
            if num in seen: return True
            seen.add(num)

        return False",data\repos\leetcode-python\problems\python\contains-duplicate.py,containsDuplicate,37
3349,continuous-subarray-sum.py::checkSubarraySum::2,"    def checkSubarraySum(self, nums, k):
        prefixSumEndings = collections.defaultdict(list)
        prefixSumEndings[0].append(-1)
        
        prefixSum = 0
        for i, n in enumerate(nums):
            prefixSum += n
            
            x = prefixSum/k
            while x>=0:
                p2 = prefixSum-k*x
                if len(prefixSumEndings[p2])>0 and prefixSumEndings[p2][0]<i-1:
                    return True
                x -= 1
            prefixSumEndings[prefixSum].append(i)
        
        return False",data\repos\leetcode-python\problems\python\continuous-subarray-sum.py,checkSubarraySum,132
3350,continuous-subarray-sum.py::checkSubarraySum::21,"    def checkSubarraySum(self, nums, k):
        if len(nums)==0 or len(nums)==1: return False
        prefixSumKRemain = collections.defaultdict(list)
        
        prefixSum = 0
        for i, n in enumerate(nums):
            prefixSum += n
            remain = prefixSum%k
            
            if prefixSum%k==0 and i>=1: return True
            if len(prefixSumKRemain[remain])>0 and prefixSumKRemain[remain][0]<i-1:
                return True
            prefixSumKRemain[remain].append(i)
            
        return False",data\repos\leetcode-python\problems\python\continuous-subarray-sum.py,checkSubarraySum,134
3351,convert-sorted-array-to-binary-search-tree.py::sortedArrayToBST::2,"    def sortedArrayToBST(self, nums):
        if not nums: return None
        
        m = len(nums)/2
        root = TreeNode(nums[m], self.sortedArrayToBST(nums[:m]), self.sortedArrayToBST(nums[m+1:]))
        return root",data\repos\leetcode-python\problems\python\convert-sorted-array-to-binary-search-tree.py,sortedArrayToBST,56
3352,convert-sorted-array-to-binary-search-tree.py::sortedArrayToBST::40,"    def sortedArrayToBST(self, nums):
        def helper(i, j):
            m = (i+j)/2
            node = TreeNode(nums[m])
            
            leftLength = m-i #number of nodes in the left subtree
            rightLength = j-(m+1) #number of nodes in the right subtree
            
            if leftLength>0: node.left = helper(i, m)
            if rightLength>0: node.right = helper(m+1, j)
            return node
        
        return helper(0, len(nums))",data\repos\leetcode-python\problems\python\convert-sorted-array-to-binary-search-tree.py,sortedArrayToBST,113
3353,convert-sorted-array-to-binary-search-tree.py::sortedArrayToBST::58,"    def sortedArrayToBST(self, nums):
        def helper(s, e):
            if s>e: return None
            m = (s+e)/2
            node = TreeNode(nums[m])
            node.left = helper(s, m-1)
            node.right = helper(m+1, e)
            return node
        return helper(0, len(nums)-1)",data\repos\leetcode-python\problems\python\convert-sorted-array-to-binary-search-tree.py,sortedArrayToBST,79
3354,convert-sorted-array-to-binary-search-tree.py::helper::41,"        def helper(i, j):
            m = (i+j)/2
            node = TreeNode(nums[m])
            
            leftLength = m-i #number of nodes in the left subtree
            rightLength = j-(m+1) #number of nodes in the right subtree
            
            if leftLength>0: node.left = helper(i, m)
            if rightLength>0: node.right = helper(m+1, j)
            return node",data\repos\leetcode-python\problems\python\convert-sorted-array-to-binary-search-tree.py,helper,93
3355,convert-sorted-array-to-binary-search-tree.py::helper::59,"        def helper(s, e):
            if s>e: return None
            m = (s+e)/2
            node = TreeNode(nums[m])
            node.left = helper(s, m-1)
            node.right = helper(m+1, e)
            return node",data\repos\leetcode-python\problems\python\convert-sorted-array-to-binary-search-tree.py,helper,57
3356,convert-sorted-list-to-binary-search-tree.py::sortedListToBST::21,"    def sortedListToBST(self, head):
        if not head: return None
        
        midNode = self.getMiddle(head)
        root = TreeNode(midNode.val)
        
        if head.val==midNode.val: return root
        
        root.left = self.sortedListToBST(head)
        root.right = self.sortedListToBST(midNode.next)
        
        return root",data\repos\leetcode-python\problems\python\convert-sorted-list-to-binary-search-tree.py,sortedListToBST,76
3357,convert-sorted-list-to-binary-search-tree.py::getMiddle::34,"    def getMiddle(self, node):
        pre = None
        slow = node
        fast = node

        while fast and fast.next:
            fast = fast.next.next
            pre = slow
            slow = slow.next

        if pre: pre.next = None
        return slow",data\repos\leetcode-python\problems\python\convert-sorted-list-to-binary-search-tree.py,getMiddle,60
3358,copy-list-with-random-pointer.py::copyRandomList::8,"    def copyRandomList(self, head):
        if head==None: return head
        
        curr = head
        while curr:
            temp = curr.next
            new_node = RandomListNode(curr.label)
            new_node.next = temp
            curr.next = new_node
            curr = curr.next.next
            
        curr = head
        while curr:
            curr.next.random = curr.random.next if curr.random else None
            curr = curr.next.next
            
        curr = head
        curr_copy = head.next
        head_copy = head.next
        
        while curr:
            curr.next = curr.next.next
            curr_copy.next = curr_copy.next.next if curr_copy.next else None
            curr = curr.next
            curr_copy = curr_copy.next
            
        return head_copy",data\repos\leetcode-python\problems\python\copy-list-with-random-pointer.py,copyRandomList,158
3359,copy-list-with-random-pointer.py::copyRandomList::38,"    def copyRandomList(self, head):
        if not head: return head
        
        clones = {}
        
        curr = head
        while curr:
            clones[curr] = Node(curr.val)
            curr = curr.next
        
        curr = head
        while curr:
            if curr.next: clones[curr].next = clones[curr.next]
            if curr.random: clones[curr].random = clones[curr.random]
            curr = curr.next
        
        return clones[head]",data\repos\leetcode-python\problems\python\copy-list-with-random-pointer.py,copyRandomList,95
3360,copy-list-with-random-pointer.py::copyRandomList::67,"    def copyRandomList(self, head):
        if not head: return head
        curr = head
        while curr:
            nextCurr = curr.next
            copy = Node(curr.val)
            curr.next = copy
            copy.next = nextCurr
            curr = nextCurr
        
        copyHead = head.next

        curr = head
        while curr:
            if curr.random: curr.next.random = curr.random.next
            curr = curr.next.next
        
        curr = head
        while curr:
            nextCurr = curr.next.next
            if nextCurr:
                curr.next.next = nextCurr.next
            curr.next = nextCurr
            curr = nextCurr
        
        return copyHead",data\repos\leetcode-python\problems\python\copy-list-with-random-pointer.py,copyRandomList,143
3361,count-all-valid-pickup-and-delivery-opti.py::countOrders::2,"    def countOrders(self, n):
        d = 1
        for i in xrange(1, 2*n, 2): d*=i
        return math.factorial(n)*d % (10**9 + 7)",data\repos\leetcode-python\problems\python\count-all-valid-pickup-and-delivery-opti.py,countOrders,50
3362,count-binary-substrings.py::countBinarySubstrings::2,"    def countBinarySubstrings(self, s):
        groups = []
        count = 0
        last = s[0]
        ans = 0
        
        for bit in s:
            if bit==last:
                count += 1
            else:
                groups.append(count)
                count = 1
            last = bit
        
        groups.append(count)
        
        for i in xrange(1, len(groups)):
            ans += min(groups[i], groups[i-1])
        
        return ans",data\repos\leetcode-python\problems\python\count-binary-substrings.py,countBinarySubstrings,103
3363,count-complete-tree-nodes.py::countNodes::8,"    def countNodes(self, root):
        if not root: return 0
        
        node = root
        l = 1 #level on the right side
        while node.left:
            node = node.left
            l += 1
        
        node = root
        r = 1 #level on the left side
        while node.right:
            node = node.right
            r += 1
        
        if l==r:
            #perfect tree
            return (2**r)-1
        else:
            return 1+self.countNodes(root.left)+self.countNodes(root.right)",data\repos\leetcode-python\problems\python\count-complete-tree-nodes.py,countNodes,124
3364,count-number-of-nice-subarrays.py::numberOfSubarrays::2,"    def numberOfSubarrays(self, nums, K):
        def atMost(k):
            oddCount = 0
            ans = 0
            i = 0
            
            for j in xrange(len(nums)):
                if nums[j]%2!=0: oddCount += 1
                
                while oddCount>k:
                    if nums[i]%2!=0: oddCount -= 1
                    i += 1
                
                ans += j-i+1
            
            return ans
        
        return atMost(K)-atMost(K-1)",data\repos\leetcode-python\problems\python\count-number-of-nice-subarrays.py,numberOfSubarrays,110
3365,count-number-of-nice-subarrays.py::atMost::3,"        def atMost(k):
            oddCount = 0
            ans = 0
            i = 0
            
            for j in xrange(len(nums)):
                if nums[j]%2!=0: oddCount += 1
                
                while oddCount>k:
                    if nums[i]%2!=0: oddCount -= 1
                    i += 1
                
                ans += j-i+1
            
            return ans",data\repos\leetcode-python\problems\python\count-number-of-nice-subarrays.py,atMost,86
3366,count-unique-characters-of-all-substrings-of-a-given-string.py::uniqueLetterString::2,"    def uniqueLetterString(self, s):
        index = {}
        ans = 0
        for c in 'abcdefghijklmnopqrstuvwxyz':
            index[c.upper()] = [-1, -1]
        
        # count the substring that s[j] is the unique letter
        for k, c in enumerate(s):
            i, j = index[c]
            ans += (j-i) * (k-j)
            index[c] = [j, k]
        
        # count the substring that s[j] is the unique letter, because last iteration did not count the last letter
        for c in index:
            i, j = index[c]
            ans += (j-i) * (len(s)-j)
        return ans",data\repos\leetcode-python\problems\python\count-unique-characters-of-all-substrings-of-a-given-string.py,uniqueLetterString,148
3367,course-schedule-ii.py::findOrder::4,"    def findOrder(self, numCourses, prerequisites):
        graph = defaultdict(list)
        inbound = defaultdict(int)
        q = deque()
        order = deque()
        
		#building graph as adjacency list
        for c1, c2 in prerequisites:
            graph[c2].append(c1)
            inbound[c1] += 1
        
		#find the starting point
        for c in xrange(numCourses):
            if inbound[c]==0:
                q.append(c)
        
		#traverse the directed graph
        while q:
            c = q.popleft()
            
            for nei in graph[c]:
                inbound[nei] -= 1
                if inbound[nei]==0:
                    q.append(nei)
                    
            order.append(c)
        
        return order if len(order)==numCourses else []",data\repos\leetcode-python\problems\python\course-schedule-ii.py,findOrder,171
3368,course-schedule-ii.py::findOrder::52,"    def findOrder(self, numCourses, prerequisites):
        graph = collections.defaultdict(list)
        inbounds = collections.defaultdict(int)
        pq = collections.deque()
        sortedNodes = []
        
        for c1, c2 in prerequisites:
            graph[c2].append(c1)
            inbounds[c1]+=1
        
        for node in xrange(numCourses):
            if inbounds[node]==0:
                pq.append(node)
        
        while pq:
            node = pq.popleft()
            
            for nei in graph[node]:
                inbounds[nei] -= 1
                if inbounds[nei]==0:
                    pq.append(nei)
            sortedNodes.append(node)
        
        return sortedNodes if len(sortedNodes)==numCourses else []",data\repos\leetcode-python\problems\python\course-schedule-ii.py,findOrder,156
3369,course-schedule.py::canFinish::2,"    def canFinish(self, numCourses, prerequisites):
        graph = {n:[] for n in xrange(numCourses)} #[0]
        
        for n1, n2 in prerequisites:
            graph[n1].append(n2)
        
        for target_course in xrange(numCourses): #[1]
            stack = graph[target_course]
            visited = set()
            while stack:
                course = stack.pop()
                visited.add(course)
                if course==target_course: return False
                for ajc in graph[course]:
                    if ajc not in visited:
                        stack.append(ajc)
        return True",data\repos\leetcode-python\problems\python\course-schedule.py,canFinish,125
3370,course-schedule.py::canFinish::41,"    def canFinish(self, numCourses, prerequisites):
        graph = collections.defaultdict(list)
        inbound = collections.defaultdict(int)
        q_next = collections.deque()
        q = collections.deque()

        for n1, n2 in prerequisites: #[1]
            graph[n1].append(n2)
            inbound[n2]+=1

        for n in xrange(numCourses): #[2]
            if inbound[n]==0:
                q_next.append(n)

        while q_next: #[3]
            n = q_next.popleft()
            for nei in graph[n]:
                inbound[nei]-=1
                if inbound[nei]==0:
                    q_next.append(nei)
            q.append(n)
        return len(q)==numCourses",data\repos\leetcode-python\problems\python\course-schedule.py,canFinish,155
3371,custom-sort-string.py::customSortString::7,"    def customSortString(self, order, s):
        sortedChars = ''
        counter = collections.Counter(s)
        for c in order:
            if c in order:
                sortedChars += c*counter[c]
        
        orderSet = set(order)
        postString = ''
        for c in s:
            if c not in orderSet:
                postString += c
        
        return sortedChars+postString",data\repos\leetcode-python\problems\python\custom-sort-string.py,customSortString,84
3372,cutting-ribbons.py::maxLength::2,"    def maxLength(self, ribbons, k):
        maxLen = max(ribbons)
        minLen = 0
        
        while minLen<maxLen:
            l = minLen + (maxLen-minLen+1)/2
            
            if sum([ribbonLen/l for ribbonLen in ribbons])>=k:
                minLen = l
            else:
                maxLen = l-1
        return maxLen",data\repos\leetcode-python\problems\python\cutting-ribbons.py,maxLength,88
3373,data-stream-as-disjoint-intervals.py::getIntervals::11,"    def getIntervals(self):
        ans = []
        
        for num in self.nums:
            if not ans:
                ans.append([num, num])
            elif ans[len(ans)-1][1]+1==num:
                ans[len(ans)-1][1] = num
            elif ans[len(ans)-1][1]<num:
                ans.append([num, num])
        return ans",data\repos\leetcode-python\problems\python\data-stream-as-disjoint-intervals.py,getIntervals,81
3374,data-stream-as-disjoint-intervals.py::addNum::34,"    def addNum(self, val):
        if not self.ans:
            self.ans.append([val, val])
            return
            
        l = 0
        r = len(self.ans)-1
        
        #find insertion point
        while l<r:
            m = (l+r)/2
            if self.checkAndAdd(l, val): return
            if self.checkAndAdd(r, val): return
            if self.checkAndAdd(m, val): return
            
            if val<self.ans[m][0]:
                r = m
            else:
                l = m+1
        
        #insert val
        if self.checkAndAdd(l, val):
            return
        elif val<self.ans[l][0]:
            self.ans.insert(l, [val, val])
        else:
            self.ans.insert(l+1, [val, val])",data\repos\leetcode-python\problems\python\data-stream-as-disjoint-intervals.py,addNum,184
3375,data-stream-as-disjoint-intervals.py::checkAndAdd::66,"    def checkAndAdd(self, i, val):
        if val==self.ans[i][0]-1:
            self.ans[i][0] = val

            #merge i-1 and i if needed
            if i>0 and self.ans[i-1][1]+1==self.ans[i][0]:
                self.ans[i][0] = self.ans[i-1][0]
                self.ans.pop(i-1)

            return True

        elif val==self.ans[i][1]+1:
            self.ans[i][1] = val

            #merge i and i+1 if needed
            if i+1<len(self.ans) and self.ans[i][1]+1==self.ans[i+1][0]:
                self.ans[i][1] = self.ans[i+1][1]
                self.ans.pop(i+1)

            return True

        elif self.ans[i][0]<=val and val<=self.ans[i][1]:
            return True

        return False",data\repos\leetcode-python\problems\python\data-stream-as-disjoint-intervals.py,checkAndAdd,223
3376,decode-string.py::decodeString::7,"    def decodeString(self, s):
        opt = ''
        k = ''
        stack = []

        for i, c in enumerate(s):
            if c=='[':
                stack.append(i)
            elif c==']':
                i_start = stack.pop()
                if not stack:
                    opt += int(k)*self.decodeString(s[i_start+1:i])
                    k = ''
            elif c.isdigit() and not stack:
                k+=c
            elif not stack:
                opt+=c
        return opt or s",data\repos\leetcode-python\problems\python\decode-string.py,decodeString,107
3377,decode-string.py::decodeString::34,"    def decodeString(self, s):
        opt = ''
        stack = []
        k = ''

        for c in s:
            if c=='[':
                stack.append(opt)
                stack.append(k)
                opt = ''
                k = ''
            elif c==']':
                n = stack.pop()
                pre = stack.pop()
                opt = pre+int(n)*opt
            elif c.isdigit():
                k+=c
            else:
                opt+=c
        return opt",data\repos\leetcode-python\problems\python\decode-string.py,decodeString,99
3378,decode-ways.py::numDecodings::6,"    def numDecodings(self, s):
        def helper(s, i):
            if (s, i) in memo: return memo[(s, i)]
            if i>=len(s): return 1
            if s[i]=='0': return 0
            
            count = 0
            count += helper(s, i+1)
            if len(s)-i>=2 and int(s[i:i+2])<=26: count += helper(s, i+2)
            memo[(s, i)] = count
            return count
                
        memo = {}
        return helper(s, 0)",data\repos\leetcode-python\problems\python\decode-ways.py,numDecodings,125
3379,decode-ways.py::helper::7,"        def helper(s, i):
            if (s, i) in memo: return memo[(s, i)]
            if i>=len(s): return 1
            if s[i]=='0': return 0
            
            count = 0
            count += helper(s, i+1)
            if len(s)-i>=2 and int(s[i:i+2])<=26: count += helper(s, i+2)
            memo[(s, i)] = count
            return count",data\repos\leetcode-python\problems\python\decode-ways.py,helper,103
3380,delete-and-earn.py::deleteAndEarn::4,"    def deleteAndEarn(self, nums):
        if not nums: return 0
        m = min(nums)
        M = max(nums)
        c = collections.Counter(nums)
        
        prev = 0 
        curr = 0
        for n in xrange(m, M+1):
            prev, curr = curr, max(prev+n*c[n], curr)
        return curr",data\repos\leetcode-python\problems\python\delete-and-earn.py,deleteAndEarn,79
3381,delete-duplicate-folders-in-system.py::deleteDuplicateFolder::8,"    def deleteDuplicateFolder(self, paths):
        def setKey(node):
            node.key = ''
            for c in sorted(node.children.keys()): #need to be sorted. so when child structs are the same, we won't generate different key from different iteration order.
                setKey(node.children[c])
                node.key += node.children[c].val + '|' + node.children[c].key + '|' #generate a key for each node. only considering its children structure. (see the ""identical"" definition, it does not consider the val of the node itself.)
                
            keyCount[node.key] += 1
        
        def addPath(node, path):
            if node.children and keyCount[node.key]>1: return #leaf node does not apply to this rule
            ans.append(path+[node.val])
            for c in node.children:
                addPath(node.children[c], path+[node.val])
            
            
        ans = []
        root = Node('/')
        keyCount = collections.Counter()
        
        #build the tree
        for path in paths:
            node = root
            for c in path:
                if c not in node.children: node.children[c] = Node(c)
                node = node.children[c]
        
        #set all nodes key recursively
        setKey(root)

        #build ans
        for c in root.children:
            addPath(root.children[c], [])
        
        return ans",data\repos\leetcode-python\problems\python\delete-duplicate-folders-in-system.py,deleteDuplicateFolder,285
3382,delete-duplicate-folders-in-system.py::setKey::9,"        def setKey(node):
            node.key = ''
            for c in sorted(node.children.keys()): #need to be sorted. so when child structs are the same, we won't generate different key from different iteration order.
                setKey(node.children[c])
                node.key += node.children[c].val + '|' + node.children[c].key + '|' #generate a key for each node. only considering its children structure. (see the ""identical"" definition, it does not consider the val of the node itself.)
                
            keyCount[node.key] += 1",data\repos\leetcode-python\problems\python\delete-duplicate-folders-in-system.py,setKey,115
3383,delete-duplicate-folders-in-system.py::addPath::17,"        def addPath(node, path):
            if node.children and keyCount[node.key]>1: return #leaf node does not apply to this rule
            ans.append(path+[node.val])
            for c in node.children:
                addPath(node.children[c], path+[node.val])",data\repos\leetcode-python\problems\python\delete-duplicate-folders-in-system.py,addPath,58
3384,delete-node-in-a-bst.py::deleteNode::22,"    def deleteNode(self, root, key):
        def find_min(root):
            curr = root
            while curr.left: curr = curr.left
            return curr.val#[5]
        
        def remove(node):
            if node.left and node.right:
                node.val = find_min(node.right)
                node.right = self.deleteNode(node.right, node.val)
                return node #[4]
            elif node.left and not node.right:
                return node.left #[3]
            elif node.right and not node.left:
                return node.right #[3]
            else:
                return None #[2]
            
        if not root: return root
        node = root
        
        while node: #[0]
            if node.val==key:
                return remove(node) #[1]
            elif node.left and node.left.val==key:
                node.left = remove(node.left) #[1]
                return root
            elif node.right and node.right.val==key:
                node.right = remove(node.right) #[1]
                return root
            
            if key>node.val and node.right:
                node = node.right
            elif key<node.val and node.left:
                node = node.left
            else:
                break
                
        return root",data\repos\leetcode-python\problems\python\delete-node-in-a-bst.py,deleteNode,250
3385,delete-node-in-a-bst.py::deleteNode::66,"    def deleteNode(self, node, key):
        if not node:
            return node
        elif key<node.val:
            node.left = self.deleteNode(node.left, key)
            return node
        elif key>node.val:
            node.right = self.deleteNode(node.right, key)
            return node
        elif key==node.val:
            if not node.left and not node.right:
                return None
            elif not node.left:
                return node.right
            elif not node.right:
                return node.left
            else:
                node.val = self.findMin(node.right) #min value in the right subtree
                node.right = self.deleteNode(node.right, node.val)
                return node",data\repos\leetcode-python\problems\python\delete-node-in-a-bst.py,deleteNode,145
3386,delete-node-in-a-bst.py::findMin::87,"    def findMin(self, root):
        ans = float('inf')
        stack = [root]

        while stack:
            node = stack.pop()
            ans = min(ans, node.val)
            if node.left: stack.append(node.left)
            if node.right: stack.append(node.right)
        return ans",data\repos\leetcode-python\problems\python\delete-node-in-a-bst.py,findMin,63
3387,delete-node-in-a-bst.py::remove::28,"        def remove(node):
            if node.left and node.right:
                node.val = find_min(node.right)
                node.right = self.deleteNode(node.right, node.val)
                return node #[4]
            elif node.left and not node.right:
                return node.left #[3]
            elif node.right and not node.left:
                return node.right #[3]
            else:
                return None #[2]",data\repos\leetcode-python\problems\python\delete-node-in-a-bst.py,remove,82
3388,delete-operation-for-two-strings.py::minDistance::2,"    def minDistance(self, word1, word2):
        N = len(word1)
        M = len(word2)
        
        dp = [[float('inf') for _ in xrange(M+1)] for _ in xrange(N+1)]
        
        
        for i in xrange(1, N+1): dp[i][0] = i #need i deletion for word1[0:i-1] to be """"
        for j in xrange(1, M+1): dp[0][j] = j #need i deletion for word1[0:j-1] to be """"
        dp[0][0] = 0
        
        for i in xrange(1, N+1):
            for j in xrange(1, M+1):
			    #dp[i][j] := min operation count for dp[0:i] and dp[0:j-1] to be the same.
                
				#if char at i-1 and j-1 are the same, no deletion needed.
                if word1[i-1]==word2[j-1]:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
                
                dp[i][j] = min(dp[i][j], dp[i][j-1]+1) #remove char on word2[j-1]
                dp[i][j] = min(dp[i][j], dp[i-1][j]+1) #remove char on word1[i-1]
            return dp[N][M]",data\repos\leetcode-python\problems\python\delete-operation-for-two-strings.py,minDistance,317
3389,design-add-and-search-words-data-structure.py::addWord::12,"    def addWord(self, word):
        word = word + self.endSign
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = Node(c)
            node = node.children[c]",data\repos\leetcode-python\problems\python\design-add-and-search-words-data-structure.py,addWord,53
3390,design-add-and-search-words-data-structure.py::searchFromNode::24,"    def searchFromNode(self, node, word):
        if not word: return True
        
        char = word[0]
        if char in node.children:
            return self.searchFromNode(node.children[char], word[1:])
        elif char=='.':
            for c in node.children:
                if self.searchFromNode(node.children[c], word[1:]):
                    return True
        return False",data\repos\leetcode-python\problems\python\design-add-and-search-words-data-structure.py,searchFromNode,82
3391,design-in-memory-file-system.py::ls::21,"    def ls(self, path):
        if path in self.files:
            return [path.split('/')[-1]]
        else:
            if path=='/': return sorted(self.dirs.keys())
            curr = self.dirs
            for d in path.split('/')[1:]:
                curr = curr[d]
            return sorted(curr.keys())",data\repos\leetcode-python\problems\python\design-in-memory-file-system.py,ls,66
3392,design-in-memory-file-system.py::mkdir::31,"    def mkdir(self, path):
        curr = self.dirs
        for d in path.split('/')[1:]:
            if d not in curr:
                curr[d] = {}
            curr = curr[d]",data\repos\leetcode-python\problems\python\design-in-memory-file-system.py,mkdir,42
3393,design-in-memory-file-system.py::addContentToFile::38,"    def addContentToFile(self, filePath, content):
        if filePath not in self.files:
            self.mkdir(filePath)
            self.files[filePath] = content
        else:
            self.files[filePath] += content",data\repos\leetcode-python\problems\python\design-in-memory-file-system.py,addContentToFile,44
3394,design-linked-list.py::get::10,"    def get(self, index): #O(1)
        if index<0 or index>=len(self.l):
            return -1
        return self.l[index].val",data\repos\leetcode-python\problems\python\design-linked-list.py,get,36
3395,design-linked-list.py::addAtHead::15,"    def addAtHead(self, val): #O(N), list extend takes O(N), <https://wiki.python.org/moin/TimeComplexity>.
        self.l = [Node(val)]+self.l",data\repos\leetcode-python\problems\python\design-linked-list.py,addAtHead,43
3396,design-linked-list.py::addAtIndex::21,"    def addAtIndex(self, index, val): #O(N)
        self.l = self.l[:index]+[Node(val)]+self.l[index:]",data\repos\leetcode-python\problems\python\design-linked-list.py,addAtIndex,32
3397,design-tic-tac-toe.py::move::35,"    def move(self, row, col, player):
        record = self.records[player-1]
        record[0][row] += 1
        record[1][col] += 1
        if row==col: record[2] += 1
        if row+col==self.n-1: record[3] += 1

        if self.checkRecord(record, row, col): return player
            
        return 0",data\repos\leetcode-python\problems\python\design-tic-tac-toe.py,move,93
3398,design-tic-tac-toe.py::checkRecord::46,"    def checkRecord(self, record, row, col):
        if record[0][row]==self.n: return True
        if record[1][col]==self.n: return True
        if record[2]==self.n: return True
        if record[3]==self.n: return True
        
        return False",data\repos\leetcode-python\problems\python\design-tic-tac-toe.py,checkRecord,67
3399,diagonal-traverse.py::findDiagonalOrder::2,"    def findDiagonalOrder(self, mat):
        def helper(i, j, reverse):
            output = []
            while 0<=i<len(mat) and 0<=j<len(mat[0]):
                output.append(mat[i][j])
                i += 1
                j -= 1
            return output if not reverse else reversed(output)
        
        
        M = len(mat)
        N = len(mat[0])
        ans = []
        reverse = True
        
        for j in xrange(N):
            ans += helper(0, j, reverse)
            reverse = not reverse
        
        for i in xrange(1, M):
            ans += helper(i, N-1, reverse)
            reverse = not reverse
        
        return ans",data\repos\leetcode-python\problems\python\diagonal-traverse.py,findDiagonalOrder,151
3400,diagonal-traverse.py::helper::3,"        def helper(i, j, reverse):
            output = []
            while 0<=i<len(mat) and 0<=j<len(mat[0]):
                output.append(mat[i][j])
                i += 1
                j -= 1
            return output if not reverse else reversed(output)",data\repos\leetcode-python\problems\python\diagonal-traverse.py,helper,62
3401,diameter-of-binary-tree.py::diameterOfBinaryTree::8,"    def diameterOfBinaryTree(self, root):
        self.diameter = 0
        
        def traverse(node):
            if not node: return 0
            
            #the max depth go left from this node
            #the max depth go right from this node
            left, right = traverse(node.left), traverse(node.right)
            
            #update diameter if left+right is bigger
            self.diameter = max(self.diameter, left+right)
            
            #add 1 is for the step that get to this node
            #max(left, right) is for the left or right path that goes to the deepest
            return max(left, right)+1
        
        #iterate through the tree
        traverse(root)
        return self.diameter",data\repos\leetcode-python\problems\python\diameter-of-binary-tree.py,diameterOfBinaryTree,154
3402,diameter-of-binary-tree.py::diameterOfBinaryTree::31,"    def diameterOfBinaryTree(self, root):
        def getMaxDepth(node):
            if not node: return 0

            l, r = getMaxDepth(node.left), getMaxDepth(node.right)
            self.ans = max(self.ans, l+r)
            return max(l, r)+1 #add the node it self

        if not root: return 0
        self.ans = float('-inf')
        getMaxDepth(root)
        return self.ans",data\repos\leetcode-python\problems\python\diameter-of-binary-tree.py,diameterOfBinaryTree,96
3403,diameter-of-binary-tree.py::diameterOfBinaryTree::95,"    def diameterOfBinaryTree(self, root):
	    #return the longest length to the leaf including itself
        #also update self.ans
        def helper(node):
            r = helper(node.right) if node.right else 0
            l = helper(node.left) if node.left else 0
            self.ans = max(self.ans, l+1+r)
            return max(l+1, r+1)
        
        helper(root)
        return self.ans-1",data\repos\leetcode-python\problems\python\diameter-of-binary-tree.py,diameterOfBinaryTree,101
3404,diameter-of-binary-tree.py::traverse::11,"        def traverse(node):
            if not node: return 0
            
            #the max depth go left from this node
            #the max depth go right from this node
            left, right = traverse(node.left), traverse(node.right)
            
            #update diameter if left+right is bigger
            self.diameter = max(self.diameter, left+right)
            
            #add 1 is for the step that get to this node
            #max(left, right) is for the left or right path that goes to the deepest
            return max(left, right)+1",data\repos\leetcode-python\problems\python\diameter-of-binary-tree.py,traverse,119
3405,diameter-of-binary-tree.py::getMaxDepth::32,"        def getMaxDepth(node):
            if not node: return 0

            l, r = getMaxDepth(node.left), getMaxDepth(node.right)
            self.ans = max(self.ans, l+r)
            return max(l, r)+1 #add the node it self",data\repos\leetcode-python\problems\python\diameter-of-binary-tree.py,getMaxDepth,57
3406,diameter-of-binary-tree.py::helper::98,"        def helper(node):
            r = helper(node.right) if node.right else 0
            l = helper(node.left) if node.left else 0
            self.ans = max(self.ans, l+1+r)
            return max(l+1, r+1)",data\repos\leetcode-python\problems\python\diameter-of-binary-tree.py,helper,59
3407,different-ways-to-add-parentheses.py::diffWaysToCompute::2,"    def diffWaysToCompute(self, S):
        def calculate(operator, n1, n2):
            if operator==""+"":
                return n1+n2
            elif operator=='-':
                return n1-n2
            elif operator=='*':
                return n1*n2
            else:
                return None

        if S.isdigit(): return [int(S)]

        opt = []
        for i in xrange(len(S)):
            if S[i]=='+' or S[i]=='-' or S[i]=='*':
                left = self.diffWaysToCompute(S[:i])
                right = self.diffWaysToCompute(S[i+1:])
                for n1 in left:
                    for n2 in right:
                        opt.append(calculate(S[i], n1, n2))
        return opt",data\repos\leetcode-python\problems\python\different-ways-to-add-parentheses.py,diffWaysToCompute,165
3408,different-ways-to-add-parentheses.py::calculate::3,"        def calculate(operator, n1, n2):
            if operator==""+"":
                return n1+n2
            elif operator=='-':
                return n1-n2
            elif operator=='*':
                return n1*n2
            else:
                return None",data\repos\leetcode-python\problems\python\different-ways-to-add-parentheses.py,calculate,56
3409,distinct-subsequences.py::numDistinct::5,"    def numDistinct(self, s, t):
        M, N = len(s), len(t)
        
        dp = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]
        for i in xrange(M+1): dp[i][0] = 1
        
        for i in xrange(1, M+1):
            for j in xrange(1, N+1):
                if s[i-1]==t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        
        return dp[-1][-1]",data\repos\leetcode-python\problems\python\distinct-subsequences.py,numDistinct,147
3410,distribute-coins-in-binary-tree.py::distributeCoins::2,"    def distributeCoins(self, root):
        def count_moves(node):
            if not node: return 0
            l, r = count_moves(node.left), count_moves(node.right)
            self.moves += abs(l)+abs(r)
            return node.val-1+l+r

        self.moves = 0
        count_moves(root)
        return self.moves",data\repos\leetcode-python\problems\python\distribute-coins-in-binary-tree.py,distributeCoins,73
3411,distribute-coins-in-binary-tree.py::count_moves::3,"        def count_moves(node):
            if not node: return 0
            l, r = count_moves(node.left), count_moves(node.right)
            self.moves += abs(l)+abs(r)
            return node.val-1+l+r",data\repos\leetcode-python\problems\python\distribute-coins-in-binary-tree.py,count_moves,48
3412,domino-and-tromino-tiling.py::numTilings::2,"    def numTilings(self, N):
        H = [[0, 0] for _ in xrange(N+1)]
        H[0][0] = 1
        H[1][0] = 1
        
        for i in xrange(2, N+1):
            H[i][0] = (H[i-1][0] + H[i-2][0] + H[i-1][1]*2) % 1000000007
            H[i][1] = (H[i-2][0] + H[i-1][1]) % 1000000007
            
        return H[N][0]",data\repos\leetcode-python\problems\python\domino-and-tromino-tiling.py,numTilings,138
3413,dot-product-of-two-sparse-vectors.py::dotProduct::11,"    def dotProduct(self, vec):
        products = 0
        indices = self.indices.intersection(vec.indices)
        for i in indices:
            products += self.values[i]*vec.values[i]
        return products",data\repos\leetcode-python\problems\python\dot-product-of-two-sparse-vectors.py,dotProduct,43
3414,dungeon-game.py::calculateMinimumHP::32,"    def calculateMinimumHP(self, D):
        N = len(D)
        M = len(D[0])
        hp = [[float('inf')]*(M+1) for _ in xrange(N+1)]
        hp[N][M-1] = 1
        hp[N-1][M] = 1

        for i in reversed(xrange(N)):
            for j in reversed(xrange(M)):
                min_required = min(hp[i+1][j], hp[i][j+1]) - D[i][j]
                hp[i][j] = min_required if min_required>1 else 1
        return hp[0][0]",data\repos\leetcode-python\problems\python\dungeon-game.py,calculateMinimumHP,138
3415,dungeon-game.py::calculateMinimumHP::48,"    def calculateMinimumHP(self, dungeon):
        def canPass(health_init):
            stack = []

            stack.append((0, 0, health_init))
            while stack:
                i, j, health = stack.pop()
                health_left = health+dungeon[i][j]
                if health<0 or health_left<0: continue
                if i==N-1 and j==M-1: return True
                if i+1<N: stack.append((i+1, j, health_left))
                if j+1<M: stack.append((i, j+1, health_left))

            return False


        N = len(dungeon)
        M = len(dungeon[0])
        l = 0
        h = 0
        for row in dungeon:
            for v in row:
                if v<0:
                    h += -1*v
        while l<h:
            ans = (l+h)/2

            if canPass(ans):
                h = ans
            else:
                l = ans+1
        return l+1",data\repos\leetcode-python\problems\python\dungeon-game.py,calculateMinimumHP,223
3416,dungeon-game.py::calculateMinimumHP::83,"    def calculateMinimumHP(self, dungeon):
        stack = []
        ans = float('inf')
        N = len(dungeon)
        M = len(dungeon[0])

        stack.append((0, 0, 0, 0))
        while stack:
            i, j, health_curr, health_need = stack.pop()
            health_curr += dungeon[i][j]
            if health_curr<0:
                health_need = max(health_need, -1*health_curr+1)
            if i==N-1 and j==M-1:
                ans = min(ans, health_need)
            if i+1<N: stack.append((i+1, j, health_curr, health_need))
            if j+1<M: stack.append((i, j+1, health_curr, health_need))
        return ans",data\repos\leetcode-python\problems\python\dungeon-game.py,calculateMinimumHP,172
3417,dungeon-game.py::canPass::49,"        def canPass(health_init):
            stack = []

            stack.append((0, 0, health_init))
            while stack:
                i, j, health = stack.pop()
                health_left = health+dungeon[i][j]
                if health<0 or health_left<0: continue
                if i==N-1 and j==M-1: return True
                if i+1<N: stack.append((i+1, j, health_left))
                if j+1<M: stack.append((i, j+1, health_left))

            return False",data\repos\leetcode-python\problems\python\dungeon-game.py,canPass,120
3418,edit-distance.py::minDistance::5,"    def minDistance(self, w1, w2):
        M, N = len(w1), len(w2)
        
        dp = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]
        
        for i in xrange(M+1): dp[i][0] = i
        for j in xrange(N+1): dp[0][j] = j
        
        for i in xrange(1, M+1):
            for j in xrange(1, N+1):
                if w1[i-1]==w2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1)

        return dp[-1][-1]",data\repos\leetcode-python\problems\python\edit-distance.py,minDistance,185
3419,egions-cut-by-slashes.py::regionsBySlashes::2,"    def regionsBySlashes(self, grid):
        region = 1
        dsu = DSU()
        N = len(grid)
        
        #Union the border lines
        for i in xrange(N):
            dsu.union((i, 0), (i+1, 0))
            dsu.union((i, N), (i+1, N))
        for j in xrange(N):
            dsu.union((0, j), (0, j+1))
            dsu.union((N, j), (N, j+1))

        #Iterate through slashes and connect the dots
        #If the slash connects two already connected dots, the region will increament by one
        for i, row in enumerate(grid):
            for j, slash in enumerate(row):
                if slash=='/':
                    if not dsu.union((j+1, i), (j, i+1)):
                        region += 1
                elif slash=='\\':
                    if not dsu.union((j, i), (j+1, i+1)):
                        region += 1
        return region",data\repos\leetcode-python\problems\python\egions-cut-by-slashes.py,regionsBySlashes,232
3420,egions-cut-by-slashes.py::find::31,"    def find(self, x):
        if x not in self.parant:
            self.parant[x] = x

        if self.parant[x]!=x:
            self.parant[x] = self.find(self.parant[x])

        return self.parant[x]",data\repos\leetcode-python\problems\python\egions-cut-by-slashes.py,find,55
3421,egions-cut-by-slashes.py::union::40,"    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr==yr: return False
        self.parant[yr] = xr
        return True",data\repos\leetcode-python\problems\python\egions-cut-by-slashes.py,union,44
3422,evaluate-division.py::calcEquation::25,"    def calcEquation(self, equations, values, queries):
        def findVal(query):
            n1, n2 = query
            if n1 not in graph or n2 not in graph: return -1.0
            
            stack = [(n1, 1.0)] #[1]
            visited = set() #[4]
            
            while stack:
                n, val = stack.pop()
                visited.add(n)
                if n==n2:
                    return val
                else:
                    for nb, nb_val in graph[n]: #nb means neighbor
                        if nb not in visited:
                            stack.append((nb, nb_val*val)) #[3]
                            if n!=n1: graph[n1].append((nb, nb_val*val)) #[5]
            return -1.0
            
        def addEdge(n1, n2, val):
            if n1 in graph:
                graph[n1].append((n2, val))
            else:
                graph[n1] = [(n2, val)]
        
        #[0]
        graph = {}
        for (n1, n2), val in zip(equations, values):
            addEdge(n1, n2, val)
            addEdge(n2, n1, 1/val)

        return [findVal(query) for query in queries]",data\repos\leetcode-python\problems\python\evaluate-division.py,calcEquation,279
3423,evaluate-division.py::calcEquation::63,"    def calcEquation(self, equations, values, queries):
		#using DFS
        def find_val(n1, n2):
            if n1 not in graph or n2 not in graph: return -1
            if n1==n2: return 1
            if n2 in graph[n1]: return graph[n1][n2]
                
            stack = [(n1, 1)]
            visited = set()
            
            while stack:
                n, v = stack.pop() #v is the val of n1/n
				
                if n in visited: continue
                visited.add(n)
                
                if n==n2:
                    graph[n1][n2] = v
                    return v
                
                stack.extend([(next_n, v*graph[n][next_n]) for next_n in graph[n]])
            return -1
        
        #build graph
        graph = defaultdict(dict)
        for i, v in enumerate(values):
            n1, n2 = equations[i][0], equations[i][1]
            graph[n1][n2] = v
            graph[n2][n1] = 1/v
        
        ans = []
        for n1, n2 in queries:
            ans.append(find_val(n1, n2))
            
        return ans",data\repos\leetcode-python\problems\python\evaluate-division.py,calcEquation,268
3424,evaluate-division.py::findVal::26,"        def findVal(query):
            n1, n2 = query
            if n1 not in graph or n2 not in graph: return -1.0
            
            stack = [(n1, 1.0)] #[1]
            visited = set() #[4]
            
            while stack:
                n, val = stack.pop()
                visited.add(n)
                if n==n2:
                    return val
                else:
                    for nb, nb_val in graph[n]: #nb means neighbor
                        if nb not in visited:
                            stack.append((nb, nb_val*val)) #[3]
                            if n!=n1: graph[n1].append((nb, nb_val*val)) #[5]
            return -1.0",data\repos\leetcode-python\problems\python\evaluate-division.py,findVal,155
3425,evaluate-division.py::addEdge::45,"        def addEdge(n1, n2, val):
            if n1 in graph:
                graph[n1].append((n2, val))
            else:
                graph[n1] = [(n2, val)]",data\repos\leetcode-python\problems\python\evaluate-division.py,addEdge,46
3426,evaluate-division.py::find_val::65,"        def find_val(n1, n2):
            if n1 not in graph or n2 not in graph: return -1
            if n1==n2: return 1
            if n2 in graph[n1]: return graph[n1][n2]
                
            stack = [(n1, 1)]
            visited = set()
            
            while stack:
                n, v = stack.pop() #v is the val of n1/n
				
                if n in visited: continue
                visited.add(n)
                
                if n==n2:
                    graph[n1][n2] = v
                    return v
                
                stack.extend([(next_n, v*graph[n][next_n]) for next_n in graph[n]])
            return -1",data\repos\leetcode-python\problems\python\evaluate-division.py,find_val,158
3427,evaluate-reverse-polish-notation.py::evalRPN::15,"    def evalRPN(self, tokens):
        def calculate(operator, n1, n2):
            if operator=='+':
                return n2+n1
            elif operator=='-':
                return n2-n1
            elif operator=='*':
                return n2*n1
            elif operator=='/' and n1!=0:
                #by description
                #division between two integers should truncate toward zero.
                if n2%n1!=0:
                    return int(n2/float(n1))
                else:
                    return n2/n1
            else:
                print('ERROR')
                
        stack = []
        
        for t in tokens:
            if t in '+-*/':
                stack.append(calculate(t, stack.pop(), stack.pop()))
            else:
                stack.append(int(t))
        return stack.pop()",data\repos\leetcode-python\problems\python\evaluate-reverse-polish-notation.py,evalRPN,170
3428,evaluate-reverse-polish-notation.py::calculate::16,"        def calculate(operator, n1, n2):
            if operator=='+':
                return n2+n1
            elif operator=='-':
                return n2-n1
            elif operator=='*':
                return n2*n1
            elif operator=='/' and n1!=0:
                #by description
                #division between two integers should truncate toward zero.
                if n2%n1!=0:
                    return int(n2/float(n1))
                else:
                    return n2/n1
            else:
                print('ERROR')",data\repos\leetcode-python\problems\python\evaluate-reverse-polish-notation.py,calculate,114
3429,exclusive-time-of-functions.py::exclusiveTime::2,"    def exclusiveTime(self, n, logs):
        ans = [0]*n
        data = []
        for log in logs:
            fid, action, t = log.split(':')
            data.append([int(t), -1 if action=='start' else 1, int(fid)])
        
        data.sort()
        
        stack = []
        for t, action, fid in data:
            if action==-1:
                if stack:
                    prevT, _, prevFid = stack[-1]
                    ans[prevFid] += t-prevT
            elif action==1:
                prevT, _, prevFid = stack.pop()
                ans[fid] += t+1-prevT
                if stack: stack[-1][0] = t+1
                
            if action==-1: stack.append([t, action, fid])
        
        return ans",data\repos\leetcode-python\problems\python\exclusive-time-of-functions.py,exclusiveTime,179
3430,expression-add-operators.py::addOperators::2,"    def addOperators(self, num, target):
        def dfs(num, curr, i):
            if i==len(num):
                if eval(curr[1:])==target: ans.append(curr[1:])
                return
            
            if curr and curr[-1] in operators:
                dfs(num, curr+num[i], i+1)
            elif curr and curr[-1]=='0':
                dfs(num, curr+'+', i)
                dfs(num, curr+'-', i)
                dfs(num, curr+'*', i)
            else:
                dfs(num, curr+'+', i)
                dfs(num, curr+'-', i)
                dfs(num, curr+'*', i)
                dfs(num, curr+num[i], i+1)
        
        operators = set(['+', '-', '*'])
        ans = []
        dfs(num, '+', 0)
        return ans",data\repos\leetcode-python\problems\python\expression-add-operators.py,addOperators,175
3431,expression-add-operators.py::dfs::3,"        def dfs(num, curr, i):
            if i==len(num):
                if eval(curr[1:])==target: ans.append(curr[1:])
                return
            
            if curr and curr[-1] in operators:
                dfs(num, curr+num[i], i+1)
            elif curr and curr[-1]=='0':
                dfs(num, curr+'+', i)
                dfs(num, curr+'-', i)
                dfs(num, curr+'*', i)
            else:
                dfs(num, curr+'+', i)
                dfs(num, curr+'-', i)
                dfs(num, curr+'*', i)
                dfs(num, curr+num[i], i+1)",data\repos\leetcode-python\problems\python\expression-add-operators.py,dfs,139
3432,filling-bookcase-shelves.py::minHeightShelves::9,"    def minHeightShelves(self, books, shelf_width):
        N = len(books)
        dp = [float('inf')]*N
        
        for j in xrange(N):
            w = 0
            h = 0
            for i in xrange(j, -1, -1):
                w+=books[i][0]
                if w>shelf_width: break
                
                h = max(h, books[i][1])
                if i==0:
                    dp[j] = min(dp[j], h)
                else:
                    dp[j] = min(dp[j], dp[i-1]+h)
        return dp[-1]",data\repos\leetcode-python\problems\python\filling-bookcase-shelves.py,minHeightShelves,132
3433,filling-bookcase-shelves.py::minHeightShelves::33,"    def minHeightShelves(self, books, W):
        dp = [float('inf')]*len(books)
        
        dp[0] = books[0][1]
        
        for i in xrange(1, len(books)):
            topLevelWidth = 0
            topLevelMaxHeight = 0
            
            for j in xrange(i, -1, -1):
                topLevelWidth += books[j][0]
                topLevelMaxHeight = max(topLevelMaxHeight, books[j][1])
                if topLevelWidth>W: break
                dp[i] = min(dp[i], (dp[j-1] if j-1>=0 else 0) + topLevelMaxHeight)
                
        return dp[-1]",data\repos\leetcode-python\problems\python\filling-bookcase-shelves.py,minHeightShelves,149
3434,find-all-possible-recipes-from-given-supplies.py::findAllRecipes::11,"    def findAllRecipes(self, recipes, ingredients, supplies):
        N = len(recipes)
        adj = collections.defaultdict(list)
        inbounds = collections.Counter()
        q = collections.deque(supplies)
        recipeSet = set(recipes)
        ans = []
        
        for i, recipe in enumerate(recipes):
            for ingredient in ingredients[i]:
                adj[ingredient].append(recipe)
                inbounds[recipe] += 1
        
        while q:
            node = q.popleft()
            
            if node in recipeSet: ans.append(node)
            
            for nei in adj[node]:
                inbounds[nei] -= 1
                if inbounds[nei]==0: q.append(nei)
        
        return ans",data\repos\leetcode-python\problems\python\find-all-possible-recipes-from-given-supplies.py,findAllRecipes,153
3435,find-and-replace-in-string.py::findReplaceString::5,"    def findReplaceString(self, s, indices, sources, targets):
        p = -1
        ans = ''
        
        memo = {}
        for i, index in enumerate(indices):
            memo[index] = (sources[i], targets[i])
        
        for i in xrange(len(s)):
            if i<=p: continue
            
            if i in memo and (s[i:i+len(memo[i][0])] if i+len(memo[i][0])<len(s) else s[i:])==memo[i][0]:
                ans += memo[i][1]
                p = i+len(memo[i][0])-1
            else:
                ans += s[i]
                p = i
            
        return ans",data\repos\leetcode-python\problems\python\find-and-replace-in-string.py,findReplaceString,146
3436,find-and-replace-in-string.py::findReplaceString::30,"    def findReplaceString(self, s, indices, sources, targets):
        ans = ''
        
        replacement = {}
        for i in xrange(len(indices)):
            index = indices[i]
            source = sources[i]
            target = targets[i]
            
            if s[index:index+len(source)]!=source: continue
            replacement[index] = (source, target)
        
        i = 0
        while i<len(s):
            if i not in replacement:
                ans += s[i]
                i += 1
            else:
                ans += replacement[i][1]
                i += len(replacement[i][0])
        
        return ans",data\repos\leetcode-python\problems\python\find-and-replace-in-string.py,findReplaceString,131
3437,find-distance-in-a-binary-tree.py::findDistance::7,"    def findDistance(self, root, p, q):
        #find the count of p or q in node's subtree, set the first node we found that has count>=2 as lca.
        def findCount(node):
            if not node: return 0
            count = 0
            if node.val==p or node.val==q: count += 1
            count += findPQCount(node.left)
            count += findPQCount(node.right)
            if count>=2 and not self.lca: self.lca = node
            return count
        
        def findHeight(node, h):
            if not node: return
            if node.val==p: self.pHeight = h
            if node.val==q: self.qHeight = h
            if self.pHeight and self.qHeight: return
            findHeight(node.left, h+1)
            findHeight(node.right, h+1)
            
        findCount(root)
        findHeight(self.lca, 0)
        return self.qHeight + self.pHeight",data\repos\leetcode-python\problems\python\find-distance-in-a-binary-tree.py,findDistance,218
3438,find-distance-in-a-binary-tree.py::findCount::9,"        def findCount(node):
            if not node: return 0
            count = 0
            if node.val==p or node.val==q: count += 1
            count += findPQCount(node.left)
            count += findPQCount(node.right)
            if count>=2 and not self.lca: self.lca = node
            return count",data\repos\leetcode-python\problems\python\find-distance-in-a-binary-tree.py,findCount,78
3439,find-distance-in-a-binary-tree.py::findHeight::18,"        def findHeight(node, h):
            if not node: return
            if node.val==p: self.pHeight = h
            if node.val==q: self.qHeight = h
            if self.pHeight and self.qHeight: return
            findHeight(node.left, h+1)
            findHeight(node.right, h+1)",data\repos\leetcode-python\problems\python\find-distance-in-a-binary-tree.py,findHeight,73
3440,find-duplicate-subtrees.py::findDuplicateSubtrees::2,"    def findDuplicateSubtrees(self, root):
        def dfs(node):
            if not node: return '#'
            string = str(node.val) + ',' + dfs(node.left) + ',' + dfs(node.right)
            data[string].append(node)
            return string
        
        data = collections.defaultdict(list)
        ans = []
        
        dfs(root)
        
        for s in data:
            if len(data[s])>=2: ans.append(data[s][0])
        return ans",data\repos\leetcode-python\problems\python\find-duplicate-subtrees.py,findDuplicateSubtrees,98
3441,find-duplicate-subtrees.py::dfs::3,"        def dfs(node):
            if not node: return '#'
            string = str(node.val) + ',' + dfs(node.left) + ',' + dfs(node.right)
            data[string].append(node)
            return string",data\repos\leetcode-python\problems\python\find-duplicate-subtrees.py,dfs,44
3442,find-eventual-safe-states.py::eventualSafeNodes::4,"    def eventualSafeNodes(self, graph):
        inbounds = defaultdict(list)
        outbondsCounter = defaultdict(int)
        q = deque()
        ans = []
        
        for n, nei_list in enumerate(graph):
            outbondsCounter[n] = len(nei_list)
            for nei in nei_list:
                inbounds[nei].append(n)
        
        for n in outbondsCounter:
            if outbondsCounter[n]==0:
                q.append(n)
        
        while q:
            n = q.popleft()

            for nei in inbounds[n]:
                outbondsCounter[nei] -= 1
                if outbondsCounter[nei]==0:
                    q.append(nei)
            
            ans.append(n)
        
        return ans.sort()",data\repos\leetcode-python\problems\python\find-eventual-safe-states.py,eventualSafeNodes,163
3443,find-first-and-last-position-of-element-in-sorted-array.py::searchRange::16,"    def searchRange(self, nums, target):
        if nums is None or len(nums)==0:
            return [-1, -1]

        l = 0
        r = len(nums)
        p = (l+r)/2

        while nums[p]!=target:
            if nums[p]>target: r = p
            else: l = p

            p_next = (l+r)/2
            if p==p_next: return [-1, -1]
            p = p_next

        l = r = p
        while r+1<len(nums) and nums[r+1]==target:
            r = r+1
        while 0<=l-1 and nums[l-1]==target:
            l = l-1
        return [l, r]",data\repos\leetcode-python\problems\python\find-first-and-last-position-of-element-in-sorted-array.py,searchRange,165
3444,find-first-and-last-position-of-element-in-sorted-array.py::searchRange::42,"    def searchRange(self, nums, target):
        if nums is None or len(nums)==0: return [-1, -1]
        if target<nums[0] or nums[-1]<target: return [-1, -1] #check if target out of range
        l = bisect.bisect_left(nums, target)
        r = bisect.bisect_right(nums, target)

        if nums[l]!=target or nums[r-1]!=target: return [-1, -1] #check if target in `nums`
        return [l, r-1]",data\repos\leetcode-python\problems\python\find-first-and-last-position-of-element-in-sorted-array.py,searchRange,122
3445,find-first-and-last-position-of-element-in-sorted-array.py::searchRange::54,"    def searchRange(self, nums, target):
        def find_range(i, nums):
            start = end = i
            while 0<=start-1 and nums[start-1]==nums[i]:
                start -= 1
            while end+1<len(nums) and nums[end+1]==nums[i]:
                end += 1
            return [start, end]
            
        
        if not nums: return [-1, -1]
        l = 0
        r = len(nums)-1

        while True:
            if l>r: break
            if target<nums[l]: return [-1, -1]
            if target>nums[r]: return [-1, -1]

            if target==nums[l]: return find_range(l, nums)
            if target==nums[r]: return find_range(r, nums)

            m = (l+r)/2
            if target==nums[m]:
                return find_range(m, nums)
            elif target<nums[m]:
                r = m-1
            else:
                l = m+1
        
        return [-1, -1]",data\repos\leetcode-python\problems\python\find-first-and-last-position-of-element-in-sorted-array.py,searchRange,229
3446,find-first-and-last-position-of-element-in-sorted-array.py::searchRange::97,"    def searchRange(self, A, T):
        def rangeOf(i):
            l = r = i
            while 0<l and A[l]==A[l-1]: l -= 1
            while r<N-1 and A[r]==A[r+1]: r += 1
            return [l, r]

        N = len(A)
        l = 0
        r = N-1
        
        while l<=r:
            m = (l+r)/2
            
            if A[l]==T: return rangeOf(l)
            if A[m]==T: return rangeOf(m)
            if A[r]==T: return rangeOf(r)
            
            if T<A[l] or A[r]<T: return [-1, -1] #out of range
            
            if T<A[m]:
                r = m-1
            else:
                l = m+1
                
        return [-1, -1]",data\repos\leetcode-python\problems\python\find-first-and-last-position-of-element-in-sorted-array.py,searchRange,195
3447,find-first-and-last-position-of-element-in-sorted-array.py::find_range::55,"        def find_range(i, nums):
            start = end = i
            while 0<=start-1 and nums[start-1]==nums[i]:
                start -= 1
            while end+1<len(nums) and nums[end+1]==nums[i]:
                end += 1
            return [start, end]",data\repos\leetcode-python\problems\python\find-first-and-last-position-of-element-in-sorted-array.py,find_range,68
3448,find-first-and-last-position-of-element-in-sorted-array.py::rangeOf::98,"        def rangeOf(i):
            l = r = i
            while 0<l and A[l]==A[l-1]: l -= 1
            while r<N-1 and A[r]==A[r+1]: r += 1
            return [l, r]",data\repos\leetcode-python\problems\python\find-first-and-last-position-of-element-in-sorted-array.py,rangeOf,59
3449,find-k-closest-elements.py::findClosestElements::2,"    def findClosestElements(self, arr, K, X):
        def isCloserThan(n1, n2, x):
            return abs(x-n1)<abs(x-n2) or (abs(x-n1)==abs(x-n2) and n1<n2)
                
        output1 = []
        output2 = []
        
        r = bisect.bisect_left(arr, X)
        l = r-1
        
        while len(output1)+len(output2)<K:
            if r>=len(arr) or (l>=0 and isCloserThan(arr[l], arr[r], X)):
                output1.append(arr[l])
                l -= 1
            else:
                output2.append(arr[r])
                r += 1
        
        return output1[::-1]+output2",data\repos\leetcode-python\problems\python\find-k-closest-elements.py,findClosestElements,165
3450,find-k-closest-elements.py::isCloserThan::3,"        def isCloserThan(n1, n2, x):
            return abs(x-n1)<abs(x-n2) or (abs(x-n1)==abs(x-n2) and n1<n2)",data\repos\leetcode-python\problems\python\find-k-closest-elements.py,isCloserThan,44
3451,find-k-pairs-with-smallest-sums.py::kSmallestPairs::18,"    def kSmallestPairs(self, nums1, nums2, k):
        if not nums1 or not nums2: return []
        if k>len(nums1)*len(nums2): k = len(nums1)*len(nums2)
            
        ans = []
        h = [(nums1[0]+nums2[0], 0, 0)] #[0]
        seen = set([(0,0)]) #[2]
        
        while len(ans)<k: #[1]
            s, i, j = heapq.heappop(h)
            ans.append((nums1[i], nums2[j]))

            if i+1<len(nums1) and (i+1, j) not in seen:
                heapq.heappush(h, (nums1[i+1]+nums2[j], i+1, j))
                seen.add((i+1, j))

            if j+1<len(nums2) and (i, j+1) not in seen:
                heapq.heappush(h, (nums1[i]+nums2[j+1], i, j+1))
                seen.add((i, j+1))
                
        return ans",data\repos\leetcode-python\problems\python\find-k-pairs-with-smallest-sums.py,kSmallestPairs,240
3452,find-leaves-of-binary-tree.py::findLeaves::19,"    def findLeaves(self, root):
        ans = []
        q = collections.deque([root])
        parents = {}
        
        #[1]
        temp = []
        while q:
            node = q.popleft()
            
            if not node.left and not node.right:
                temp.append(node)
            
            if node.left:
                q.append(node.left)
                parents[node.left] = node
            
            if node.right:
                q.append(node.right)
                parents[node.right] = node

        #[2] 
        while temp:
            ans.append(temp)
            temp = []
            
            for node in ans[-1]:
                if node not in parents: break
                p = parents[node]
                if p.left==node: p.left = None
                if p.right==node: p.right = None
                if not p.left and not p.right: temp.append(p)
        
        #[3]
        ans2 = []
        for temp in ans:
            ans2.append([node.val for node in temp])
        
        return ans2",data\repos\leetcode-python\problems\python\find-leaves-of-binary-tree.py,findLeaves,214
3453,find-median-from-data-stream.py::findMedian::13,"    def findMedian(self):
        i = len(self.a)/2
        return (self.a[i-1]+self.a[i])/2.0 if len(self.a)%2==0 else self.a[i]",data\repos\leetcode-python\problems\python\find-median-from-data-stream.py,findMedian,44
3454,find-median-from-data-stream.py::addNum::28,"    def addNum(self, num):
        if not self.smaller or num<-self.smaller[0]:
            heapq.heappush(self.smaller, -num)
        else:
            heapq.heappush(self.larger, num)
        
        if len(self.smaller)-len(self.larger)>1:
            heapq.heappush(self.larger, -heapq.heappop(self.smaller))
        elif len(self.larger)-len(self.smaller)>=1:
            heapq.heappush(self.smaller, -heapq.heappop(self.larger))",data\repos\leetcode-python\problems\python\find-median-from-data-stream.py,addNum,116
3455,find-median-from-data-stream.py::findMedian::39,"    def findMedian(self):
        return -self.smaller[0] if (len(self.smaller)-len(self.larger))%2!=0 else (-self.smaller[0]+self.larger[0])/2.0",data\repos\leetcode-python\problems\python\find-median-from-data-stream.py,findMedian,48
3456,find-minimum-in-rotated-sorted-array-ii.py::findMin::9,"    def findMin(self, nums):
        if nums is None or len(nums)==0:
            return None
        m = nums[0]
        l = 0
        r = len(nums)-1

        while l<=r:
            p = (l+r)/2
            m = min(m, nums[l], nums[p], nums[r])

            if nums[l]<nums[r]:
                break
            elif nums[l]<nums[p]:
                l = p+1
            elif nums[p]<nums[r]:
                r = p-1
            else:
                l = l+1
                r = r-1
        return m",data\repos\leetcode-python\problems\python\find-minimum-in-rotated-sorted-array-ii.py,findMin,135
3457,find-minimum-in-rotated-sorted-array-ii.py::findMin::41,"    def findMin(self, A):
        N = len(A)
        l = 0
        r = N-1
        
        while l<r:
            #skip the same
            while l<N-1 and A[l]==A[l+1]: l += 1
            while 0<r and A[r]==A[r-1]: r -= 1
            while l<N-1 and A[l]==A[r]: l += 1
            while 0<r and A[l]==A[r]: r -= 1
                
            m = (l+r)/2
            
            if A[l]<=A[m] and A[m]<=A[r]:
                #l~r is in-order, A[l] is the smallest.
                return A[l]
            elif A[l]<=A[m]:
                #l~m is in-order, m~r is rotated. smallet must be in m~r
                l = m+1
            else:
                #m~r is in-order, l~m is rotated. smallet must be in l~m
                r = m
        return A[l]",data\repos\leetcode-python\problems\python\find-minimum-in-rotated-sorted-array-ii.py,findMin,233
3458,find-minimum-in-rotated-sorted-array.py::findMin::9,"    def findMin(self, nums):
        if nums is None or len(nums)==0: return None
        m = nums[0]
        l = 0
        r = len(nums)-1

        while l<=r:
            p = (l+r)/2
            m = min(m, nums[l], nums[p], nums[r])

            if nums[l]<nums[r]:
                #the l~r is sorted now
                #the smallest is at `l`, and we compared it already.
                break
            else:
                if nums[l]<nums[p]:
                    #l~p is sorted
                    #the smallest is at `l`, and we compared it already.
                    #use the same method on (p+1)~r
                    l = p+1
                elif nums[p]<nums[r]:
                    #p~r is sorted
                    #the smallest is at `l`, and we compared it already.
                    #use the same method on l~(p-1)
                    r = p-1
                else:
                    break
        return m",data\repos\leetcode-python\problems\python\find-minimum-in-rotated-sorted-array.py,findMin,226
3459,find-minimum-in-rotated-sorted-array.py::findMin::60,"    def findMin(self, nums):
        if not nums: return 0
        l = 0 #[0]
        r = len(nums)-1 #[0]

        while l<=r:
            if nums[l]<=nums[r]: return nums[l] #[1]
            
            m = (l+r)/2
            if m-1>=0 and nums[m-1]>nums[m]: return nums[m] #[3]
            
            if nums[l]<=nums[m]:
                l = m+1 #[2]
            else:
                r = m-1 #[2]
        return 0",data\repos\leetcode-python\problems\python\find-minimum-in-rotated-sorted-array.py,findMin,123
3460,find-minimum-in-rotated-sorted-array.py::findMin::93,"    def findMin(self, nums):
        N = len(nums)
        
        l = 0
        r = N-1
        
        while l<=r:
            m = (l+r)/2
            
            if nums[l]<=nums[m] and nums[m]<=nums[r]: return nums[l] #[0]
            
            if nums[l]>nums[m]:
                #l~m is unsorted
                r = m
            else:
                #m~r is unsorted
                #in this case, we already sure that current m is not the MIN, so we can +1 to speed up and avoid infinitive loop
                l = m+1",data\repos\leetcode-python\problems\python\find-minimum-in-rotated-sorted-array.py,findMin,137
3461,find-peak-element.py::findPeakElement::12,"    def findPeakElement(self, nums):
        l = 0
        r = len(nums)-1
        while l<r:
            p = (l+r)/2
            if nums[p]<nums[p+1]:
                l = p+1
            else:
                r = p
        return l",data\repos\leetcode-python\problems\python\find-peak-element.py,findPeakElement,65
3462,find-peak-element.py::findPeakElement::26,"    def findPeakElement(self, nums):
        if nums is None or len(nums)==0: return None
        for i in xrange(len(nums)):
            l = nums[i-1] if (i-1)>=0 else float('-inf')
            r = nums[i+1] if (i+1)<len(nums) else float('-inf')
            if nums[i]>l and nums[i]>r: return i
        return None",data\repos\leetcode-python\problems\python\find-peak-element.py,findPeakElement,91
3463,find-peak-element.py::findPeakElement::37,"    def findPeakElement(self, nums):
        l = 0
        r = len(nums)-1
        
        while l<=r:
            if l==r: return l
            if nums[l]>nums[l+1]: return l #check l is peak
            if nums[r-1]<nums[r]: return r #check r is peak
            
            m = (l+r)/2
            
            if nums[m]<nums[m+1]:
                #m is in the falling slope
                l = m
            elif nums[m]>nums[m+1]:
                #m is in the rising slope
                r = m
        return l",data\repos\leetcode-python\problems\python\find-peak-element.py,findPeakElement,134
3464,find-peak-element.py::findPeakElement::66,"    def findPeakElement(self, nums):
        l = 0
        r = len(nums)-1
        
        while l<r:
            m = l+(r-l+1)/2
            if nums[m-1]<nums[m]:
                l = m
            else:
                r = m-1
        return l",data\repos\leetcode-python\problems\python\find-peak-element.py,findPeakElement,68
3465,find-the-duplicate-number.py::findDuplicate::8,"    def findDuplicate(self, nums):

        #find the intersect node, where slow and fast pointer meets.
        slow = fast = 0
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow==fast: break
        
        #find the intersect node, where slow and slow2 pointer meets. slow2 is starting from the begin.
        slow2 = 0
        while True:
            slow = nums[slow]
            slow2 = nums[slow2]
            if slow==slow2: return slow
        
        return 0",data\repos\leetcode-python\problems\python\find-the-duplicate-number.py,findDuplicate,122
3466,first-bad-version.py::firstBadVersion::15,"    def firstBadVersion(self, n):
        if isBadVersion(1): return 1
        
        l = 2
        h = n
        
        while l<h:
            v = (l+h)/2
            r1 = isBadVersion(v)
            r2 = isBadVersion(v-1)
            
            if r1 and not r2:
                return v
            elif not r1 and not r2:
                l = v+1
            elif r1 and r2:
                h = v-1
                
        return (l+h)/2",data\repos\leetcode-python\problems\python\first-bad-version.py,firstBadVersion,119
3467,first-missing-positive.py::firstMissingPositive::2,"    def firstMissingPositive(self, nums):
        N = len(nums)
        
        if 1 not in nums: return 1
        
        for i, num in enumerate(nums):
            if num<=0 or num>N:
                nums[i] = 1
        
        for i in xrange(N):
            a = abs(nums[i])
            
            if a==N:
                nums[0] = -abs(nums[0])
            else:
                nums[a] = -abs(nums[a])
        
        for i in xrange(1, N):
            if nums[i]>0: return i
        if nums[0]>0: return N
        
        return N+1",data\repos\leetcode-python\problems\python\first-missing-positive.py,firstMissingPositive,137
3468,first-missing-positive.py::firstMissingPositive::43,"    def firstMissingPositive(self, nums):
        N = len(nums)
        
        #[1]
        for i in xrange(N):
            while 1<=nums[i]<=N and nums[i]!=i+1:
                j = nums[i]-1
                if nums[i]==nums[j]: break #otherwise they are going to keep swapping infinitely, because one of them is not inplace.
                nums[i], nums[j] = nums[j], nums[i]
        
        #[2]
        for i in xrange(N):
            if nums[i]!=i+1: return i+1
        
        #[3]
        return N+1",data\repos\leetcode-python\problems\python\first-missing-positive.py,firstMissingPositive,128
3469,first-unique-character-in-a-string.py::firstUniqChar::4,"    def firstUniqChar(self, string):
        # counter = Counter()
        # for char in string:
        #     counter[char]+=1
        counter = Counter(string)

        for i in xrange(len(string)):
            char = string[i]
            if counter[char]==1: return i

        return -1",data\repos\leetcode-python\problems\python\first-unique-character-in-a-string.py,firstUniqChar,65
3470,fizz-buzz.py::fizzBuzz::3,"    def fizzBuzz(self, n):
        nums = []
        for num in range(1, n+1):
            
            if num%3==0 and num%5==0:
                nums.append('FizzBuzz')
            elif num%3==0:
                nums.append('Fizz')
            elif num%5==0:
                nums.append('Buzz')
            else:
                nums.append(str(num))

        return nums",data\repos\leetcode-python\problems\python\fizz-buzz.py,fizzBuzz,86
3471,flatten-binary-tree-to-linked-list.py::flatten::8,"    def flatten(self, root):
        if not root: return None
        
        preHead = TreeNode(0)
        curr = preHead
        stack = [root]
        
        while stack:
            node = stack.pop()
            
            if node.right: stack.append(node.right)
            if node.left: stack.append(node.left)
            
            node.right = None
            node.left = None
            curr.right = node
            curr = curr.right
            
        return preHead.right",data\repos\leetcode-python\problems\python\flatten-binary-tree-to-linked-list.py,flatten,97
3472,flatten-binary-tree-to-linked-list.py::flatten::35,"    def flatten(self, root):
        node = root
        
        while node:
            if node.left:
                rightmost = node.left
                while rightmost.right: rightmost = rightmost.right
                rightmost.right = node.right
                node.right = node.left
                node.left = None
            else:
                node = node.right
        return root",data\repos\leetcode-python\problems\python\flatten-binary-tree-to-linked-list.py,flatten,74
3473,flip-binary-tree-to-match-preorder-traversal.py::flipMatchVoyage::2,"    def flipMatchVoyage(self, root, voyage):
        def helper(node):
            if not node: return
            if node.val!=voyage[self.i]:
                self.valid = False
                return
            
            self.i += 1
            if node.left and node.left.val!=voyage[self.i]:
                self.ans.append(node.val)
                helper(node.right)
                helper(node.left)
                
            else:
                helper(node.left)
                helper(node.right)
        
        self.ans = []
        self.i = 0
        self.valid = True
        helper(root)
        return self.ans if self.valid else [-1]",data\repos\leetcode-python\problems\python\flip-binary-tree-to-match-preorder-traversal.py,flipMatchVoyage,133
3474,flip-binary-tree-to-match-preorder-traversal.py::helper::3,"        def helper(node):
            if not node: return
            if node.val!=voyage[self.i]:
                self.valid = False
                return
            
            self.i += 1
            if node.left and node.left.val!=voyage[self.i]:
                self.ans.append(node.val)
                helper(node.right)
                helper(node.left)
                
            else:
                helper(node.left)
                helper(node.right)",data\repos\leetcode-python\problems\python\flip-binary-tree-to-match-preorder-traversal.py,helper,84
3475,flip-string-to-monotone-increasing.py::minFlipsMonoIncr::9,"    def minFlipsMonoIncr(self, s):
        dp = [[0, 0] for _ in xrange(len(s)+1)]
        
        for i, c in enumerate(s):
            if c=='0':
                dp[i+1][0] = dp[i][0]
                dp[i+1][1] = min(dp[i][0], dp[i][1]) + 1
            elif c=='1':
                dp[i+1][0] = dp[i][0] + 1
                dp[i+1][1] = min(dp[i][0], dp[i][1])
                
        return min(dp[-1])",data\repos\leetcode-python\problems\python\flip-string-to-monotone-increasing.py,minFlipsMonoIncr,136
3476,flood-fill.py::floodFill::2,"    def floodFill(self, image, sr, sc, newColor):
        stack = [(sr, sc)]
        originColor = image[sr][sc]
        
        while stack:
            i, j = stack.pop()
            
            if image[i][j]==newColor or image[i][j]!=originColor: continue

            image[i][j] = newColor
            if i+1<len(image): stack.append((i+1, j))
            if 0<=i-1: stack.append((i-1, j))
            if j+1<len(image[0]): stack.append((i, j+1))
            if 0<=j-1: stack.append((i, j-1))

        return image",data\repos\leetcode-python\problems\python\flood-fill.py,floodFill,152
3477,friend-circles.py::findCircleNum::11,"    def findCircleNum(self, M):
        def dfs(i):
            stack = [i]
            while stack and len(stack)>0:
                node = stack.pop()
                visited.add(node) #[2]
                for j in xrange(len(M)):
                    if M[node][j]==1 and j not in visited:
                        stack.append(j)

        circles = 0
        visited = set()
        for i in xrange(len(M)): #[1]
            if i in visited: continue #[3]
            dfs(i)
            circles+=1 #[4]

        return circles",data\repos\leetcode-python\problems\python\friend-circles.py,findCircleNum,116
3478,friend-circles.py::findCircleNum::51,"    def findCircleNum(self, M):
        def find(x):
            if x != roots[x]:
                roots[x] = find(roots[x])
            return roots[x]

        def union(p1, p2): #[2]
            p1_root = find(p1)
            p2_root = find(p2)
            roots[p1_root] = p2_root

        roots = [i for i in xrange(len(M))] #[1]

        for p1 in xrange(len(M)):
            for p2 in xrange(len(M)):
                if M[p1][p2] == 1:
                    union(p1, p2) #[3]
        
        roots = [find(i) for i in roots] #[5]
        return len(set(roots)) #[4]",data\repos\leetcode-python\problems\python\friend-circles.py,findCircleNum,160
3479,friend-circles.py::findCircleNum::81,"    def findCircleNum(self, M):
        if not M or not M[0]: return 0
        count = 0
        visited = set()
        
        for student in xrange(len(M)):
            if student in visited: continue
            
            count += 1

            #dfs
            stack = [student]
            while stack:
                curr_student = stack.pop()
                if curr_student in visited: continue
                visited.add(curr_student)
                stack.extend([class_mate for class_mate, is_friend in enumerate(M[curr_student]) if is_friend])
                
        return count",data\repos\leetcode-python\problems\python\friend-circles.py,findCircleNum,121
3480,friend-circles.py::dfs::12,"        def dfs(i):
            stack = [i]
            while stack and len(stack)>0:
                node = stack.pop()
                visited.add(node) #[2]
                for j in xrange(len(M)):
                    if M[node][j]==1 and j not in visited:
                        stack.append(j)",data\repos\leetcode-python\problems\python\friend-circles.py,dfs,61
3481,friend-circles.py::union::57,"        def union(p1, p2): #[2]
            p1_root = find(p1)
            p2_root = find(p2)
            roots[p1_root] = p2_root",data\repos\leetcode-python\problems\python\friend-circles.py,union,40
3482,fruit-into-baskets.py::totalFruit::6,"    def totalFruit(self, tree):
        counter = 0 #max fruit count
        start = 0 #the point where from start to i has only two types of fruit
        mark = {} #we keep track of each type of fruit's index last seen
        type_basket = [] #types of fruit in the basket now

        for i in range(len(tree)):
            t = tree[i]
            if t not in type_basket:
                if len(type_basket)<2:
                    """"""
                    if this type of fruit not in type_basket
                    and the type_basket is not full yet
                    add the type to the type_basket
                    """"""
                    type_basket.append(t)

                elif len(type_basket)==2:
                    """"""
                    if this type of fruit not in type_basket
                    and the type_basket has two types already
                    we get rid of the type with smaller last seen index
                    by moving the start to its index+1
                    so now between start and i has only two types of fruit
                    """"""
                    t1 = type_basket[0]
                    t2 = type_basket[1]
                    if mark[t1]<mark[t2]:
                        start = mark[t1]+1
                        type_basket[0] = t
                    else:
                        start = mark[t2]+1
                        type_basket[1] = t
                else:
                    #basket should not have more than two types
                    print('ERROR')
                    return 0
            
            counter = max(counter, i-start+1)
            mark[t] = i
        return counter",data\repos\leetcode-python\problems\python\fruit-into-baskets.py,totalFruit,338
3483,fruit-into-baskets.py::totalFruit::53,"    def totalFruit(self, fruits):
        ans = 0
        uniqueFruits = 0
        i = 0
        counter = collections.Counter()
        
        for j, fruit in enumerate(fruits):
            counter[fruit] += 1
            if counter[fruit]==1: uniqueFruits += 1
            
            while uniqueFruits>2:
                counter[fruits[i]] -= 1
                if counter[fruits[i]]==0: uniqueFruits -= 1
                i += 1
            
            ans = max(ans, j-i+1)
        return ans",data\repos\leetcode-python\problems\python\fruit-into-baskets.py,totalFruit,127
3484,game-of-life.py::gameOfLife::29,"    def gameOfLife(self, board):
        if board==None or len(board)==0 or len(board[0])==0: return board

        m = len(board)
        n = len(board[0])
        
        def count_alive(i, j):
            if i<0 or j<0 or i>=m or j>=n: return 0
            count = 0

            #bottom, top, right, left
            if i+1<m: count+=board[i+1][j]%2 #[0]
            if 0<=i-1: count+=board[i-1][j]%2
            if j+1<n: count+=board[i][j+1]%2
            if 0<=j-1: count+=board[i][j-1]%2

            #bottomright, topleft, bottomleft, topright
            if i+1<m and j+1<n: count+=board[i+1][j+1]%2
            if 0<=i-1 and 0<=j-1: count+=board[i-1][j-1]%2
            if i+1<m and 0<=j-1: count+=board[i+1][j-1]%2
            if 0<=i-1 and j+1<n: count+=board[i-1][j+1]%2

            return count

        for i in xrange(m): #[1]
            for j in xrange(n):
                count = count_alive(i, j) #[2]

                if board[i][j]==1:
                    if count<2 or count>3:
                        board[i][j] = 3
                elif board[i][j]==0:
                    if count==3:
                        board[i][j] = 2

        for i in xrange(m): #[3]
            for j in xrange(n):
                if board[i][j]==2:
                    board[i][j] = 1
                elif board[i][j]==3:
                    board[i][j] = 0

        return board",data\repos\leetcode-python\problems\python\game-of-life.py,gameOfLife,438
3485,game-of-life.py::count_alive::35,"        def count_alive(i, j):
            if i<0 or j<0 or i>=m or j>=n: return 0
            count = 0

            #bottom, top, right, left
            if i+1<m: count+=board[i+1][j]%2 #[0]
            if 0<=i-1: count+=board[i-1][j]%2
            if j+1<n: count+=board[i][j+1]%2
            if 0<=j-1: count+=board[i][j-1]%2

            #bottomright, topleft, bottomleft, topright
            if i+1<m and j+1<n: count+=board[i+1][j+1]%2
            if 0<=i-1 and 0<=j-1: count+=board[i-1][j-1]%2
            if i+1<m and 0<=j-1: count+=board[i+1][j-1]%2
            if 0<=i-1 and j+1<n: count+=board[i-1][j+1]%2

            return count",data\repos\leetcode-python\problems\python\game-of-life.py,count_alive,251
3486,generate-parentheses.py::generateParenthesis::10,"    def generateParenthesis(self, N):
        def dfs(path, open_count, open_remain, close_remain):
            if open_remain==0 and close_remain==0:
                opt.append(path)
                return
            if open_count>0 and close_remain>0:
                dfs(path+')', open_count-1, open_remain, close_remain-1)
            if open_remain>0:
                dfs(path+'(', open_count+1, open_remain-1, close_remain)

        opt = []
        dfs('', 0, N, N)
        return opt",data\repos\leetcode-python\problems\python\generate-parentheses.py,generateParenthesis,115
3487,generate-parentheses.py::generateParenthesis::26,"    def generateParenthesis(self, N):
        def helper(open_remain, close_remain, s):
            if open_remain==0 and close_remain==0:
                ans.append(s)
            if close_remain>open_remain and close_remain>0:
                helper(open_remain, close_remain-1, s+')')
            if open_remain>0:
                helper(open_remain-1, close_remain, s+'(')
        ans = []
        helper(N, N, '')
        return ans",data\repos\leetcode-python\problems\python\generate-parentheses.py,generateParenthesis,98
3488,generate-parentheses.py::generateParenthesis::43,"    def generateParenthesis(self, n):
        def helper(curr, openCount, left, right):
            if left==0 and right==0: ans.append(curr)
            if left>0:
                helper(curr+'(', openCount+1, left-1, right)
            if right>0 and openCount>0:
                helper(curr+')', openCount-1, left, right-1)
        
        ans = []
        helper('', 0, n, n)
        return ans",data\repos\leetcode-python\problems\python\generate-parentheses.py,generateParenthesis,102
3489,generate-parentheses.py::dfs::11,"        def dfs(path, open_count, open_remain, close_remain):
            if open_remain==0 and close_remain==0:
                opt.append(path)
                return
            if open_count>0 and close_remain>0:
                dfs(path+')', open_count-1, open_remain, close_remain-1)
            if open_remain>0:
                dfs(path+'(', open_count+1, open_remain-1, close_remain)",data\repos\leetcode-python\problems\python\generate-parentheses.py,dfs,89
3490,generate-parentheses.py::helper::27,"        def helper(open_remain, close_remain, s):
            if open_remain==0 and close_remain==0:
                ans.append(s)
            if close_remain>open_remain and close_remain>0:
                helper(open_remain, close_remain-1, s+')')
            if open_remain>0:
                helper(open_remain-1, close_remain, s+'(')",data\repos\leetcode-python\problems\python\generate-parentheses.py,helper,75
3491,generate-parentheses.py::helper::44,"        def helper(curr, openCount, left, right):
            if left==0 and right==0: ans.append(curr)
            if left>0:
                helper(curr+'(', openCount+1, left-1, right)
            if right>0 and openCount>0:
                helper(curr+')', openCount-1, left, right-1)",data\repos\leetcode-python\problems\python\generate-parentheses.py,helper,75
3492,group-anagrams.py::groupAnagrams::3,"    def groupAnagrams(self, strs):
        anagrams = collections.defaultdict(list)
        for s in strs:
            anagrams[''.join(sorted(s))].append(s)
        return anagrams.values()",data\repos\leetcode-python\problems\python\group-anagrams.py,groupAnagrams,43
3493,group-anagrams.py::groupAnagrams::10,"    def groupAnagrams(self, strs):
        anagrams = collections.defaultdict(list)
        for s in strs:
            hashkey = [0]*26
            for c in s: hashkey[ord(c)-97] +=1
            anagrams[''.join(hashkey)].append(s)
        return anagrams.values()",data\repos\leetcode-python\problems\python\group-anagrams.py,groupAnagrams,68
3494,group-anagrams.py::groupAnagrams::23,"    def groupAnagrams(self, strs):
        anagrams = collections.defaultdict(list)
        
        for s in strs:
            anagrams[self.getKey(s)].append(s)
        
        return anagrams.values()",data\repos\leetcode-python\problems\python\group-anagrams.py,groupAnagrams,42
3495,group-anagrams.py::getKey::31,"    def getKey(self, s):
        key = ''
        counts = collections.Counter(s)
        for c in 'abcdefghijklmnopqrstuvwxyz':
            key += counts[c]*c
        return key",data\repos\leetcode-python\problems\python\group-anagrams.py,getKey,36
3496,group-shifted-strings.py::groupStrings::2,"    def groupStrings(self, strings):
        def getHash(string):
            h = ''
            offset = getNumByChar(string[0])*-1
            for c in string:
                h += getCharByNum((getNumByChar(c)+offset) if (getNumByChar(c)+offset)>=0 else 26+(getNumByChar(c)+offset))
            return h
        
        def getNumByChar(letter):
            return ord(letter) - 97

        def getCharByNum(pos):
            return chr(pos + 97)
        
        groups = collections.defaultdict(list)
        for string in strings:
            h = getHash(string)
            groups[h].append(string)
        return groups.values()",data\repos\leetcode-python\problems\python\group-shifted-strings.py,groupStrings,145
3497,group-shifted-strings.py::getHash::3,"        def getHash(string):
            h = ''
            offset = getNumByChar(string[0])*-1
            for c in string:
                h += getCharByNum((getNumByChar(c)+offset) if (getNumByChar(c)+offset)>=0 else 26+(getNumByChar(c)+offset))
            return h",data\repos\leetcode-python\problems\python\group-shifted-strings.py,getHash,69
3498,guess-number-higher-or-lower-ii.py::getMoneyAmount::6,"    def getMoneyAmount(self, N):
        dp = [[float('inf') for _ in xrange(N)] for _ in xrange(N)]
        for i in xrange(N): dp[i][i] = 0
        
        
        for l in xrange(2, N+1):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                for k in xrange(i, j+1):
                    dp[i][j] = min(dp[i][j], max(dp[i][k-1] if k-1>=0 else 0, dp[k+1][j] if k+1<N else 0) + (k+1))
        
        return dp[0][N-1]",data\repos\leetcode-python\problems\python\guess-number-higher-or-lower-ii.py,getMoneyAmount,155
3499,guess-number-higher-or-lower.py::guessNumber::15,"    def guessNumber(self, n):
        l = 1
        h = n
        
        while l<h:
            m = (l+h)/2    
            
            r = guess(m)
            
            if r==0:
                return m
            elif r==1:
                l = m+1
            elif r==-1:
                h = m-1
                
        return (l+h)/2",data\repos\leetcode-python\problems\python\guess-number-higher-or-lower.py,guessNumber,84
3500,guess-the-word.py::findSecretWord::13,"    def findSecretWord(self, wordlist, master):
        def similarity(w1, w2):
            count = 0
            for i in xrange(6):
                if w1[i]==w2[i]: count += 1
            return count
        
        for _ in xrange(10):
            
            temp = []
            
            word = random.choice(wordlist)
            k = master.guess(word)
            if k==6: return
            
            for otherWord in wordlist:
                if otherWord==word: continue
                if similarity(word, otherWord)==k: temp.append(otherWord)
            
            wordlist = temp",data\repos\leetcode-python\problems\python\guess-the-word.py,findSecretWord,130
3501,guess-the-word.py::similarity::14,"        def similarity(w1, w2):
            count = 0
            for i in xrange(6):
                if w1[i]==w2[i]: count += 1
            return count",data\repos\leetcode-python\problems\python\guess-the-word.py,similarity,41
3502,h-index-ii.py::hIndex::16,"    def hIndex(self, citations):
        N = len(citations)
        
        l = 0
        r = N-1
        
        while l<r:
            i = (l+r)/2
            h = N-i

            if citations[i]>=h:
                #h may be the h-index, check larger h.
                r = i
            else:
                #h is not h-index, check smaller h.
                l = i+1
        
        #now, l is equal to r

        return N-l if citations[l]!=0 else 0  #take care of edge case [0], [0, 0] or [0, 0, 0]",data\repos\leetcode-python\problems\python\h-index-ii.py,hIndex,144
3503,h-index.py::hIndex::14,"    def hIndex(self, citations):
        citations.sort(reverse=True)
        
        ans = 0
        for i in xrange(len(citations)):
            if i+1>citations[i]: break
            ans = i+1
                
        return ans",data\repos\leetcode-python\problems\python\h-index.py,hIndex,51
3504,h-index.py::hIndex::40,"    def hIndex(self, citations):
        counter = collections.Counter() #count for each citation
        N = len(citations)
        count = 0
        
        for citation in citations:
            counter[min(N, citation)] += 1 #[0]
            
        for n in xrange(N, -1, -1):
            count += counter[n] #count of citation that is larger or equal to n
            if count>=n: return n
        
        return 0",data\repos\leetcode-python\problems\python\h-index.py,hIndex,97
3505,hamming-distance.py::hammingDistance::26,"    def hammingDistance(self, x, y):
        xor = x^y
        count = 0
        while xor:
            count += 1
            xor = xor&(xor-1)
        return count",data\repos\leetcode-python\problems\python\hamming-distance.py,hammingDistance,46
3506,house-robber-ii.py::rob::8,"    def rob(self, nums):
        if (len(nums)==0): return 0

        #first robbed
        K = [0]*len(nums)
        for i in xrange(len(nums)):
        	if i==0:
        		K[i] = nums[0]
        	elif i==1:
        		K[i] = nums[0]
        	elif i==len(nums)-1:
        		K[i] = K[i-1]
        	else:
        		prev_selected = K[i-1]!=K[i-2] 
        		if prev_selected:
        			K[i] = max(K[i-2]+nums[i], K[i-1])
        		else:
        			K[i] = K[i-1]+nums[i]
        v1 = K[-1]

        #first not robbed
        K = [0]*len(nums)
        for i in xrange(len(nums)):
        	if i==0:
        		K[i] = 0
        	elif i==1:
        		K[i] = nums[1]
        	else:
        		prev_selected = K[i-1]!=K[i-2] 
        		if prev_selected:
        			K[i] = max(K[i-2]+nums[i], K[i-1])
        		else:
        			K[i] = K[i-1]+nums[i]
        v2 = K[-1]
        return max(v1, v2)",data\repos\leetcode-python\problems\python\house-robber-ii.py,rob,283
3507,house-robber-ii.py::rob::46,"    def rob(self, nums):
        if not nums: return 0
        if len(nums)==0 or len(nums)==1: return max(nums)
        N = len(nums)
        
        v1 = nums[0]
        v2 = nums[0]
        for i in xrange(2, N-1):
            v1, v2 = max(nums[i]+v2, v1), v1
        
        w1 = nums[1]
        w2 = 0
        for i in xrange(2, N):
            w1, w2 = max(nums[i]+w2, w1), w1
        
        return max(v1, w1)",data\repos\leetcode-python\problems\python\house-robber-ii.py,rob,141
3508,house-robber-iii.py::rob::22,"    def rob(self, root):
        def get_max_value(node):
            if node is None: return 0, 0
            left_rob, left_not_rob = get_max_value(node.left)
            right_rob, right_not_rob = get_max_value(node.right)

            rob = node.val+left_not_rob+right_not_rob
            not_rob = max(left_rob, left_not_rob)+max(right_rob, right_not_rob)

            return rob, not_rob

        return max(get_max_value(root))",data\repos\leetcode-python\problems\python\house-robber-iii.py,rob,116
3509,house-robber-iii.py::get_max_value::23,"        def get_max_value(node):
            if node is None: return 0, 0
            left_rob, left_not_rob = get_max_value(node.left)
            right_rob, right_not_rob = get_max_value(node.right)

            rob = node.val+left_not_rob+right_not_rob
            not_rob = max(left_rob, left_not_rob)+max(right_rob, right_not_rob)

            return rob, not_rob",data\repos\leetcode-python\problems\python\house-robber-iii.py,get_max_value,100
3510,house-robber.py::rob::15,"    def rob(self, nums):
        if (len(nums)==0): return 0
        K = [0]*len(nums)
        for i in xrange(len(nums)):
        	if i==0:
        		K[i] = nums[0]
        	elif i==1:
        		K[i] = max(nums[0], nums[1])
        	else:
        		prev_selected = K[i-1]!=K[i-2] 
        		if prev_selected: #[1]
        			K[i] = max(K[i-2]+nums[i], K[i-1])
        		else: #[2]
        			K[i] = K[i-1]+nums[i]
        return K[-1]",data\repos\leetcode-python\problems\python\house-robber.py,rob,141
3511,house-robber.py::rob::33,"    def rob(self, nums):
        def helper(i):
            if i>=len(nums): return 0
            if i in history: return history[i]
            history[i] = max(nums[i]+helper(i+2), helper(i+1))
            return history[i]
        
        history = {}
        return helper(0)",data\repos\leetcode-python\problems\python\house-robber.py,rob,68
3512,house-robber.py::rob::45,"    def rob(self, nums):
        if not nums: return 0
        if len(nums)==0 or len(nums)==1: return max(nums)
        
        last1 = max(nums[0], nums[1])
        last2 = nums[0]
        
        for i in xrange(len(nums)):
            if i==0 or i==1: continue
            last2, last1 = last1, max(nums[i]+last2, last1)
            
        return last1",data\repos\leetcode-python\problems\python\house-robber.py,rob,100
3513,house-robber.py::helper::34,"        def helper(i):
            if i>=len(nums): return 0
            if i in history: return history[i]
            history[i] = max(nums[i]+helper(i+2), helper(i+1))
            return history[i]",data\repos\leetcode-python\problems\python\house-robber.py,helper,50
3514,implement-trie-prefix-tree.py::insert::19,"    def insert(self, word):
        word = word + self.period
        node = self.root
        
        for c in word:
            if c not in node.children:
                node.children[c] = Node(c)
            node = node.children[c]",data\repos\leetcode-python\problems\python\implement-trie-prefix-tree.py,insert,51
3515,implement-trie-prefix-tree.py::search::29,"    def search(self, word):
        word = word + self.period
        node = self.root
        
        for c in word:
            if c not in node.children:
                return False
            node = node.children[c]
        return True",data\repos\leetcode-python\problems\python\implement-trie-prefix-tree.py,search,49
3516,implement-trie-prefix-tree.py::startsWith::40,"    def startsWith(self, prefix):
        node = self.root
        for c in prefix:
            if c not in node.children:
                return False
            node = node.children[c]
        return True",data\repos\leetcode-python\problems\python\implement-trie-prefix-tree.py,startsWith,42
3517,increasing-triplet-subsequence.py::increasingTriplet::13,"    def increasingTriplet(self, nums):
        min1 = min2 = float('inf')
        
        for n in nums:
            if n<min1:
                min1 = n
            elif min1<n and n<min2:
                min2 = n
            elif min2<n:
                return True
        
        return False",data\repos\leetcode-python\problems\python\increasing-triplet-subsequence.py,increasingTriplet,70
3518,inorder-successor-in-bst-ii.py::inorderSuccessor::12,"    def inorderSuccessor(self, node):
        if node.right:
            node = node.right
            while node.left:
                node = node.left
            return node
        
        while node.parent and node.parent.right==node:
            node = node.parent
        return node.parent",data\repos\leetcode-python\problems\python\inorder-successor-in-bst-ii.py,inorderSuccessor,56
3519,insert-interval.py::insert::2,"    def insert(self, intervals, newInterval):
        if not intervals: return [newInterval]
        
        max_index = float('-inf')
        min_index = float('inf')
        s0 = newInterval[0]
        e0 = newInterval[1]
        
        for i, interval in enumerate(intervals):
            s = interval[0]
            e = interval[1]
            
            if not (newInterval[1]<s or e<newInterval[0]):
                s0 = min(s0, s)
                e0 = max(e0, e)
                max_index = max(max_index, i)
                min_index = min(min_index, i)
       
        return intervals[:min_index]+[[s0, e0]]+intervals[max_index+1:] if min_index!=float('inf') else sorted(intervals+[[s0, e0]])",data\repos\leetcode-python\problems\python\insert-interval.py,insert,182
3520,insert-into-a-binary-search-tree.py::insertIntoBST::6,"    def insertIntoBST(self, root, val):
        if not root: return TreeNode(val)
        
        node = root
        while node:
            if val<node.val:
                if not node.left:
                    node.left = TreeNode(val)
                    return root
                else:
                    node = node.left
            else:
                if not node.right:
                    node.right = TreeNode(val)
                    return root
                else:
                    node = node.right
        
        return None",data\repos\leetcode-python\problems\python\insert-into-a-binary-search-tree.py,insertIntoBST,95
3521,insert-into-a-binary-search-tree.py::insertIntoBST::31,"    def insertIntoBST(self, root, val):
        def helper(node, val):
            if not node: return
            if val<node.val:
                if node.left:
                    helper(node.left, val)
                else:
                    node.left = TreeNode(val)
            else:
                if node.right:
                    helper(node.right, val)
                else:
                    node.right = TreeNode(val)
        
        if not root: return TreeNode(val)
        helper(root, val)
        return root",data\repos\leetcode-python\problems\python\insert-into-a-binary-search-tree.py,insertIntoBST,98
3522,insert-into-a-binary-search-tree.py::helper::32,"        def helper(node, val):
            if not node: return
            if val<node.val:
                if node.left:
                    helper(node.left, val)
                else:
                    node.left = TreeNode(val)
            else:
                if node.right:
                    helper(node.right, val)
                else:
                    node.right = TreeNode(val)",data\repos\leetcode-python\problems\python\insert-into-a-binary-search-tree.py,helper,68
3523,insert-into-a-sorted-circular-linked-list.py::insert::2,"    def insert(self, random, insertVal):
        def allValSame(node):
            curr = node.next
            while curr!=node:
                if curr.val!=node.val: return False
                curr = curr.next
            return True
                
        newNode = Node(insertVal)
        
        #handle null linked list
        if not random:
            newNode.next = newNode
            return newNode
        
        #handle linked list with val all the same
        if allValSame(random):
            temp = random.next
            random.next = newNode
            newNode.next = temp
            return random
        
        #find head and tail, head is the min val node, tail is the max val node.
        curr = random
        while curr.val<=curr.next.val:
            curr = curr.next
        tail = curr
        head = curr.next
        
        #insert new node
        if insertVal>=tail.val or insertVal<=head.val:
            tail.next = newNode
            newNode.next = head
        else:
            curr = head
            while not curr.val<=insertVal<=curr.next.val: curr = curr.next
            temp = curr.next
            curr.next = newNode
            newNode.next = temp
        
        return random",data\repos\leetcode-python\problems\python\insert-into-a-sorted-circular-linked-list.py,insert,251
3524,insert-into-a-sorted-circular-linked-list.py::allValSame::3,"        def allValSame(node):
            curr = node.next
            while curr!=node:
                if curr.val!=node.val: return False
                curr = curr.next
            return True",data\repos\leetcode-python\problems\python\insert-into-a-sorted-circular-linked-list.py,allValSame,39
3525,insertion-sort-list.py::insertionSortList::9,"    def insertionSortList(self, node):
        """"""
        `pre_head` is a common technique that used in linked list problem.
        So we don't need to handle the edge case all the time.
        """"""
        pre_head = ListNode(float('-inf'))
        pre_head.next = node
        pre = pre_head
        while node:
            if node.val>=pre.val: #see if node need to shift, if true, no need to shift this node
                pre = node
                node = node.next
            else:
                next_node = node.next
                self.remove(pre, node)
                self.insert(pre_head, node)
                node = next_node
        return pre_head.next",data\repos\leetcode-python\problems\python\insertion-sort-list.py,insertionSortList,143
3526,insertion-sort-list.py::insert::31,"    def insert(self, pre_head, node):
        curr = pre_head.next
        pre = pre_head
        while curr:
            if node.val<curr.val:
                pre.next = node
                node.next = curr
                break
            pre = curr
            curr = curr.next",data\repos\leetcode-python\problems\python\insertion-sort-list.py,insert,60
3527,integer-to-english-words.py::numberToWords::2,"    def numberToWords(self, num):
        underTwenty = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen', ]
        tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']
        
        def toWords(n):
            if n==0:
                return []
            elif n<20:
                return [underTwenty[n]]
            elif n<100:
                c, r = n/10, n%10
                return [tens[c]] + toWords(r)
            elif n<1000:
                c, r = n/100, n%100
                return toWords(c) + ['Hundred'] + toWords(r)
            else:
                if n>=1000000000:
                    c, r = n/1000000000, n%1000000000
                    return toWords(c) + ['Billion'] + toWords(r)
                elif n>=1000000:
                    c, r = n/1000000, n%1000000
                    return toWords(c) + ['Million'] + toWords(r)
                elif n>=1000:
                    c, r = n/1000, n%1000
                    return toWords(c) + ['Thousand'] + toWords(r)

        return ' '.join(toWords(num)) or 'Zero'",data\repos\leetcode-python\problems\python\integer-to-english-words.py,numberToWords,357
3528,integer-to-english-words.py::toWords::6,"        def toWords(n):
            if n==0:
                return []
            elif n<20:
                return [underTwenty[n]]
            elif n<100:
                c, r = n/10, n%10
                return [tens[c]] + toWords(r)
            elif n<1000:
                c, r = n/100, n%100
                return toWords(c) + ['Hundred'] + toWords(r)
            else:
                if n>=1000000000:
                    c, r = n/1000000000, n%1000000000
                    return toWords(c) + ['Billion'] + toWords(r)
                elif n>=1000000:
                    c, r = n/1000000, n%1000000
                    return toWords(c) + ['Million'] + toWords(r)
                elif n>=1000:
                    c, r = n/1000, n%1000
                    return toWords(c) + ['Thousand'] + toWords(r)",data\repos\leetcode-python\problems\python\integer-to-english-words.py,toWords,221
3529,interleaving-string.py::isInterleave::5,"    def isInterleave(self, s1, s2, s3):
        if len(s1)+len(s2)!=len(s3): return False
        
        M, N = len(s1), len(s2)
        dp = [[False for _ in xrange(N+1)] for _ in xrange(M+1)]
        
        for i in xrange(M+1): dp[i][0] = s1[:i] == s3[:i]
        for j in xrange(N+1): dp[0][j] = s2[:j] == s3[:j]
        
        for i in xrange(1, M+1):
            for j in xrange(1, N+1):
                if s1[i-1]==s3[i+j-1] and dp[i-1][j]:
                    dp[i][j] = True
                elif s2[j-1]==s3[i+j-1] and dp[i][j-1]:
                    dp[i][j] = True
        
        return dp[-1][-1]",data\repos\leetcode-python\problems\python\interleaving-string.py,isInterleave,218
3530,intersection-of-two-arrays-ii.py::intersect::6,"    def intersect(self, nums1, nums2):
        nums1.sort()
        nums2.sort()
        
        i = j = 0
        ans = []
        
        while i<len(nums1) and j<len(nums2):
            if nums1[i]==nums2[j]:
                ans.append(nums1[i])
                i += 1
                j +=1
            elif nums1[i]>nums2[j]:
                j += 1
            else:
                i += 1
        return ans",data\repos\leetcode-python\problems\python\intersection-of-two-arrays-ii.py,intersect,104
3531,intersection-of-two-arrays-ii.py::intersect::29,"    def intersect(self, nums1, nums2):
        c = {} #nums1 counter
        ans = []
        
        for n in nums1:
            if n in c:
                c[n] += 1
            else:
                c[n] = 1
        
        for n in nums2:
            if n in c and c[n]>0:
                ans.append(n)
                c[n] -= 1
        return ans",data\repos\leetcode-python\problems\python\intersection-of-two-arrays-ii.py,intersect,91
3532,intersection-of-two-arrays.py::intersection::6,"    def intersection(self, nums1, nums2):
        d1 = {}
        d2 = {}
        for n1 in nums1:
            d1[n1] = 0
        
        for n2 in nums2:
            if n2 in d1:
                d2[n2] = 0
        
        return d2.keys()",data\repos\leetcode-python\problems\python\intersection-of-two-arrays.py,intersection,71
3533,intersection-of-two-arrays.py::intersection::26,"    def intersection(self, nums1, nums2):
        nums1 = set(nums1)
        nums2 = set(nums2)
        
        return nums1.intersection(nums2)",data\repos\leetcode-python\problems\python\intersection-of-two-arrays.py,intersection,36
3534,invert-binary-tree.py::invertTree::6,"    def invertTree(self, root):
        if not root: return root
        q = collections.deque([root])
        
        while q:
            node = q.popleft()
            node.left, node.right = node.right, node.left
            if node.left: q.append(node.left)
            if node.right: q.append(node.right)
        
        return root",data\repos\leetcode-python\problems\python\invert-binary-tree.py,invertTree,74
3535,is-graph-bipartite.py::isBipartite::4,"    def isBipartite(self, graph):
        if not graph: return True
        
        A, B = set(), set()
        stack = []
        
        for node in xrange(len(graph)): #[1]
            #check if visited, if not start DFS by putting it to stack
            if node not in A and node not in B:
                stack.append(node)
                A.add(node)
            
            while stack: #[0]
                n = stack.pop()
                if n in A:
                    for nei in graph[n]:
                        if nei in A: return False
                        if nei not in B:
                            stack.append(nei)
                            B.add(nei)
                elif n in B:
                    for nei in graph[n]:
                        if nei in B: return False
                        if nei not in A:
                            stack.append(nei)
                            A.add(nei)
        return True",data\repos\leetcode-python\problems\python\is-graph-bipartite.py,isBipartite,181
3536,is-subsequence.py::isSubsequence::2,"    def isSubsequence(self, s, t):
        i = 0
        
        for c in t:
            if i>=len(s): break
            if s[i]==c: i += 1
        
        return i==len(s)",data\repos\leetcode-python\problems\python\is-subsequence.py,isSubsequence,51
3537,isomorphic-strings.py::isIsomorphic::18,"    def isIsomorphic(self, s, t):
        if len(s)!=len(t): return False
        
        # check if s1 chars could be replaced and become s2
        def helper(s1, s2):
            memo = {}
            
            for i in xrange(len(s)):
                c1 = s1[i]
                c2 = s2[i]
                
                if c1 in memo and memo[c1]!=c2: return False
                memo[c1] = c2
            return True
        
        return helper(s, t) and helper(t, s)",data\repos\leetcode-python\problems\python\isomorphic-strings.py,isIsomorphic,119
3538,isomorphic-strings.py::helper::22,"        def helper(s1, s2):
            memo = {}
            
            for i in xrange(len(s)):
                c1 = s1[i]
                c2 = s2[i]
                
                if c1 in memo and memo[c1]!=c2: return False
                memo[c1] = c2
            return True",data\repos\leetcode-python\problems\python\isomorphic-strings.py,helper,68
3539,jewels-and-stones.py::numJewelsInStones::3,"    def numJewelsInStones(self, J, S):
        n=0
        for j in J:
            n+=S.count(j)
        return n",data\repos\leetcode-python\problems\python\jewels-and-stones.py,numJewelsInStones,36
3540,jump-game.py::canJump::14,"    def canJump(self, nums):
        step_need = 0
        for num in reversed(nums[:-1]):
            step_need+=1
            if num>=step_need:
                step_need = 0
        return step_need==0",data\repos\leetcode-python\problems\python\jump-game.py,canJump,50
3541,k-empty-slots.py::kEmptySlots::12,"    def kEmptySlots(self, schedule, K):
        def check(l, r):
            if l<0 or r>=len(bulbs): return False
            if bulbs[l]!=1 or bulbs[r]!=1: return False
            for k in xrange(l+1, r):
                if bulbs[k]!=0: return False
            return True
        
        bulbs = [0]*len(schedule)
        for day, x in enumerate(schedule):
            i = x-1
            bulbs[i] = 1
            if check(i, i+K+1): return day+1
            if check(i-(K+1), i): return day+1
        return -1",data\repos\leetcode-python\problems\python\k-empty-slots.py,kEmptySlots,143
3542,k-empty-slots.py::kEmptySlots::47,"    def kEmptySlots(self, schedule, K):
        def check(l, r):
            if l<0 or r>=len(bulbs): return False
            if bulbs[l]!=1 or bulbs[r]!=1: return False
            
            i = ss.bisect_right(l)
            j = ss.bisect_left(r)
            
            return j!=0 and i!=len(ss) and i==j
        
        bulbs = [0]*len(schedule)
        ss = SortedSet()
        for day, x in enumerate(schedule):
            i = x-1
            bulbs[i] = 1
            ss.add(i)
            if check(i, i+K+1): return day+1
            if check(i-(K+1), i): return day+1
        return -1",data\repos\leetcode-python\problems\python\k-empty-slots.py,kEmptySlots,166
3543,k-empty-slots.py::check::13,"        def check(l, r):
            if l<0 or r>=len(bulbs): return False
            if bulbs[l]!=1 or bulbs[r]!=1: return False
            for k in xrange(l+1, r):
                if bulbs[k]!=0: return False
            return True",data\repos\leetcode-python\problems\python\k-empty-slots.py,check,62
3544,k-empty-slots.py::check::48,"        def check(l, r):
            if l<0 or r>=len(bulbs): return False
            if bulbs[l]!=1 or bulbs[r]!=1: return False
            
            i = ss.bisect_right(l)
            j = ss.bisect_left(r)
            
            return j!=0 and i!=len(ss) and i==j",data\repos\leetcode-python\problems\python\k-empty-slots.py,check,74
3545,keys-and-rooms.py::canVisitAllRooms::2,"    def canVisitAllRooms(self, rooms):
        if not rooms: return True
        
        visited = set()
        stack = [0]

        while stack:
            key = stack.pop()
            if key in visited: continue
            visited.add(key)
            stack.extend(rooms[key])

        return len(rooms)==len(visited)",data\repos\leetcode-python\problems\python\keys-and-rooms.py,canVisitAllRooms,69
3546,knight-dialer.py::knightDialer::2,"    def knightDialer(self, n):
        def helper(initial, n):
            # return the number of posible count starting from initial with n steps left
            
            if str(initial)+'-'+str(n) in history: return history[str(initial)+'-'+str(n)]
            count = 0
            
            if n==0: return 1
            for next_number in memo[initial]:
                count += helper(next_number, n-1)
            
            history[str(initial)+'-'+str(n)] = count
            return count
        
        memo = {
            1: [6, 8],
            2: [7, 9],
            3: [4, 8],
            4: [0, 3, 9],
            5: [],
            6: [0, 1, 7],
            7: [2, 6],
            8: [1, 3],
            9: [2, 4],
            0: [4, 6]
        }
        
        history = {}
        count = 0

        for i in xrange(10):
            count += helper(i, n-1)
        return count % 1000000007",data\repos\leetcode-python\problems\python\knight-dialer.py,knightDialer,252
3547,knight-dialer.py::knightDialer::43,"    def knightDialer(self, n):
        dp = [[0 for _ in xrange(10)] for _ in xrange(n)]
        for i in xrange(10): dp[0][i] = 1 #initialize
        
        memo = {
            1: [6, 8],
            2: [7, 9],
            3: [4, 8],
            4: [0, 3, 9],
            5: [],
            6: [0, 1, 7],
            7: [2, 6],
            8: [1, 3],
            9: [2, 4],
            0: [4, 6]
        }

        for j in xrange(n-1):
            for i in xrange(10):
                for next_n in memo[i]:
                    dp[j+1][next_n] += dp[j][i]
        
        return sum(dp[n-1]) % 1000000007",data\repos\leetcode-python\problems\python\knight-dialer.py,knightDialer,210
3548,knight-dialer.py::helper::3,"        def helper(initial, n):
            # return the number of posible count starting from initial with n steps left
            
            if str(initial)+'-'+str(n) in history: return history[str(initial)+'-'+str(n)]
            count = 0
            
            if n==0: return 1
            for next_number in memo[initial]:
                count += helper(next_number, n-1)
            
            history[str(initial)+'-'+str(n)] = count
            return count",data\repos\leetcode-python\problems\python\knight-dialer.py,helper,96
3549,knight-probability-in-chessboard.py::knightProbability::2,"    def knightProbability(self, N, K, r, c):
        if K==0: return 1
        
        dp = [[[0 for _ in xrange(N)] for _ in xrange(N)] for _ in xrange(K+1)]
        
        dp[0][r][c] = 1
        possible = float(0)
        
        for k in xrange(1, K+1):
            for i in xrange(N):
                for j in xrange(N):
                    if dp[k-1][i][j]>0:
                        for x, y in [(i+1, j+2), (i-1, j+2), (i+1, j-2), (i-1, j-2), (i+2, j+1), (i-2, j+1), (i+2, j-1), (i-2, j-1)]:
                            if 0<=x and x<N and 0<=y and y<N:
                                dp[k][x][y]+=dp[k-1][i][j]
                                if k==K: possible+=dp[k-1][i][j] #calculate the possible in the last iteration.
                                
        return possible/(8**K)",data\repos\leetcode-python\problems\python\knight-probability-in-chessboard.py,knightProbability,259
3550,koko-eating-bananas.py::minEatingSpeed::14,"    def minEatingSpeed(self, piles, H):
        def canEatAll(time):
            return sum((p+time-1)/time for p in piles) <= H
            # time_required = 0
            # for count in piles:
            #     time_required += math.ceil(count/float(time))
            # return time_required<=H

        l = 1
        h = max(piles)

        while l<h:
            m = (l+h)/2
            if canEatAll(m):
                h = m
            else:
                l = m+1
        return l",data\repos\leetcode-python\problems\python\koko-eating-bananas.py,minEatingSpeed,126
3551,koko-eating-bananas.py::minEatingSpeed::36,"    def minEatingSpeed(self, piles, H):
        if not piles: return 0
        
        l = 1
        r = max(piles) #[0]
        
        while l<r:
            K = (l+r)/2 #[1]
            
            #time Koko needs to eat all bananas
            t = sum([-(-banana_count//K) for banana_count in piles]) #-(-a//b) means ceil(a/b)
            
            if t>H:
                #K cannot be the answer.
                #next round we don't need to put K in l~r.
                l = K+1
            else:
                #K might ot might not be the answer.
                #next round we still need to put K in l~r.
                r = K

        return l #[2]",data\repos\leetcode-python\problems\python\koko-eating-bananas.py,minEatingSpeed,171
3552,kth-largest-element-in-an-array.py::findKthLargest::24,"    def findKthLargest(self, nums, k):
        ans = 0
        k = len(nums)-(k-1)
        heapq.heapify(nums)
        
        while k>0:
            ans = heapq.heappop(nums)
            k -= 1
        
        return ans",data\repos\leetcode-python\problems\python\kth-largest-element-in-an-array.py,findKthLargest,60
3553,kth-largest-element-in-an-array.py::findKthLargest::42,"    def findKthLargest(self, nums, k):
        def sortRange(A, l, r):
            if l>=r: return A

            p = A[(l+r)/2]
            i = partition(A, l, r, p)
            if k<i:
                sortRange(A, l, i-1)
            else:
                sortRange(A, i, r)
            return A

        def partition(A, l, r, p):
            while l<=r:
                while A[l]<p: l += 1
                while A[r]>p: r -= 1
                if l<=r:
                    A[l], A[r] = A[r], A[l]
                    l += 1
                    r -= 1
            return l
        
        k = len(nums)-k #redefine the problem to find the kth nums when sorted
        sortRange(nums, 0, len(nums)-1)
        return nums[k]",data\repos\leetcode-python\problems\python\kth-largest-element-in-an-array.py,findKthLargest,202
3554,kth-largest-element-in-an-array.py::findKthLargest::71,"    def findKthLargest(self, nums, K):
        def quickSelect(A, s, e, K):
            pivot = A[(s+e)/2]
            i = s
            t = s
            j = e
            
            while t<=j:
                if A[t]<pivot:
                    A[i], A[t] = A[t], A[i]
                    i += 1
                    t += 1
                elif A[t]==pivot:
                    t += 1
                else:
                    A[t], A[j] = A[j], A[t]
                    j -= 1
            
            if e-j>=K:
                return quickSelect(A, j+1, e, K)
            elif e-i+1>=K:
                return pivot
            else:
                return quickSelect(A, s, i-1, K-(e-(i-1)))
            
        return quickSelect(nums, 0, len(nums)-1, K)",data\repos\leetcode-python\problems\python\kth-largest-element-in-an-array.py,findKthLargest,200
3555,kth-largest-element-in-an-array.py::sortRange::43,"        def sortRange(A, l, r):
            if l>=r: return A

            p = A[(l+r)/2]
            i = partition(A, l, r, p)
            if k<i:
                sortRange(A, l, i-1)
            else:
                sortRange(A, i, r)
            return A",data\repos\leetcode-python\problems\python\kth-largest-element-in-an-array.py,sortRange,72
3556,kth-largest-element-in-an-array.py::partition::54,"        def partition(A, l, r, p):
            while l<=r:
                while A[l]<p: l += 1
                while A[r]>p: r -= 1
                if l<=r:
                    A[l], A[r] = A[r], A[l]
                    l += 1
                    r -= 1
            return l",data\repos\leetcode-python\problems\python\kth-largest-element-in-an-array.py,partition,76
3557,kth-largest-element-in-an-array.py::quickSelect::72,"        def quickSelect(A, s, e, K):
            pivot = A[(s+e)/2]
            i = s
            t = s
            j = e
            
            while t<=j:
                if A[t]<pivot:
                    A[i], A[t] = A[t], A[i]
                    i += 1
                    t += 1
                elif A[t]==pivot:
                    t += 1
                else:
                    A[t], A[j] = A[j], A[t]
                    j -= 1
            
            if e-j>=K:
                return quickSelect(A, j+1, e, K)
            elif e-i+1>=K:
                return pivot
            else:
                return quickSelect(A, s, i-1, K-(e-(i-1)))",data\repos\leetcode-python\problems\python\kth-largest-element-in-an-array.py,quickSelect,170
3558,kth-smallest-element-in-a-sorted-matrix.py::kthSmallest::2,"    def kthSmallest(self, matrix, k):
        memo = [0]*len(matrix)
        opt = []
        while len(opt)<k:
            m = float('inf')
            i_min = None
            for i, row in enumerate(matrix):
                if memo[i]<len(matrix) and row[memo[i]]<m:
                    m = row[memo[i]]
                    i_min = i
            opt.append(m)
            memo[i_min]+=1
        return opt[-1]",data\repos\leetcode-python\problems\python\kth-smallest-element-in-a-sorted-matrix.py,kthSmallest,103
3559,kth-smallest-element-in-a-sorted-matrix.py::kthSmallest::23,"    def kthSmallest(self, matrix, k):
        def count_smaller(t):
            count = 0
            col = 0
            for i, row in enumerate(reversed(matrix)):
                while col<len(row) and row[col]<=t:
                    count += len(matrix)-i
                    col += 1
            return count
        
        l = matrix[0][0]
        r = matrix[-1][-1]
        
        while l<r:
            m = (l+r)/2
            c = count_smaller(m)
            
            if c<k:
                l = m+1
            else:
                r = m
                
        return l",data\repos\leetcode-python\problems\python\kth-smallest-element-in-a-sorted-matrix.py,kthSmallest,137
3560,kth-smallest-element-in-a-sorted-matrix.py::count_smaller::24,"        def count_smaller(t):
            count = 0
            col = 0
            for i, row in enumerate(reversed(matrix)):
                while col<len(row) and row[col]<=t:
                    count += len(matrix)-i
                    col += 1
            return count",data\repos\leetcode-python\problems\python\kth-smallest-element-in-a-sorted-matrix.py,count_smaller,59
3561,largest-1-bordered-square.py::largest1BorderedSquare::2,"    def largest1BorderedSquare(self, grid):
        if not grid or not grid[0]: return 
        M, N = len(grid), len(grid[0])
        
        dp = [[[0, 0] for _ in xrange(N+1)] for _ in xrange(M+1)]
        ans = 0
        for i in xrange(M):
            for j in xrange(N):
                if grid[i][j]==1:
                    #[0]
                    dp[i+1][j+1][0] = dp[i][j+1][0]+1
                    dp[i+1][j+1][1] = dp[i+1][j][1]+1

                    #[1]
                    K = min(dp[i+1][j+1][0], dp[i+1][j+1][1])
                    
                    #[2]
                    for k in xrange(K, -1, -1):
                        if dp[i+1-k+1][j+1][1]>=k and dp[i+1][j+1-k+1][0]>=k:
                            ans = max(ans, k**2)
                            break
                    
                elif grid[i][j]==0:
                    #[0]
                    dp[i+1][j+1][0] = 0
                    dp[i+1][j+1][1] = 0

        return ans",data\repos\leetcode-python\problems\python\largest-1-bordered-square.py,largest1BorderedSquare,286
3562,largest-bst-subtree.py::largestBSTSubtree::6,"    def largestBSTSubtree(self, root):
        def helper(node, minVal, maxVal):
            if not node: return True, 0, float('-inf'), float('inf')
            if not node.left and not node.right: return True, 1, node.val, node.val
            
            isLeftBST, leftSize, leftMin, leftMax = helper(node.left, minVal, node.val)
            isRightBST, rightSize, rightMin, rightMax = helper(node.right, node.val, maxVal)
            
            currMin = min(leftMin, rightMin, node.val)
            currMax = max(leftMax, rightMax, node.val)
            
            if isLeftBST and isRightBST and leftMax<node.val and node.val<rightMin:
                return True, 1+leftSize+rightSize, currMin, currMax
            else:
                return False, max(leftSize, rightSize), currMin, currMax
            
        return helper(root, float('-inf'), float('inf'))[1]",data\repos\leetcode-python\problems\python\largest-bst-subtree.py,largestBSTSubtree,217
3563,largest-bst-subtree.py::helper::7,"        def helper(node, minVal, maxVal):
            if not node: return True, 0, float('-inf'), float('inf')
            if not node.left and not node.right: return True, 1, node.val, node.val
            
            isLeftBST, leftSize, leftMin, leftMax = helper(node.left, minVal, node.val)
            isRightBST, rightSize, rightMin, rightMax = helper(node.right, node.val, maxVal)
            
            currMin = min(leftMin, rightMin, node.val)
            currMax = max(leftMax, rightMax, node.val)
            
            if isLeftBST and isRightBST and leftMax<node.val and node.val<rightMin:
                return True, 1+leftSize+rightSize, currMin, currMax
            else:
                return False, max(leftSize, rightSize), currMin, currMax",data\repos\leetcode-python\problems\python\largest-bst-subtree.py,helper,190
3564,largest-sum-of-averages.py::largestSumOfAverages::5,"    def largestSumOfAverages(self, nums, K):
        N = len(nums)
        
        dp = [[0 for _ in xrange(K+1)] for _ in xrange(N+1)]
        for i in xrange(1, N+1): dp[i][0] = float('-inf')
        
        for i in xrange(1, N+1):
            for k in xrange(1, min(i, K)+1):
                for j in xrange(k, i+1):
                    dp[i][k] = max(dp[i][k], dp[j-1][k-1] + float(sum(nums[j-1:i]))/(i-j+1))
        
        return max(dp[N])",data\repos\leetcode-python\problems\python\largest-sum-of-averages.py,largestSumOfAverages,146
3565,largest-sum-of-averages.py::largestSumOfAverages::24,"    def largestSumOfAverages(self, nums, K):
        N = len(nums)

        avg = [[0 for _ in xrange(N)] for _ in xrange(N)]
        for i in xrange(N): avg[i][i] = float(nums[i])
        
        for l in xrange(2, N+1):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                avg[i][j] = float((avg[i+1][j-1]*((j-1)-(i+1)+1)+nums[i]+nums[j]))/(j-i+1)
        
        dp = [[0 for _ in xrange(K+1)] for _ in xrange(N+1)]
        for i in xrange(1, N+1): dp[i][0] = float('-inf')
        
        for i in xrange(1, N+1):
            for k in xrange(1, min(i, K)+1):
                for j in xrange(k, i+1):
                    dp[i][k] = max(dp[i][k], dp[j-1][k-1] + avg[j-1][i-1])
        
        return max(dp[N])",data\repos\leetcode-python\problems\python\largest-sum-of-averages.py,largestSumOfAverages,252
3566,last-stone-weight-ii.py::lastStoneWeightII::8,"    def lastStoneWeightII(self, stones):
        total = sum(stones)
        target = total/2
        dp = [[False for _ in xrange(target+1)] for _ in xrange(len(stones)+1)]
        dp[0][0] = True
        
        maxSum = 0
        # Keep trace of the max sum that stones can sum up to.
        
        for i in xrange(1, len(stones)+1):
            for t in xrange(target+1):
                if (dp[i-1][t] or (t-stones[i-1]>=0 and dp[i-1][t-stones[i-1]])):
                    # it can sum up to t considering stones[0~i-2]
                    # OR
                    # it can sum up to t considering stones[0~i-1]
                    dp[i][t] = True
                    maxSum = max(maxSum, t)
                    if t==target: return total-maxSum*2
        
        # Two collection of stones will be total-maxSum and maxSum
        # (total-maxSum) - maxSum => total-maxSum*2
        return total-maxSum*2",data\repos\leetcode-python\problems\python\last-stone-weight-ii.py,lastStoneWeightII,246
3567,last-stone-weight-ii.py::lastStoneWeightII::38,"    def lastStoneWeightII(self, stones):
        N = len(stones)
        W = sum(stones)
        dp = [collections.defaultdict(bool) for _ in xrange(N+1)]
        dp[0][0] = True
        
        for i in xrange(1, N+1):
            for w in xrange(-W, W+1):
                dp[i][w] = dp[i-1][w+stones[i-1]] or dp[i-1][w-stones[i-1]]
        
        for w, b in dp[N].iteritems():
            if b and w>=0: return w
        
        return 0",data\repos\leetcode-python\problems\python\last-stone-weight-ii.py,lastStoneWeightII,135
3568,last-stone-weight.py::lastStoneWeight::3,"    def lastStoneWeight(self, stones):
        stones.sort()
        
        while len(stones)>1:
            x = stones.pop()
            y = stones.pop()
            bisect.insort_left(stones, abs(x-y))

        return 0 if not stones else stones[0]",data\repos\leetcode-python\problems\python\last-stone-weight.py,lastStoneWeight,59
3569,last-stone-weight.py::lastStoneWeight::15,"    def lastStoneWeight(self, stones):
        h = []
        
        for stone in stones:
            heapq.heappush(h, stone*-1)
        
        while len(h)>1:
            x = heapq.heappop(h)
            y = heapq.heappop(h)
            heapq.heappush(h, abs(x-y)*-1)
        
        return 0 if not h else abs(h[0])",data\repos\leetcode-python\problems\python\last-stone-weight.py,lastStoneWeight,85
3570,least-number-of-unique-integers-after-k-removals.py::findLeastNumOfUniqueInts::8,"    def findLeastNumOfUniqueInts(self, nums, k):
        counter = collections.Counter(nums)
        h = []
        
        for num in counter:
            heapq.heappush(h, (counter[num], num))
            
        for _ in xrange(k):
            count, num = heapq.heappop(h)
            count -= 1
            if count>0: heapq.heappush(h, (count, num))
        
        return len(h)",data\repos\leetcode-python\problems\python\least-number-of-unique-integers-after-k-removals.py,findLeastNumOfUniqueInts,94
3571,letter-case-permutation.py::letterCasePermutation::10,"    def letterCasePermutation(self, S):
        def dfs(path, i):
            if i>=len(S):
                opt.append(path)
                return
            if S[i] not in num_char:
                dfs(path+S[i].upper(), i+1)
                dfs(path+S[i].lower(), i+1)
            else:
                dfs(path+S[i], i+1)

        num_char = set(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'])
        opt = []
        dfs('', 0)
        return opt",data\repos\leetcode-python\problems\python\letter-case-permutation.py,letterCasePermutation,127
3572,letter-case-permutation.py::dfs::11,"        def dfs(path, i):
            if i>=len(S):
                opt.append(path)
                return
            if S[i] not in num_char:
                dfs(path+S[i].upper(), i+1)
                dfs(path+S[i].lower(), i+1)
            else:
                dfs(path+S[i], i+1)",data\repos\leetcode-python\problems\python\letter-case-permutation.py,dfs,69
3573,letter-combinations-of-a-phone-number.py::letterCombinations::6,"    def letterCombinations(self, digits):
        def helper(A, digit):
            if not A: return memo[digit]

            opt = []
            for letter in memo[digit]:
                for string in A:
                    opt.append(string+letter)
            return opt

        ans = []
        memo = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']
        }

        for digit in digits:
            ans = helper(ans, digit)
        return ans",data\repos\leetcode-python\problems\python\letter-combinations-of-a-phone-number.py,letterCombinations,192
3574,letter-combinations-of-a-phone-number.py::helper::7,"        def helper(A, digit):
            if not A: return memo[digit]

            opt = []
            for letter in memo[digit]:
                for string in A:
                    opt.append(string+letter)
            return opt",data\repos\leetcode-python\problems\python\letter-combinations-of-a-phone-number.py,helper,45
3575,license-key-formatting.py::licenseKeyFormatting::3,"    def licenseKeyFormatting(self, S, K):
        r = ''
        s = S.replace('-', '').upper()
        
        #cut first part of string
        remainder = len(s)%K
        if remainder!=0:
            r = s[:remainder]+'-'
            s = s[remainder:]
        
        while len(s)>0:
            r += s[:K]+'-'
            s = s[K:]
        
        #remove last '-'
        r = r[:-1]
        
        return r",data\repos\leetcode-python\problems\python\license-key-formatting.py,licenseKeyFormatting,104
3576,linked-list-cycle-ii.py::detectCycle::6,"    def detectCycle(self, head):
        curr = head
        while curr:
            if hasattr(curr, 'visited') and curr.visited: return curr
            curr.visited = True
            curr = curr.next
        return None",data\repos\leetcode-python\problems\python\linked-list-cycle-ii.py,detectCycle,49
3577,linked-list-cycle-ii.py::detectCycle::19,"    def detectCycle(self, head):
        visited = set()
        curr = head
        while curr:
            if curr in visited: return curr
            visited.add(curr)
            curr = curr.next
        return None",data\repos\leetcode-python\problems\python\linked-list-cycle-ii.py,detectCycle,45
3578,linked-list-cycle.py::hasCycle::6,"    def hasCycle(self, head):
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast is slow: return True
        return False",data\repos\leetcode-python\problems\python\linked-list-cycle.py,hasCycle,50
3579,linked-list-cycle.py::hasCycle::20,"    def hasCycle(self, head):
        curr = head
        while curr:
            if hasattr(curr, 'visited') and curr.visited: return True
            curr.visited = True
            curr = curr.next
        return False",data\repos\leetcode-python\problems\python\linked-list-cycle.py,hasCycle,49
3580,linked-list-cycle.py::hasCycle::33,"    def hasCycle(self, head):
        visited = set()
        curr = head
        while curr:
            if curr in visited: return True
            visited.add(curr)
            curr = curr.next
        return False",data\repos\leetcode-python\problems\python\linked-list-cycle.py,hasCycle,45
3581,linked-list-random-node.py::getRandom::17,"    def getRandom(self):
        rand = randrange(self.count)
        while rand>0:
            rand -= 1
            self.curr = self.curr.next
        return self.curr.val",data\repos\leetcode-python\problems\python\linked-list-random-node.py,getRandom,38
3582,logger-rate-limiter.py::shouldPrintMessage::5,"    def shouldPrintMessage(self, timestamp, message):
        if message not in self.log or self.log[message]+10<=timestamp:
            self.log[message] = timestamp
            return True
        else:
            return False",data\repos\leetcode-python\problems\python\logger-rate-limiter.py,shouldPrintMessage,47
3583,logger-rate-limiter.py::shouldPrintMessage::22,"    def shouldPrintMessage(self, timestamp, message):
        while self.q and timestamp-self.q[0][0]>=10:
            time, msg = self.q.popleft()
            self.set.remove(msg)
        
        if message not in self.set:
            self.q.append((timestamp, message))
            self.set.add(message)
            return True
        else:
            return False",data\repos\leetcode-python\problems\python\logger-rate-limiter.py,shouldPrintMessage,76
3584,longest-common-prefix.py::longestCommonPrefix::13,"    def longestCommonPrefix(self, strs):
        if len(strs)==0 or strs==None:
            return ''
        
        bench_mark = strs[0] #[0]
        
        for i in range(1, len(bench_mark)+1): #[1]
            common_substring = bench_mark[:i]
            for s in strs:
                if s[:i]!=common_substring: #[2]
                    return bench_mark[:i-1]
        return bench_mark #[3]",data\repos\leetcode-python\problems\python\longest-common-prefix.py,longestCommonPrefix,100
3585,longest-common-prefix.py::longestCommonPrefix::28,"    def longestCommonPrefix(self, strs):
        j = 0
        minLen = float('inf')
        for s in strs: minLen = min(minLen, len(s))
        if minLen==float('inf'): return """"
        
        while j<minLen:
            c = strs[0][j]
            for i in xrange(1, len(strs)):
                if strs[i][j]!=c: return strs[i][:j]
            j += 1
            
        return strs[0][:j]",data\repos\leetcode-python\problems\python\longest-common-prefix.py,longestCommonPrefix,108
3586,longest-common-subsequence.py::longestCommonSubsequence::2,"    def longestCommonSubsequence(self, text1, text2):
        M, N = len(text1), len(text2)
        
        #dp[i][j] := logest subsequence of text1[0:i-1] and text[0:j-1]
        dp = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]
            
        for i in xrange(1, M+1):
            for j in xrange(1, N+1):
                if text1[i-1]==text2[j-1]:
                    dp[i][j] = dp[i-1][j-1]+1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                    
        return dp[M][N]",data\repos\leetcode-python\problems\python\longest-common-subsequence.py,longestCommonSubsequence,168
3587,longest-consecutive-sequence.py::longestConsecutive::9,"    def longestConsecutive(self, nums):
        s = set(nums)
        ans = 0
        
        for n in s:
            if n-1 not in s:
                c = 1
                curr = n
                
                while curr+1 in s:
                    curr = curr+1
                    c += 1

                ans = max(ans, c)
                
        return ans",data\repos\leetcode-python\problems\python\longest-consecutive-sequence.py,longestConsecutive,80
3588,longest-increasing-path-in-a-matrix.py::longestIncreasingPath::2,"    def longestIncreasingPath(self, matrix):
        def getLongest(i, j):
            if (i, j) in longest: return longest[(i, j)]
            l = 1

            #call getLongest to the neighbors that are larger than itself.
            if i+1<M and matrix[i][j]<matrix[i+1][j]:
                l = max(l, 1+getLongest(i+1, j))
            if i-1>=0 and matrix[i][j]<matrix[i-1][j]:
                l = max(l, 1+getLongest(i-1, j))
            if j+1<N and matrix[i][j]<matrix[i][j+1]:
                l = max(l, 1+getLongest(i, j+1))
            if j-1>=0 and matrix[i][j]<matrix[i][j-1]:
                l = max(l, 1+getLongest(i, j-1))
            
            longest[(i, j)] = l
            self.ans = max(self.ans, l)
            return l

        M = len(matrix)
        N = len(matrix[0])
        
        longest = {}
        self.ans = float('-inf')
        
        for i in xrange(M):
            for j in xrange(N):
                getLongest(i, j)
                
        return self.ans",data\repos\leetcode-python\problems\python\longest-increasing-path-in-a-matrix.py,longestIncreasingPath,290
3589,longest-increasing-path-in-a-matrix.py::getLongest::3,"        def getLongest(i, j):
            if (i, j) in longest: return longest[(i, j)]
            l = 1

            #call getLongest to the neighbors that are larger than itself.
            if i+1<M and matrix[i][j]<matrix[i+1][j]:
                l = max(l, 1+getLongest(i+1, j))
            if i-1>=0 and matrix[i][j]<matrix[i-1][j]:
                l = max(l, 1+getLongest(i-1, j))
            if j+1<N and matrix[i][j]<matrix[i][j+1]:
                l = max(l, 1+getLongest(i, j+1))
            if j-1>=0 and matrix[i][j]<matrix[i][j-1]:
                l = max(l, 1+getLongest(i, j-1))
            
            longest[(i, j)] = l
            self.ans = max(self.ans, l)
            return l",data\repos\leetcode-python\problems\python\longest-increasing-path-in-a-matrix.py,getLongest,223
3590,longest-increasing-subsequence.py::lengthOfLIS::4,"    def lengthOfLIS(self, nums):
        dp = [1 for _ in nums]
        
        for i in xrange(1, len(nums)):
            for j in xrange(i-1, -1, -1):
                if nums[j]<nums[i]:
                    dp[i] = max(dp[i], dp[j]+1)
        
        return max(dp)",data\repos\leetcode-python\problems\python\longest-increasing-subsequence.py,lengthOfLIS,75
3591,longest-increasing-subsequence.py::lengthOfLIS::20,"    def lengthOfLIS(self, nums):
        dp = []

        for n in nums:
            i = bisect_left(dp, n)
            if i==len(dp):
                dp.append(n)
            else:
                dp[i] = n
                
        return len(dp)",data\repos\leetcode-python\problems\python\longest-increasing-subsequence.py,lengthOfLIS,57
3592,longest-increasing-subsequence.py::lengthOfLIS::38,"    def lengthOfLIS(self, nums):
        dp = [1]*len(nums)
        
        for i in xrange(1, (len(nums))):
            for j in xrange(i-1, -1, -1):
                if nums[i]>nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        
        return max(dp)",data\repos\leetcode-python\problems\python\longest-increasing-subsequence.py,lengthOfLIS,75
3593,longest-palindromic-subsequence.py::longestPalindromeSubseq::5,"    def longestPalindromeSubseq(self, s):
        N = len(s)

        dp = [[0 for _ in xrange(N)] for _ in xrange(N)]
        for i in xrange(N): dp[i][i] = 1

        for l in xrange(2, N+1):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                dp[i][j] = dp[i+1][j-1]+2 if s[i]==s[j] else max(dp[i+1][j], dp[i][j-1])
        
        return dp[0][N-1]",data\repos\leetcode-python\problems\python\longest-palindromic-subsequence.py,longestPalindromeSubseq,135
3594,longest-palindromic-substring.py::longestPalindrome::11,"    def longestPalindrome(self, s):
        def findPalindorome(mid, mid2=None):
            r = 0
            l = len(s)
            max_pal = ''

            if mid2:
                #case 2
                if mid<0 or mid>=l: return ''
                if mid2<0 or mid2>=l: return ''
                while mid-r>=0 and mid2+r<l and s[mid-r]==s[mid2+r]:
                    max_pal = s[mid-r:mid2+r+1]
                    r+=1
            else:
                #case 1
                if mid<0 or mid>=l: return ''
                while mid-r>=0 and mid+r<l and s[mid-r]==s[mid+r]:
                    max_pal = s[mid-r:mid+r+1]
                    r+=1
            return max_pal
                
        max_pal = ''
        l = len(s)
        for i in range(len(s)):
            #case 1
            p = findPalindorome(i)
            max_pal = p if len(p)>len(max_pal) else max_pal

            #case 2
            p2 = findPalindorome(i, i+1)
            max_pal = p2 if len(p2)>len(max_pal) else max_pal
            
        return max_pal",data\repos\leetcode-python\problems\python\longest-palindromic-substring.py,longestPalindrome,274
3595,longest-palindromic-substring.py::longestPalindrome::51,"    def longestPalindrome(self, s):
        if not s: return s
        
        N = len(s)
        dp = [[False for _ in xrange(N+1)] for _ in xrange(N+1)]
        for i in xrange(N+1): dp[i][i] = True
        ans = s[0]    
        
        for l in xrange(2, N+1):
            for i in xrange(1, N+1):
                j = i+l-1
                if j>N: continue
                dp[i][j] = s[i-1]==s[j-1] and (dp[i+1][j-1] or j-1<i+1)
                if dp[i][j]: ans = s[i-1:j]
        
        return ans",data\repos\leetcode-python\problems\python\longest-palindromic-substring.py,longestPalindrome,163
3596,longest-palindromic-substring.py::findPalindorome::12,"        def findPalindorome(mid, mid2=None):
            r = 0
            l = len(s)
            max_pal = ''

            if mid2:
                #case 2
                if mid<0 or mid>=l: return ''
                if mid2<0 or mid2>=l: return ''
                while mid-r>=0 and mid2+r<l and s[mid-r]==s[mid2+r]:
                    max_pal = s[mid-r:mid2+r+1]
                    r+=1
            else:
                #case 1
                if mid<0 or mid>=l: return ''
                while mid-r>=0 and mid+r<l and s[mid-r]==s[mid+r]:
                    max_pal = s[mid-r:mid+r+1]
                    r+=1
            return max_pal",data\repos\leetcode-python\problems\python\longest-palindromic-substring.py,findPalindorome,169
3597,longest-repeating-character-replacement.py::characterReplacement::10,"    def characterReplacement(self, s, k):
        counter = collections.Counter()
        ans = 0
        
        l = 0
        for r in xrange(len(s)):
            counter[s[r]] += 1
            
            while r-l+1-max(counter.values())>k:
                counter[s[l]] -= 1
                l += 1
                
            ans = max(ans, r-l+1)
        return ans",data\repos\leetcode-python\problems\python\longest-repeating-character-replacement.py,characterReplacement,87
3598,longest-string-chain.py::longestStrChain::14,"    def longestStrChain(self, words):
        dp = {}
        
        for word in sorted(words, key=len):
            dp[word] = 1
            for i in xrange(len(word)):
                posible_predecessor = word[:i]+word[i+1:]
                dp[word] = max(dp.get(word), dp.get(posible_predecessor, 0)+1)
                
        return max(dp.values())",data\repos\leetcode-python\problems\python\longest-string-chain.py,longestStrChain,85
3599,longest-string-chain.py::longestStrChain::36,"    def longestStrChain(self, words):
        def isPredecessor(word, word2):
            if not word or not word2: return False
            for i in xrange(len(word)):
                if word[:i]+word[i+1:]==word2:
                    return True
            return False

        def shortestPredecessor(word):
            if word in history: return history[word]
            shortest_predecessor = word
            for word2 in word_group[len(word)-1]:
                if isPredecessor(word, word2):
                    sp = shortestPredecessor(word2)
                    if len(sp)<len(shortest_predecessor): shortest_predecessor = sp
            history[word] = shortest_predecessor
            return history[word]

        word_group = collections.defaultdict(list)
        ans = 1
        history = {} # classic memorization for the recursion.
        
        for word in words:
            word_group[len(word)].append(word)
        
        for l in xrange(max(word_group.keys()), 0, -1):
            if l<ans: break # no need to check since the l is already too small
            for word in word_group[l]:
                ans = max(ans, l-len(shortestPredecessor(word))+1)
        
        return ans",data\repos\leetcode-python\problems\python\longest-string-chain.py,longestStrChain,265
3600,longest-string-chain.py::longestStrChain::70,"    def longestStrChain(self, words):
        def getLongestStringChain(word):
            if word in history: return history[word]
            if not orderedWords[len(word)+1]: return 1
            
            temp = 0
            for word2 in orderedWords[len(word)+1]:
                if isPredecessor(word2, word):
                    temp = max(temp, getLongestStringChain(word2))
            
            history[word] = temp+1
            return temp+1
        
        def isPredecessor(w2, w1):
            if len(w2)!=len(w1)+1: return False
            
            j = 0
            for c in w1:
                found = False
                while j<len(w2):
                    if c==w2[j]:
                        found = True
                        j += 1
                        break
                    else:
                        j += 1
                if not found: return False

            return True
        
        orderedWords = collections.defaultdict(list)
        for word in words: orderedWords[len(word)].append(word)
        history = {}
        ans = 0
        
        for word in words:
            ans = max(ans, getLongestStringChain(word))
        return ans",data\repos\leetcode-python\problems\python\longest-string-chain.py,longestStrChain,251
3601,longest-string-chain.py::isPredecessor::37,"        def isPredecessor(word, word2):
            if not word or not word2: return False
            for i in xrange(len(word)):
                if word[:i]+word[i+1:]==word2:
                    return True
            return False",data\repos\leetcode-python\problems\python\longest-string-chain.py,isPredecessor,53
3602,longest-string-chain.py::shortestPredecessor::44,"        def shortestPredecessor(word):
            if word in history: return history[word]
            shortest_predecessor = word
            for word2 in word_group[len(word)-1]:
                if isPredecessor(word, word2):
                    sp = shortestPredecessor(word2)
                    if len(sp)<len(shortest_predecessor): shortest_predecessor = sp
            history[word] = shortest_predecessor
            return history[word]",data\repos\leetcode-python\problems\python\longest-string-chain.py,shortestPredecessor,93
3603,longest-string-chain.py::getLongestStringChain::71,"        def getLongestStringChain(word):
            if word in history: return history[word]
            if not orderedWords[len(word)+1]: return 1
            
            temp = 0
            for word2 in orderedWords[len(word)+1]:
                if isPredecessor(word2, word):
                    temp = max(temp, getLongestStringChain(word2))
            
            history[word] = temp+1
            return temp+1",data\repos\leetcode-python\problems\python\longest-string-chain.py,getLongestStringChain,91
3604,longest-string-chain.py::isPredecessor::83,"        def isPredecessor(w2, w1):
            if len(w2)!=len(w1)+1: return False
            
            j = 0
            for c in w1:
                found = False
                while j<len(w2):
                    if c==w2[j]:
                        found = True
                        j += 1
                        break
                    else:
                        j += 1
                if not found: return False

            return True",data\repos\leetcode-python\problems\python\longest-string-chain.py,isPredecessor,94
3605,longest-substring-with-at-least-k-repeating-characters.py::longestSubstring::11,"    def longestSubstring(self, s, k):
        if not s: return 0
        counter = collections.Counter(s)
        
        i = 0
        while i<len(s):
            c = s[i]
            
            if counter[c]>=k:
                i += 1
            else:
                return max(self.longestSubstring(s[:i], k), self.longestSubstring(s[i+1:], k))
        return i",data\repos\leetcode-python\problems\python\longest-substring-with-at-least-k-repeating-characters.py,longestSubstring,89
3606,longest-substring-with-at-least-k-repeating-characters.py::longestSubstring::29,"    def longestSubstring(self, s, k):
        def helper(l, r):
            if r-l==0: return 0
            counter = collections.Counter(s[l:r])
            
            i = l
            while i<r:
                c = s[i]
                
                if counter[c]>=k:
                    i += 1
                else:
                    return max(helper(l, i), helper(i+1, r))
            return i-l
        
        return helper(0, len(s))",data\repos\leetcode-python\problems\python\longest-substring-with-at-least-k-repeating-characters.py,longestSubstring,100
3607,longest-substring-with-at-least-k-repeating-characters.py::longestSubstring::65,"    def longestSubstring(self, s, k):
        ans = 0
        uniqueCount = len(set(s))
        
        for m in xrange(1, uniqueCount+1):
            ans = max(ans, self.helper(s, k, m))
            
        return ans",data\repos\leetcode-python\problems\python\longest-substring-with-at-least-k-repeating-characters.py,longestSubstring,56
3608,longest-substring-with-at-least-k-repeating-characters.py::helper::75,"    def helper(self, s, k, m):
        j = 0
        counter = collections.Counter() #count each char in s[i:j+1]
        countOverK = 0 #number of char in s[i:j+1] count>=k
        ans = 0
        
        for i in xrange(len(s)):
            while j<len(s) and len(counter)<=m:
                counter[s[j]] += 1
                
                if counter[s[j]]==k: countOverK += 1
                
                #all char in the sliding window has count larger or equal to k.
                if len(counter)==m and countOverK==m: ans = max(ans, j-i+1)
                
                j += 1
            
            #[0]
            counter[s[i]] -= 1
            if counter[s[i]]==k-1: countOverK -= 1
            if counter[s[i]]==0: counter.pop(s[i], None)
                
        return ans",data\repos\leetcode-python\problems\python\longest-substring-with-at-least-k-repeating-characters.py,helper,204
3609,longest-substring-with-at-least-k-repeating-characters.py::helper::30,"        def helper(l, r):
            if r-l==0: return 0
            counter = collections.Counter(s[l:r])
            
            i = l
            while i<r:
                c = s[i]
                
                if counter[c]>=k:
                    i += 1
                else:
                    return max(helper(l, i), helper(i+1, r))
            return i-l",data\repos\leetcode-python\problems\python\longest-substring-with-at-least-k-repeating-characters.py,helper,80
3610,longest-substring-without-repeating-characters.py::lengthOfLongestSubstring::22,"    def lengthOfLongestSubstring(self, s):
        if s is None or s=='': return 0
        counter = 0 #max length of substring
        start = 0 #index where all the char between the start and i are all unique
        mark = {} #all the char index we last seen

        for i in range(len(s)):
            char_now = s[i]
            if char_now in mark:
                start = max(start, mark[char_now]+1)
            counter = max(counter, i-start+1)
            mark[char_now] = i
                
        return counter",data\repos\leetcode-python\problems\python\longest-substring-without-repeating-characters.py,lengthOfLongestSubstring,124
3611,longest-substring-without-repeating-characters.py::lengthOfLongestSubstring::40,"    def lengthOfLongestSubstring(self, s):
        lastSeen = {}
        start = 0
        maxLength = 0
        for i, c in enumerate(s):
            if c in lastSeen: start = max(start, lastSeen[c]+1)
            lastSeen[c] = i
            maxLength = max(maxLength, i-start+1)
            
        return maxLength",data\repos\leetcode-python\problems\python\longest-substring-without-repeating-characters.py,lengthOfLongestSubstring,79
3612,longest-substring-without-repeating-characters.py::lengthOfLongestSubstring::62,"    def lengthOfLongestSubstring(self, s):
        ans = 0
        start = 0
        lastSeen = {}
        
        for i, c in enumerate(s):
            if c in lastSeen: start = max(start, lastSeen[c]+1) #[0]
            lastSeen[c] = i
            ans = max(ans, i-start+1)
        
        return ans",data\repos\leetcode-python\problems\python\longest-substring-without-repeating-characters.py,lengthOfLongestSubstring,82
3613,longest-univalue-path.py::longestUnivaluePath::2,"    def longestUnivaluePath(self, root):
        def getUnivalueLength(node, val):
            if not node: return 0
            
            l, r = getUnivalueLength(node.left, node.val), getUnivalueLength(node.right, node.val)
            self.ans = max(self.ans, l+r)
            
            if node.val==val: return 1+max(l, r)
            return 0
            
        if not root: return 0
        self.ans = float('-inf')
        getUnivalueLength(root, root.val)
        return self.ans",data\repos\leetcode-python\problems\python\longest-univalue-path.py,longestUnivaluePath,127
3614,longest-univalue-path.py::getUnivalueLength::3,"        def getUnivalueLength(node, val):
            if not node: return 0
            
            l, r = getUnivalueLength(node.left, node.val), getUnivalueLength(node.right, node.val)
            self.ans = max(self.ans, l+r)
            
            if node.val==val: return 1+max(l, r)
            return 0",data\repos\leetcode-python\problems\python\longest-univalue-path.py,getUnivalueLength,81
3615,lowest-common-ancestor-of-a-binary-search-tree.py::lowestCommonAncestor::10,"    def lowestCommonAncestor(self, root, p, q):
        node = root
        
        while node:
            if node.val>q.val and node.val>p.val:
                node = node.left
            elif node.val<q.val and node.val<p.val:
                node = node.right
            else:
                return node",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-search-tree.py,lowestCommonAncestor,67
3616,lowest-common-ancestor-of-a-binary-search.py::lowestCommonAncestor::2,"    def lowestCommonAncestor(self, root, p, q):
        def find_ancestors(target):
            ancestors = []
            curr = root
            while curr:
                ancestors.append(curr)

                if curr is target: break

                if target.val>curr.val:
                    curr = curr.right
                else:
                    curr = curr.left

            ancestors.reverse()
            return ancestors

        def find_lowest_common(a1, a2):
            if len(a1)>len(a2):
                a2 = set(a2)
                for node in a1:
                    if node in a2:
                        return node
            else:
                a1 = set(a1)
                for node in a2:
                    if node in a1:
                        return node
        
        p_ancestors = find_ancestors(p)
        q_ancestors = find_ancestors(q)
        return find_lowest_common(p_ancestors, q_ancestors)",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-search.py,lowestCommonAncestor,203
3617,lowest-common-ancestor-of-a-binary-search.py::find_ancestors::3,"        def find_ancestors(target):
            ancestors = []
            curr = root
            while curr:
                ancestors.append(curr)

                if curr is target: break

                if target.val>curr.val:
                    curr = curr.right
                else:
                    curr = curr.left

            ancestors.reverse()
            return ancestors",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-search.py,find_ancestors,65
3618,lowest-common-ancestor-of-a-binary-search.py::find_lowest_common::19,"        def find_lowest_common(a1, a2):
            if len(a1)>len(a2):
                a2 = set(a2)
                for node in a1:
                    if node in a2:
                        return node
            else:
                a1 = set(a1)
                for node in a2:
                    if node in a1:
                        return node",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-search.py,find_lowest_common,76
3619,lowest-common-ancestor-of-a-binary-tree-ii.py::lowestCommonAncestor::5,"    def lowestCommonAncestor(self, root, p, q):
        def dfs(node):
            if not node: return 0
            
            count = 0
            if node is p or node is q: count += 1
            count += dfs(node.left)
            count += dfs(node.right)
            if count>=2 and not self.ans: self.ans = node
            return count
        
        dfs(root)
        return self.ans",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree-ii.py,lowestCommonAncestor,93
3620,lowest-common-ancestor-of-a-binary-tree-ii.py::dfs::6,"        def dfs(node):
            if not node: return 0
            
            count = 0
            if node is p or node is q: count += 1
            count += dfs(node.left)
            count += dfs(node.right)
            if count>=2 and not self.ans: self.ans = node
            return count",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree-ii.py,dfs,69
3621,lowest-common-ancestor-of-a-binary-tree-iii.py::lowestCommonAncestor::6,"    def lowestCommonAncestor(self, p, q):
        ancestorP = set()
        ancestorQ = set()
        
        temp = p
        while temp:
            ancestorP.add(temp)
            temp = temp.parent
        
        temp = q
        while temp:
            ancestorQ.add(temp)
            temp = temp.parent
        
        commonAncestor = ancestorQ.intersection(ancestorP)
        temp = q
        while temp:
            if temp in commonAncestor: return temp 
            temp = temp.parent
        return None",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree-iii.py,lowestCommonAncestor,108
3622,lowest-common-ancestor-of-a-binary-tree-iii.py::lowestCommonAncestor::36,"    def lowestCommonAncestor(self, p, q):
        parents1 = []
        parents2 = []
        
        curr = p
        while curr:
            parents1.append(curr)
            curr = curr.parent
        
        curr = q
        while curr:
            parents2.append(curr)
            curr = curr.parent
        
        i = len(parents1)-1
        j = len(parents2)-1
        while i>=0 and j>=0 and parents1[i]==parents2[j]:
            i -= 1
            j -= 1
        return parents1[i+1]",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree-iii.py,lowestCommonAncestor,123
3623,lowest-common-ancestor-of-a-binary-tree-iv.py::lowestCommonAncestor::5,"    def lowestCommonAncestor(self, root, nodes):
        def dfs(node):
            if not node: return 0
            
            count = 0
            if node in nodes: count += 1
            count += dfs(node.left)
            count += dfs(node.right)
            if count>=len(nodes) and not self.ans: self.ans = node    
            return count
        
        nodes = set(nodes)
        dfs(root)
        return self.ans",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree-iv.py,lowestCommonAncestor,95
3624,lowest-common-ancestor-of-a-binary-tree-iv.py::dfs::6,"        def dfs(node):
            if not node: return 0
            
            count = 0
            if node in nodes: count += 1
            count += dfs(node.left)
            count += dfs(node.right)
            if count>=len(nodes) and not self.ans: self.ans = node    
            return count",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree-iv.py,dfs,67
3625,lowest-common-ancestor-of-a-binary-tree.py::lowestCommonAncestor::2,"    def lowestCommonAncestor(self, root, p, q):
        p_ancestor = []
        q_ancestor = []

        stack = []
        stack.append((root, []))
        while stack:
            node, path = stack.pop()
            if node is p: p_ancestor = path+[p]
            if node is q: q_ancestor = path+[q]
            if p_ancestor and q_ancestor: break #[0]
            if node.left: stack.append((node.left, path+[node]))
            if node.right: stack.append((node.right, path+[node]))
        
        if len(p_ancestor)>len(q_ancestor): #[1]
            s = set(q_ancestor)
            for node in reversed(p_ancestor): #[2]
                if node in s: return node #[3]
        else: #[1]
            s = set(p_ancestor)
            for node in reversed(q_ancestor): #[2]
                if node in s: return node #[3]
        return None",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,lowestCommonAncestor,209
3626,lowest-common-ancestor-of-a-binary-tree.py::lowestCommonAncestor::29,"    def lowestCommonAncestor(self, root, p, q):
        def helper(node):
            if not node: return False
            l, r = helper(node.left), helper(node.right)
            curr = node is p or node is q
            if (int(l)+int(r)+int(curr) >= 2): self.ans = node
            return l or r or curr
        
        self.ans = None
        helper(root)
        return self.ans",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,lowestCommonAncestor,97
3627,lowest-common-ancestor-of-a-binary-tree.py::lowestCommonAncestor::44,"    def lowestCommonAncestor(self, root, p, q):
        stack = []
        stack.append(root)

        parent = {}
        parent[root] = None

        while p not in parent or q not in parent:
            node = stack.pop()
            if node.left:
                parent[node.left] = node
                stack.append(node.left)
            if node.right:
                parent[node.right] = node
                stack.append(node.right)
        
        p_ancestor = p
        q_ancestor = q
        p_ancestors = set()
        while p_ancestor:
            p_ancestors.add(p_ancestor)
            p_ancestor = parent[p]
        while q_ancestor:
            if q_ancestor in p_ancestors: return q_ancestor
            q_ancestor = parent[q]
            
        return None",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,lowestCommonAncestor,174
3628,lowest-common-ancestor-of-a-binary-tree.py::lowestCommonAncestor::75,"    def lowestCommonAncestor(self, root, p, q):
        def find_genealogy():
            genealogy = {}
            stack = []
            stack.append(root)
            p_found = q_found = False
            while stack:
                node = stack.pop()
                if node.left:
                    genealogy[node.left] = node
                    stack.append(node.left)
                if node.right:
                    genealogy[node.right] = node
                    stack.append(node.right)
    
                if node is p: p_found = True
                if node is q: q_found = True
                if p_found and q_found: break
            return genealogy

        def find_ancestors(target, genealogy):
            ancestors = []
            curr_node = target
            while curr_node:
                ancestors.append(curr_node)
                curr_node = genealogy[curr_node] if curr_node in genealogy else None
            return ancestors

        def find_lowest_common(a1, a2):
            if len(a1)>len(a2):
                a2 = set(a2)
                for node in a1:
                    if node in a2:
                        return node
            else:
                a1 = set(a1)
                for node in a2:
                    if node in a1:
                        return node

        genealogy = find_genealogy()
        p_ancestors = find_ancestors(p, genealogy)
        q_ancestors = find_ancestors(q, genealogy)
        return find_lowest_common(p_ancestors, q_ancestors)",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,lowestCommonAncestor,323
3629,lowest-common-ancestor-of-a-binary-tree.py::lowestCommonAncestor::137,"    def lowestCommonAncestor(self, root, p, q):
        def __init__(self):
            self.ans = None
            
        def helper(node):
            
            if not node: return False
            mid = node==q or node==p
            left = helper(node.left)
            right = helper(node.right)
            
            if (mid and left) or (mid and right) or (left and right): self.ans = node
            
            return mid or left or right
        
        helper(root)
        return self.ans",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,lowestCommonAncestor,110
3630,lowest-common-ancestor-of-a-binary-tree.py::helper::30,"        def helper(node):
            if not node: return False
            l, r = helper(node.left), helper(node.right)
            curr = node is p or node is q
            if (int(l)+int(r)+int(curr) >= 2): self.ans = node
            return l or r or curr",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,helper,66
3631,lowest-common-ancestor-of-a-binary-tree.py::find_genealogy::76,"        def find_genealogy():
            genealogy = {}
            stack = []
            stack.append(root)
            p_found = q_found = False
            while stack:
                node = stack.pop()
                if node.left:
                    genealogy[node.left] = node
                    stack.append(node.left)
                if node.right:
                    genealogy[node.right] = node
                    stack.append(node.right)
    
                if node is p: p_found = True
                if node is q: q_found = True
                if p_found and q_found: break
            return genealogy",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,find_genealogy,116
3632,lowest-common-ancestor-of-a-binary-tree.py::find_ancestors::95,"        def find_ancestors(target, genealogy):
            ancestors = []
            curr_node = target
            while curr_node:
                ancestors.append(curr_node)
                curr_node = genealogy[curr_node] if curr_node in genealogy else None
            return ancestors",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,find_ancestors,54
3633,lowest-common-ancestor-of-a-binary-tree.py::find_lowest_common::103,"        def find_lowest_common(a1, a2):
            if len(a1)>len(a2):
                a2 = set(a2)
                for node in a1:
                    if node in a2:
                        return node
            else:
                a1 = set(a1)
                for node in a2:
                    if node in a1:
                        return node",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,find_lowest_common,76
3634,lowest-common-ancestor-of-a-binary-tree.py::helper::141,"        def helper(node):
            
            if not node: return False
            mid = node==q or node==p
            left = helper(node.left)
            right = helper(node.right)
            
            if (mid and left) or (mid and right) or (left and right): self.ans = node
            
            return mid or left or right",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-a-binary-tree.py,helper,72
3635,lowest-common-ancestor-of-deepest-leaves.py::lcaDeepestLeaves::5,"    def lcaDeepestLeaves(self, root):
        def checkCount(node, deepestNode):
            if not node:
                count = 0
                if count==len(deepestNode) and not self.ans: self.ans = node
                return 0
            
            if node in deepestNode:
                count = 1
                if count==len(deepestNode) and not self.ans: self.ans = node
                return count
            
            leftCount = checkCount(node.left, deepestNode)
            rightCount = checkCount(node.right, deepestNode)
            
            if leftCount+rightCount==len(deepestNode) and not self.ans: self.ans = node
            return leftCount+rightCount
            
        q = collections.deque([(root, 0)])
        q2 = collections.deque()
        deepestNode = set([node for node, h in q])
        
        while q:
            node, d = q.popleft()
            if node.left: q2.append((node.left, d+1))
            if node.right: q2.append((node.right, d+1))
            if not q:
                q = q2
                if q: deepestNode = set([node for node, h in q])
                q2 = collections.deque()
        
        checkCount(root, deepestNode)
        return self.ans",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-deepest-leaves.py,lcaDeepestLeaves,288
3636,lowest-common-ancestor-of-deepest-leaves.py::checkCount::6,"        def checkCount(node, deepestNode):
            if not node:
                count = 0
                if count==len(deepestNode) and not self.ans: self.ans = node
                return 0
            
            if node in deepestNode:
                count = 1
                if count==len(deepestNode) and not self.ans: self.ans = node
                return count
            
            leftCount = checkCount(node.left, deepestNode)
            rightCount = checkCount(node.right, deepestNode)
            
            if leftCount+rightCount==len(deepestNode) and not self.ans: self.ans = node
            return leftCount+rightCount",data\repos\leetcode-python\problems\python\lowest-common-ancestor-of-deepest-leaves.py,checkCount,144
3637,lru-cache.py::promote::57,"    def promote(self, node): #[1]
        #set the node next to head
        temp = self.head.next
        node.next = temp
        temp.prev = node
        self.head.next = node
        node.prev = self.head",data\repos\leetcode-python\problems\python\lru-cache.py,promote,51
3638,lru-cache.py::get::65,"    def get(self, key):
        if key in self.dic:
            node = self.dic[key]
            self.remove(node)
            self.promote(node)
            return node.val
        return -1",data\repos\leetcode-python\problems\python\lru-cache.py,get,43
3639,lru-cache.py::put::73,"    def put(self, key, value):
        if key in self.dic:
            self.remove(self.dic[key])
        node = Node(key, value)
        self.promote(node)
        self.dic[key] = node
        
        if len(self.dic)>self.capacity: #[2]
            del self.dic[self.tail.prev.key]
            self.remove(self.tail.prev)",data\repos\leetcode-python\problems\python\lru-cache.py,put,78
3640,lru-cache.py::get::90,"    def get(self, key):
        if key not in self.dic:
            return -1
        v = self.dic.pop(key) 
        self.dic[key] = v   # set key as the newest one
        return v",data\repos\leetcode-python\problems\python\lru-cache.py,get,51
3641,lru-cache.py::set::97,"    def set(self, key, value):
        if key in self.dic:    
            self.dic.pop(key)
        else:
            if self.remain > 0:
                self.remain -= 1  
            else:  # self.dic is full
                self.dic.popitem(last=False) 
        self.dic[key] = value",data\repos\leetcode-python\problems\python\lru-cache.py,set,74
3642,majority-element-ii.py::majorityElement::2,"    def majorityElement(self, nums):
        ans = []
        counter = {}
        requiredCount = len(nums)/3.0
        
        for n in nums:
            if n not in counter: counter[n] = 0
            counter[n] += 1
        
        for n in counter:
            if counter[n]>requiredCount: ans.append(n)
        
        return ans",data\repos\leetcode-python\problems\python\majority-element-ii.py,majorityElement,77
3643,majority-element.py::majorityElement::6,"    def majorityElement(self, nums):
        counter = {}
        
        for n in nums:
            if n not in counter: counter[n] = 0
            counter[n] += 1
            if counter[n]>len(nums)/2.0: return n
        
        return 0",data\repos\leetcode-python\problems\python\majority-element.py,majorityElement,60
3644,majority-element.py::majorityElement::25,"    def majorityElement(self, nums):
        ans = nums[0]
        count = 0
        
        for n in nums:
            if n==ans:
                count += 1
            else:
                count -= 1
                if count==0:
                    ans = n
                    count = 1
        return ans",data\repos\leetcode-python\problems\python\majority-element.py,majorityElement,68
3645,making-a-large-island.py::largestIsland::9,"    def largestIsland(self, grid):
        def isValid(i, j, M, N):
            return 0<=i<M and 0<=j<N
        
        def dfs(i, j, groupId):
            if not isValid(i, j, M, N): return
            if grid[i][j]!=1: return
            grid[i][j] = groupId
            groupIdToSize[groupId] += 1
            for iNext, jNext in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:
                dfs(iNext, jNext, groupId)

        M = len(grid)
        N = len(grid[0])
        
        zeros = []
        groupIdToSize = {}
        groupId = 2
        for i in xrange(M):
            for j in xrange(N):
                if grid[i][j]==1:
                    groupIdToSize[groupId] = 0
                    dfs(i, j, groupId)
                    groupId += 1
                elif grid[i][j]==0:
                    zeros.append((i, j))
                    
        ans = max(groupIdToSize.values()) if groupIdToSize else 0
        
        for i, j in zeros:
            neiGroupId = set()
            neiSize = 0
            for iNext, jNext in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:
                if not isValid(iNext, jNext, M, N): continue
                if grid[iNext][jNext]>1:
                    neiGroupId.add(grid[iNext][jNext])
            
            for groupId in list(neiGroupId):
                neiSize += groupIdToSize[groupId]
            
            ans = max(ans, 1+neiSize)
        
        return ans",data\repos\leetcode-python\problems\python\making-a-large-island.py,largestIsland,383
3646,making-a-large-island.py::dfs::13,"        def dfs(i, j, groupId):
            if not isValid(i, j, M, N): return
            if grid[i][j]!=1: return
            grid[i][j] = groupId
            groupIdToSize[groupId] += 1
            for iNext, jNext in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:
                dfs(iNext, jNext, groupId)",data\repos\leetcode-python\problems\python\making-a-large-island.py,dfs,101
3647,max-area-of-island.py::maxAreaOfIsland::2,"    def maxAreaOfIsland(self, grid):
        def dfs(i0, j0):
            stack = [(i0, j0)]
            area = 0
            
            while stack:
                i, j = stack.pop()
                if grid[i][j]==0 or grid[i][j]==2: continue
                grid[i][j] = 2
                area += 1
                
                if i+1<M: stack.append((i+1, j))
                if 0<=i-1: stack.append((i-1, j))
                if j+1<N: stack.append((i, j+1))
                if 0<=j-1: stack.append((i, j-1))
            
            return area
                
        if not grid or not grid[0]: return 0
        
        max_area = 0
        M = len(grid)
        N = len(grid[0])
        
        for i in xrange(M):
            for j in xrange(N):
                if grid[i][j]==0 or grid[i][j]==2: continue
                max_area = max(max_area, dfs(i, j))
                
        return max_area",data\repos\leetcode-python\problems\python\max-area-of-island.py,maxAreaOfIsland,241
3648,max-area-of-island.py::dfs::3,"        def dfs(i0, j0):
            stack = [(i0, j0)]
            area = 0
            
            while stack:
                i, j = stack.pop()
                if grid[i][j]==0 or grid[i][j]==2: continue
                grid[i][j] = 2
                area += 1
                
                if i+1<M: stack.append((i+1, j))
                if 0<=i-1: stack.append((i-1, j))
                if j+1<N: stack.append((i, j+1))
                if 0<=j-1: stack.append((i, j-1))
            
            return area",data\repos\leetcode-python\problems\python\max-area-of-island.py,dfs,143
3649,max-consecutive-ones-iii.py::longestOnes::2,"    def longestOnes(self, nums, k):
        ans = 0
        zeroCount = 0
        i = 0
        
        for j, num in enumerate(nums):
            if num==0: zeroCount += 1
            
            while zeroCount>k:
                if nums[i]==0: zeroCount -= 1
                i += 1
            ans = max(ans, j-i+1)
        
        return ans",data\repos\leetcode-python\problems\python\max-consecutive-ones-iii.py,longestOnes,91
3650,max-stack.py::popMax::27,"    def popMax(self):
        max_num = None
        max_index = None
        
        for i in range(len(self.stack)):
            num = self.stack[i]
            if num>=max_num:
                max_num = num
                max_index = i

        return self.stack.pop(max_index)",data\repos\leetcode-python\problems\python\max-stack.py,popMax,61
3651,max-sum-of-rectangle-no-larger-than-k.py::maxSumSubmatrix::11,"    def maxSumSubmatrix(self, matrix, k):
        if len(matrix)>len(matrix[0]): matrix = self.rotate(matrix)
        
        ans = float('-inf')
        M = len(matrix)
        N = len(matrix[0])
        
        for start in xrange(M):
            rowSum = [0]*N #row sum of rows from matrix[start] to row
            for row in matrix[start:]:
                for i, n in enumerate(row): rowSum[i] += n
                ans = max(ans, self.maxSumRow(rowSum, k))
                if ans==k: return ans
        return ans",data\repos\leetcode-python\problems\python\max-sum-of-rectangle-no-larger-than-k.py,maxSumSubmatrix,128
3652,max-sum-of-rectangle-no-larger-than-k.py::maxSumRow::26,"    def maxSumRow(self, row, k):
        ans = float('-inf')
        total = 0
        
        ss = SortedSet()
        ss.add(0)
        
        for n in row:
            total += n
            i = ss.bisect_left(total-k)
            if i<len(ss):
                x = ss[i]
                ans = max(ans, total-x)
            ss.add(total)
        return ans",data\repos\leetcode-python\problems\python\max-sum-of-rectangle-no-larger-than-k.py,maxSumRow,88
3653,max-sum-of-rectangle-no-larger-than-k.py::rotate::42,"    def rotate(self, matrix):
        M = len(matrix)
        N = len(matrix[0])
        matrixRotated = [[0]*M for _ in xrange(N)]
        
        for i in xrange(M):
            for j in xrange(N):
                matrixRotated[j][i] = matrix[i][j]
        
        return matrixRotated",data\repos\leetcode-python\problems\python\max-sum-of-rectangle-no-larger-than-k.py,rotate,71
3654,maximal-square.py::maximalSquare::2,"    def maximalSquare(self, grid):
        if not grid or not grid[0]: return 
        M, N = len(grid), len(grid[0])
        
        dp = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]
        ans = 0
        for i in xrange(M):
            for j in xrange(N):
                if grid[i][j]=='1':
                    dp[i+1][j+1] = min(dp[i][j], dp[i][j+1], dp[i+1][j])+1
                    ans = max(ans, dp[i+1][j+1])
        return ans**2",data\repos\leetcode-python\problems\python\maximal-square.py,maximalSquare,137
3655,maximal-square.py::maximalSquare::18,"    def maximalSquare(self, matrix):
        """"""
        dp[i][j] := maximal square length with matrix[i-1][j-1] at the bottom right corner in the square
        """"""
        ans = 0
        N = len(matrix)
        M = len(matrix[0])
        
        dp = [[0 for _ in xrange(M+1)] for _ in xrange(N+1)]
        
        for i in xrange(1, N+1):
            for j in xrange(1, M+1):
                if matrix[i-1][j-1]=='1':
                    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])+1
                    ans = max(ans, dp[i][j]**2)
        return ans",data\repos\leetcode-python\problems\python\maximal-square.py,maximalSquare,170
3656,maximum-average-subtree.py::maximumAverageSubtree::12,"    def maximumAverageSubtree(self, root):
        def getAVGAndCount(node):
            if not node: return 0, 0
            leftAvg, leftCount = getAVGAndCount(node.left)
            rightAvg, rightCount = getAVGAndCount(node.right)
            
            count = leftCount+rightCount+1
            avg = (leftAvg*leftCount + rightAvg*rightCount + node.val)/float(count)
            
            self.ans = max(self.ans, avg)
            return avg, count
        
        getAVGAndCount(root)
        return self.ans",data\repos\leetcode-python\problems\python\maximum-average-subtree.py,maximumAverageSubtree,127
3657,maximum-average-subtree.py::getAVGAndCount::13,"        def getAVGAndCount(node):
            if not node: return 0, 0
            leftAvg, leftCount = getAVGAndCount(node.left)
            rightAvg, rightCount = getAVGAndCount(node.right)
            
            count = leftCount+rightCount+1
            avg = (leftAvg*leftCount + rightAvg*rightCount + node.val)/float(count)
            
            self.ans = max(self.ans, avg)
            return avg, count",data\repos\leetcode-python\problems\python\maximum-average-subtree.py,getAVGAndCount,103
3658,maximum-compatibility-score-sum.py::maxCompatibilitySum::9,"    def maxCompatibilitySum(self, students, mentors):
        M = len(students)
        N = len(students[0])

        #initialize reverseScores
        reverseScores = [[0]*M for _ in xrange(M)]
        for i in xrange(M):
            for j in xrange(M):
                reverseScore = 0
                for k in xrange(N):
                    if students[i][k]!=mentors[j][k]:
                        reverseScore += 1
                reverseScores[i][j] = reverseScore
        
        #Dijkstra
        startState = '0'*M
        endState = '1'*M
        visited = set()
        pq = [(0, startState)]
        
        while pq:
            cost, state = heapq.heappop(pq)
            if state in visited: continue
            visited.add(state)
            
            if state==endState: return M*N-cost
            
            j = state.count('1')
            for i in xrange(M):
                if state[i]=='1': continue
                
                nextState = state[:i]+'1'+state[i+1:]
                if nextState in visited: continue
                heapq.heappush(pq, (cost+reverseScores[i][j], nextState))
        
        return -1",data\repos\leetcode-python\problems\python\maximum-compatibility-score-sum.py,maxCompatibilitySum,256
3659,maximum-depth-of-binary-tree.py::maxDepth::6,"    def maxDepth(self, root):
        if not root: return 0
        
        stack = []
        stack.append((root, 1))
        max_depth = 0
        
        while stack:
            node, depth = stack.pop()
            max_depth = max(max_depth, depth)
            if node.left:
                stack.append((node.left, depth+1))
            if node.right:
                stack.append((node.right, depth+1))
        return max_depth",data\repos\leetcode-python\problems\python\maximum-depth-of-binary-tree.py,maxDepth,95
3660,maximum-depth-of-binary-tree.py::maxDepth::30,"    def maxDepth(self, root):
        if not root: return 0
        
        ans = float('-inf')
        q = collections.deque([(root, 1)])
        node = root
        
        while q:
            node, d = q.popleft()
            
            ans = max(ans, d)
            
            if node.left: q.append((node.left, d+1))
            if node.right: q.append((node.right, d+1))
        
        return ans",data\repos\leetcode-python\problems\python\maximum-depth-of-binary-tree.py,maxDepth,98
3661,maximum-length-of-repeated-subarray.py::findLength::2,"    def findLength(self, A, B):
        M, N = len(A), len(B)
        
        #dp[i][j] := the logest length of sub array that needs to involve A[i] and B[j]
        dp = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]
            
        for i in xrange(1, M+1):
            for j in xrange(1, N+1):
                if A[i-1]==B[j-1]:
                    dp[i][j] = dp[i-1][j-1]+1
                    
        return max(max(row) for row in dp)",data\repos\leetcode-python\problems\python\maximum-length-of-repeated-subarray.py,findLength,135
3662,maximum-number-of-events-that-can-be-attended.py::maxEvents::6,"    def maxEvents(self, A):
        d = 0
        count = 0
        h = [] #a heap. store the started event
        A.sort(reverse=True)
        
        #for each day, attend the event with smallest endtime, so we can have the most free time in the future.
        while A or h:
            if not h: d = A[-1][0]
            
            while A and A[-1][0]<=d:
                heapq.heappush(h, A.pop()[1])
            
            heapq.heappop(h) #attend the event with smallest endtime
            count += 1
            d += 1
            
            while h and h[0]<d: heapq.heappop(h) #remove the ended event
        
        return count",data\repos\leetcode-python\problems\python\maximum-number-of-events-that-can-be-attended.py,maxEvents,164
3663,maximum-number-of-visible-points.py::visiblePoints::12,"    def visiblePoints(self, points, angle, location):
        def getAngle(x, y):
            #4 axis
            if x>0 and y==0:
                return 0
            elif x==0 and y>0:
                return 90
            elif x<0 and y==0:
                return 180
            elif x==0 and y<0:
                return 270
            
            #4 quadrant
            if x>0 and y>0:
                return math.degrees(math.atan2(abs(y), abs(x)))
            elif x<0 and y>0:
                return 180-math.degrees(math.atan2(abs(y), abs(x)))
            elif x<0 and y<0:
                return 180+math.degrees(math.atan2(abs(y), abs(x)))
            else:
                return 360-math.degrees(math.atan2(abs(y), abs(x)))
            
        ans = 0
        onLocation = 0
        angles = []
        
        for x, y in points:
            if x==location[0] and y==location[1]:
                onLocation += 1
            else:
                a = getAngle(x-location[0], y-location[1])
                angles.append(a)
                if a<=angle: angles.append(360+a) #[1]
        
        angles.sort()
        
        i = 0
        for j in xrange(len(angles)):
            while angles[j]-angles[i]>angle:
                i += 1
            ans = max(ans, j-i+1)
                
        return ans+onLocation",data\repos\leetcode-python\problems\python\maximum-number-of-visible-points.py,visiblePoints,330
3664,maximum-number-of-visible-points.py::getAngle::13,"        def getAngle(x, y):
            #4 axis
            if x>0 and y==0:
                return 0
            elif x==0 and y>0:
                return 90
            elif x<0 and y==0:
                return 180
            elif x==0 and y<0:
                return 270
            
            #4 quadrant
            if x>0 and y>0:
                return math.degrees(math.atan2(abs(y), abs(x)))
            elif x<0 and y>0:
                return 180-math.degrees(math.atan2(abs(y), abs(x)))
            elif x<0 and y<0:
                return 180+math.degrees(math.atan2(abs(y), abs(x)))
            else:
                return 360-math.degrees(math.atan2(abs(y), abs(x)))",data\repos\leetcode-python\problems\python\maximum-number-of-visible-points.py,getAngle,176
3665,maximum-product-of-three-numbers.py::maximumProduct::13,"    def maximumProduct(self, nums):
        min1 = float('inf') #smallest
        min2 = float('inf') #second smallest

        max1 = float('-inf') #largest
        max2 = float('-inf') #second largest
        max3 = float('-inf') #third largest

        for n in nums:
            if n<=min1:
                min2 = min1
                min1 = n
            elif n<=min2:
                min2 = n
            
            if n>=max1:
                max3 = max2
                max2 = max1
                max1 = n
            elif n>=max2:
                max3 = max2
                max2 = n
            elif n>=max3:
                max3 = n

        return max(min1*min2*max1, max1*max2*max3)",data\repos\leetcode-python\problems\python\maximum-product-of-three-numbers.py,maximumProduct,188
3666,maximum-product-subarray.py::maxProduct::9,"    def maxProduct(self, nums):
        if not nums: return 0
        dp = [[float('-inf'), float('inf')] for _ in xrange(len(nums))]
        
        dp[0] = [nums[0], nums[0]]
        ans = nums[0]
        
        for i in xrange(1, len(nums)):
            if nums[i]==0:
                dp[i][0] = 0
                dp[i][1] = 0
            elif nums[i]>0:
                dp[i][0] = dp[i-1][0]*nums[i] if dp[i-1][0]>0 else nums[i]
                dp[i][1] = dp[i-1][1]*nums[i] if dp[i-1][1]<=0 else nums[i]
            else:
                dp[i][0] = dp[i-1][1]*nums[i] if dp[i-1][1]<=0 else nums[i]
                dp[i][1] = dp[i-1][0]*nums[i] if dp[i-1][0]>0 else nums[i]
                
            ans = max(ans, dp[i][0])
            
        return ans",data\repos\leetcode-python\problems\python\maximum-product-subarray.py,maxProduct,244
3667,maximum-product-subarray.py::maxProduct::35,"    def maxProduct(self, nums):
        if not nums: return 0
        
        maxLast = nums[0]
        minLast = nums[0]
        ans = nums[0]
        
        for i in xrange(1, len(nums)):
            if nums[i]==0:
                newMax = 0
                newMin = 0
            elif nums[i]>0:
                newMax = maxLast*nums[i] if maxLast>0 else nums[i]
                newMin = minLast*nums[i] if minLast<=0 else nums[i]
            else:
                newMax = minLast*nums[i] if minLast<=0 else nums[i]
                newMin = maxLast*nums[i] if maxLast>0 else nums[i]
            
            maxLast = newMax
            minLast = newMin
            ans = max(ans, maxLast)
            
        return ans",data\repos\leetcode-python\problems\python\maximum-product-subarray.py,maxProduct,187
3668,maximum-subarray-sum-with-one-deletion.py::maximumSum::13,"    def maximumSum(self, arr):
        if not arr: return arr
        if len(arr)==1: return arr[0]
        
        dp = [[0, 0] for _ in xrange(len(arr))]
        subarrayMaxSum = arr[0]
        
        for i in xrange(len(arr)):
            if i==0:
                dp[i][0] = arr[i]
                dp[i][1] = arr[i]
            else:
                dp[i][0] = max(dp[i-1][0]+arr[i], arr[i])
                dp[i][1] = max(dp[i-1][0], dp[i-1][1]+arr[i])
            subarrayMaxSum = max(subarrayMaxSum, dp[i][0], dp[i][1])
        
        return subarrayMaxSum",data\repos\leetcode-python\problems\python\maximum-subarray-sum-with-one-deletion.py,maximumSum,168
3669,maximum-subarray.py::maxSubArray::17,"    def maxSubArray(self, nums):
        if nums==None or len(nums)==0: return None
        maxCurrent = [nums[0]] #[1]
        for i in xrange(1, len(nums)):
            maxCurrent.append(max(nums[i], nums[i]+maxCurrent[-1])) #[0]
        return max(maxCurrent) #[2]",data\repos\leetcode-python\problems\python\maximum-subarray.py,maxSubArray,74
3670,maximum-subarray.py::maxSubArray::26,"    def maxSubArray(self, nums):
        ans = nums[0]
        last_max = nums[0]
        
        for i in xrange(len(nums)):
            if i==0: continue
            last_max = max(nums[i], nums[i]+last_max)
            ans = max(ans, last_max)
            
        return ans",data\repos\leetcode-python\problems\python\maximum-subarray.py,maxSubArray,68
3671,maximum-swap.py::maximumSwap::8,"    def maximumSwap(self, num):
        numList = [int(n) for n in str(num)]
        positions = collections.defaultdict(list)
        for i, n in enumerate(numList): positions[n].append(i) #[1]
        
        i = 0
        for i, n1 in enumerate(numList): #[2]
            n1 = numList[i]
            for n2 in xrange(9, n1, -1): 
                if n2 in positions and len(positions[n2])>0:
                    j = positions[n2][-1] #[3]
                    numList[i], numList[j] = numList[j], numList[i]
                    return int(''.join([str(n) for n in numList]))
            positions[n1].pop(0) #[4]
            
        return num",data\repos\leetcode-python\problems\python\maximum-swap.py,maximumSwap,172
3672,maximum-units-on-a-truck.py::maximumUnits::2,"    def maximumUnits(self, boxTypes, truckSize):
        sortedBox = []
        ans = 0
        
        for count, units in boxTypes:
            sortedBox.append((units, count))
        
        sortedBox.sort()
        
        while sortedBox and truckSize>0:
            units, count = sortedBox.pop()
            d = min(count, truckSize)
            truckSize -= d
            ans += d*units
            
        return ans",data\repos\leetcode-python\problems\python\maximum-units-on-a-truck.py,maximumUnits,92
3673,median-of-two-sorted-arrays.py::findMedianSortedArrays::54,"    def findMedianSortedArrays(self, A, B):
        if len(A)>len(B): A, B = B, A #[0]

        M, N = len(A), len(B)
        l, r = 0, M

        while l<=r:
            i = (r+l)/2
            j = (M+N)/2-i #[1]

            max_left_A = A[i-1] if i>0 else float('-inf') #[2]
            max_left_B = B[j-1] if j>0 else float('-inf')

            min_right_A = A[i] if M-i>0 else float('inf')
            min_right_B = B[j] if N-j>0 else float('inf')

            if max_left_A<=min_right_B and max_left_B<=min_right_A:
                if (M+N)%2==0:
                    return (max(max_left_A, max_left_B)+min(min_right_A, min_right_B))/2.0
                else:
                    return min(min_right_A, min_right_B) #[1]
            elif min_right_B<max_left_A:
                r = i-1
            else:
                l = i+1
        return None",data\repos\leetcode-python\problems\python\median-of-two-sorted-arrays.py,findMedianSortedArrays,255
3674,median-of-two-sorted-arrays.py::findMedianSortedArrays::128,"    def findMedianSortedArrays(self, X, Y):
        if len(X)>len(Y): X, Y = Y, X
        M, N = len(X), len(Y)

        after = (M+N-1)/2
        l, r = 0, M

        while l<r:
            i = (l+r)/2
            if after-i-1 < 0 or X[i] >= Y[after-i-1]:
                r = i
            else:
                l = i + 1
        i = l
        nextfew = sorted(X[i:i+2] + Y[after-i:after-i+2])
        return (nextfew[0]+nextfew[1-(M+N)%2])/2.0",data\repos\leetcode-python\problems\python\median-of-two-sorted-arrays.py,findMedianSortedArrays,159
3675,meeting-rooms-ii.py::minMeetingRooms::8,"    def minMeetingRooms(self, intervals):
        if len(intervals)==0: return 0
        
        timeline = {}
        room_open = 0
        result = 0
        
        for inter in intervals:
            if inter.start not in timeline:
                timeline[inter.start] = [1, 0]
            else:
                timeline[inter.start][0]+=1
            if inter.end not in timeline:
                timeline[inter.end] = [0, 1]
            else:
                timeline[inter.end][1]+=1

        for time in timeline.keys().sort():
            room_open-=timeline[time][1]
            room_open+=timeline[time][0]
            result = max(result, room_open)

        return result",data\repos\leetcode-python\problems\python\meeting-rooms-ii.py,minMeetingRooms,153
3676,meeting-rooms-ii.py::minMeetingRooms::41,"    def minMeetingRooms(self, intervals):
        if not intervals: return 0

        free_rooms = []
        intervals.sort(key= lambda x: x.start)

        heapq.heappush(free_rooms, intervals[0].end)
        for i in intervals[1:]:
            if free_rooms[0]<=i.start:
                heapq.heappop(free_rooms)
            heapq.heappush(free_rooms, i.end)

        return len(free_rooms)",data\repos\leetcode-python\problems\python\meeting-rooms-ii.py,minMeetingRooms,95
3677,meeting-rooms-ii.py::minMeetingRooms::73,"    def minMeetingRooms(self, intervals):
        intervals.sort()
        h = [intervals[0][1]]
        
        for i in xrange(1, len(intervals)):
            start = intervals[i][0]
            end = intervals[i][1]
            
            if start>=h[0]:
                #the room at h[0] is avaliable
                heapq.heappop(h)
            heapq.heappush(h, end)
            
        return len(h)",data\repos\leetcode-python\problems\python\meeting-rooms-ii.py,minMeetingRooms,97
3678,meeting-rooms-ii.py::minMeetingRooms::96,"    def minMeetingRooms(self, intervals):
        if not intervals: return 0
        ans = 1
        h = []
        
        intervals.sort()
        heapq.heappush(h, (intervals[0][1], intervals[0][0]))
        
        for i in xrange(1, len(intervals)):
            s = intervals[i][0]
            e = intervals[i][1]
            
            e0, s0 = h[0]
            
            if s>=e0: heapq.heappop(h)
            heapq.heappush(h, (e, s))
            ans = max(ans, len(h))
            
        return ans",data\repos\leetcode-python\problems\python\meeting-rooms-ii.py,minMeetingRooms,134
3679,meeting-rooms.py::canAttendMeetings::8,"    def canAttendMeetings(self, intervals):
        intervals.sort()
        
        for i in xrange(len(intervals)-1):
            end = intervals[i][1]
            nextStart = intervals[i+1][0]
            if end>nextStart: return False
        
        return True",data\repos\leetcode-python\problems\python\meeting-rooms.py,canAttendMeetings,58
3680,merge-intervals.py::merge::15,"    def merge(self, intervals):
        result = []
        intervals.sort() #[1]
        
        for inter in intervals:
            if len(result)>0 and result[-1][1]>=inter[0]: #[2]
                result[-1][1] = max(result[-1][1], inter[1]) #[3]
            else: #[4]
                result.append(inter) 
        return result",data\repos\leetcode-python\problems\python\merge-intervals.py,merge,82
3681,merge-intervals.py::merge::28,"    def merge(self, intervals):
        intervals.sort()
        
        i = 0
        while i<len(intervals)-1:
            if intervals[i][1]>=intervals[i+1][0]:
                intervals = intervals[:i] + [[min(intervals[i][0], intervals[i+1][0]), max(intervals[i][1], intervals[i+1][1])]] + intervals[i+2:]
            else:
                i += 1
        return intervals",data\repos\leetcode-python\problems\python\merge-intervals.py,merge,98
3682,merge-k-sorted-lists.py::mergeKLists::14,"    def mergeKLists(self, lists):
        h = [(node.val, node) for node in lists if node]
        heapq.heapify(h)
        
        preHead = ListNode()
        curr = preHead
        
        while h:
            _, node = heapq.heappop(h)
            if node.next: heapq.heappush(h, (node.next.val, node.next))
            curr.next = node
            curr = curr.next
        
        return preHead.next",data\repos\leetcode-python\problems\python\merge-k-sorted-lists.py,mergeKLists,94
3683,merge-sorted-array.py::merge::3,"    def merge(self, nums1, m, nums2, n):
        #Compare nums1 and nums2 from backward
        #Put the larger one to nums1's end
        #If one of the array is done
        #The rest is already sorted
        #Just put them in place
        
        i = m+n-1 #cursor on nums1 that we are editting
        i1 = m-1 #cursor on nums1
        i2 = n-1 #cursor on nums2
        
        while i1>=0 and i2>=0:
            if nums1[i1]>nums2[i2]:
                nums1[i] = nums1[i1]
                i1 = i1-1
                i = i-1
            else:
                nums1[i] = nums2[i2]
                i2 = i2-1
                i = i-1
        
        #One of the array is done, put the rest in place
        nums1[:i2+1] = nums2[:i2+1]",data\repos\leetcode-python\problems\python\merge-sorted-array.py,merge,222
3684,merge-two-sorted-lists.py::mergeTwoLists::4,"    def mergeTwoLists(self, l1, l2):
        pre_head = ListNode(-1)
        curr = pre_head
        
        while l1 and l2:
            if l1.val<l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
            
        if l1: curr.next = l1
        if l2: curr.next = l2
            
        return pre_head.next",data\repos\leetcode-python\problems\python\merge-two-sorted-lists.py,mergeTwoLists,110
3685,min-cost-climbing-stairs.py::minCostClimbingStairs::13,"    def minCostClimbingStairs(self, cost):
        if cost is None or len(cost)==0: return 0
        memo = [0]*(len(cost)+1)
        
        for i in xrange(len(memo)):
            if i==0 or i==1:
                memo[i] = 0
            else:
                memo[i] = min(memo[i-1]+cost[i-1], memo[i-2]+cost[i-2])
                
        return memo[-1]",data\repos\leetcode-python\problems\python\min-cost-climbing-stairs.py,minCostClimbingStairs,104
3686,min-cost-climbing-stairs.py::minCostClimbingStairs::27,"    def minCostClimbingStairs(self, cost):
        def helper(i):
            if i in history: return history[i]
            
            if i>len(cost)-1:
                history[i] = 0
            elif i==len(cost)-1 or i==len(cost)-2:
                history[i] = cost[i]
            elif i<len(cost)-2:
                history[i] = cost[i] + min(helper(i+1), helper(i+2))
                
            return history[i]
        
        history = {}
        return min(helper(0), helper(1))",data\repos\leetcode-python\problems\python\min-cost-climbing-stairs.py,minCostClimbingStairs,120
3687,min-cost-climbing-stairs.py::helper::28,"        def helper(i):
            if i in history: return history[i]
            
            if i>len(cost)-1:
                history[i] = 0
            elif i==len(cost)-1 or i==len(cost)-2:
                history[i] = cost[i]
            elif i<len(cost)-2:
                history[i] = cost[i] + min(helper(i+1), helper(i+2))
                
            return history[i]",data\repos\leetcode-python\problems\python\min-cost-climbing-stairs.py,helper,91
3688,minimize-malware-spread.py::minMalwareSpread::45,"    def minMalwareSpread(self, graph, initial):
        colored = set()
        initial_set = set(initial)
        color_data = {} #[4]
        color = 0
        
        def dfs(node, c):
            stack = [node]
            while stack:
                n = stack.pop()
                if n in colored: continue #[1]
                colored.add(n)

                if n in initial_set:
                    color_data[c][0].append(n)
                color_data[c][1]+=1

                for nb in xrange(len(graph)):
                    if graph[n][nb]==1:
                        stack.append(nb)
                
        # [0]
        for node in initial:
            if color not in color_data:
                color_data[color] = [[], 0]

            dfs(node, color)
            color+=1

        ans = min(initial)
        max_infected = float('-inf')
        for c in color_data.keys():
            if len(color_data[c][0])!=1: continue #[3]
            n = color_data[c][0][0]
            infected = color_data[c][1]

            if color_data[c][1]>max_infected: #[2]
                max_infected = infected
                ans = n
            elif infected==max_infected and n<ans:
                ans = n

        return ans",data\repos\leetcode-python\problems\python\minimize-malware-spread.py,minMalwareSpread,272
3689,minimize-malware-spread.py::dfs::51,"        def dfs(node, c):
            stack = [node]
            while stack:
                n = stack.pop()
                if n in colored: continue #[1]
                colored.add(n)

                if n in initial_set:
                    color_data[c][0].append(n)
                color_data[c][1]+=1

                for nb in xrange(len(graph)):
                    if graph[n][nb]==1:
                        stack.append(nb)",data\repos\leetcode-python\problems\python\minimize-malware-spread.py,dfs,86
3690,minimum-ascii-delete-sum-for-two-strings.py::minimumDeleteSum::2,"    def minimumDeleteSum(self, s1, s2):
        N, M = len(s1), len(s2)
        dp = [[float('inf') for _ in xrange(M+1)] for _ in xrange(N+1)]
        
        dp[0][0] = 0
        
        for i in xrange(1, N+1):
            dp[i][0] = dp[i-1][0]+ord(s1[i-1])
            
        for j in xrange(1, M+1):
            dp[0][j] = dp[0][j-1]+ord(s2[j-1])
        
        for i in xrange(1, N+1):
            for j in xrange(1, M+1):
                if s1[i-1]==s2[j-1]:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
                dp[i][j] = min(dp[i][j], dp[i][j-1]+ord(s2[j-1]), dp[i-1][j]+ord(s1[i-1]))
        
        return dp[N][M]",data\repos\leetcode-python\problems\python\minimum-ascii-delete-sum-for-two-strings.py,minimumDeleteSum,241
3691,minimum-cost-to-connect-sticks.py::connectSticks::2,"    def connectSticks(self, sticks):
        if not sticks or len(sticks)==1: return 0
        h = []
        
        for n in sticks:
            heapq.heappush(h, n)
        
        cost = 0
        while len(h)>1:
            currSum = heapq.heappop(h)+heapq.heappop(h)
            cost += currSum
            heapq.heappush(h, currSum)
        
        return cost",data\repos\leetcode-python\problems\python\minimum-cost-to-connect-sticks.py,connectSticks,95
3692,minimum-cost-to-hire-k-workers.py::mincostToHireWorkers::26,"    def mincostToHireWorkers(self, quality, wage, k):
        cost = float('inf')
        
        workers = [(wage[i]/float(quality[i]), quality[i], wage[i]) for i in xrange(len(quality))]
        workers = sorted(workers)
        
        paidGroup = []
        sumQ = 0
        
        for r, q, w in workers:
            heapq.heappush(paidGroup, -q)
            sumQ += q
            
            if len(paidGroup)>k:
                sumQ -= -heapq.heappop(paidGroup)
            
            if len(paidGroup)==k:
                cost = min(cost, sumQ*r)
        
        return cost",data\repos\leetcode-python\problems\python\minimum-cost-to-hire-k-workers.py,mincostToHireWorkers,146
3693,minimum-cost-to-make-at-least-one-valid-path-in-a-grid.py::minCost::2,"    def minCost(self, grid):
        pq = [(0, False, 0, 0, 0)]
        visited = set()
        M = len(grid)
        N = len(grid[0])
        
        while pq:
            cost, modified, direction, x, y = heapq.heappop(pq)
            if x<0 or x>=M or y<0 or y>=N: continue
            if (direction, x, y) in visited: continue
            visited.add((direction, x, y))
            
            if x==M-1 and y==N-1: return cost
            
            if direction==0: direction = grid[x][y]

            if direction==1:
                heapq.heappush(pq, (cost, False, 0, x, y+1))
            elif direction==2:
                heapq.heappush(pq, (cost, False, 0, x, y-1))
            elif direction==3:
                heapq.heappush(pq, (cost, False, 0, x+1, y))
            elif direction==4:
                heapq.heappush(pq, (cost, False, 0, x-1, y))
        
            if not modified:    
                for d in [1,2,3,4]:
                    if d==grid[x][y]: continue
                    heapq.heappush(pq, (cost+1, True, d, x, y))
                            
        return float('inf')",data\repos\leetcode-python\problems\python\minimum-cost-to-make-at-least-one-valid-path-in-a-grid.py,minCost,313
3694,minimum-cost-to-reach-city-with-discounts.py::minimumCost::2,"    def minimumCost(self, n, highways, discounts):
        pq = [(0, discounts, 0)]
        visited = set()
        
        adj = collections.defaultdict(list)
        for city1, city2, toll in highways:
            adj[city1].append((city2, toll))
            adj[city2].append((city1, toll))
        
        
        while pq:
            toll, d, city = heapq.heappop(pq)
            if (d, city) in visited: continue
            visited.add((d, city))
            
            if city==n-1: return toll
            
            for nei, toll2 in adj[city]:
                if (d, nei) not in visited:
                    heapq.heappush(pq, (toll+toll2, d, nei))
                if d>0 and (d-1, nei) not in visited:
                    heapq.heappush(pq, (toll+toll2/2, d-1, nei))    
        
        return -1",data\repos\leetcode-python\problems\python\minimum-cost-to-reach-city-with-discounts.py,minimumCost,213
3695,minimum-depth-of-binary-tree.py::minDepth::9,"    def minDepth(self, root):
        if not root: return 0
        q = deque()
        q.append((root, 1))
        
        while q:
            node, depth = q.popleft()
            if not node.left and not node.right:
                return depth
            if node.left:
                q.append((node.left, depth+1))
            if node.right:
                q.append((node.right, depth+1))",data\repos\leetcode-python\problems\python\minimum-depth-of-binary-tree.py,minDepth,91
3696,minimum-depth-of-binary-tree.py::minDepth::32,"    def minDepth(self, root):
        if not root: return 0
        q = collections.deque([(root, 1)])
        
        while q:
            node, depth = q.popleft()
            
            if not node.left and not node.right: return depth
            
            if node.left: q.append((node.left, depth+1))
            if node.right: q.append((node.right, depth+1))
        
        return 'ERROR'",data\repos\leetcode-python\problems\python\minimum-depth-of-binary-tree.py,minDepth,93
3697,minimum-difficulty-of-a-job-schedule.py::minDifficulty::7,"    def minDifficulty(self, D, K):
        if not D or not K or K>len(D): return -1
        N = len(D)

        maxInRange = [[0 for _ in xrange(N)] for _ in xrange(N)]
        for i in xrange(N): maxInRange[i][i] = D[i]
        for l in xrange(2, N+1):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                maxInRange[i][j] = max(maxInRange[i+1][j-1], D[i], D[j])

        dp = [[float('inf') for _ in xrange(K+1)] for _ in xrange(N+1)]
        dp[0][0] = 0

        for i in xrange(1, N+1):
            for k in xrange(1, min(i, K)+1):
                for j in xrange(k, i+1):
                    dp[i][k] = min(dp[i][k], dp[j-1][k-1]+maxInRange[j-1][i-1])
                    
                    #if you don't pre-calculate maxInRange
                    #dp[i][k] = min(dp[i][k], dp[j-1][k-1]+max(D[j-1:i]))
        return dp[N][K]",data\repos\leetcode-python\problems\python\minimum-difficulty-of-a-job-schedule.py,minDifficulty,283
3698,minimum-falling-path-sum-ii.py::minFallingPathSum::16,"    def minFallingPathSum(self, A):
        def getMin(i, j):
            minN = float('inf')
            for idx, n in enumerate(dp[i]):
                if j==idx: continue
                minN = min(minN, n)
            return minN
                
        if not A or not A[0]: return 0
        if len(A)==1: return min(A)
        
        history = collections.defaultdict(list)
        
        dp = [[0 for _ in xrange(len(A[0]))] for _ in xrange(len(A))]
        
        for i in xrange(len(A)):
            for j in xrange(len(A[0])):
                dp[i][j] = getMin(i-1, j) + A[i][j]

        return min(dp[-1])",data\repos\leetcode-python\problems\python\minimum-falling-path-sum-ii.py,minFallingPathSum,164
3699,minimum-falling-path-sum-ii.py::minFallingPathSum::37,"    def minFallingPathSum(self, A):
        if not A or not A[0]: return 0
        if len(A)==1: return min(A)

        dp = [[0 for _ in xrange(len(A[0]))] for _ in xrange(len(A))]

        for i in xrange(len(A)):
            h = heapq.nsmallest(2, dp[i-1]) if i>0 else [0, 0]
            for j in xrange(len(A[0])):
                dp[i][j] = (h[1] if h[0]==dp[i-1][j] else h[0]) + A[i][j]

        return min(dp[-1])",data\repos\leetcode-python\problems\python\minimum-falling-path-sum-ii.py,minFallingPathSum,145
3700,minimum-falling-path-sum-ii.py::getMin::17,"        def getMin(i, j):
            minN = float('inf')
            for idx, n in enumerate(dp[i]):
                if j==idx: continue
                minN = min(minN, n)
            return minN",data\repos\leetcode-python\problems\python\minimum-falling-path-sum-ii.py,getMin,48
3701,minimum-knight-moves.py::minKnightMoves::3,"    def minKnightMoves(self, x, y):
        offsets = [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]
        q1 = collections.deque([(0, 0)])
        q2 = collections.deque([(x, y)])
        steps1 = {(0, 0): 0} #steps needed starting from (0, 0)
        steps2 = {(x, y): 0} #steps needed starting from (x,y)
        
        while q1 and q2:
            i1, j1 = q1.popleft()
            if (i1, j1) in steps2: return steps1[(i1, j1)]+steps2[(i1, j1)]
            
            i2, j2 = q2.popleft()
            if (i2, j2) in steps1: return steps1[(i2, j2)]+steps2[(i2, j2)]
            
            for ox, oy in offsets:
                nextI1 = i1+ox
                nextJ1 = j1+oy
                if (nextI1, nextJ1) not in steps1:
                    q1.append((nextI1, nextJ1))
                    steps1[(nextI1, nextJ1)] = steps1[(i1, j1)]+1
                
                nextI2 = i2+ox
                nextJ2 = j2+oy
                if (nextI2, nextJ2) not in steps2:
                    q2.append((nextI2, nextJ2))
                    steps2[(nextI2, nextJ2)] = steps2[(i2, j2)]+1
                
        return float('inf')",data\repos\leetcode-python\problems\python\minimum-knight-moves.py,minKnightMoves,395
3702,minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py::minFlips::2,"    def minFlips(self, mat):
        def flip(mat, m, n):
            mat[m][n] = 0 if mat[m][n]==1 else 1
            if m+1<len(mat): mat[m+1][n] = 0 if mat[m+1][n]==1 else 1
            if n+1<len(mat[0]): mat[m][n+1] = 0 if mat[m][n+1]==1 else 1
            if m-1>=0: mat[m-1][n] = 0 if mat[m-1][n]==1 else 1
            if n-1>=0: mat[m][n-1] = 0 if mat[m][n-1]==1 else 1
            
        def check(mat, state):
            for i, b in enumerate(state):
                if b=='1':
                    m = i/len(mat[0])
                    n = i%len(mat[0])
                    flip(mat, m, n)
            
            for i in xrange(len(mat)):
                for j in xrange(len(mat[0])):
                    if mat[i][j]==1: return False
            
            return True
                    
        
        M = len(mat)
        N = len(mat[0])
        q = collections.deque(['0'*(M*N)])
        visited = set()
        
        while q:
            state = q.popleft()
            if state in visited: continue
            visited.add(state)
            
            if check([row[:] for row in mat], state): return state.count('1')
            
            for i in xrange(len(state)):
                if state[i]=='1': continue
                nextState = state[:i] + '1' +state[i+1:]
                q.append(nextState)
                
        return -1",data\repos\leetcode-python\problems\python\minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py,minFlips,373
3703,minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py::flip::3,"        def flip(mat, m, n):
            mat[m][n] = 0 if mat[m][n]==1 else 1
            if m+1<len(mat): mat[m+1][n] = 0 if mat[m+1][n]==1 else 1
            if n+1<len(mat[0]): mat[m][n+1] = 0 if mat[m][n+1]==1 else 1
            if m-1>=0: mat[m-1][n] = 0 if mat[m-1][n]==1 else 1
            if n-1>=0: mat[m][n-1] = 0 if mat[m][n-1]==1 else 1",data\repos\leetcode-python\problems\python\minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py,flip,154
3704,minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py::check::10,"        def check(mat, state):
            for i, b in enumerate(state):
                if b=='1':
                    m = i/len(mat[0])
                    n = i%len(mat[0])
                    flip(mat, m, n)
            
            for i in xrange(len(mat)):
                for j in xrange(len(mat[0])):
                    if mat[i][j]==1: return False
            
            return True",data\repos\leetcode-python\problems\python\minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py,check,84
3705,minimum-path-sum.py::minPathSum::13,"    def minPathSum(self, grid):
        n = len(grid)
        m = len(grid[0])
        for i in xrange(n):
            for j in xrange(m):
                s1 = s2 = float('inf')
                if i-1>=0:
                    s1 = grid[i-1][j]
                if j-1>=0:
                    s2 = grid[i][j-1]
                    
                if s1==float('inf') and s2==float('inf'): continue #both source out of range
                grid[i][j]+=min(s1, s2)
                
        return grid[-1][-1]",data\repos\leetcode-python\problems\python\minimum-path-sum.py,minPathSum,134
3706,minimum-score-triangulation-of-polygon.py::minScoreTriangulation::2,"    def minScoreTriangulation(self, values):
        N = len(values)
        dp = [[float('inf')]*N for _ in xrange(N)]
        
        for i in xrange(N-1):
            dp[i][i+1] = 0
        
        for l in xrange(3, N+1):
            for i in xrange(N-l+1):
                j = i+l-1
                
                for k in xrange(i+1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k]+values[i]*values[k]*values[j]+dp[k][j])
        return dp[0][N-1]",data\repos\leetcode-python\problems\python\minimum-score-triangulation-of-polygon.py,minScoreTriangulation,138
3707,minimum-size-subarray-sum.py::minSubArrayLen::6,"    def minSubArrayLen(self, target, nums):
        s = 0
        l = 0
        ans = float('inf')
        
        for i in xrange(len(nums)):
            s += nums[i]
            
            while s>=target:
                ans = min(i-l+1, ans)
                s -= nums[l]
                l += 1
        
        return ans if ans!=float('inf') else 0",data\repos\leetcode-python\problems\python\minimum-size-subarray-sum.py,minSubArrayLen,89
3708,minimum-swaps-to-group-all-1s-together.py::minSwaps::10,"    def minSwaps(self, data):
        L = 0 #sliding window length
        #initialize L
        for num in data:
            if num==1: L += 1
        
        count = 0 #count of 1 within the sliding window
        maxCount = 0 #max count of 1 within the sliding window

        #initialize the count from data[0] to data[L-1]
        for i in xrange(L):
            if data[i]==1: count += 1
        maxCount = count

        #slide the window
        for i in xrange(1, len(data)):
            #i: start index of the sliding window
            j = i+L-1 #end index of the sliding window
            if j>=len(data): break
            if data[j]==1: count += 1
            if data[i-1]==1: count -= 1
            maxCount = max(maxCount, count)
        
        return L-maxCount",data\repos\leetcode-python\problems\python\minimum-swaps-to-group-all-1s-together.py,minSwaps,210
3709,minimum-swaps-to-make-sequences-increasing.py::minSwap::2,"    def minSwap(self, A, B):
        keep = [float('inf') for _ in xrange(len(A))]
        swap = [float('inf') for _ in xrange(len(A))]
        
        keep[0] = 0
        swap[0] = 1
        
        for i in xrange(1, len(A)):
            
            if A[i]>A[i-1] and B[i]>B[i-1]:
                keep[i] = keep[i-1]
                swap[i] = swap[i-1]+1
                
            if A[i]>B[i-1] and B[i]>A[i-1]:
                keep[i] = min(keep[i], swap[i-1])
                swap[i] = min(swap[i], keep[i-1]+1)
                
        return min(keep[-1], swap[-1])",data\repos\leetcode-python\problems\python\minimum-swaps-to-make-sequences-increasing.py,minSwap,176
3710,minimum-time-difference.py::findMinDifference::6,"    def findMinDifference(self, timeStrings):
        def timeStringToMinutes(timeString):
            time = timeString.split(':')
            h = int(time[0])
            m = int(time[1])
            return h*60+m
        
        ans = float('inf')
        minTime = float('inf')
        maxTime = float('-inf')
        timeSet = set()
        for timeString in timeStrings:
            t = timeStringToMinutes(timeString)
            if t in timeSet: return 0
            minTime = min(minTime, t)
            maxTime = max(maxTime, t)
            timeSet.add(t)
        
        
        prev = None
        for t in xrange(minTime, maxTime+1):
            if t not in timeSet: continue
            if prev!=None: ans = min(ans, t-prev)
            prev = t
        
        ans = min(ans, 1440+minTime-maxTime) #compare minTime and maxTime
        return ans",data\repos\leetcode-python\problems\python\minimum-time-difference.py,findMinDifference,208
3711,minimum-time-difference.py::timeStringToMinutes::7,"        def timeStringToMinutes(timeString):
            time = timeString.split(':')
            h = int(time[0])
            m = int(time[1])
            return h*60+m",data\repos\leetcode-python\problems\python\minimum-time-difference.py,timeStringToMinutes,39
3712,minimum-window-substring.py::minWindow::13,"    def minWindow(self, s, t):
        ans = s
        ansFound = False
        windowCounter = collections.Counter()
        tCounter = collections.Counter(t)
        required = len(tCounter) #number of unique char in t
        actual = 0 #number of unique char in t in the window that has the count needed in tCounter
        r = l = 0
        
        while r<len(s):
            cr = s[r] #char right
            windowCounter[cr] += 1
            if cr in tCounter and windowCounter[cr]==tCounter[cr]: actual += 1
            
            #after having the desired window (actual==required)
            #update the ans
            #also start constrating the window from the left
            while l<=r and actual==required:
                if len(s[l:r+1])<=len(ans):
                    ans = s[l:r+1]
                    ansFound = True
                
                cl = s[l]
                windowCounter[cl] -= 1
                if cl in tCounter and windowCounter[cl]<tCounter[cl]: actual -= 1
                l += 1
            
            r += 1
        
        return ans if ansFound else """"",data\repos\leetcode-python\problems\python\minimum-window-substring.py,minWindow,257
3713,minimum-xor-sum-of-two-arrays.py::minimumXORSum::5,"    def minimumXORSum(self, nums1, nums2):
        N = len(nums1)
        
        pq = [(0, '0'*N)]
        visited = set()
        while pq:
            s, state = heapq.heappop(pq)
            if state in visited: continue
            visited.add(state)
            
            j = state.count('1')
            if j==N: return s
            
            for i in xrange(N):
                if state[i]=='1': continue
                nextState = state[:i]+'1'+state[i+1:]
                if nextState in visited: continue
                heapq.heappush(pq, ((s+(nums1[i]^nums2[j-1]), nextState)))
        
        return float('inf')",data\repos\leetcode-python\problems\python\minimum-xor-sum-of-two-arrays.py,minimumXORSum,153
3714,missing-number.py::missingNumber::6,"    def missingNumber(self, nums):
        maxNum = max(nums)
        s = set(nums)
        
        for num in xrange(maxNum+1):
            if num not in s:
                return num
        
        return maxNum+1",data\repos\leetcode-python\problems\python\missing-number.py,missingNumber,49
3715,missing-number.py::missingNumber::24,"    def missingNumber(self, nums):
        n = len(nums) #[1]
        expectedSum = n*(n+1)/2 #[0]
        actualSum = sum(nums)
        return expectedSum-actualSum",data\repos\leetcode-python\problems\python\missing-number.py,missingNumber,45
3716,most-frequent-subtree-sum.py::findFrequentTreeSum::3,"    def findFrequentTreeSum(self, root):
        def dfs(node):
            if not node: return 0
            s = dfs(node.left)+node.val+dfs(node.right)
            counter[s] += 1
            return s
        
        if not root: return []
        counter = Counter()
        dfs(root) #start counting

        max_freq = max(counter.values())
        return [v for v, freq in counter.items() if freq==max_freq]",data\repos\leetcode-python\problems\python\most-frequent-subtree-sum.py,findFrequentTreeSum,97
3717,most-frequent-subtree-sum.py::findFrequentTreeSum::29,"    def findFrequentTreeSum(self, root):
        def getSubtreeSum(node):
            if not node: return 0
            subtreeSum = node.val+getSubtreeSum(node.left)+getSubtreeSum(node.right)
            memo[subtreeSum] += 1
            return subtreeSum
        
        
        memo = collections.Counter()
        getSubtreeSum(root)
        mostFrequenctCount = max([memo[subtreeSum] for subtreeSum in memo])
        return [subtreeSum for subtreeSum in memo if memo[subtreeSum]==mostFrequenctCount]",data\repos\leetcode-python\problems\python\most-frequent-subtree-sum.py,findFrequentTreeSum,122
3718,most-frequent-subtree-sum.py::dfs::4,"        def dfs(node):
            if not node: return 0
            s = dfs(node.left)+node.val+dfs(node.right)
            counter[s] += 1
            return s",data\repos\leetcode-python\problems\python\most-frequent-subtree-sum.py,dfs,39
3719,most-frequent-subtree-sum.py::getSubtreeSum::30,"        def getSubtreeSum(node):
            if not node: return 0
            subtreeSum = node.val+getSubtreeSum(node.left)+getSubtreeSum(node.right)
            memo[subtreeSum] += 1
            return subtreeSum",data\repos\leetcode-python\problems\python\most-frequent-subtree-sum.py,getSubtreeSum,52
3720,most-stones-removed-with-same-row-or-column.py::removeStones::21,"    def removeStones(self, stones):
        def union(x, y):
            row = 'r'+str(x)
            col = 'c'+str(y)
            p1 = find(row)
            p2 = find(col)
            if p1==p2: return False
            parents[p2] = p1
            return True
        
        def find(c):
            p = parents[c]
            while p!=parents[p]:
                p = find(p)
            parents[c] = p
            return p
        
        parents = {}
        for x, y in stones:
            row = 'r'+str(x)
            col = 'c'+str(y)
            parents[row] = row
            parents[col] = col
        
        groupCount = len(parents)
        for x, y in stones:
            if union(x, y): groupCount -= 1
        
        return len(stones)-groupCount",data\repos\leetcode-python\problems\python\most-stones-removed-with-same-row-or-column.py,removeStones,188
3721,most-stones-removed-with-same-row-or-column.py::union::22,"        def union(x, y):
            row = 'r'+str(x)
            col = 'c'+str(y)
            p1 = find(row)
            p2 = find(col)
            if p1==p2: return False
            parents[p2] = p1
            return True",data\repos\leetcode-python\problems\python\most-stones-removed-with-same-row-or-column.py,union,62
3722,most-stones-removed-with-same-row-or-column.py::find::31,"        def find(c):
            p = parents[c]
            while p!=parents[p]:
                p = find(p)
            parents[c] = p
            return p",data\repos\leetcode-python\problems\python\most-stones-removed-with-same-row-or-column.py,find,34
3723,move-zeroes.py::moveZeroes::3,"    def moveZeroes(self, nums):
        # Loop through the array
        # Find the first number that are not 0
        # Switch it with the nums[0]
        # Now nums[0] has the right value
        #
        # Find the second number that are not 0
        # Switch it with the nums[1]
        # Now nums[1] has the right value
        # ...
        
        cursor = 0 #the array index sorted so far
        for i in range(0, len(nums)):
            num = nums[i]
            if num!=0:
                temp = nums[cursor]
                nums[cursor] = nums[i]
                nums[i] = temp
                cursor+=1",data\repos\leetcode-python\problems\python\move-zeroes.py,moveZeroes,153
3724,move-zeroes.py::moveZeroes::29,"    def moveZeroes(self, nums):
        j = 0
        
        for n in nums:
            if n!=0:
                nums[j] = n
                j += 1
        
        for i in xrange(j, len(nums)):
            nums[i] = 0
        
        return nums",data\repos\leetcode-python\problems\python\move-zeroes.py,moveZeroes,61
3725,moving-average-from-data-stream.py::next::8,"    def next(self, val):
        self.queue.append(val)
        
        if len(self.queue)>self.size:
            self.sum = self.sum+val-self.queue.popleft()
        else:
            self.sum = self.sum+val
            
        return self.sum/float(len(self.queue))",data\repos\leetcode-python\problems\python\moving-average-from-data-stream.py,next,58
3726,moving-average-from-data-stream.py::next::30,"    def next(self, val):
        if len(self.q)>=self.size:
            self.sum -= self.q.popleft()
        
        self.sum += val
        self.q.append(val)
        return float(self.sum)/len(self.q)",data\repos\leetcode-python\problems\python\moving-average-from-data-stream.py,next,48
3727,my-calendar-ii.py::book::17,"    def book(self, start, end):
        for s, e in self.overlaps:
            if not (e<=start or end<=s):
                return False
        
        for s, e in self.booked:
            if not (e<=start or end<=s):
                self.overlaps.append((max(start, s), min(end, e)))
        
        self.booked.append((start, end))
        return True",data\repos\leetcode-python\problems\python\my-calendar-ii.py,book,87
3728,n-ary-tree-level-order-traversal.py::levelOrder::4,"    def levelOrder(self, root):
        opt = []

        if not root: return opt

        q = deque()
        q.append((root, 0))

        while q:
            node, depth = q.popleft()
            if depth<len(opt):
                opt[depth].append(node.val)
            else:
                opt.append([node.val])
            if node.children:
                for child in node.children:
                    q.append((child, depth+1))
        return opt",data\repos\leetcode-python\problems\python\n-ary-tree-level-order-traversal.py,levelOrder,97
3729,n-ary-tree-postorder-traversal.py::postorder::8,"    def postorder(self, root):
        def helper(node):
            if not node: return
            for child in node.children:
                helper(child)
            opt.append(node.val)
        opt = []
        helper(root)
        return opt",data\repos\leetcode-python\problems\python\n-ary-tree-postorder-traversal.py,postorder,48
3730,n-ary-tree-preorder-traversal.py::preorder::8,"    def preorder(self, root):
        def helper(node):
            if not node: return
            opt.append(node.val)
            for child in node.children:
                helper(child)
        opt = []
        helper(root)
        return opt",data\repos\leetcode-python\problems\python\n-ary-tree-preorder-traversal.py,preorder,47
3731,nested-list-weight-sum.py::depthSum::6,"    def depthSum(self, nestedList, weight=1):
        counter = 0
        for e in nestedList:
            if e.isInteger():
                counter+=(e.getInteger()*weight)
            else:
                counter+=self.depthSum(e.getList(), weight+1)
        return counter",data\repos\leetcode-python\problems\python\nested-list-weight-sum.py,depthSum,59
3732,nested-list-weight-sum.py::depthSum::17,"    def depthSum(self, nestedList):
        counter = 0
        queue = [(1, e) for e in nestedList]
        while queue:
            weight, e = queue.pop(0)
            if e.isInteger():
                counter += e.getInteger()*weight
            else:
                for child_list in e.getList():
                    queue.append((weight+1, child_list))
                
        return counter",data\repos\leetcode-python\problems\python\nested-list-weight-sum.py,depthSum,83
3733,network-delay-time.py::networkDelayTime::34,"    def networkDelayTime(self, times, N, K):
        aj_list = collections.defaultdict(list) #[0]
        for u, v, w in times: 
            aj_list[u].append((w, v))
        
        dis = {} #[1]
        pq = [(0, K)] #[2]
        
        while pq:
            if len(dis)==N: break

            d, node = heapq.heappop(pq)
            if node in dis: continue #[3]

            dis[node] = d
            
            for d2, nb in aj_list[node]: #[4]
                if nb not in dis: #[3]
                    heapq.heappush(pq, (d+d2, nb)) #[2]
                    
        return max(dis.values()) if len(dis)==N else -1 #[5]",data\repos\leetcode-python\problems\python\network-delay-time.py,networkDelayTime,169
3734,network-delay-time.py::networkDelayTime::59,"    def networkDelayTime(self, times, N, K):
        ans = float('-inf')
        h = [(0, K)]
        visited = set()
        G = collections.defaultdict(list)
        
        for u, v, w in times:
            G[u].append((v, w))
        
        while h:
            time, node = heapq.heappop(h)
            
            if node in visited: continue
            visited.add(node)
            ans = max(ans, time)
            
            if len(visited)==N: return time
            for nei, time_to_nei in G[node]:
                heapq.heappush(h, (time+time_to_nei, nei))
        
        return -1",data\repos\leetcode-python\problems\python\network-delay-time.py,networkDelayTime,146
3735,network-delay-time.py::networkDelayTime::88,"    def networkDelayTime(self, times, n, k):
        G = collections.defaultdict(list) #adjacency list
        D = [float('inf')]*(n+1) #D[n] store the distance between n and k
        D[k] = 0
        h = [(0, k)]
        visited = set()
        
        #form the djacency list
        for u, v, w in times:
            G[u].append((v, w))
        
        #dijkstra
        while h:
            d1, node = heapq.heappop(h)
            if node in visited: continue
            visited.add(node)
            
            for nei, d2 in G[node]:
                if d1+d2<D[nei]:
                    D[nei] = d1+d2
                    heapq.heappush(h, (D[nei], nei))
        
        #iterate through the distance between n and k, find ans
        ans = float('-inf')
        for i, d in enumerate(D):
            if i==0: continue
            if d==float('inf'): return -1
            ans = max(ans, d)
        return ans",data\repos\leetcode-python\problems\python\network-delay-time.py,networkDelayTime,247
3736,network-delay-time.py::networkDelayTime::126,"    def networkDelayTime(self, times, N, K):
        ans = -1 #max time from K to any
        visited = set()
        pq = [(0, K)] #[(node's distance to K, node)]
        
        #construct adjacency list
        adj = collections.defaultdict(list)
        for u, v, w in times:
            adj[u].append((w, v))
            
        while pq:
            dis, node = heapq.heappop(pq)
            if node in visited: continue
            visited.add(node)
            
            ans = max(ans, dis)
            
            for d2, nei in adj[node]:
                heapq.heappush(pq, (d2+dis, nei))
        
        return ans if len(visited)==N else -1",data\repos\leetcode-python\problems\python\network-delay-time.py,networkDelayTime,163
3737,network-delay-time.py::networkDelayTime::155,"    def networkDelayTime(self, times, N, K):
        #construct dis. dis[n] := node n distance to K
        dis = {}
        for n in xrange(1, N+1):
            dis[n] = float('inf')
        dis[K] = 0
        
        visited = set()
        
        #construct adjacency list
        adj = collections.defaultdict(list)
        for u, v, w in times:
            adj[u].append((w, v))
        

        while len(visited)<N:
            #find the nearest node to K, lets call it minDisNode
            minDisNode = None
            minDis = float('inf')
            
            for n in xrange(1, N+1):
                if n not in visited and dis[n]<minDis:
                    minDisNode = n
                    minDis = dis[n]
            
            #update minDisNode neighbor's distance to K    
            if minDis==float('inf'): break
            for d2, nei in adj[minDisNode]:
                dis[nei] = min(dis[nei], d2+minDis)
            
            #store the node we alreay determined the distance to K in visited
            visited.add(minDisNode)
        
        return max(dis.values()) if len(visited)==N else -1",data\repos\leetcode-python\problems\python\network-delay-time.py,networkDelayTime,277
3738,network-delay-time.py::networkDelayTime::198,"    def networkDelayTime(self, times, N, K):
        #dp[i-1][j-1] := distance from i to j
        dp = [[float('inf') for i in xrange(1, N+1)] for j in xrange(1, N+1)]
        
        for i in xrange(1, N+1):
            dp[i-1][i-1] = 0
        for u, v, w in times:
            dp[u-1][v-1] = w
        
        for k in xrange(1, N+1):
            for i in xrange(1, N+1):
                for j in xrange(1, N+1):
                    dp[i-1][j-1] = min(dp[i-1][j-1], dp[i-1][k-1]+dp[k-1][j-1])
        
        ans = max(dp[K-1])
        return ans if ans!=float('inf') else -1",data\repos\leetcode-python\problems\python\network-delay-time.py,networkDelayTime,209
3739,next-closest-time.py::nextClosestTime::9,"    def nextClosestTime(self, time):
        def getNextHour():
            currentHour = int(time[0]+time[1]) if time[0]!='0' else int(time[1])
            
            for h in xrange(currentHour+1, 24):
                hs = str(h) if h>9 else '0'+str(h)
                if all([c in digits for c in hs]): return hs
            return ''
        
        def getSmallestHour():
            for h in xrange(0, 24):
                hs = str(h) if h>9 else '0'+str(h)
                if all([c in digits for c in hs]): return hs
            return ''
        
        def getNextMinute():
            currentMinute = int(time[3]+time[4]) if time[3]!='0' else int(time[4])
            
            for m in xrange(currentMinute+1, 60):
                ms = str(m) if m>9 else '0'+str(m)
                if all([c in digits for c in ms]): return ms
            return ''
        
        def getSmallestMinute():
            for m in xrange(0, 60):
                ms = str(m) if m>9 else '0'+str(m)
                if all([c in digits for c in ms]): return ms
            return ''
                
        digits = set([time[0], time[1], time[3], time[4]])
        nextMinute = getNextMinute()
        if nextMinute:
            return time[:3]+nextMinute
        else:
            return (getNextHour() or getSmallestHour())+':'+getSmallestMinute()",data\repos\leetcode-python\problems\python\next-closest-time.py,nextClosestTime,345
3740,next-closest-time.py::getNextHour::10,"        def getNextHour():
            currentHour = int(time[0]+time[1]) if time[0]!='0' else int(time[1])
            
            for h in xrange(currentHour+1, 24):
                hs = str(h) if h>9 else '0'+str(h)
                if all([c in digits for c in hs]): return hs
            return ''",data\repos\leetcode-python\problems\python\next-closest-time.py,getNextHour,80
3741,next-closest-time.py::getSmallestHour::18,"        def getSmallestHour():
            for h in xrange(0, 24):
                hs = str(h) if h>9 else '0'+str(h)
                if all([c in digits for c in hs]): return hs
            return ''",data\repos\leetcode-python\problems\python\next-closest-time.py,getSmallestHour,53
3742,next-closest-time.py::getNextMinute::24,"        def getNextMinute():
            currentMinute = int(time[3]+time[4]) if time[3]!='0' else int(time[4])
            
            for m in xrange(currentMinute+1, 60):
                ms = str(m) if m>9 else '0'+str(m)
                if all([c in digits for c in ms]): return ms
            return ''",data\repos\leetcode-python\problems\python\next-closest-time.py,getNextMinute,80
3743,next-closest-time.py::getSmallestMinute::32,"        def getSmallestMinute():
            for m in xrange(0, 60):
                ms = str(m) if m>9 else '0'+str(m)
                if all([c in digits for c in ms]): return ms
            return ''",data\repos\leetcode-python\problems\python\next-closest-time.py,getSmallestMinute,53
3744,next-permutation.py::nextPermutation::8,"    def nextPermutation(self, nums):
        def reverse(start):
            end = len(nums)-1
            
            while start<end:
                swap(start, end)
                start += 1
                end -= 1
        
        def swap(i, j):
            nums[i], nums[j] = nums[j], nums[i]
        
        
        i = len(nums)-2
        
        while i>=0 and nums[i+1]<=nums[i]:
            i -= 1
        
        if i>=0:
            j = len(nums)-1
            while nums[j]<=nums[i]: j -= 1
            swap(i, j)
        
        reverse(i+1)
        return nums",data\repos\leetcode-python\problems\python\next-permutation.py,nextPermutation,139
3745,next-permutation.py::nextPermutation::45,"    def nextPermutation(self, nums):
        def reverse(nums, l, r):
            while l<=r:
                nums[l], nums[r] = nums[r], nums[l]
                l += 1
                r -= 1
            
        i = len(nums)-2
        while i>=0 and nums[i]>=nums[i+1]: i -= 1 #[1]
        
        if i==-1:
            return reverse(nums, 0, len(nums)-1) #nums is the largest permutation, sort nums
        else:
            j = len(nums)-1
            while j>i and nums[j]<=nums[i]: j -= 1 #[2]
            nums[i], nums[j] = nums[j], nums[i] #[3]
            reverse(nums, i+1, len(nums)-1) #[4]",data\repos\leetcode-python\problems\python\next-permutation.py,nextPermutation,171
3746,next-permutation.py::reverse::9,"        def reverse(start):
            end = len(nums)-1
            
            while start<end:
                swap(start, end)
                start += 1
                end -= 1",data\repos\leetcode-python\problems\python\next-permutation.py,reverse,36
3747,next-permutation.py::reverse::46,"        def reverse(nums, l, r):
            while l<=r:
                nums[l], nums[r] = nums[r], nums[l]
                l += 1
                r -= 1",data\repos\leetcode-python\problems\python\next-permutation.py,reverse,40
3748,number-complement.py::findComplement::20,"    def findComplement(self, num):
        b = bin(num)[2:]
        opt = 0
        for i, c in enumerate(reversed(b)):
            if c=='0': opt+=pow(2, i)
        return opt",data\repos\leetcode-python\problems\python\number-complement.py,findComplement,51
3749,number-of-connected-components-in-an-undirected-graph.py::countComponents::2,"    def countComponents(self, N, edges):
        def dfs(start):
            stack = [start]
            
            while stack:
                node = stack.pop()
                if node in visited: continue
                visited.add(node)
                
                for nei in g[node]:
                    stack.append(nei)
                    
        g = collections.defaultdict(list)
        visited = set()
        count = 0
        
        for n1, n2 in edges:
            g[n1].append(n2)
            g[n2].append(n1)
        
        for n in xrange(N):
            if n in visited: continue
            dfs(n)
            count += 1
            
        return count",data\repos\leetcode-python\problems\python\number-of-connected-components-in-an-undirected-graph.py,countComponents,136
3750,number-of-connected-components-in-an-undirected-graph.py::countComponents::31,"    def countComponents(self, n, edges):
        def find(n):
            p = parents[n]
            while p!=parents[p]:
                p = find(p)
            parents[n] = p
            return p
        
        def union(n1, n2):
            p1, p2 = find(n1), find(n2)
            if p1==p2: return False
            parents[p2] = p1
            return True
        
        count = n
        parents = [n for n in xrange(n)]
        
        for n1, n2 in edges:
            if union(n1, n2): count -= 1
        return count",data\repos\leetcode-python\problems\python\number-of-connected-components-in-an-undirected-graph.py,countComponents,137
3751,number-of-connected-components-in-an-undirected-graph.py::dfs::3,"        def dfs(start):
            stack = [start]
            
            while stack:
                node = stack.pop()
                if node in visited: continue
                visited.add(node)
                
                for nei in g[node]:
                    stack.append(nei)",data\repos\leetcode-python\problems\python\number-of-connected-components-in-an-undirected-graph.py,dfs,49
3752,number-of-connected-components-in-an-undirected-graph.py::find::32,"        def find(n):
            p = parents[n]
            while p!=parents[p]:
                p = find(p)
            parents[n] = p
            return p",data\repos\leetcode-python\problems\python\number-of-connected-components-in-an-undirected-graph.py,find,34
3753,number-of-connected-components-in-an-undirected-graph.py::union::39,"        def union(n1, n2):
            p1, p2 = find(n1), find(n2)
            if p1==p2: return False
            parents[p2] = p1
            return True",data\repos\leetcode-python\problems\python\number-of-connected-components-in-an-undirected-graph.py,union,47
3754,number-of-islands-ii.py::numIslands2::7,"    def numIslands2(self, M, N, positions):
        def coorToNum(r, c):
            return N*r+c
        
        def find(n):
            p = parents[n]
            while p!=parents[p]:
                p = find(p)
            parents[n] = p
            return parents[n]
            
        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2: return
            parents[p1] = p2
            
        count = 0
        lands = set()
        ans = []
        parents = [n for n in xrange(M*N)]
        
        for r, c in positions:
            n = coorToNum(r, c)
            
            if n in lands:
                ans.append(count)
                continue
            
            neis = set()
            if r+1<M and coorToNum(r+1, c) in lands: neis.add(find(coorToNum(r+1, c)))
            if 0<=r-1 and coorToNum(r-1, c) in lands: neis.add(find(coorToNum(r-1, c)))
            if c+1<N and coorToNum(r, c+1) in lands: neis.add(find(coorToNum(r, c+1)))
            if 0<=c-1 and coorToNum(r, c-1) in lands: neis.add(find(coorToNum(r, c-1)))
                
            count -= (len(neis)-1)
            lands.add(n)
            ans.append(count)
            
            for nei in neis:
                union(n, nei)
            
        return ans",data\repos\leetcode-python\problems\python\number-of-islands-ii.py,numIslands2,359
3755,number-of-islands-ii.py::find::11,"        def find(n):
            p = parents[n]
            while p!=parents[p]:
                p = find(p)
            parents[n] = p
            return parents[n]",data\repos\leetcode-python\problems\python\number-of-islands-ii.py,find,36
3756,number-of-islands-ii.py::union::18,"        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2: return
            parents[p1] = p2",data\repos\leetcode-python\problems\python\number-of-islands-ii.py,union,44
3757,number-of-islands.py::numIslands::10,"    def numIslands(self, grid):
        if grid is None or grid==[] or grid==[[]]: return 0
        
        count = 0
        height = len(grid)
        width = len(grid[0])

        #explore_adjacent() if grid[h][w] is unexplored, mark it as explored. 1->2.
        #and continue to do the same to the adjacent
        def explore_adjacent(h, w):
            #check border
            if h<0 or h>height-1: return
            if w<0 or w>width-1: return

            #if grid[h][w]==0: it is sea, return
            #if grid[h][w]==2: we already explore this place, return
            if grid[h][w]=='1':
                grid[h][w] = '2'
                explore_adjacent(h+1, w)
                explore_adjacent(h-1, w)
                explore_adjacent(h, w+1)
                explore_adjacent(h, w-1)
            return
        
        for h in range(height):
            for w in range(width):
                #if v==0: it is sea, continue to find unexplored
                #if v==2: we already explore this place, continue to find unexplored
                if grid[h][w]=='1':
                    #if we discover an unexplored place
                    #count it
                    #and set it as root to explore the whole island
                    count+=1
                    explore_adjacent(h, w)
        return count",data\repos\leetcode-python\problems\python\number-of-islands.py,numIslands,332
3758,number-of-islands.py::numIslands::47,"    def numIslands(self, grid):
        if grid is None or grid==[] or grid==[[]]: return 0
        
        count = 0
        height = len(grid)
        width = len(grid[0])
        
        def explore_adjacent(h_root, w_root):
            if h_root<0 or h_root>height-1: return
            if w_root<0 or w_root>width-1: return

            #start the queue from root
            queue = [(h_root, w_root)]
                
            while len(queue)>0:
                coor = queue.pop(0)
                h = coor[0]
                w = coor[1]
                
                #check border
                if h<0 or h>height-1: continue
                if w<0 or w>width-1: continue
                
                if grid[h][w]=='1':
                    grid[h][w] = '2'
                    queue.extend([(h+1, w), (h-1, w), (h, w+1), (h, w-1)])

            #this function will end if there are no new adjacent to add to queue
            #which means the whole island explored (mark as 2)
            return
                    
        for h in range(height):
            for w in range(width):
                if grid[h][w]=='1':
                    #if we discover an unexplored place
                    #count it
                    #and set it as root to explore the whole island
                    count+=1
                    explore_adjacent(h, w)
                    
        return count",data\repos\leetcode-python\problems\python\number-of-islands.py,numIslands,330
3759,number-of-islands.py::numIslands::91,"    def numIslands(self, grid):
        def dfs(i0, j0):
            stack = [(i0, j0)]
            
            while stack:
                i, j = stack.pop()
                if grid[i][j]==""0"" or grid[i][j]==""2"": continue
                grid[i][j] = ""2""
                
                if i+1<M: stack.append((i+1, j))
                if 0<=i-1: stack.append((i-1, j))
                if j+1<N: stack.append((i, j+1))
                if 0<=j-1: stack.append((i, j-1))
                
        if not grid or not grid[0]: return 0
        
        count = 0
        M = len(grid)
        N = len(grid[0])
        
        for i in xrange(M):
            for j in xrange(N):
                if grid[i][j]==""0"" or grid[i][j]==""2"": continue
                dfs(i, j)
                count += 1
        return count",data\repos\leetcode-python\problems\python\number-of-islands.py,numIslands,223
3760,number-of-islands.py::explore_adjacent::19,"        def explore_adjacent(h, w):
            #check border
            if h<0 or h>height-1: return
            if w<0 or w>width-1: return

            #if grid[h][w]==0: it is sea, return
            #if grid[h][w]==2: we already explore this place, return
            if grid[h][w]=='1':
                grid[h][w] = '2'
                explore_adjacent(h+1, w)
                explore_adjacent(h-1, w)
                explore_adjacent(h, w+1)
                explore_adjacent(h, w-1)
            return",data\repos\leetcode-python\problems\python\number-of-islands.py,explore_adjacent,137
3761,number-of-islands.py::explore_adjacent::54,"        def explore_adjacent(h_root, w_root):
            if h_root<0 or h_root>height-1: return
            if w_root<0 or w_root>width-1: return

            #start the queue from root
            queue = [(h_root, w_root)]
                
            while len(queue)>0:
                coor = queue.pop(0)
                h = coor[0]
                w = coor[1]
                
                #check border
                if h<0 or h>height-1: continue
                if w<0 or w>width-1: continue
                
                if grid[h][w]=='1':
                    grid[h][w] = '2'
                    queue.extend([(h+1, w), (h-1, w), (h, w+1), (h, w-1)])

            #this function will end if there are no new adjacent to add to queue
            #which means the whole island explored (mark as 2)
            return",data\repos\leetcode-python\problems\python\number-of-islands.py,explore_adjacent,211
3762,number-of-islands.py::dfs::92,"        def dfs(i0, j0):
            stack = [(i0, j0)]
            
            while stack:
                i, j = stack.pop()
                if grid[i][j]==""0"" or grid[i][j]==""2"": continue
                grid[i][j] = ""2""
                
                if i+1<M: stack.append((i+1, j))
                if 0<=i-1: stack.append((i-1, j))
                if j+1<N: stack.append((i, j+1))
                if 0<=j-1: stack.append((i, j-1))",data\repos\leetcode-python\problems\python\number-of-islands.py,dfs,130
3763,number-of-matching-subsequences.py::numMatchingSubseq::8,"    def numMatchingSubseq(self, s, words):
        def match(position, word):
            prev = -1
            for c in word:
                if c not in position: return False
                i = bisect.bisect_left(position[c], prev+1)
                if i==len(position[c]): return False
                prev = position[c][i]
            return True
        
        position = collections.defaultdict(list)
        count = 0
        for i, c in enumerate(s):
            position[c].append(i)
        
        for word in words:
            if match(position, word): count += 1
        return count",data\repos\leetcode-python\problems\python\number-of-matching-subsequences.py,numMatchingSubseq,132
3764,number-of-matching-subsequences.py::match::9,"        def match(position, word):
            prev = -1
            for c in word:
                if c not in position: return False
                i = bisect.bisect_left(position[c], prev+1)
                if i==len(position[c]): return False
                prev = position[c][i]
            return True",data\repos\leetcode-python\problems\python\number-of-matching-subsequences.py,match,67
3765,number-of-provinces.py::findCircleNum::2,"    def findCircleNum(self, isConnected):
        def bfs(startNode):
            q = collections.deque([startNode])
            
            while q:
                node = q.popleft()
                if node in visited: continue
                visited.add(node)
                
                for nei in xrange(N):
                    if nei!=node and isConnected[node][nei]==1:
                        q.append(nei)
        
        N = len(isConnected)
        visited = set()
        ans = 0
        
        for node in xrange(N):
            if node in visited: continue
            bfs(node) #put all the nodes in the same province to visited
            ans += 1
                    
        return ans",data\repos\leetcode-python\problems\python\number-of-provinces.py,findCircleNum,137
3766,number-of-provinces.py::bfs::3,"        def bfs(startNode):
            q = collections.deque([startNode])
            
            while q:
                node = q.popleft()
                if node in visited: continue
                visited.add(node)
                
                for nei in xrange(N):
                    if nei!=node and isConnected[node][nei]==1:
                        q.append(nei)",data\repos\leetcode-python\problems\python\number-of-provinces.py,bfs,69
3767,number-of-recent-calls.py::ping::19,"    def ping(self, t):
        self.q.append(t)
        while len(self.q)>0 and self.q[0]<t-3000:
            self.q.popleft()
        
        return len(self.q)",data\repos\leetcode-python\problems\python\number-of-recent-calls.py,ping,44
3768,number-of-squareful-arrays.py::numSquarefulPerms::18,"    def numSquarefulPerms(self, nums):
        def isSquare(num):
            return int(math.sqrt(num))**2==num
        
        def helper(per, remains):
            if not remains: self.ans += 1
            last = per[-1]
            
            for i, n in enumerate(remains):
                if i>0 and n==remains[i-1]: continue
                if isSquare(last+n):
                    helper(per+[n], remains[:i]+remains[i+1:])
        
        nums.sort()
        for i, n in enumerate(nums):
            if i>0 and n==nums[i-1]: continue
            helper([nums[i]], nums[:i]+nums[i+1:])
        
        return self.ans",data\repos\leetcode-python\problems\python\number-of-squareful-arrays.py,numSquarefulPerms,156
3769,number-of-squareful-arrays.py::helper::22,"        def helper(per, remains):
            if not remains: self.ans += 1
            last = per[-1]
            
            for i, n in enumerate(remains):
                if i>0 and n==remains[i-1]: continue
                if isSquare(last+n):
                    helper(per+[n], remains[:i]+remains[i+1:])",data\repos\leetcode-python\problems\python\number-of-squareful-arrays.py,helper,77
3770,number-of-substrings-containing-all-thre.py::numberOfSubstrings::2,"    def numberOfSubstrings(self, s):
        #number of subarrays that at most have k unique char
        def atMost(k):
            counter = collections.Counter()
            uniqueCount = 0
            ans = 0
            i = 0
            
            for j, c in enumerate(s):
                counter[c] += 1
                if counter[c]==1: uniqueCount += 1

                while uniqueCount>k:
                    counter[s[i]] -= 1
                    if counter[s[i]]==0: uniqueCount-= 1
                    i += 1
                ans += j-i+1
            return ans
        
        n = len(s)
        return atMost(3) - atMost(2)",data\repos\leetcode-python\problems\python\number-of-substrings-containing-all-thre.py,numberOfSubstrings,151
3771,number-of-substrings-containing-all-thre.py::atMost::4,"        def atMost(k):
            counter = collections.Counter()
            uniqueCount = 0
            ans = 0
            i = 0
            
            for j, c in enumerate(s):
                counter[c] += 1
                if counter[c]==1: uniqueCount += 1

                while uniqueCount>k:
                    counter[s[i]] -= 1
                    if counter[s[i]]==0: uniqueCount-= 1
                    i += 1
                ans += j-i+1
            return ans",data\repos\leetcode-python\problems\python\number-of-substrings-containing-all-thre.py,atMost,108
3772,number-of-ways-to-arrive-at-destination.py::countPaths::2,"    def countPaths(self, n, roads):
        def countWaysToReach(node):
            if node==0: return 1
            if node in history: return history[node]
            c = 0
            for nei, t in adj[node]:
                if nei in times and times[nei]+t==times[node]:
                    c += countWaysToReach(nei)
            history[node] = c
            return c
        
        history = {} #cache for countWaysToReach()
        times = {} #min times to reach node n-1
        pq = [(0, 0)]
        
        adj = collections.defaultdict(list)
        for u, v, t in roads:
            adj[u].append((v, t))
            adj[v].append((u, t))
        
        while pq:
            t, node = heapq.heappop(pq)
            if node in times: continue
            times[node] = t
            
            if node==n-1: break
            
            for nei, t2 in adj[node]:
                if nei in times: continue
                heapq.heappush(pq, (t+t2, nei))
        
        return countWaysToReach(n-1)%(10**9 + 7)",data\repos\leetcode-python\problems\python\number-of-ways-to-arrive-at-destination.py,countPaths,262
3773,number-of-ways-to-arrive-at-destination.py::countWaysToReach::3,"        def countWaysToReach(node):
            if node==0: return 1
            if node in history: return history[node]
            c = 0
            for nei, t in adj[node]:
                if nei in times and times[nei]+t==times[node]:
                    c += countWaysToReach(nei)
            history[node] = c
            return c",data\repos\leetcode-python\problems\python\number-of-ways-to-arrive-at-destination.py,countWaysToReach,81
3774,ones-and-zeroes.py::findMaxForm::6,"    def findMaxForm(self, strs, M, N):
        dp = [[[0 for _ in xrange(M+1)] for _ in xrange(N+1)] for _ in xrange(len(strs)+1)]
        
        for i in xrange(1, len(strs)+1):
            count0 = strs[i-1].count('0')
            count1 = len(strs[i-1])-count0

            for n in xrange(N+1):
                for m in xrange(M+1):
                    dp[i][n][m] = max(dp[i-1][n][m], (dp[i-1][n-count1][m-count0]+1) if m>=count0 and n>=count1 else 0)
        
        ans = 0
        for n in xrange(N+1):
                for m in xrange(M+1):
                    ans = max(ans, dp[-1][n][m])
            
        return ans",data\repos\leetcode-python\problems\python\ones-and-zeroes.py,findMaxForm,196
3775,open-the-lock.py::openLock::7,"    def openLock(self, deadends, target):
        def getNeighbor(node):
            opt = []
            for i in xrange(len(node)):
                if node[i]==0:
                    opt.append(tuple(node[:i]+(1,)+node[i+1:]))
                    opt.append(tuple(node[:i]+(9,)+node[i+1:]))
                elif node[i]==9:
                    opt.append(tuple(node[:i]+(0,)+node[i+1:]))
                    opt.append(tuple(node[:i]+(8,)+node[i+1:]))
                else:
                    opt.append(tuple(node[:i]+(node[i]+1,)+node[i+1:]))
                    opt.append(tuple(node[:i]+(node[i]-1,)+node[i+1:]))
            return opt

        def getDistance(node):
            distance = 0
            for i in xrange(len(node)):
                d = abs(int(node[i])-int(target[i]))
                d2 = abs(10-d)
                distance+=min(d, d2)
            return distance

        def tupify(node):
            return tuple(map(int, node))

        target = tupify(target)
        visited = set([tupify(node) for node in deadends])
        pq = [(0, 0, tupify('0000'))]

        while pq:
            _, steps, node = heapq.heappop(pq)
            if node==target: return steps
            if node in visited: continue
            visited.add(node)
            for nei in getNeighbor(node):
                heapq.heappush(pq, (steps+1+getDistance(nei), steps+1, nei))
        return -1",data\repos\leetcode-python\problems\python\open-the-lock.py,openLock,346
3776,open-the-lock.py::openLock::47,"    def openLock(self, deadends, target):
        def getNeighbor(node):
            opt = []
            for i in xrange(len(node)):
                add_one = delta[node[i]][0]
                minus_one = delta[node[i]][1]
                opt.append(node[:i]+add_one+node[i+1:])
                opt.append(node[:i]+minus_one+node[i + 1:])
            return opt

        delta = {str(i): [str((i+1)%10), str((i-1)%10)] for i in xrange(10)}
        visited = set(deadends)
        q = collections.deque([('0000', 0)])
        steps = 0

        while q:
            node, steps = q.popleft()
            if node==target: return steps
            if node in visited: continue
            visited.add(node)
            for nei in getNeighbor(node):
                q.append((nei, steps+1))

        return -1",data\repos\leetcode-python\problems\python\open-the-lock.py,openLock,199
3777,open-the-lock.py::getNeighbor::8,"        def getNeighbor(node):
            opt = []
            for i in xrange(len(node)):
                if node[i]==0:
                    opt.append(tuple(node[:i]+(1,)+node[i+1:]))
                    opt.append(tuple(node[:i]+(9,)+node[i+1:]))
                elif node[i]==9:
                    opt.append(tuple(node[:i]+(0,)+node[i+1:]))
                    opt.append(tuple(node[:i]+(8,)+node[i+1:]))
                else:
                    opt.append(tuple(node[:i]+(node[i]+1,)+node[i+1:]))
                    opt.append(tuple(node[:i]+(node[i]-1,)+node[i+1:]))
            return opt",data\repos\leetcode-python\problems\python\open-the-lock.py,getNeighbor,152
3778,open-the-lock.py::getDistance::22,"        def getDistance(node):
            distance = 0
            for i in xrange(len(node)):
                d = abs(int(node[i])-int(target[i]))
                d2 = abs(10-d)
                distance+=min(d, d2)
            return distance",data\repos\leetcode-python\problems\python\open-the-lock.py,getDistance,53
3779,open-the-lock.py::getNeighbor::48,"        def getNeighbor(node):
            opt = []
            for i in xrange(len(node)):
                add_one = delta[node[i]][0]
                minus_one = delta[node[i]][1]
                opt.append(node[:i]+add_one+node[i+1:])
                opt.append(node[:i]+minus_one+node[i + 1:])
            return opt",data\repos\leetcode-python\problems\python\open-the-lock.py,getNeighbor,72
3780,out-of-boundary-paths.py::findPaths::11,"    def findPaths(self, M, N, K, i, j):
        ans = 0
        
        dp = [[[0 for _ in xrange(N)] for _ in xrange(M)] for _ in xrange(K+1)]
        dp[0][i][j] = 1
        
        for k in xrange(K):
            for i in xrange(M):
                for j in xrange(N):
                    if dp[k][i][j]>0:
                        for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                            if x<0 or x>=M or y<0 or y>=N:
                                ans+=dp[k][i][j]
                            else:
                                dp[k+1][x][y]+=dp[k][i][j]
        return ans % (1000000007)",data\repos\leetcode-python\problems\python\out-of-boundary-paths.py,findPaths,185
3781,pacific-atlantic-water-flow.py::pacificAtlantic::2,"    def pacificAtlantic(self, heights):
        def bfs(q, ocian):
            while q:
                i0, j0 = q.popleft()
                if (i0, j0) in ocian: continue
                ocian.add((i0, j0))
                
                for i, j in [(i0+1, j0), (i0-1, j0), (i0, j0+1), (i0, j0-1)]:
                    if i>=len(heights) or i<0 or j>=len(heights[0]) or j<0: continue
                    if heights[i][j]>=heights[i0][j0]: q.append((i, j))
                        
        pacific = set()
        altalantic = set()
        q1 = collections.deque()
        q2 = collections.deque()
        
        #add top, left to pacific
        for j in xrange(len(heights[0])): q1.append((0, j))
        for i in xrange(len(heights)): q1.append((i, 0))
            
        #add right, bottom to atalantic
        for j in xrange(len(heights[0])): q2.append((len(heights)-1, j))
        for i in xrange(len(heights)): q2.append((i, len(heights[0])-1))
        
        bfs(q1, pacific)
        bfs(q2, altalantic)
                        
        return pacific.intersection(altalantic)",data\repos\leetcode-python\problems\python\pacific-atlantic-water-flow.py,pacificAtlantic,319
3782,pacific-atlantic-water-flow.py::bfs::3,"        def bfs(q, ocian):
            while q:
                i0, j0 = q.popleft()
                if (i0, j0) in ocian: continue
                ocian.add((i0, j0))
                
                for i, j in [(i0+1, j0), (i0-1, j0), (i0, j0+1), (i0, j0-1)]:
                    if i>=len(heights) or i<0 or j>=len(heights[0]) or j<0: continue
                    if heights[i][j]>=heights[i0][j0]: q.append((i, j))",data\repos\leetcode-python\problems\python\pacific-atlantic-water-flow.py,bfs,143
3783,pairs-of-songs-with-total-durations-divisible-by-60.py::numPairsDivisibleBy60::2,"    def numPairsDivisibleBy60(self, times):
        counter = collections.Counter()
        ans = 0
        
        for time in times:
            time = time%60
            ans += counter[60-time if time!=0 else 0]
            counter[time] += 1",data\repos\leetcode-python\problems\python\pairs-of-songs-with-total-durations-divisible-by-60.py,numPairsDivisibleBy60,60
3784,palindrome-pairs.py::palindromePairs::6,"    def palindromePairs(self, words):
        ans = set()
        index = {word:i for i, word in enumerate(words)}
        
        for i, word in enumerate(words):
            for j in xrange(len(word)+1):
                left = word[:j]
                right = word[j:]
                
                # check if any other word that concat to the left will make palindrome: ""OTHER_WORD+`left`+`right`""
                # The above will be palindrome only if
                # 1. `left` is palindrome (left==left[::-1])
                # 2. Exsit an ""OTHER_WORD"" in word in words that equals to the reverse of `right` (right[::-1] in index and index[right[::-1]]!=i).
                if left==left[::-1]:
                    if right[::-1] in index and index[right[::-1]]!=i:
                        ans.add((index[right[::-1]], i))
                
                # check if any other word that concat to the right will make palindrome: ""`left`+`right`+OTHER_WORD""
                # The above will be palindrome only if
                # 1. `rihgt` is palindrome (right==right[::-1])
                # 2. Exsit an ""OTHER_WORD"" in words that equals to the reverse of `left` (left[::-1] in index and index[left[::-1]]!=i).
                if right==right[::-1]:
                    if left[::-1] in index and index[left[::-1]]!=i:
                        ans.add((i, index[left[::-1]]))
                        
        return ans",data\repos\leetcode-python\problems\python\palindrome-pairs.py,palindromePairs,330
3785,palindrome-pairs.py::palindromePairs::39,"    def palindromePairs(self, words):
        N = len(words)
        ans = []
        
        for i in xrange(N):
            for j in xrange(N):
                if i==j: continue
                if self.isPalindrome(words[i]+words[j]):
                    ans.append([i, j])
        return ans",data\repos\leetcode-python\problems\python\palindrome-pairs.py,palindromePairs,63
3786,palindrome-pairs.py::isPalindrome::50,"    def isPalindrome(self, word):
        l = 0
        r = len(word)-1
        
        while l<=r:
            if word[l]==word[r]:
                l += 1
                r -= 1
            else:
                return False
        return True",data\repos\leetcode-python\problems\python\palindrome-pairs.py,isPalindrome,58
3787,palindrome-partitioning-iii.py::palindromePartition::5,"    def palindromePartition(self, s, K):
        def count(r, l):
            c = 0
            
            while r>l:
                if s[r]!=s[l]: c += 1
                r -= 1
                l += 1
            return c

        N = len(s) 
        
        dp = [[float('inf') for _ in xrange(K+1)] for _ in xrange(N+1)]
        dp[0][0] = 0
        
        for i in xrange(1, N+1):
            for k in xrange(1, min(K, i)+1):
                for j in xrange(k, i+1):
                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + count(i-1, j-1))
                    
        return dp[N][K]",data\repos\leetcode-python\problems\python\palindrome-partitioning-iii.py,palindromePartition,178
3788,palindrome-partitioning-iii.py::palindromePartition::33,"    def palindromePartition(self, s, K):
        N = len(s)

        count = [[0 for _ in xrange(N)] for _ in xrange(N)]
        for i in xrange(N): count[i][i] = 0

        for l in xrange(2, N+1):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                count[j][i] = count[j-1][i+1] + (0 if s[i]==s[j] else 1)
        
        dp = [[float('inf') for _ in xrange(K+1)] for _ in xrange(N+1)]
        dp[0][0] = 0
        
        for i in xrange(1, N+1):
            for k in xrange(1, min(K, i)+1):
                for j in xrange(k, i+1):
                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + count[i-1][j-1])
                    
        return dp[N][K]",data\repos\leetcode-python\problems\python\palindrome-partitioning-iii.py,palindromePartition,228
3789,palindrome-partitioning-iii.py::count::6,"        def count(r, l):
            c = 0
            
            while r>l:
                if s[r]!=s[l]: c += 1
                r -= 1
                l += 1
            return c",data\repos\leetcode-python\problems\python\palindrome-partitioning-iii.py,count,47
3790,palindrome-partitioning.py::partition::2,"    def partition(self, S):
        def isPalindrome(s):
            return len(s)==1 or (len(s)>0 and s==s[::-1])
        def search(s, pal_list):
            if len(s)==0:
                opt.append(pal_list)
                return
            for i in xrange(1, len(s)+1):
                if isPalindrome(s[:i]):
                    search(s[i:], pal_list+[s[:i]])
        opt = []
        search(S, [])
        return opt",data\repos\leetcode-python\problems\python\palindrome-partitioning.py,partition,102
3791,palindrome-partitioning.py::search::5,"        def search(s, pal_list):
            if len(s)==0:
                opt.append(pal_list)
                return
            for i in xrange(1, len(s)+1):
                if isPalindrome(s[:i]):
                    search(s[i:], pal_list+[s[:i]])",data\repos\leetcode-python\problems\python\palindrome-partitioning.py,search,58
3792,palindromic-substrings.py::countSubstrings::11,"    def countSubstrings(self, s):
        N = len(s)
        dp = [[False]*N for _ in xrange(N)]
        ans = 0
        
        #1
        for i in xrange(N):
            dp[i][i] = True
            ans += 1
        
        #2
        for i in xrange(N-1):
            if s[i]==s[i+1]:
                dp[i][i+1] = True
                ans += 1
        
        #3
        for l in xrange(3, N+1):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                if dp[i+1][j-1] and s[i]==s[j]:
                    dp[i][j] = True
                    ans += 1
        return ans",data\repos\leetcode-python\problems\python\palindromic-substrings.py,countSubstrings,175
3793,palindromic-substrings.py::countSubstrings::45,"    def countSubstrings(self, s):
        def count(l, r, N):
            count = 0
            
            while l>=0 and r<N and s[l]==s[r]:
                count += 1
                l = l-1
                r = r+1
            return count
                
        N = len(s)
        ans = 0
        
        for i in xrange(N):
            ans += count(i, i+1, N) #count even length palindrome
            ans += count(i, i, N) #count odd length palindrome
        return ans",data\repos\leetcode-python\problems\python\palindromic-substrings.py,countSubstrings,119
3794,palindromic-substrings.py::count::46,"        def count(l, r, N):
            count = 0
            
            while l>=0 and r<N and s[l]==s[r]:
                count += 1
                l = l-1
                r = r+1
            return count",data\repos\leetcode-python\problems\python\palindromic-substrings.py,count,53
3795,partition-array-for-maximum-sum.py::maxSumAfterPartitioning::5,"    def maxSumAfterPartitioning(self, A, K):
        dp = [0 for _ in xrange(len(A)+1)]

        for i in xrange(1, len(A)+1):
            m = float('-inf') # max in A[i-k]~A[i-1]
            for k in xrange(1, min(i+1, K+1)):
                m = max(m, A[i-k])
                dp[i] = max(dp[i], m*k + dp[i-k])

        return dp[-1]",data\repos\leetcode-python\problems\python\partition-array-for-maximum-sum.py,maxSumAfterPartitioning,109
3796,partition-labels.py::partitionLabels::13,"    def partitionLabels(self, s):
        charRange = {}
        r = []
        
        for i, c in enumerate(s):
            if c not in charRange:
                charRange[c] = [i, i]
            else:
                charRange[c][1] = i
        
        for i, c in enumerate(s):
            if i==0 or charRange[c][0]>r[-1]:
                r.append(charRange[c][1])
            else:
                r[-1] = max(r[-1], charRange[c][1])
        
        ans = []
        for i in xrange(len(r)):
            if i==0:
                ans.append(r[i]+1)
            else:
                ans.append(r[i]-r[i-1])
        return ans",data\repos\leetcode-python\problems\python\partition-labels.py,partitionLabels,157
3797,partition-labels.py::partitionLabels::41,"    def partitionLabels(self, s):
        lastSeen = {}
        for i, c in enumerate(s): lastSeen[c] = i
        
        ans = []
        start = end = 0
        for i, c in enumerate(s):
            end = max(end, lastSeen[c])
            if i==end:
                ans.append(end-start+1)
                start = i+1
        return ans",data\repos\leetcode-python\problems\python\partition-labels.py,partitionLabels,84
3798,partition-to-k-equal-sum-subsets.py::canPartitionKSubsets::2,"    def canPartitionKSubsets(self, nums, k):
        def search(subs):
            if not nums: return True
            n = nums.pop()
            for i, sub in enumerate(subs):
                if sub+n<=target:
                    subs[i]+=n
                    if search(subs): return True
                    subs[i]-=n
                if not sub: break
            nums.append(n)
            return False

        if sum(nums)%k!=0: return False
        target = sum(nums)/k
        nums.sort()
        return search([0]*k)",data\repos\leetcode-python\problems\python\partition-to-k-equal-sum-subsets.py,canPartitionKSubsets,120
3799,partition-to-k-equal-sum-subsets.py::canPartitionKSubsets::23,"    def canPartitionKSubsets(self, nums, k):
        def dfs(currSum, k, s=0):
            if k==0: return True
            if currSum==target: return dfs(0, k-1)
            
            for i in xrange(s, N):
                num = nums[i]
                if not visited[i] and num+currSum<=target:
                    visited[i] = True
                    if dfs(currSum+num, k, i+1): return True
                    visited[i] = False
            return False
        
        target, remain = divmod(sum(nums), k)
        if remain>0: return False
        
        N = len(nums)
        visited = [False]*N
        return dfs(target, k)",data\repos\leetcode-python\problems\python\partition-to-k-equal-sum-subsets.py,canPartitionKSubsets,157
3800,partition-to-k-equal-sum-subsets.py::search::3,"        def search(subs):
            if not nums: return True
            n = nums.pop()
            for i, sub in enumerate(subs):
                if sub+n<=target:
                    subs[i]+=n
                    if search(subs): return True
                    subs[i]-=n
                if not sub: break
            nums.append(n)
            return False",data\repos\leetcode-python\problems\python\partition-to-k-equal-sum-subsets.py,search,74
3801,partition-to-k-equal-sum-subsets.py::dfs::24,"        def dfs(currSum, k, s=0):
            if k==0: return True
            if currSum==target: return dfs(0, k-1)
            
            for i in xrange(s, N):
                num = nums[i]
                if not visited[i] and num+currSum<=target:
                    visited[i] = True
                    if dfs(currSum+num, k, i+1): return True
                    visited[i] = False
            return False",data\repos\leetcode-python\problems\python\partition-to-k-equal-sum-subsets.py,dfs,101
3802,path-sum-ii.py::pathSum::2,"    def pathSum(self, root, S):
        if not root: return False
        
        opt = []
        stack = []
        stack.append((root, 0, []))
        
        while stack:
            node, s, path = stack.pop()
            s += node.val
            path = path + [node.val]
            if not node.left and not node.right and s==S: opt.append(path)
            if node.left: stack.append((node.left, s, path))
            if node.right: stack.append((node.right, s, path))
        return opt",data\repos\leetcode-python\problems\python\path-sum-ii.py,pathSum,118
3803,path-sum-ii.py::pathSum::29,"    def pathSum(self, root, targetSum):
        if not root: return []
        
        ans = []
        stack = [(root, root.val, [root.val])]
        
        while stack:
            node, total, path = stack.pop()
            
            if not node.left and not node.right and total==targetSum: ans.append(path)
            if node.left: stack.append((node.left, total+node.left.val, path+[node.left.val]))
            if node.right: stack.append((node.right, total+node.right.val, path+[node.right.val]))
                
        return ans",data\repos\leetcode-python\problems\python\path-sum-ii.py,pathSum,121
3804,path-sum-iii.py::pathSum::4,"    def pathSum(self, root, sum):
        def helper(node, sum_from_root, record):
            sum_from_root += node.val
            sum_to_p = sum_from_root-sum
            self.ans += record[sum_to_p]

            record[sum_from_root] += 1 #1
            if node.left:
                helper(node.left, sum_from_root, record)
            if node.right:
                helper(node.right, sum_from_root, record)
            record[sum_from_root] -= 1 #2
        
        self.ans = 0
        if not root: return self.ans
        record = Counter()
        record[0] = 1 #3
        helper(root, 0, record)
        return self.ans",data\repos\leetcode-python\problems\python\path-sum-iii.py,pathSum,156
3805,path-sum-iii.py::helper::5,"        def helper(node, sum_from_root, record):
            sum_from_root += node.val
            sum_to_p = sum_from_root-sum
            self.ans += record[sum_to_p]

            record[sum_from_root] += 1 #1
            if node.left:
                helper(node.left, sum_from_root, record)
            if node.right:
                helper(node.right, sum_from_root, record)
            record[sum_from_root] -= 1 #2",data\repos\leetcode-python\problems\python\path-sum-iii.py,helper,97
3806,path-sum.py::hasPathSum::2,"    def hasPathSum(self, root, S):
        if not root: return False
        
        stack = []
        stack.append((root, 0))
        
        while stack:
            node, s = stack.pop()
            s += node.val
            if not node.left and not node.right and s==S: return True
            if node.left: stack.append((node.left, s))
            if node.right: stack.append((node.right, s))
        return False",data\repos\leetcode-python\problems\python\path-sum.py,hasPathSum,97
3807,path-sum.py::hasPathSum::24,"    def hasPathSum(self, root, targetSum):
        if not root: return False
        
        stack = [(root, root.val)]
        
        while stack:
            node, total = stack.pop()
            
            if not node.left and not node.right and total==targetSum: return True
            if node.left: stack.append((node.left, total+node.left.val))
            if node.right: stack.append((node.right, total+node.right.val))
            
        return False",data\repos\leetcode-python\problems\python\path-sum.py,hasPathSum,99
3808,path-with-maximum-probability.py::maxProbability::2,"    def maxProbability(self, n, edges, succProb, start, end):
        pq = [(-1, start)]
        visited = set()
        adj = collections.defaultdict(list)
        for i in xrange(len(edges)):
            a, b = edges[i]
            p = succProb[i]
            adj[a].append((b, p))
            adj[b].append((a, p))
        
        while pq:
            p, node = heapq.heappop(pq)
            p = p*-1
            if node in visited: continue
            visited.add(node)
            
            if node==end: return p
            
            for nei, p2 in adj[node]:
                if nei in visited: continue
                heapq.heappush(pq, (-1*p*p2, nei))
        
        return 0",data\repos\leetcode-python\problems\python\path-with-maximum-probability.py,maxProbability,168
3809,peak-index-in-a-mountain-array.py::peakIndexInMountainArray::11,"    def peakIndexInMountainArray(self, A):
        l = 0
        r = len(A)-1
        while l<r:
            p = (l+r)/2
            if A[p]<A[p+1]:
                l = p+1
            else:
                r = p
        return l",data\repos\leetcode-python\problems\python\peak-index-in-a-mountain-array.py,peakIndexInMountainArray,67
3810,perfect-squares.py::numSquares::3,"    def numSquares(self, n):
        def helper(n):
            if not n: return 0
            if n in history: return history[n]
            
            elements = [e**2 for e in range(2, int(n**0.5)+1)]
            ans = n

            for e in reversed(elements):
                count_of_element = int(n/e)
                n_approximate = count_of_element*e
                ans = min(ans, count_of_element+helper(n-n_approximate))
            
            history[n] = ans
            return history[n]
        
        history = {1:1, 2:2, 3:3}
        return helper(n)",data\repos\leetcode-python\problems\python\perfect-squares.py,numSquares,141
3811,perfect-squares.py::numSquares::24,"    def numSquares(self, N):
        squares = [s**2 for s in range(2, int(N**0.5)+1)]
        
        dp = [n for n in xrange(N+1)]
        
        for n in xrange(N+1):
            for square in squares:
                if square>n:
                    break
                elif square==n:
                    dp[n] = 1
                    break
                else:
                    dp[n] = min(dp[n], dp[square]+dp[n-square])
        return dp[N]",data\repos\leetcode-python\problems\python\perfect-squares.py,numSquares,112
3812,perfect-squares.py::helper::4,"        def helper(n):
            if not n: return 0
            if n in history: return history[n]
            
            elements = [e**2 for e in range(2, int(n**0.5)+1)]
            ans = n

            for e in reversed(elements):
                count_of_element = int(n/e)
                n_approximate = count_of_element*e
                ans = min(ans, count_of_element+helper(n-n_approximate))
            
            history[n] = ans
            return history[n]",data\repos\leetcode-python\problems\python\perfect-squares.py,helper,108
3813,permutation-in-string.py::checkInclusion::17,"    def checkInclusion(self, s1, s2):
        l = len(s1)
        counter1 = collections.Counter(s1)
        counter2 = collections.Counter(s2[:l-1])
        
        for i in xrange(len(s2)):
            j = i+l-1
            if j>=len(s2): break
            counter2[s2[j]] += 1
            
            if counter1==counter2: return True
            
            counter2[s2[i]] -= 1
            if counter2[s2[i]]==0: counter2.pop(s2[i], None)
            
        return False",data\repos\leetcode-python\problems\python\permutation-in-string.py,checkInclusion,127
3814,permutation-sequence.py::getPermutation::2,"    def getPermutation(self, N, K):
        K = K-1 #make it 0-index
        nums = range(1, N+1)
        ans = ''
        
        while N>0:
            a = K/math.factorial(N-1)
            ans += str(nums[a])
            nums.pop(a)
            
            K -= math.factorial(N-1)*(a+1)
            N -= 1
        return ans",data\repos\leetcode-python\problems\python\permutation-sequence.py,getPermutation,93
3815,permutations-ii.py::permuteUnique::15,"    def permuteUnique(self, nums):
        def dfs(path, options):
            if len(path)==len(nums):
                opt.append(path)
                return
            for i, n in enumerate(options):
                if i>0 and options[i]==options[i-1]: continue
                dfs(path+[n], options[:i]+options[i+1:])
        opt = []
        nums.sort()
        dfs([], nums)
        return opt",data\repos\leetcode-python\problems\python\permutations-ii.py,permuteUnique,88
3816,permutations-ii.py::permuteUnique::39,"    def permuteUnique(self, nums):
        def helper(path):
            if len(path)==len(nums): ans.append(path[:])
            
            for num in counter:
                if counter[num]>0:
                    path.append(num)
                    counter[num] -= 1
                    
                    helper(path)
                    
                    path.pop()
                    counter[num] += 1
        ans = []
        counter = collections.Counter(nums)
        helper([])
        return ans",data\repos\leetcode-python\problems\python\permutations-ii.py,permuteUnique,88
3817,permutations-ii.py::permuteUnique::62,"    def permuteUnique(self, nums):
        if not nums: return []
        
        permutations = collections.deque([[nums[0]]])
        
        for i in xrange(1, len(nums)):
            num = nums[i]
            l = len(permutations)    
            
            while l:
                permutation = permutations.popleft()
                for j in xrange(len(permutation)+1):
                    if 0<j and num==permutation[j-1]: break
                    newPermutaion = permutation[:]
                    newPermutaion.insert(j, num)
                    permutations.append(newPermutaion)
                l -= 1
        
        return permutations",data\repos\leetcode-python\problems\python\permutations-ii.py,permuteUnique,132
3818,permutations-ii.py::dfs::16,"        def dfs(path, options):
            if len(path)==len(nums):
                opt.append(path)
                return
            for i, n in enumerate(options):
                if i>0 and options[i]==options[i-1]: continue
                dfs(path+[n], options[:i]+options[i+1:])",data\repos\leetcode-python\problems\python\permutations-ii.py,dfs,63
3819,permutations-ii.py::helper::40,"        def helper(path):
            if len(path)==len(nums): ans.append(path[:])
            
            for num in counter:
                if counter[num]>0:
                    path.append(num)
                    counter[num] -= 1
                    
                    helper(path)
                    
                    path.pop()
                    counter[num] += 1",data\repos\leetcode-python\problems\python\permutations-ii.py,helper,61
3820,permutations.py::permute::19,"    def permute(self, nums):
        def dfs(path, options):
            if len(nums)==len(path):
                opt.append(path)
                return
            for i, nums in enumerate(options):
                dfs(path+[nums], options[:i]+options[i+1:])

        opt = []
        dfs([], nums)
        return opt",data\repos\leetcode-python\problems\python\permutations.py,permute,68
3821,permutations.py::permute::41,"    def permute(self, nums):
        def dfs(remains, path):
            if not remains: ans.append(path)
            
            for i, n in enumerate(remains):
                dfs(remains[:i]+remains[i+1:], path+[n])
        
        ans = []
        dfs(nums, [])
        return ans",data\repos\leetcode-python\problems\python\permutations.py,permute,69
3822,permutations.py::permute::64,"    def permute(self, nums):
        def helper(i):
            if i>=N: ans.append(nums[:])
            
            for j in xrange(i, N):
                nums[i], nums[j] = nums[j], nums[i]
                helper(i+1)
                nums[i], nums[j] = nums[j], nums[i]
        
        N = len(nums)
        ans = []
        helper(0)
        return ans",data\repos\leetcode-python\problems\python\permutations.py,permute,87
3823,permutations.py::permute::83,"    def permute(self, nums):
        if not nums: return []
        
        permutations = collections.deque([[nums[0]]])
        
        for i in xrange(1, len(nums)):
            num = nums[i]
            l = len(permutations)    
            
            while l:
                permutation = permutations.popleft()
                for j in xrange(len(permutation)+1):
                    newPermutaion = permutation[:]
                    newPermutaion.insert(j, num)
                    permutations.append(newPermutaion)
                l -= 1
        
        return permutations",data\repos\leetcode-python\problems\python\permutations.py,permute,115
3824,permutations.py::dfs::20,"        def dfs(path, options):
            if len(nums)==len(path):
                opt.append(path)
                return
            for i, nums in enumerate(options):
                dfs(path+[nums], options[:i]+options[i+1:])",data\repos\leetcode-python\problems\python\permutations.py,dfs,47
3825,permutations.py::dfs::42,"        def dfs(remains, path):
            if not remains: ans.append(path)
            
            for i, n in enumerate(remains):
                dfs(remains[:i]+remains[i+1:], path+[n])",data\repos\leetcode-python\problems\python\permutations.py,dfs,48
3826,permutations.py::helper::65,"        def helper(i):
            if i>=N: ans.append(nums[:])
            
            for j in xrange(i, N):
                nums[i], nums[j] = nums[j], nums[i]
                helper(i+1)
                nums[i], nums[j] = nums[j], nums[i]",data\repos\leetcode-python\problems\python\permutations.py,helper,60
3827,populating-next-right-pointers-in-each-node-ii.py::connect::13,"    def connect(self, root):
        if not root: return root
        
        leftmost = root
        
        while leftmost:
            curr = leftmost
            
            while curr:
                if curr.left:
                    if curr.right:
                        curr.left.next = curr.right
                    else:
                        n = curr.next
                        while n:
                            curr.left.next = n.left or n.right
                            if curr.left.next: break
                            n = n.next
                
                if curr.right:
                    n = curr.next
                    while n:
                        curr.right.next = n.left or n.right
                        if curr.right.next: break
                        n = n.next
                
                curr = curr.next
            
            nextLevelLeftmost = None
            n = leftmost
            while n:
                if n.left or n.right:
                    nextLevelLeftmost = n.left or n.right
                    break
                n = n.next
            leftmost = nextLevelLeftmost
            
        return root",data\repos\leetcode-python\problems\python\populating-next-right-pointers-in-each-node-ii.py,connect,197
3828,populating-next-right-pointers-in-each-node.py::connect::9,"    def connect(self, root):
        if not root: return root
        level = collections.deque([root])
        nextLevel = collections.deque()
        
        while level:
            node = level.popleft()
            
            if node.left: nextLevel.append(node.left)
            if node.right: nextLevel.append(node.right)
            
            if not level:
                if not nextLevel: break
                for i, c in enumerate(nextLevel):
                    if i==len(nextLevel)-1: continue #skip last
                    c.next = nextLevel[i+1]
                level = nextLevel
                nextLevel = collections.deque()
                
        return root",data\repos\leetcode-python\problems\python\populating-next-right-pointers-in-each-node.py,connect,134
3829,populating-next-right-pointers-in-each-node.py::connect::42,"    def connect(self, root):
        if not root: return root
        
        leftmost = root
        while leftmost:
            
            curr = leftmost
            while curr:
                if curr.left: curr.left.next = curr.right
                if curr.right and curr.next: curr.right.next = curr.next.left
                curr = curr.next
                
            leftmost = leftmost.left
        
        return root",data\repos\leetcode-python\problems\python\populating-next-right-pointers-in-each-node.py,connect,82
3830,powx-n.py::myPow::2,"    def myPow(self, x, n):
        if n==0:
            return 1
        elif n<0:
            return 1/self.myPow(x, -n)
        elif n%2>0:
            half = self.myPow(x, n-1)
            return x*half
        elif n%2==0:
            half = self.myPow(x, n/2)
            return half*half",data\repos\leetcode-python\problems\python\powx-n.py,myPow,90
3831,product-of-array-except-self.py::productExceptSelf::25,"    def productExceptSelf(self, nums):
        l = len(nums)
        output = []

        t = 1
        for i in xrange(l): #[1]
            output.append(t)
            t = t*nums[i] #[2]
        
        t = 1 #reset the temporary variable
        for i in reversed(xrange(l)): #[3]
            output[i] = output[i]*t #[5]
            t = t*nums[i] #[4]
            
        return output",data\repos\leetcode-python\problems\python\product-of-array-except-self.py,productExceptSelf,102
3832,product-of-array-except-self.py::productExceptSelf::49,"    def productExceptSelf(self, nums):
        N = len(nums)
        
        left = [1]*N
        for i in xrange(1, len(nums)):
            left[i] = left[i-1] * nums[i-1]
        
        right = [1]*N
        for i in xrange(N-2, -1, -1):
            right[i] = right[i+1] * nums[i+1]
        
        ans = []
        for i in xrange(N):
            ans.append(left[i]*right[i])
        return ans",data\repos\leetcode-python\problems\python\product-of-array-except-self.py,productExceptSelf,115
3833,product-of-array-except-self.py::productExceptSelf::70,"    def productExceptSelf(self, nums):
        N = len(nums)
        
        #[1]
        opt = [1]*N
        for i in xrange(1, len(nums)):
            opt[i] = opt[i-1] * nums[i-1]
        
        #[2]
        t = 1
        for i in xrange(N-2, -1, -1):
            t *= nums[i+1]
            opt[i] *= t
        
        return opt",data\repos\leetcode-python\problems\python\product-of-array-except-self.py,productExceptSelf,99
3834,profitable-schemes.py::profitableSchemes::6,"    def profitableSchemes(self, maxMember, minProfit, group, profit):
        P = sum(profit)
        N = sum(group)
        dp = [[[0 for _ in xrange(P+1)] for _ in xrange(N+1)] for _ in xrange(len(profit)+1)]
        dp[0][0][0] = 1
        
        count = 0
        for i in xrange(1, len(profit)+1):
            for n in xrange(N+1):
                for p in xrange(P+1):
                    dp[i][n][p] = (dp[i-1][n-group[i-1]][p-profit[i-1]] if p-profit[i-1]>=0 and n-group[i-1]>=0 else 0) + dp[i-1][n][p]
                    if i==len(profit) and p>=minProfit and n<=maxMember: count += dp[i][n][p]
        return count",data\repos\leetcode-python\problems\python\profitable-schemes.py,profitableSchemes,200
3835,profitable-schemes.py::profitableSchemes::26,"    def profitableSchemes(self, n, minProfit, group, profit):
        N = len(profit)
        
        dp = [[[0]*(n+2) for _ in xrange(minProfit+1)] for _ in xrange(N+1)]
        dp[0][0][0] = 1
        
        for i in xrange(1, N+1):
            for p in xrange(minProfit+1):
                for g in xrange(n+1):
                    pi = profit[i-1]
                    gi = group[i-1]
                    
                    #considerting last round using p and g
                    dp[i][p][g] += dp[i-1][p][g]
                    dp[i][min(pi+p, minProfit)][min(gi+g, n+1)] += dp[i-1][p][g]
        
        ans = 0
        for g in xrange(n+1):
            ans += dp[N][minProfit][g]
        return ans % (10**9 + 7)",data\repos\leetcode-python\problems\python\profitable-schemes.py,profitableSchemes,213
3836,queue-reconstruction-by-height.py::reconstructQueue::10,"    def reconstructQueue(self, people):
        people.sort(key=lambda x: (-x[0], x[1]))
        ans = []
        for h, k in people:
            ans.insert(k, (h, k))
        return ans",data\repos\leetcode-python\problems\python\queue-reconstruction-by-height.py,reconstructQueue,49
3837,range-addition.py::getModifiedArray::25,"    def getModifiedArray(self, length, updates):
        ans = [0]*length
        updateSummary = [0]*length
        
        for s, e, v in updates:
            updateSummary[s] += v
            if e+1<len(updateSummary): updateSummary[e+1] -= v
        
        temp = 0
        for i in xrange(len(ans)):
            temp+=updateSummary[i]
            ans[i] = temp
        
        return ans",data\repos\leetcode-python\problems\python\range-addition.py,getModifiedArray,95
3838,range-addition.py::getModifiedArray::47,"    def getModifiedArray(self, length, updates):
        ans = [0]*length
        
        for s, e, v in updates:
            ans[s] += v
            if e+1<len(ans): ans[e+1] -= v
        
        temp = 0
        for i in xrange(len(ans)):
            temp+=ans[i]
            ans[i] = temp
        
        return ans",data\repos\leetcode-python\problems\python\range-addition.py,getModifiedArray,82
3839,range-sum-of-bst.py::rangeSumBST::2,"    def rangeSumBST(self, root, low, high):
        def helper(node, low, high):
            total = 0
            if not node: return total
            if low<=node.val<=high: total += node.val
            if node.val<=high: total += helper(node.right, low, high)
            if node.val>=low: total += helper(node.left, low, high)
            return total
        
        return helper(root, low, high)",data\repos\leetcode-python\problems\python\range-sum-of-bst.py,rangeSumBST,97
3840,range-sum-of-bst.py::helper::3,"        def helper(node, low, high):
            total = 0
            if not node: return total
            if low<=node.val<=high: total += node.val
            if node.val<=high: total += helper(node.right, low, high)
            if node.val>=low: total += helper(node.left, low, high)
            return total",data\repos\leetcode-python\problems\python\range-sum-of-bst.py,helper,74
3841,range-sum-query-immutable.py::sumRange::12,"    def sumRange(self, i, j):
        return self.total[j] - self.total[i-1] if i>0 else self.total[j]",data\repos\leetcode-python\problems\python\range-sum-query-immutable.py,sumRange,32
3842,range-sum-query-mutable.py::update::27,"    def update(self, i, val):
        def helper(node, i, val):
            if node.start==node.end==i:
                node.val = val
                return
            
            if node.mid<i:
                helper(node.right, i, val)
            elif i<=node.mid:
                helper(node.left, i, val)
            node.val = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
            
        return helper(self.root, i, val)",data\repos\leetcode-python\problems\python\range-sum-query-mutable.py,update,106
3843,range-sum-query-mutable.py::sumRange::43,"    def sumRange(self, i, j):
        def helper(node, i, j):
            if not node: return 0
            if node.start==i and node.end==j:
                return node.val
            elif node.mid<i:
                return helper(node.right, i, j)
            elif j<=node.mid:
                return helper(node.left, i, j)
            else:
                return helper(node.left, i, node.mid)+helper(node.right, node.mid+1, j)
        return helper(self.root, i, j)",data\repos\leetcode-python\problems\python\range-sum-query-mutable.py,sumRange,113
3844,range-sum-query-mutable.py::buildSegmentTree::11,"        def buildSegmentTree(start, end):
            if start>end: return None
            node = Node(start, end)
            
            if start==end:
                node.val = nums[end]
            else:
                node.left = buildSegmentTree(start, node.mid)
                node.right = buildSegmentTree(node.mid+1, end)
                node.val = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
            
            return node",data\repos\leetcode-python\problems\python\range-sum-query-mutable.py,buildSegmentTree,100
3845,range-sum-query-mutable.py::helper::28,"        def helper(node, i, val):
            if node.start==node.end==i:
                node.val = val
                return
            
            if node.mid<i:
                helper(node.right, i, val)
            elif i<=node.mid:
                helper(node.left, i, val)
            node.val = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)",data\repos\leetcode-python\problems\python\range-sum-query-mutable.py,helper,86
3846,range-sum-query-mutable.py::helper::44,"        def helper(node, i, j):
            if not node: return 0
            if node.start==i and node.end==j:
                return node.val
            elif node.mid<i:
                return helper(node.right, i, j)
            elif j<=node.mid:
                return helper(node.left, i, j)
            else:
                return helper(node.left, i, node.mid)+helper(node.right, node.mid+1, j)",data\repos\leetcode-python\problems\python\range-sum-query-mutable.py,helper,93
3847,rearrange-string-k-distance-apart.py::rearrangeString::24,"    def rearrangeString(self, s, k):
        if k==0: return s
        ans = ''
        
		#[0]
        counter = collections.Counter(s)
        h = [(-counter[c], c) for c in counter]
        heapq.heapify(h)
        
        while h:
            l = []
            for i in xrange(k):
                _, c = heapq.heappop(h)
                ans += c
                counter[c] -= 1
                if counter[c]!=0: l.append((-counter[c], c)) #[2]
                
                if len(ans)==len(s): return ans
                if not h and i!=k-1: return '' #[3]
            
            for e in l: heapq.heappush(h, e)
        
        return ans #this line should never be executed",data\repos\leetcode-python\problems\python\rearrange-string-k-distance-apart.py,rearrangeString,169
3848,reconstruct-itinerary.py::findItinerary::21,"    def findItinerary(self, tickets):
        def dfs():
            if len(itinerary)==len(tickets)+1: return True
            here = itinerary[-1]
            if here not in G: return False

            candidates = [(nei, ticket_id) for nei, ticket_id in G[here] if ticket_id not in ticket_used]
            
            for nei, ticket_id in candidates:
                ticket_used.add(ticket_id)
                itinerary.append(nei)
                if dfs(): return True
                ticket_used.remove(ticket_id)
                itinerary.pop()
            return False

        G = collections.defaultdict(list)
        itinerary = ['JFK']
        ticket_used = set()

        #build graph
        ticket_id_counter = 0
        for n1, n2 in tickets:
            G[n1].append((n2, ticket_id_counter))
            ticket_id_counter += 1
        for k in G: G[k].sort(key=lambda x:x[0])
        
        return dfs()",data\repos\leetcode-python\problems\python\reconstruct-itinerary.py,findItinerary,206
3849,reconstruct-itinerary.py::dfs::22,"        def dfs():
            if len(itinerary)==len(tickets)+1: return True
            here = itinerary[-1]
            if here not in G: return False

            candidates = [(nei, ticket_id) for nei, ticket_id in G[here] if ticket_id not in ticket_used]
            
            for nei, ticket_id in candidates:
                ticket_used.add(ticket_id)
                itinerary.append(nei)
                if dfs(): return True
                ticket_used.remove(ticket_id)
                itinerary.pop()
            return False",data\repos\leetcode-python\problems\python\reconstruct-itinerary.py,dfs,108
3850,recover-binary-search-tree.py::recoverTree::6,"    def recoverTree(self, root):
        memo = {} #{node.val:node}
        stack = []
        node = root
        vals = []
        
        #inorder traversal and store the values in `vals` and `memo`
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            
            node = stack.pop()
            
            memo[node.val] = node
            vals.append(node.val)
            
            node = node.right
        
        #find two val that needed to be swapped
        diff = []
        sortedVals = sorted(vals)
        for i in xrange(len(sortedVals)):
            if vals[i]!=sortedVals[i]: diff.append(vals[i])
            if len(diff)>=2: break
        
        #swap the values
        memo[diff[0]].val = diff[1]
        memo[diff[1]].val = diff[0]
        
        return root",data\repos\leetcode-python\problems\python\recover-binary-search-tree.py,recoverTree,188
3851,recover-binary-search-tree.py::recoverTree::44,"    def recoverTree(self, root):
        stack = []
        node = root
        prev = TreeNode(float('-inf'))
        swap1 = swap2 = None
        
        #inorder traversal and find the swapped values
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            
            node = stack.pop()
            
            if swap1==None and prev.val>node.val: swap1 = prev
            if swap1!=None and prev.val>node.val: swap2 = node

            prev = node

            node = node.right
        
        #swap the values
        swap1.val, swap2.val = swap2.val, swap1.val
        
        return root",data\repos\leetcode-python\problems\python\recover-binary-search-tree.py,recoverTree,146
3852,redundant-connection.py::findRedundantConnection::10,"    def findRedundantConnection(self, edges):
        def dfs(u, v):
            seen = set()
            stack = []
            stack.append(u)
            
            while stack:
                node = stack.pop()
                seen.add(node)
                
                if v in G[node]: return True
                
                for nei in G[node]:
                    if nei not in seen:
                        stack.append(nei)
            return False
            
        G = defaultdict(set)
        
        for u, v in edges:
            if u in G and v in G and dfs(u, v): return u, v
            G[u].add(v)
            G[v].add(u)",data\repos\leetcode-python\problems\python\redundant-connection.py,findRedundantConnection,132
3853,redundant-connection.py::find::46,"    def find(self, x):
        if self.parant[x]!=x:
            self.parant[x] = self.find(self.parant[x])
        return self.parant[x]",data\repos\leetcode-python\problems\python\redundant-connection.py,find,37
3854,redundant-connection.py::union::51,"    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr==yr:
            return False
        elif self.rank[xr]>self.rank[yr]:
            self.parant[yr] = xr
            self.rank[xr] += 1
        else:
            self.parant[xr] = yr
            self.rank[yr] += 1
        return True",data\repos\leetcode-python\problems\python\redundant-connection.py,union,90
3855,redundant-connection.py::findRedundantConnection::64,"    def findRedundantConnection(self, edges):
        dsu = DSU()
        for edge in edges:
            if not dsu.union(*edge):
                return edge",data\repos\leetcode-python\problems\python\redundant-connection.py,findRedundantConnection,36
3856,redundant-connection.py::find::79,"    def find(self, x):
        if self.parant[x]!=x:
            self.parant[x] = self.find(self.parant[x])
        return self.parant[x]",data\repos\leetcode-python\problems\python\redundant-connection.py,find,37
3857,redundant-connection.py::union::84,"    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr==yr: return False
        self.parant[yr] = xr
        return True",data\repos\leetcode-python\problems\python\redundant-connection.py,union,44
3858,redundant-connection.py::findRedundantConnection::91,"    def findRedundantConnection(self, edges):
        dsu = DSU()
        for edge in edges:
            if not dsu.union(*edge):
                return edge",data\repos\leetcode-python\problems\python\redundant-connection.py,findRedundantConnection,36
3859,redundant-connection.py::dfs::11,"        def dfs(u, v):
            seen = set()
            stack = []
            stack.append(u)
            
            while stack:
                node = stack.pop()
                seen.add(node)
                
                if v in G[node]: return True
                
                for nei in G[node]:
                    if nei not in seen:
                        stack.append(nei)
            return False",data\repos\leetcode-python\problems\python\redundant-connection.py,dfs,71
3860,remove-all-adjacent-duplicates-in-string.py::removeDuplicates::2,"    def removeDuplicates(self, s):
        stack = []
        i = 0
        while i<len(s):
            if stack and stack[-1]==s[i]:
                stack.pop()    
            else:
                stack.append(s[i])
            i += 1
        
        return ''.join(stack)",data\repos\leetcode-python\problems\python\remove-all-adjacent-duplicates-in-string.py,removeDuplicates,61
3861,remove-all-ones-with-row-and-column-flips.py::removeOnes::12,"    def removeOnes(self, grid):
        if not grid: return True
        rowStrings = set()
        
        for row in grid:
            rowStrings.add(''.join((str(e) for e in row)))
        
        if len(rowStrings)>2: return False
        if len(rowStrings)==1: return True
        
        s1 = rowStrings.pop()
        s2 = rowStrings.pop()
        
        for i in xrange(len(s1)):
            if (s1[i]=='0' and s2[i]=='1') or (s1[i]=='1' and s2[i]=='0'): continue
            return False
        return True",data\repos\leetcode-python\problems\python\remove-all-ones-with-row-and-column-flips.py,removeOnes,135
3862,remove-duplicates-from-sorted-array-ii.py::removeDuplicates::7,"    def removeDuplicates(self, nums):
        j = 2
        
        for i in xrange(2, len(nums)):
            if not (nums[i]==nums[j-1] and nums[i]==nums[j-2]):
                nums[j] = nums[i]
                j += 1
        return j",data\repos\leetcode-python\problems\python\remove-duplicates-from-sorted-array-ii.py,removeDuplicates,63
3863,remove-duplicates-from-sorted-array.py::removeDuplicates::6,"    def removeDuplicates(self, nums):
        j = 1
        for i in xrange(1, len(nums)):
            if nums[i]!=nums[i-1]:
                nums[j] = nums[i]
                j += 1
        return j",data\repos\leetcode-python\problems\python\remove-duplicates-from-sorted-array.py,removeDuplicates,52
3864,remove-duplicates-from-sorted-list.py::deleteDuplicates::16,"    def deleteDuplicates(self, head):
        if head is None or head.next is None: return head

        prev = head
        curr = head.next
        seen = set() #[1]

        seen.add(prev.val)
        while curr:
            if curr.val not in seen: #[2]
                seen.add(curr.val)
                curr = curr.next
                prev = prev.next
            else: #[3]
                prev.next = curr.next #remove
                curr = curr.next
        return head",data\repos\leetcode-python\problems\python\remove-duplicates-from-sorted-list.py,deleteDuplicates,104
3865,remove-element.py::removeElement::6,"    def removeElement(self, nums, val):
        j = 0
        for n in nums:
            if n!=val:
                nums[j] = n
                j += 1
        return j",data\repos\leetcode-python\problems\python\remove-element.py,removeElement,44
3866,remove-invalid-parentheses.py::removeInvalidParentheses::2,"    def removeInvalidParentheses(self, s):
        def dfs(s, curr, i, count):
            if count<0: return
            if len(curr)>self.maxLen: return
            
            if i>=len(s):
                if len(curr)==self.maxLen and count==0:
                    self.ans.append(curr)
                return
            
            if s[i]!='(' and s[i]!=')':
                dfs(s, curr+s[i], i+1, count)
            elif not curr or s[i]!=curr[-1]:
                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))
                dfs(s, curr, i+1, count)
            elif s[i]==curr[-1]:
                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))
                
        def getMaxLen(s):
            openCount = removeCount = 0
            for c in s:
                if c=='(':
                    openCount += 1
                elif c==')':
                    openCount -= 1
                
                if openCount<0:
                    removeCount += abs(openCount)
                    openCount = 0
            removeCount += openCount   
            return len(s)-removeCount
        
        self.ans = []
        self.maxLen = getMaxLen(s)
        
        dfs(s, """", 0, 0)
        return self.ans",data\repos\leetcode-python\problems\python\remove-invalid-parentheses.py,removeInvalidParentheses,297
3867,remove-invalid-parentheses.py::dfs::3,"        def dfs(s, curr, i, count):
            if count<0: return
            if len(curr)>self.maxLen: return
            
            if i>=len(s):
                if len(curr)==self.maxLen and count==0:
                    self.ans.append(curr)
                return
            
            if s[i]!='(' and s[i]!=')':
                dfs(s, curr+s[i], i+1, count)
            elif not curr or s[i]!=curr[-1]:
                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))
                dfs(s, curr, i+1, count)
            elif s[i]==curr[-1]:
                dfs(s, curr+s[i], i+1, count + (1 if s[i]=='(' else -1))",data\repos\leetcode-python\problems\python\remove-invalid-parentheses.py,dfs,169
3868,remove-invalid-parentheses.py::getMaxLen::20,"        def getMaxLen(s):
            openCount = removeCount = 0
            for c in s:
                if c=='(':
                    openCount += 1
                elif c==')':
                    openCount -= 1
                
                if openCount<0:
                    removeCount += abs(openCount)
                    openCount = 0
            removeCount += openCount   
            return len(s)-removeCount",data\repos\leetcode-python\problems\python\remove-invalid-parentheses.py,getMaxLen,84
3869,remove-linked-list-elements.py::removeElements::3,"    def removeElements(self, head, val):
        if head is None:
            return head
        
        #check head
        if head.val==val:
            return self.removeElements(head.next, val)
        
        current = head
        
        while current and current.next:
            #save the current node on prev
            #move current to next node
            prev = current
            current = current.next
            
            if current.val==val:
                #remove
                prev.next = current.next
                current = prev
                
        return head",data\repos\leetcode-python\problems\python\remove-linked-list-elements.py,removeElements,109
3870,remove-nth-node-from-end-of-list.py::removeNthFromEnd::2,"    def removeNthFromEnd(self, head, n):
        def getCount(node0):
            curr = node0
            count = 0
            while curr:
                curr = curr.next
                count += 1
            return count
        
        def removeNext(node0):
            nextNode = node0.next
            if not nextNode: return
            node0.next = nextNode.next
        
        k = getCount(head)-n-1 #need to ""curr = curr.next"" k times to reach the node that we can call removeNext(curr)
        if k==-1: return head.next #remove head
        
        curr = head
        while k>0:
            k -= 1
            curr = curr.next
        
        removeNext(curr)
        return head",data\repos\leetcode-python\problems\python\remove-nth-node-from-end-of-list.py,removeNthFromEnd,159
3871,remove-nth-node-from-end-of-list.py::getCount::3,"        def getCount(node0):
            curr = node0
            count = 0
            while curr:
                curr = curr.next
                count += 1
            return count",data\repos\leetcode-python\problems\python\remove-nth-node-from-end-of-list.py,getCount,37
3872,remove-nth-node-from-end-of-list.py::removeNext::11,"        def removeNext(node0):
            nextNode = node0.next
            if not nextNode: return
            node0.next = nextNode.next",data\repos\leetcode-python\problems\python\remove-nth-node-from-end-of-list.py,removeNext,31
3873,reorder-list.py::reorderList::20,"    def reorderList(self, head):
        if head is None: return
        h = head
        curr = head
        stack = []
        count = 0

        while curr:
            count+=1
            stack.append(curr)
            curr = curr.next

        while count>1:
            temp = h.next
            h.next = stack.pop()
            h.next.next = temp
            count-=2
            h = h.next.next

        h.next = None",data\repos\leetcode-python\problems\python\reorder-list.py,reorderList,99
3874,repeated-string-match.py::repeatedStringMatch::2,"    def repeatedStringMatch(self, a, b):
        """"""
        compare a[i] and b[j]
        if a[i]!=b[j], return -1 
        if a new set of ""a"" is needed, count += 1
        """"""
        def helper(i):
            count = 1
            j = 0
            
            while j<len(b):
                if a[i]!=b[j]: return -1
                j += 1
                
                if i==len(a)-1 and j<len(b):
                    # if we need an extra ""a"", count += 1
                    i = 0
                    count += 1
                else:
                    i += 1
            return count
        
        if len(set(b)-set(a))>0: return -1
        
        #the index of the starting point need to be as small as posible. So that we can get the minimum answer.
        for i in xrange(len(a)):
            if a[i]==b[0]:
                ans = helper(i)
                if ans>0: return ans
        
        return -1",data\repos\leetcode-python\problems\python\repeated-string-match.py,repeatedStringMatch,224
3875,repeated-string-match.py::helper::8,"        def helper(i):
            count = 1
            j = 0
            
            while j<len(b):
                if a[i]!=b[j]: return -1
                j += 1
                
                if i==len(a)-1 and j<len(b):
                    # if we need an extra ""a"", count += 1
                    i = 0
                    count += 1
                else:
                    i += 1
            return count",data\repos\leetcode-python\problems\python\repeated-string-match.py,helper,93
3876,replace-the-substring-for-balanced-string.py::balancedString::2,"    def balancedString(self, s):
        n = len(s)
        counter = collections.Counter(s)
        i = 0
        ans = n
        
        for j, c in enumerate(s):
            counter[c] -= 1
            
            while i<n and all(counter[c]<=n/4 for c in 'QEWR'):
                counter[s[i]] += 1
                ans = min(ans, j-i+1)
                i += 1
        return ans",data\repos\leetcode-python\problems\python\replace-the-substring-for-balanced-string.py,balancedString,97
3877,restore-ip-addresses.py::restoreIpAddresses::2,"    def restoreIpAddresses(self, s):
        def search(digit, ip):
            if len(ip)==4:
                if len(digit)==0: opt.append(ip)
                return

            for i in xrange(1, len(digit)+1):
                num = int(digit[:i])
                if 0<=num and num<=255 and len(digit[:i])==len(str(num)):
                    search(digit[i:], ip+[digit[:i]])
        opt = []
        search(s, [])
        return ['.'.join(ip) for ip in opt]",data\repos\leetcode-python\problems\python\restore-ip-addresses.py,restoreIpAddresses,116
3878,restore-ip-addresses.py::search::3,"        def search(digit, ip):
            if len(ip)==4:
                if len(digit)==0: opt.append(ip)
                return

            for i in xrange(1, len(digit)+1):
                num = int(digit[:i])
                if 0<=num and num<=255 and len(digit[:i])==len(str(num)):
                    search(digit[i:], ip+[digit[:i]])",data\repos\leetcode-python\problems\python\restore-ip-addresses.py,search,86
3879,reverse-integer.py::reverse::3,"    def reverse(self, x):
        if x>=(2**31)-1 or x<(-2)**31:
            return 0
        
        if x>=0:
            x = str(x)[::-1]
        else:
            x = str(-x)[::-1]
            x = '-'+x
            
        if x[0] == '0':
            x = x[0:]
            
        x = int(x)
        
        if x>=(2**31)-1 or x<(-2)**31:
            return 0
        
        return x",data\repos\leetcode-python\problems\python\reverse-integer.py,reverse,116
3880,reverse-linked-list.py::reverseList::28,"    def reverseList(self, node):
        if node and node.next:
            new_head = self.reverseList(node.next)
            node.next.next = node
            node.next = None
            return new_head
        return node",data\repos\leetcode-python\problems\python\reverse-linked-list.py,reverseList,46
3881,reverse-linked-list.py::reverseList::38,"    def reverseList(self, node):
        pre = None
        while node:
            next_node = node.next
            node.next = pre
            if not next_node: return node
            pre = node
            node = next_node",data\repos\leetcode-python\problems\python\reverse-linked-list.py,reverseList,49
3882,reverse-linked-list.py::reverseList::54,"    def reverseList(self, head):
        if not head or not head.next: return head
        
        reversedHead = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return reversedHead",data\repos\leetcode-python\problems\python\reverse-linked-list.py,reverseList,47
3883,reverse-string.py::reverseString::17,"    def reverseString(self, string):
        s = 0
        e = len(string)-1
        while e>s:
            (string[s], string[e]) = (string[e], string[s])
            s+=1
            e-=1
        return string",data\repos\leetcode-python\problems\python\reverse-string.py,reverseString,56
3884,reverse-vowels-of-a-string.py::reverseVowels::2,"    def reverseVowels(self, s):
        i = 0
        j = len(s)-1
        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])
        s = list(s)
        
        while i<j:
            if s[i] not in vowels:
                i += 1
                continue
            if s[j] not in vowels:
                j -= 1
                continue
            
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1
        
        return """".join(s)",data\repos\leetcode-python\problems\python\reverse-vowels-of-a-string.py,reverseVowels,138
3885,reverse-words-in-a-string.py::reverseWords::15,"    def reverseWords(self, s):
        temp = ''
        opt = ''
        s = s+' ' #[0]
        for c in s:
            if c==' ':
                if temp is not '': opt = temp+' '+opt #[1]
                temp = ''
            else:
                temp+=c

        opt = opt[:-1] #[2]
        return opt",data\repos\leetcode-python\problems\python\reverse-words-in-a-string.py,reverseWords,78
3886,reverse-words-in-a-string.py::reverseWords::32,"    def reverseWords(self, s):
        stack = s.split()
        
        ans = ''
        while stack: ans += stack.pop()+' '
        ans = ans[:len(ans)-1] #remove last space
        return ans",data\repos\leetcode-python\problems\python\reverse-words-in-a-string.py,reverseWords,48
3887,robot-bounded-in-circle.py::isRobotBounded::2,"    def isRobotBounded(self, instructions):
        direction = 0
        x = y = 0
        
        for i in instructions:
            if i=='L':
                direction -= 1
                direction = direction%4
            elif i=='R':
                direction += 1
                direction = direction%4
            elif i=='G':
                if direction==0:
                    y+=1
                elif direction==1:
                    x+=1
                elif direction==2:
                    y-=1
                elif direction==3:
                    x-=1
        
        moved = (x, y) != (0, 0)
        rotated = direction!=0

        if not moved: return True
        if moved and rotated: return True
        if moved and not rotated: return False",data\repos\leetcode-python\problems\python\robot-bounded-in-circle.py,isRobotBounded,166
3888,roman-to-integer.py::romanToInt::3,"    def romanToInt(self, s):
        counter = 0
        special = {
            'IV':4,
            'IX':9,
            'XL':40,
            'XC':90,
            'CD':400,
            'CM':900,
        }
        normal = {
            'I':1,
            'V':5,
            'X':10,
            'L':50,
            'C':100,
            'D':500,
            'M':1000
        }
        
        for char, num in special.items():
            if char in s:
                counter+=num
                s = s.replace(char, '')
                if s=='':
                    return counter
                
        for char, num in normal.items():
            if char in s:
                counter+=num*s.count(char)
                s = s.replace(char, '')
                if s=='':
                    return counter
                
                
        return counter",data\repos\leetcode-python\problems\python\roman-to-integer.py,romanToInt,187
3889,rotate-array.py::rotate::6,"    def rotate(self, nums, k):
        if len(nums)<=1: return nums
        
        N = len(nums)
        k = k%N
        store = nums[:k]
        
        for i in xrange(N-1, k-1, -1):
            j = i+k if i+k<N else i+k-N
            nums[j] = nums[i]
        
        for i in xrange(len(store)):
            j = i+k if i+k<N else i+k-N
            nums[j] = store[i]",data\repos\leetcode-python\problems\python\rotate-array.py,rotate,109
3890,rotate-array.py::rotate::26,"    def rotate(self, nums, k):
        def reverse(A, start, end):
            while start<end:
                A[start], A[end] = A[end], A[start]
                start += 1
                end -= 1
        

        N = len(nums)
        k = k%N
        reverse(nums, 0, N-1-k)
        reverse(nums, N-k, N-1)
        reverse(nums, 0, N-1)",data\repos\leetcode-python\problems\python\rotate-array.py,rotate,98
3891,rotate-array.py::reverse::27,"        def reverse(A, start, end):
            while start<end:
                A[start], A[end] = A[end], A[start]
                start += 1
                end -= 1",data\repos\leetcode-python\problems\python\rotate-array.py,reverse,40
3892,rotate-image.py::rotate::2,"    def rotate(self, matrix):
        N = len(matrix)
        
        #transpose
        for i in xrange(N):
            for j in xrange(N):
                if j<=i: continue
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        
        #reflect
        for i in xrange(N):
            for j in xrange(N/2):
                matrix[i][j], matrix[i][N-1-j] = matrix[i][N-1-j], matrix[i][j]
        
        return matrix",data\repos\leetcode-python\problems\python\rotate-image.py,rotate,115
3893,russian-doll-envelopes.py::maxEnvelopes::10,"    def maxEnvelopes(self, envelopes):
        if not envelopes: return 0
        
        N = len(envelopes)
        dp = [1]*N
        envelopes = sorted(envelopes)
        ans = 1
        
        for i in xrange(N):
            for j in xrange(i):
                if envelopes[i][0]>envelopes[j][0] and envelopes[i][1]>envelopes[j][1]:
                    dp[i] = max(dp[i], dp[j]+1)
                    ans = max(ans, dp[i])
        
        return ans",data\repos\leetcode-python\problems\python\russian-doll-envelopes.py,maxEnvelopes,117
3894,russian-doll-envelopes.py::maxEnvelopes::41,"    def maxEnvelopes(self, envelopes):
        if not envelopes: return 0
        
        N = len(envelopes)
        dp = [1]*N
        envelopes = envelopes.sort(key=lambda x:(x[0], -x[1]))

        return self.getLIS([envelope[1] for envelope in envelopes])",data\repos\leetcode-python\problems\python\russian-doll-envelopes.py,maxEnvelopes,70
3895,russian-doll-envelopes.py::getLIS::50,"    def getLIS(self, A):
        dp = []

        for n in A:
            i = bisect.bisect_left(dp, n)

            if i==len(dp):
                dp.append(n)
            else:
                dp[i] = n
        
        return len(dp)",data\repos\leetcode-python\problems\python\russian-doll-envelopes.py,getLIS,59
3896,same-tree.py::isSameTree::4,"    def isSameTree(self, p, q):
        q1 = deque([p])
        q2 = deque([q])
        while q1 or q2:
            if not q1 or not q2: return False
            n1 = q1.popleft()
            n2 = q2.popleft()
            
            if n1 and n2:
                if n1.val!=n2.val: return False
                q1.append(n1.left)
                q1.append(n1.right)
                q2.append(n2.left)
                q2.append(n2.right)
            elif n1 and not n2:
                return False
            elif not n1 and n2:
                return False
        return True",data\repos\leetcode-python\problems\python\same-tree.py,isSameTree,149
3897,same-tree.py::isSameTree::34,"    def isSameTree(self, p, q):
        def getStr(node):
            s = ''
            q = collections.deque([node])
            
            while q:
                node = q.popleft()
                if not node:
                    s += '#'
                else:
                    s += str(node.val)
                    q.append(node.left)
                    q.append(node.right)
            return s
        
        return getStr(p)==getStr(q)",data\repos\leetcode-python\problems\python\same-tree.py,isSameTree,88
3898,same-tree.py::getStr::35,"        def getStr(node):
            s = ''
            q = collections.deque([node])
            
            while q:
                node = q.popleft()
                if not node:
                    s += '#'
                else:
                    s += str(node.val)
                    q.append(node.left)
                    q.append(node.right)
            return s",data\repos\leetcode-python\problems\python\same-tree.py,getStr,66
3899,satisfiability-of-equality-equations.py::equationsPossible::4,"    def equationsPossible(self, equations):
        def isConnected(n1, n2):
            if n1==n2: return True
            
            stack = [n1]
            visited = set()
            
            while stack:
                n = stack.pop()
                if n in visited: continue
                visited.add(n)
                
                if n==n2: return True
                
                stack.extend(graph[n])
            return False
        
        not_equals = set()
        graph = defaultdict(list)
        
        #build graph
        for e in equations:
            if e[1:3]=='==':
                graph[e[0]].append(e[3])
                graph[e[3]].append(e[0])
            elif e[1:3]=='!=':
                if (e[0], e[3]) not in not_equals and (e[3], e[0]) not in not_equals:
                    not_equals.add((e[0], e[3]))
        
        #find contradiction
        for n1, n2 in not_equals:
            if isConnected(n1, n2): return False
        
        return True",data\repos\leetcode-python\problems\python\satisfiability-of-equality-equations.py,equationsPossible,226
3900,satisfiability-of-equality-equations.py::isConnected::5,"        def isConnected(n1, n2):
            if n1==n2: return True
            
            stack = [n1]
            visited = set()
            
            while stack:
                n = stack.pop()
                if n in visited: continue
                visited.add(n)
                
                if n==n2: return True
                
                stack.extend(graph[n])
            return False",data\repos\leetcode-python\problems\python\satisfiability-of-equality-equations.py,isConnected,76
3901,score-of-parentheses.py::scoreOfParentheses::19,"    def scoreOfParentheses(self, S):
        depth = 0
        start = 0
        score = 0
        for i, s in enumerate(S):
            if s=='(': depth+=1
            if s==')': depth-=1
            if depth==0:
                content = S[start+1:i]
                if content == '':
                    score+=1
                else:
                    score+=self.scoreOfParentheses(content)*2
                start = i+1
        return score",data\repos\leetcode-python\problems\python\score-of-parentheses.py,scoreOfParentheses,106
3902,score-of-parentheses.py::scoreOfParentheses::44,"    def scoreOfParentheses(self, S):
        score = 0
        depth = 0

        for i, s in enumerate(S):
            if s=='(':
                depth+=1
            else:
                depth-=1
                if S[i-1]=='(':
                    score+=2**depth
        return score",data\repos\leetcode-python\problems\python\score-of-parentheses.py,scoreOfParentheses,69
3903,search-a-2d-matrix.py::searchMatrix::7,"    def searchMatrix(self, matrix, target):
        A = []
        for row in matrix: A.extend(row)

        l = 0
        r = len(A)-1
        while l<=r:
            m = (l+r)/2
            if A[l]==target: return True
            if A[m]==target: return True
            if A[r]==target: return True

            if A[m]>target:
                r = m-1
            else:
                l = m+1
        return False",data\repos\leetcode-python\problems\python\search-a-2d-matrix.py,searchMatrix,110
3904,search-a-2d-matrix.py::searchMatrix::26,"    def searchMatrix(self, matrix, target):
        def getMatrix(i):
            n = i/M
            m = i%M
            return matrix[n][m]

        if not matrix or len(matrix)==0 or len(matrix[0])==0: return False

        N = len(matrix)
        M = len(matrix[0])

        l = 0
        r = N*M-1
        while l<=r:
            p = (l+r)/2
            if getMatrix(l)==target: return True
            if getMatrix(p)==target: return True
            if getMatrix(r)==target: return True

            if getMatrix(p)>target:
                r = p-1
            else:
                l = p+1
        return False",data\repos\leetcode-python\problems\python\search-a-2d-matrix.py,searchMatrix,159
3905,search-a-2d-matrix.py::searchMatrix::54,"    def searchMatrix(self, matrix, target):
        if not matrix or not matrix[0]: return False
        
        #if you do not understand binary search yet, please study it first.
        #use binary search to find the list that has target.
        #if found, asign it to A.
        l = 0
        r = len(matrix)-1
        A = None
        while l<=r:
            if matrix[l][0]<=target and target<=matrix[l][-1]:
                A = matrix[l]
                break
            if matrix[r][0]<=target and target<=matrix[r][-1]:
                A = matrix[r]
                break
            
            m = (l+r)/2
            
            if matrix[m][0]<=target and target<=matrix[m][-1]:
                A = matrix[m]
                break
            elif target<matrix[m][0]:
                r = m-1
            else:
                l = m+1
        
        if not A: return False
        
        #find if target in A
        l = 0
        r = len(A)-1
        while l<=r:
            if target==A[l] or target==A[r]: return True
            
            m = (l+r)/2
            
            if target==A[m]:
                return True
            elif target<A[m]:
                r = m-1
            else:
                l = m+1
        return False",data\repos\leetcode-python\problems\python\search-a-2d-matrix.py,searchMatrix,295
3906,search-in-a-binary-search-tree.py::searchBST::6,"    def searchBST(self, root, val):
        node = root
        
        while node:
            if node.val==val:
                return node
            elif node.val>val:
                node = node.left
            else:
                node = node.right

        return None",data\repos\leetcode-python\problems\python\search-in-a-binary-search-tree.py,searchBST,55
3907,search-in-a-binary-search-tree.py::searchBST::24,"    def searchBST(self, node, val):
        if not node: return None
        if node.val==val:
            return node
        elif node.val<val:
            return self.searchBST(node.right, val)
        elif node.val>val:
            return self.searchBST(node.left, val)",data\repos\leetcode-python\problems\python\search-in-a-binary-search-tree.py,searchBST,63
3908,search-in-rotated-sorted-array-ii.py::search::11,"    def search(self, nums, t):
        if nums is None or len(nums)==0: return False
        l = 0
        r = len(nums)-1

        while l<=r:
            p = (l+r)/2
            if nums[l]==t or nums[p]==t or nums[r]==t:
                return True

            if nums[l]<nums[r]:
                #check if out of ragne
                if t<nums[l] or nums[r]<t: return False
                #binary search
                if t<nums[p]:
                    r = p-1
                else:
                    l = p+1
            else:
                if nums[l]<nums[p] and nums[l]<t and t<nums[p]:
                    r = p-1
                elif nums[p]<nums[r] and nums[p]<t and t<nums[r]:
                    l = p+1
                else:
                    r = r-1
                    l = l+1
        return False",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array-ii.py,search,210
3909,search-in-rotated-sorted-array-ii.py::search::42,"    def search(self, nums, target):
        def binary_search(l, r):
            if l>r: return False
            if nums[l]==target: return True
            if nums[r]==target: return True

            m = (l+r)/2
            if nums[m]==target:
                return m
            if target<nums[m]:
                return binary_search(l, m-1)
            else:
                return binary_search(m+1, r)
        
            if not nums: return False
        
        def helper(l, r):
            if l>r: return False
            if nums[l]==target: return True
            if nums[r]==target: return True
            if nums[l]<nums[r]: return binary_search(l+1, r-1)
            
            m = (l+r)/2
            if nums[m]==target: return m

            if helper(l+1, m-1): return True
            if helper(m+1, r-1): return True
            return False
        
        if not nums: return False
        return helper(0, len(nums)-1)",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array-ii.py,search,229
3910,search-in-rotated-sorted-array-ii.py::search::85,"    def search(self, A, T):
        N = len(A)
        l = 0
        r = N-1
        
        while l<=r:

            #skip repeated numbers
            while r>0 and A[r]==A[r-1]: r -= 1
            while l<N-1 and A[l]==A[l+1]: l += 1
            while r>0 and A[l]==A[r]: r -= 1
            while l<N-1 and A[l]==A[r]: l += 1
            
            m = (l+r)/2
            
            if A[l]==T or A[m]==T or A[r]==T: return True
            
            if A[l]<=A[m] and A[m]<=A[r]:
                #l~r is in-order, standard binary search.
                if T<A[l] or T>A[r]: return False #out of range l~r
                
                if A[m]<T:
                    l = m+1
                else:
                    r = m-1
            elif A[l]<=A[m]:
                #l~m is in-order

                if A[l]<T and T<A[m]:
                    #T is in l~m, so search in l~m
                    r = m-1
                else:
                    #T is not in l~m, so search in m~r
                    l = m+1
            else:
                #m~r is in-order

                if A[m]<T and T<A[r]:
                    #T is in m~r, so search m~r
                    l = m+1
                else:
                    #T is not in m~r, so search in l~m
                    r = m-1
        
        return False",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array-ii.py,search,369
3911,search-in-rotated-sorted-array-ii.py::binary_search::43,"        def binary_search(l, r):
            if l>r: return False
            if nums[l]==target: return True
            if nums[r]==target: return True

            m = (l+r)/2
            if nums[m]==target:
                return m
            if target<nums[m]:
                return binary_search(l, m-1)
            else:
                return binary_search(m+1, r)
        
            if not nums: return False",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array-ii.py,binary_search,94
3912,search-in-rotated-sorted-array-ii.py::helper::58,"        def helper(l, r):
            if l>r: return False
            if nums[l]==target: return True
            if nums[r]==target: return True
            if nums[l]<nums[r]: return binary_search(l+1, r-1)
            
            m = (l+r)/2
            if nums[m]==target: return m

            if helper(l+1, m-1): return True
            if helper(m+1, r-1): return True
            return False",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array-ii.py,helper,105
3913,search-in-rotated-sorted-array.py::search::22,"    def search(self, nums, target):
        if not nums or len(nums)==0:
            return -1

        l = 0
        r = len(nums)-1
        while True:
            m = (l+r)/2

            left_num = nums[l]
            right_num = nums[r]
            mid_num = nums[m]

            if left_num==target:
                return l
            if right_num==target:
                return r
            if mid_num==target:
                return m

            #break the array into two part
            #l~m and m~r

            if left_num<target and target<mid_num:
                #l~m is sorted and target is inside
                #do the same calculation to this part
                r = m-1
                continue

            if mid_num<target and target<right_num:
                #m~r is sorted and target is inside
                #do the same calculation to this part
                l = m+1
                continue

            #if the code goes here
            #the target doesn't exist or
            #one of two part is not sorted
            #the target is in the not sorted part

            if mid_num>right_num:
                #m~r is not sorted
                #check m+1~r
                l = m+1
                continue

            if mid_num<left_num:
                #l~m is not sorted
                #check l~m-1
                r = m-1
                continue

            return -1",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array.py,search,326
3914,search-in-rotated-sorted-array.py::search::87,"    def search(self, nums, target):
        if nums is None or len(nums)==0: return -1

        l = 0
        r = len(nums)-1

        while l<=r:
            p = (l+r)/2

            if nums[l]==target: return l
            if nums[p]==target: return p
            if nums[r]==target: return r

            #array sorted
            if nums[l]<nums[r]:
                #binary search

                #check target is in range
                if target<nums[l] or nums[r]<target:
                    return -1

                if target<nums[p]:
                    r = p-1
                else:
                    l = p+1

            #array not sorted
            else:
                #the left half is sorted
                if nums[l]<nums[p]:
                    #the left half is sorted and target in it, search left.
                    if nums[l]<target and target<nums[p]:
                        r = p-1
                    else:
                        l = p+1

                #the right half is sorted
                else:
                    #the right half is sorted and target in it, search right.
                    if nums[p]<target and target<nums[r]:
                        l = p+1
                    else:
                        r = p-1
        return -1",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array.py,search,279
3915,search-in-rotated-sorted-array.py::search::139,"    def search(self, nums, target):
        def binary_search(l, r):
            if l>r: return -1
            if nums[l]==target: return l
            if nums[r]==target: return r

            m = (l+r)/2
            if nums[m]==target:
                return m
            if target<nums[m]:
                return binary_search(l, m-1)
            else:
                return binary_search(m+1, r)

        if not nums: return -1

        def helper(l, r):
            if l>r: return -1
            if nums[l]==target: return l
            if nums[r]==target: return r
            if nums[l]<=nums[r]: return binary_search(l+1, r-1)
            
            m = (l+r)/2
            if nums[m]==target: return m

            if nums[l]<nums[m]:
                if nums[l]<target and target<nums[m]:
                    return binary_search(l+1, m-1)
                else:
                    return helper(m+1, r)
            else:
                if nums[m]<target and target<nums[r]:
                    return binary_search(m+1, r-1)
                else:
                    return helper(l, m-1)
        
        if not nums: return -1
        return helper(0, len(nums)-1)",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array.py,search,284
3916,search-in-rotated-sorted-array.py::search::191,"    def search(self, A, T):
        l = 0
        r = len(A)-1
        
        while l<=r:
            m = (l+r)/2
            
            if A[l]==T: return l
            if A[m]==T: return m
            if A[r]==T: return r
            
            if A[l]<=A[m] and A[m]<=A[r]:
                #l~r is in-order, standard binary search.
                if T<A[l] or A[r]<T: return -1
                
                if T<A[m]:
                    r = m-1
                else:
                    l = m+1
            elif A[l]<=A[m]:
                #l~m is in-order
                if A[l]<T and T<A[m]:
                    #T is in l~m, so search in l~m
                    r = m-1
                else:
                    #T is not in l~m, so search in m~r
                    l = m+1
            else:
                #m~r is in-order
                if A[m]<T and T<A[r]:
                    #T is in m~r, so search m~r
                    l = m+1
                else:
                    #T is not in m~r, so search in l~m
                    r = m-1
                
        return -1",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array.py,search,289
3917,search-in-rotated-sorted-array.py::lengthOfLIS::237,"    def lengthOfLIS(self, nums):
        N = len(nums)
        dp = []
        
        for n in nums:
            i = bisect.bisect_left(dp, n)
            
            if i==len(dp):
                dp.append(n)
            else:
                dp[i] = n
        
        return len(dp)",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array.py,lengthOfLIS,68
3918,search-in-rotated-sorted-array.py::binary_search::140,"        def binary_search(l, r):
            if l>r: return -1
            if nums[l]==target: return l
            if nums[r]==target: return r

            m = (l+r)/2
            if nums[m]==target:
                return m
            if target<nums[m]:
                return binary_search(l, m-1)
            else:
                return binary_search(m+1, r)",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array.py,binary_search,87
3919,search-in-rotated-sorted-array.py::helper::155,"        def helper(l, r):
            if l>r: return -1
            if nums[l]==target: return l
            if nums[r]==target: return r
            if nums[l]<=nums[r]: return binary_search(l+1, r-1)
            
            m = (l+r)/2
            if nums[m]==target: return m

            if nums[l]<nums[m]:
                if nums[l]<target and target<nums[m]:
                    return binary_search(l+1, m-1)
                else:
                    return helper(m+1, r)
            else:
                if nums[m]<target and target<nums[r]:
                    return binary_search(m+1, r-1)
                else:
                    return helper(l, m-1)",data\repos\leetcode-python\problems\python\search-in-rotated-sorted-array.py,helper,158
3920,search-insert-position.py::searchInsert::20,"    def searchInsert(self, nums, target):
        if nums is None or len(nums)==0: return 0
        l = 0
        r = len(nums)-1

        while l<r:
            #[0]
            if nums[l]>target: return l
            if nums[r]<target: return r+1

            #[1]
            if nums[l]==target: return l
            if nums[r]==target: return r

            #[2]
            p = (l+r)/2
            if nums[p]==target:
                return p
            elif nums[p]>target:
                r = p-1
            else:
                l = p+1

        #[4]
        if nums[l]==target:
            return l
        elif nums[l]>target:
            return l
        else:
            return l+1",data\repos\leetcode-python\problems\python\search-insert-position.py,searchInsert,176
3921,search-insert-position.py::searchInsert::54,"    def searchInsert(self, nums, target):
        if not nums: return 0
        
        l = 0
        r = len(nums)-1
        
        while True:
            if l>r: break
            if target<nums[l]: return l
            if target>nums[r]: return r+1
            
            if target==nums[l]: return l
            if target==nums[r]: return r
            
            m = int((l+r)/2)
            
            if target==nums[m]:
                return m
            elif target>nums[m]:
                l = m+1
            else:
                r = m-1
        return 0",data\repos\leetcode-python\problems\python\search-insert-position.py,searchInsert,136
3922,search-insert-position.py::searchInsert::85,"    def searchInsert(self, A, T):
        if not A: return 0
        
        N = len(A)
        r = N-1
        l = 0

        #we are going to check the element within l and r by constantly narrow down l and r.z 
        while l<=r:
            m = (l+r)/2
            
            if A[l]==T: return l
            if A[m]==T: return m
            if A[r]==T: return r
            
            #check if the target is out of range.
            if A[r]<T: return r+1
            if T<A[l]: return l
            
            #using `m` to navigate `l` and `r`.
            #if the value on the pivot is larger then the target, we search the left-half.
            #if the value on the pivot is smaller then the target, we search the right-half.
            if T<A[m]:
                r = m-1
            else:
                l = m+1
        
        return ""Error""",data\repos\leetcode-python\problems\python\search-insert-position.py,searchInsert,220
3923,search-suggestions-system.py::suggestedProducts::8,"    def suggestedProducts(self, products, searchWord):
        def search(products, word):
            l = 0
            r = len(products)-1
            n = len(word)
            
            while l<=r:
                m = (l+r)/2
                if products[l].startswith(word): return getTop3(products, word, l)
                if products[r].startswith(word): return getTop3(products, word, r)
                if products[m].startswith(word): return getTop3(products, word, m)
                
                if products[m][:n]>word:
                    r = m-1
                else:
                    l = m+1
                
            return []
        
        def getTop3(products, word, i):
            suggestion = []
            
            while i-1>=0 and  products[i-1].startswith(word):
                i -= 1
            
            for j in xrange(i, min(len(products), i+3)):
                if not products[j].startswith(word): break
                suggestion.append(products[j])
            return suggestion
        
        
        ans = []
        products.sort()
        
        currSearchWord = ''
        for c in searchWord:
            currSearchWord += c
            ans.append(search(products, currSearchWord))
            
        return ans",data\repos\leetcode-python\problems\python\search-suggestions-system.py,suggestedProducts,257
3924,search-suggestions-system.py::suggestedProducts::65,"    def suggestedProducts(self, products, searchWord):
        ans = []
        root = Node('')
        
        #build trie
        for product in products:
            curr = root
            for c in product+'.':
                if c not in curr.nexts:
                    curr.nexts[c] = Node(c)
                curr = curr.nexts[c]
        
        # search top3 for each prefix
        curr = root
        for i, c in enumerate(searchWord):
            if c not in curr.nexts: break
            curr = curr.nexts[c]
            ans.append(self.getTop3(searchWord[:i+1], curr))
                
        ans += [[] for _ in xrange(len(searchWord)-len(ans))]
        return ans",data\repos\leetcode-python\problems\python\search-suggestions-system.py,suggestedProducts,151
3925,search-suggestions-system.py::getTop3::87,"    def getTop3(self, prefix, node):
        def helper(prefix, node):
            if len(top3)>=3: return
            if '.' in node.nexts: top3.append(prefix)
                
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c in node.nexts:
                    helper(prefix+c, node.nexts[c])
        
        top3 = []
        helper(prefix, node)
        return top3",data\repos\leetcode-python\problems\python\search-suggestions-system.py,getTop3,83
3926,search-suggestions-system.py::search::9,"        def search(products, word):
            l = 0
            r = len(products)-1
            n = len(word)
            
            while l<=r:
                m = (l+r)/2
                if products[l].startswith(word): return getTop3(products, word, l)
                if products[r].startswith(word): return getTop3(products, word, r)
                if products[m].startswith(word): return getTop3(products, word, m)
                
                if products[m][:n]>word:
                    r = m-1
                else:
                    l = m+1
                
            return []",data\repos\leetcode-python\problems\python\search-suggestions-system.py,search,127
3927,search-suggestions-system.py::getTop3::27,"        def getTop3(products, word, i):
            suggestion = []
            
            while i-1>=0 and  products[i-1].startswith(word):
                i -= 1
            
            for j in xrange(i, min(len(products), i+3)):
                if not products[j].startswith(word): break
                suggestion.append(products[j])
            return suggestion",data\repos\leetcode-python\problems\python\search-suggestions-system.py,getTop3,74
3928,search-suggestions-system.py::helper::88,"        def helper(prefix, node):
            if len(top3)>=3: return
            if '.' in node.nexts: top3.append(prefix)
                
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c in node.nexts:
                    helper(prefix+c, node.nexts[c])",data\repos\leetcode-python\problems\python\search-suggestions-system.py,helper,56
3929,sell-diminishing-valued-colored-balls.py::maxProfit::2,"    def maxProfit(self, I, orders):
        I.sort(reverse=True)
        I.append(0)
        
        profit = 0
        w = 1
        
        for i in xrange(len(I)-1):
            if orders==0: break
            if I[i]>I[i+1]:
                if w*(I[i]-I[i+1])<orders:
                    profit += w*self.sumRange(I[i+1]+1, I[i])
                    orders -= w*(I[i]-I[i+1])
                else:
                    h, remain = divmod(orders, w)
                    profit += w*self.sumRange(I[i]-h+1, I[i])
                    profit += remain*(I[i]-h)
                    orders -= w*h+remain
            w += 1
        
        return profit % (10**9+7)",data\repos\leetcode-python\problems\python\sell-diminishing-valued-colored-balls.py,maxProfit,175
3930,serialize-and-deserialize-binary-tree.py::serialize::3,"    def serialize(self, root):
        if not root: return ''
        q = collections.deque([root])
        s = ''
        while q:
            node = q.popleft()
            
            if node:
                s += str(node.val)
                q.append(node.left)
                q.append(node.right)
            else:
                s += '#'
            s += ','
        return s[:-1]",data\repos\leetcode-python\problems\python\serialize-and-deserialize-binary-tree.py,serialize,81
3931,serialize-and-deserialize-binary-tree.py::deserialize::20,"    def deserialize(self, data):
        if not data: return None
        
        data = data.split(',')
        root = TreeNode(data[0])
        q = collections.deque([root])
        i = 1
        
        while q and i<len(data):
            node = q.popleft()
            
            if data[i]!='#':
                node.left = TreeNode(data[i])
                q.append(node.left)
            i+=1
            
            if i>=len(data): continue
            if data[i]!='#':
                node.right = TreeNode(data[i])
                q.append(node.right)
            i += 1
            
        return root",data\repos\leetcode-python\problems\python\serialize-and-deserialize-binary-tree.py,deserialize,125
3932,serialize-and-deserialize-binary-tree.py::serialize::48,"    def serialize(self, root):
        if not root: return '#,'
        return str(root.val) + ',' + self.serialize(root.left) + self.serialize(root.right)",data\repos\leetcode-python\problems\python\serialize-and-deserialize-binary-tree.py,serialize,36
3933,serialize-and-deserialize-binary-tree.py::getNode::56,"    def getNode(self, data):
        if not data: return None
        val = data.pop()
        if val=='#': return None
        node = TreeNode(val)
        node.left = self.getNode(data)
        node.right = self.getNode(data)
        return node",data\repos\leetcode-python\problems\python\serialize-and-deserialize-binary-tree.py,getNode,55
3934,set-matrix-zeroes.py::setZeroes::13,"    def setZeroes(self, matrix):
        firstRowToZero = False
        
        for i in xrange(len(matrix)):
            for j in xrange(len(matrix[0])):
                if matrix[i][j]==0:
                    if i!=0:
                        matrix[i][0] = str(matrix[i][0])
                    else:
                        firstRowToZero = True
                    matrix[0][j] = str(matrix[0][j])
        
        
        for i in xrange(1, len(matrix)):
            if type(matrix[i][0])!=type(''): continue
            for j in xrange(len(matrix[0])): matrix[i][j] = 0
        
        for j in xrange(len(matrix[0])):
            if type(matrix[0][j])!=type(''): continue
            for i in xrange(len(matrix)): matrix[i][j] = 0
        
        if firstRowToZero:
            for j in xrange(len(matrix[0])): matrix[0][j] = 0",data\repos\leetcode-python\problems\python\set-matrix-zeroes.py,setZeroes,204
3935,shortest-bridge.py::shortestBridge::26,"    def shortestBridge(self, A):
        def findFirst(target):
            for i in xrange(M):
                for j in xrange(N):
                    if A[i][j]==target: return (i, j)

        M, N = len(A), len(A[0])

        #[0]
        q = collections.deque([findFirst(1)])
        while q:
            i, j = q.popleft()
            if i<0 or i>=M: continue
            if j<0 or j>=N: continue
            if A[i][j]==2 or A[i][j]==0: continue
            if A[i][j]==1: A[i][j] = 2
            q.extend([(i+1, j), (i-1, j), (i, j+1), (i, j-1)])

        #[1]
        q.append(findFirst(1))
        q2 = []
        tile = 0
        visited = set()
        while q or q2:
            if not q: #[2]
                q.extend(q2)
                q2 = []
                tile+=1

            i, j = q.popleft()
            if (i, j) in visited: continue
            visited.add((i, j))

            if A[i][j]==2: return tile #[3]

            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if ni<0 or ni>=M: continue
                if nj<0 or nj>=N: continue
                if A[ni][nj]==0:
                    q2.append((ni, nj))
                else:
                    q.append((ni, nj))

        return tile #should not comes here",data\repos\leetcode-python\problems\python\shortest-bridge.py,shortestBridge,374
3936,shortest-bridge.py::findFirst::27,"        def findFirst(target):
            for i in xrange(M):
                for j in xrange(N):
                    if A[i][j]==target: return (i, j)",data\repos\leetcode-python\problems\python\shortest-bridge.py,findFirst,35
3937,shortest-common-supersequence.py::shortestCommonSupersequence::5,"    def shortestCommonSupersequence(self, s1, s2):
        N, M = len(s1), len(s2)
        
        if not s1: return s2
        if not s2: return s1
        
        dp = [[0 for _ in xrange(M+1)] for _ in xrange(N+1)]
        for i in range(1, N+1): dp[i][0] = i
        for j in range(1, M+1): dp[0][j] = j
        
        for i in xrange(1, N+1):
            for j in xrange(1, M+1):
                if s1[i-1]==s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]+1
                else:
                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1)
        
        i, j = N, M
        ans = ''
        
        while i>0 and j>0:
            if s1[i-1]==s2[j-1]:
                ans = s1[i-1] + ans
                i -= 1
                j -= 1
            else:
                if dp[i][j-1]<dp[i-1][j]:
                    ans = s2[j-1] + ans
                    j -= 1
                else:
                    ans = s1[i-1] + ans
                    i -= 1

        if i>0: ans = s1[:i] + ans
        if j>0: ans = s2[:j] + ans

        return ans",data\repos\leetcode-python\problems\python\shortest-common-supersequence.py,shortestCommonSupersequence,351
3938,shortest-distance-from-all-buildings.py::shortestDistance::2,"    def shortestDistance(self, grid):
        def bfs(i0, j0):
            q = collections.deque([(i0, j0, 0)])
            visited = set()
            while q:
                i, j, dis = q.popleft()
                if (i, j) in visited: continue
                visited.add((i, j))
                
                reach[i][j] += 1
                distances[i][j] += dis
                
                for iNext, jNext in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                    if not (0<=iNext<len(grid) and 0<=jNext<len(grid[0])): continue
                    if grid[iNext][jNext]==2 or grid[iNext][jNext]==1: continue
                    if (iNext, jNext) in visited: continue
                    q.append((iNext, jNext, dis+1))
        
        M = len(grid)
        N = len(grid[0])
        ans = float('inf')
        reach = [[0]*N for _ in xrange(M)] #number of buildings can reach (i, j)
        distances = [[0]*N for _ in xrange(M)] #aggregate distance btwn 0 and buildings.
        buildingCount = 0
        
        for i in xrange(M):
            for j in xrange(N):
                if grid[i][j]==1:
                    buildingCount += 1
                    bfs(i, j)
        
        
        for i in xrange(M):
            for j in xrange(N):
                if grid[i][j]==0 and reach[i][j]==buildingCount:
                    ans = min(ans, distances[i][j])
        
        return ans if ans!=float('inf') else -1",data\repos\leetcode-python\problems\python\shortest-distance-from-all-buildings.py,shortestDistance,373
3939,shortest-distance-from-all-buildings.py::bfs::3,"        def bfs(i0, j0):
            q = collections.deque([(i0, j0, 0)])
            visited = set()
            while q:
                i, j, dis = q.popleft()
                if (i, j) in visited: continue
                visited.add((i, j))
                
                reach[i][j] += 1
                distances[i][j] += dis
                
                for iNext, jNext in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                    if not (0<=iNext<len(grid) and 0<=jNext<len(grid[0])): continue
                    if grid[iNext][jNext]==2 or grid[iNext][jNext]==1: continue
                    if (iNext, jNext) in visited: continue
                    q.append((iNext, jNext, dis+1))",data\repos\leetcode-python\problems\python\shortest-distance-from-all-buildings.py,bfs,196
3940,shortest-path-in-a-grid-with-obstacles-elimination.py::shortestPath::2,"    def shortestPath(self, grid, K):
        N = len(grid)
        M = len(grid[0])
        
        q = collections.deque([(0, 0, 0, K)])
        qNext = collections.deque()
        visited = set()
        
        while q:
            step, i0, j0, k0 = q.popleft()
            if (i0, j0, k0) in visited: continue
            visited.add((i0, j0, k0))
            
            if i0==N-1 and j0==M-1: return step
            
            for i, j in [(i0+1, j0), (i0-1, j0), (i0, j0+1), (i0, j0-1)]:
                if i>=N or i<0 or j>=M or j<0: continue
                if grid[i][j]==1 and k0>0:
                    qNext.append((step+1, i, j, k0-1))
                elif grid[i][j]==0:
                    qNext.append((step+1, i, j, k0))
            if not q: q = qNext
        
        return -1",data\repos\leetcode-python\problems\python\shortest-path-in-a-grid-with-obstacles-elimination.py,shortestPath,260
3941,shortest-path-in-binary-matrix.py::shortestPathBinaryMatrix::2,"    def shortestPathBinaryMatrix(self, grid):
        q = collections.deque([(0, 0, 1)])
        seen = 2
        
        while q:
            i, j, step = q.popleft()
            if not (0<=i<len(grid) and 0<=j<len(grid[0])): continue
            if grid[i][j]==1 or grid[i][j]==seen: continue
            grid[i][j] = seen
            
            if i==len(grid)-1 and j==len(grid[0])-1: return step
            
            for k, l in ((i+1, j), (i-1, j), (i, j+1), (i, j-1), (i-1, j-1), (i+1, j-1), (i+1, j+1), (i-1, j+1)):
                q.append((k, l, step+1))
        
        return -1",data\repos\leetcode-python\problems\python\shortest-path-in-binary-matrix.py,shortestPathBinaryMatrix,204
3942,shortest-path-to-get-food.py::getFood::2,"    def getFood(self, grid):
        q = collections.deque()
        visited = set()
        
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if grid[i][j]=='*':
                    q.append((i, j, 0))
                    break
        while q:
            i, j, steps = q.popleft()
            
            if not 0<=i<len(grid): continue
            if not 0<=j<len(grid[0]): continue
            if (i, j) in visited: continue
            visited.add((i, j))
            
            if grid[i][j]=='#':
                return steps
            elif grid[i][j]=='X':
                continue
            elif grid[i][j]=='O' or grid[i][j]=='*':
                q.append((i+1, j, steps+1))
                q.append((i-1, j, steps+1))
                q.append((i, j+1, steps+1))
                q.append((i, j-1, steps+1))
        
        return -1",data\repos\leetcode-python\problems\python\shortest-path-to-get-food.py,getFood,228
3943,shuffle-an-array.py::shuffle::16,"    def shuffle(self):
        ans = []
        
        #new LinkList
        head = None
        curr = head
                
        while len(ans)<len(self.nums):
            #each time remove a random node
            #add the val to ans
            #and add the node to the newLinkList
            
            #select a random node, self.curr
            rand = randrange(len(self.nums)-len(ans))
            while rand>0:
                self.curr = self.curr.next
                rand -= 1
            
            #add self.curr.next's value to ans
            ans.append(self.curr.next.val)
            
            #add self.curr.next to a new LinkList
            if not curr:
                head = self.curr.next
                curr = head
            else:
                curr.next = self.curr.next
                curr = curr.next
            
            #remove self.curr.next from the LinkList
            self.curr.next = self.curr.next.next
            
        curr.next = head
        self.curr = head
        return ans",data\repos\leetcode-python\problems\python\shuffle-an-array.py,shuffle,210
3944,shuffle-an-array.py::getLinkList::52,"    def getLinkList(self, nums):
        head = ListNode(nums[0])
        curr = head
        for i in xrange(1, len(self.nums)):
            curr.next = ListNode(nums[i])
            curr = curr.next
        curr.next = head
        return head",data\repos\leetcode-python\problems\python\shuffle-an-array.py,getLinkList,58
3945,simplify-path.py::simplifyPath::2,"    def simplifyPath(self, path):
        ans = ''
        skip = 0
        
        for directory in reversed(path.split('/')):
            if directory=='' or directory=='.':
                continue
            elif directory=='..':
                skip += 1
            else:
                if skip>0:
                    skip -= 1
                    continue
                else:
                    ans = '/'+directory+ans
        
        return ans if ans!='' else '/'",data\repos\leetcode-python\problems\python\simplify-path.py,simplifyPath,91
3946,single-threaded-cpu.py::getOrder::2,"    def getOrder(self, tasks):
        ans = []
        tasks = sorted([(task[0], task[1], i) for i, task in enumerate(tasks)], reverse=True)
        pq = [] #tasks available
        now = 0
        
        
        while tasks or pq:
            #check if the task is availiable, if yes, add to pq
            while tasks and tasks[-1][0]<=now:
                startTime, processTime, i = tasks.pop()
                heapq.heappush(pq, (processTime, i))
                        
            if pq:
                processTime, i = heapq.heappop(pq)
                ans.append(i)
                now += processTime
            else:
                now = tasks[-1][0]
                    
        return ans",data\repos\leetcode-python\problems\python\single-threaded-cpu.py,getOrder,156
3947,sliding-window-maximum.py::maxSlidingWindow::2,"    def maxSlidingWindow(self, nums, k):
        opt = []
        q = collections.deque()
        for i in xrange(len(nums)):
            n = nums[i]
            
            #move the window
            if q and q[0]<=i-k: q.popleft()

            #pop the right if the element in queue is not greater than the in-coming one
            #by doing this, we can always keep the max in the current window at left most
            while q and nums[q[-1]]<=n: q.pop()

            q.append(i)

            #add the max to the output array after the first kth element
            if 1+i>=k: opt.append(nums[q[0]])
        return opt",data\repos\leetcode-python\problems\python\sliding-window-maximum.py,maxSlidingWindow,153
3948,sliding-window-maximum.py::maxSlidingWindow::31,"    def maxSlidingWindow(self, nums, k):
        if not nums or not k: return []
        if k==1: return nums
        
        ans = []
        
        counter = collections.Counter(nums[:k])
        h = [-num for num in nums[:k]]
        heapq.heapify(h)
        
        for i in xrange(len(nums)):    
            while counter[-h[0]]==0: heapq.heappop(h)
            ans.append(-h[0])
            
            if i+k>=len(nums): break
            counter[nums[i]] -= 1
            heapq.heappush(h, -nums[i+k])
            counter[nums[i+k]] += 1
        
        return ans",data\repos\leetcode-python\problems\python\sliding-window-maximum.py,maxSlidingWindow,145
3949,sliding-window-maximum.py::maxSlidingWindow::61,"    def maxSlidingWindow(self, nums, k):
        ans = []
        q = collections.deque()
        
        for i, num in enumerate(nums):
            #keep only the element in the window inside deque.
            #the window lies between index i-k+1 to i.
            if q and q[0][1]<=i-k: q.popleft()
            
            #keep the element in deque in descending order by popping the elements from rihgt that are smaller than num.
            #by keeping the deque in descending order, we can get the largest element by just getting the first element.
            #also since they are certainly not the max in the deque, we don't care.
            while q and q[-1][0]<=num: q.pop()
            q.append((num, i))
            
            #wait until i>=k-1 when the window pass at least k elements.
            if (i>=k-1): ans.append(q[0][0])
                
        return ans",data\repos\leetcode-python\problems\python\sliding-window-maximum.py,maxSlidingWindow,206
3950,snapshot-array.py::get::17,"    def get(self, index, snapId):
        j = bisect.bisect_right(self.data[index], (snapId, float('inf'))) - 1
        return self.data[index][j][1]",data\repos\leetcode-python\problems\python\snapshot-array.py,get,45
3951,sort-colors.py::sortColors::2,"    def sortColors(self, nums):
        l = 0
        r = len(nums)-1
        
        i = 0
        while i<=r:
            if nums[i]==0:
                nums[l], nums[i] = nums[i], nums[l]
                l += 1
                i += 1
            elif nums[i]==2:
                nums[i], nums[r] = nums[r], nums[i]
                r -= 1
            elif nums[i]==1:
                i += 1",data\repos\leetcode-python\problems\python\sort-colors.py,sortColors,106
3952,sort-colors.py::sortColors::20,"    def sortColors(self, nums):
        count0 = count1 = count2 = 0
        
        for num in nums:
            if num==0:
                count0 += 1
            elif num==1:
                count1 += 1
            elif num==2:
                count2 += 1
        
        i = 0
        while count0>0:
            nums[i] = 0
            i += 1
            count0 -= 1
            
        while count1>0:
            nums[i] = 1
            i += 1
            count1 -= 1
            
        while count2>0:
            nums[i] = 2
            i += 1
            count2 -= 1",data\repos\leetcode-python\problems\python\sort-colors.py,sortColors,155
3953,sort-list.py::sortList::9,"    def sortList(self, head):
        if head==None or head.next==None:
            return head
        
        #find mid point
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        second_half = slow.next
        slow.next = None
        
        head = self.sortList(head)
        second_half = self.sortList(second_half)
        
        return self.merge(head, second_half)",data\repos\leetcode-python\problems\python\sort-list.py,sortList,100
3954,sort-list.py::merge::37,"    def merge(self, l1, l2):
        if l1==None and l2==None:
            return None
        elif l1 and l2==None:
            return l1
        elif l1==None and l2:
            return l2
        
        pre = ListNode(None)
        curr = pre
        
        while l1 and l2:
            if l1.val<=l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
            
        if l1:
            curr.next = l1
        elif l2:
            curr.next = l2
        
        return pre.next",data\repos\leetcode-python\problems\python\sort-list.py,merge,153
3955,spiral-matrix.py::spiralOrder::2,"    def spiralOrder(self, matrix):
        ans = []
        i, j = 0, 0
        direction = 'right'
        count = 0
        
        while count<=len(matrix)*len(matrix[0]):
            iNext, jNext = i, j
            
            if direction=='right':
                if j+1<len(matrix[0]) and matrix[i][j+1]!='v':
                    jNext = j+1
                else:
                    direction = 'down'
            elif direction=='down':
                if i+1<len(matrix) and matrix[i+1][j]!='v':
                    iNext = i+1
                else:
                    direction = 'left'
            elif direction=='left':
                if j-1>=0 and matrix[i][j-1]!='v':
                    jNext = j-1
                else:
                    direction = 'up'
            elif direction=='up':
                if i-1>=0 and matrix[i-1][j]!='v':
                    iNext = i-1
                else:
                    direction = 'right'
            
            if (iNext, jNext)!=(i, j) or count>=len(matrix)*len(matrix[0])-1:
                ans.append(matrix[i][j])
                matrix[i][j] = 'v' #visited
                count += 1
                i = iNext
                j = jNext

        return ans[:-1]",data\repos\leetcode-python\problems\python\spiral-matrix.py,spiralOrder,295
3956,split-array-into-fibonacci-sequence.py::splitIntoFibonacci::2,"    def splitIntoFibonacci(self, S):
        def is_bibonacci(opt, num):
            return num == opt[-1]+opt[-2]

        def helper(s, first):
            if first==len(s) and len(opt)>=3:
                return True

            for i in xrange(first, len(s)):
                if s[first]=='0' and i!=first: break #skip leading zero
                num = int(s[first:i+1])

                if num>2147483648: break

                #early termination
                if len(opt)>=2 and num>opt[-1]+opt[-2]:
                    break

                if len(opt)<=1 or is_bibonacci(opt, num):
                    opt.append(int(num))
                    if helper(s, i+1): return True
                    opt.pop()
            return False

        opt = []
        helper(S, 0)
        return opt",data\repos\leetcode-python\problems\python\split-array-into-fibonacci-sequence.py,splitIntoFibonacci,186
3957,split-array-into-fibonacci-sequence.py::helper::6,"        def helper(s, first):
            if first==len(s) and len(opt)>=3:
                return True

            for i in xrange(first, len(s)):
                if s[first]=='0' and i!=first: break #skip leading zero
                num = int(s[first:i+1])

                if num>2147483648: break

                #early termination
                if len(opt)>=2 and num>opt[-1]+opt[-2]:
                    break

                if len(opt)<=1 or is_bibonacci(opt, num):
                    opt.append(int(num))
                    if helper(s, i+1): return True
                    opt.pop()
            return False",data\repos\leetcode-python\problems\python\split-array-into-fibonacci-sequence.py,helper,138
3958,split-array-largest-sum.py::splitArray::6,"    def splitArray(self, nums, K):
        N = len(nums)
        
        dp = [[float('inf') for _ in xrange(K+1)] for _ in xrange(N+1)]
        dp[0][0] = 0
        
        for i in xrange(1, N+1):
            for k in xrange(1, min(i, K)+1):
                for j in xrange(k, i+1):
                    dp[i][k] = min(dp[i][k], max(dp[j-1][k-1], sum(nums[j-1:i])))
        
        return dp[N][K]",data\repos\leetcode-python\problems\python\split-array-largest-sum.py,splitArray,128
3959,split-array-largest-sum.py::splitArray::26,"    def splitArray(self, nums, K):
        N = len(nums)

        s = [[0 for _ in xrange(N)] for _ in xrange(N)]
        for i in xrange(N): s[i][i] = nums[i]
        for l in xrange(2, N):
            for i in xrange(N):
                j = i+l-1
                if j>=N: continue
                s[i][j] = s[i+1][j-1]+nums[i]+nums[j]

        dp = [[float('inf') for _ in xrange(K+1)] for _ in xrange(N+1)]
        dp[0][0] = 0
        
        for i in xrange(1, N+1):
            for k in xrange(1, min(i, K)+1):
                for j in xrange(k, i+1):
                    dp[i][k] = min(dp[i][k], max(dp[j-1][k-1], s[j-1][i-1]))
        
        return dp[N][K]",data\repos\leetcode-python\problems\python\split-array-largest-sum.py,splitArray,217
3960,sqrtx.py::mySqrt::9,"    def mySqrt(self, x):
        def isAns(a):
            if a**2<=x and (a+1)**2>x:
                return True
            return False

        l = 0
        r = x
        while True:
            m = (l+r)/2
            if isAns(l): return l
            if isAns(m): return m
            if isAns(r): return r

            if m**2<x:
                l = m+1
            else:
                r = m-1
        return -1",data\repos\leetcode-python\problems\python\sqrtx.py,mySqrt,118
3961,sqrtx.py::mySqrt::33,"    def mySqrt(self, x):
        l = 0
        r = x
        
        while l<=r:
            m = (l+r)/2
            m_sqr = m**2
            
            if m_sqr==x or (m_sqr<x and x<(m+1)**2):
                return m
            elif m_sqr<x:
                l = m+1
            else:
                r = m-1",data\repos\leetcode-python\problems\python\sqrtx.py,mySqrt,93
3962,squares-of-a-sorted-array.py::sortedSquares::18,"    def sortedSquares(self, numbers):
        if not numbers: return numbers

        if numbers[0]>=0:
            return [n**2 for n in numbers]

        m = 0
        for i, n in enumerate(numbers):
            if n>=0:
                m = i
                break

        A, B = numbers[m:], [-1*n for n in reversed(numbers[:m])]
        return [n**2 for n in self.merge(A, B)]",data\repos\leetcode-python\problems\python\squares-of-a-sorted-array.py,sortedSquares,99
3963,squares-of-a-sorted-array.py::merge::33,"    def merge(self, A, B):
        a = b = 0
        opt = []
        while a<len(A) and b<len(B):
            if A[a]<B[b]:
                opt.append(A[a])
                a+=1
            else:
                opt.append(B[b])
                b+=1
        if a<len(A): opt.extend(A[a:])
        if b<len(B): opt.extend(B[b:])
        return opt",data\repos\leetcode-python\problems\python\squares-of-a-sorted-array.py,merge,90
3964,step-by-step-directions-from-a-binary-tree-node-to-another.py::getDirections::5,"    def getDirections(self, root, startValue, destValue):
        def findPath(node, path, val):
            if not node: return False
            if node.val==val: return True
            
            path.append('L')
            if findPath(node.left, path, val): return True
            path.pop()
            
            path.append('R')
            if findPath(node.right, path, val): return True
            path.pop()
            
            return False
            
        def findCount(node, startValue, destValue):
            if not node: return 0
            count = 0
            if node.val==startValue or node.val==destValue: count += 1
            count += findCount(node.left, startValue, destValue)
            count += findCount(node.right, startValue, destValue)
            if count>=2 and not self.lca: self.lca = node
            return count
        
        findCount(root, startValue, destValue)
        
        path1 = []
        findPath(self.lca, path1, startValue)
        path2 = []
        findPath(self.lca, path2, destValue)
        
        return 'U'*len(path1) + ''.join(path2)",data\repos\leetcode-python\problems\python\step-by-step-directions-from-a-binary-tree-node-to-another.py,getDirections,255
3965,step-by-step-directions-from-a-binary-tree-node-to-another.py::findPath::6,"        def findPath(node, path, val):
            if not node: return False
            if node.val==val: return True
            
            path.append('L')
            if findPath(node.left, path, val): return True
            path.pop()
            
            path.append('R')
            if findPath(node.right, path, val): return True
            path.pop()
            
            return False",data\repos\leetcode-python\problems\python\step-by-step-directions-from-a-binary-tree-node-to-another.py,findPath,81
3966,step-by-step-directions-from-a-binary-tree-node-to-another.py::findCount::20,"        def findCount(node, startValue, destValue):
            if not node: return 0
            count = 0
            if node.val==startValue or node.val==destValue: count += 1
            count += findCount(node.left, startValue, destValue)
            count += findCount(node.right, startValue, destValue)
            if count>=2 and not self.lca: self.lca = node
            return count",data\repos\leetcode-python\problems\python\step-by-step-directions-from-a-binary-tree-node-to-another.py,findCount,94
3967,stock-price-fluctuation.py::update::17,"    def update(self, timestamp, price):
        if timestamp in self.timeToPrice:
            prevPrice = self.timeToPrice[timestamp]
            self.priceToTime[prevPrice].remove(timestamp)
            if len(self.priceToTime[prevPrice])==0: self.priceToTime.pop(prevPrice) #[0]
        
        if price not in self.priceToTime: self.priceToTime[price] = set() #initialized
        self.priceToTime[price].add(timestamp)
        self.timeToPrice[timestamp] = price",data\repos\leetcode-python\problems\python\stock-price-fluctuation.py,update,110
3968,stone-game-ii.py::stoneGameII::2,"    def stoneGameII(self, piles):
        def helper(start, m):
            if (start, m) in history: return history[(start, m)]
            
            if start>=len(piles): return 0
            if start+m*2>=len(piles): return sum(piles[start:])
            
            max_stones = float('-inf')
            for x in xrange(1, m*2+1):
                max_stones = max(max_stones, sum(piles[start:])-helper(start+x, max(m, x)))
            
            history[(start, m)] = max_stones
            return history[(start, m)]
        
        history = {}
        return helper(0, 1)",data\repos\leetcode-python\problems\python\stone-game-ii.py,stoneGameII,147
3969,stone-game-ii.py::helper::3,"        def helper(start, m):
            if (start, m) in history: return history[(start, m)]
            
            if start>=len(piles): return 0
            if start+m*2>=len(piles): return sum(piles[start:])
            
            max_stones = float('-inf')
            for x in xrange(1, m*2+1):
                max_stones = max(max_stones, sum(piles[start:])-helper(start+x, max(m, x)))
            
            history[(start, m)] = max_stones
            return history[(start, m)]",data\repos\leetcode-python\problems\python\stone-game-ii.py,helper,124
3970,student-attendance-record-ii.py::checkRecord::2,"    def checkRecord(self, n):
        """"""
        dp[l] := number of eligible combination of a length l record without A
        """"""
        
        ans = 0
        M = 1000000007
        
        dp = [0]*max(n+1, 4)
        dp[0] = 1
        dp[1] = 2
        dp[2] = 4
        dp[3] = 7
        
        for i in xrange(4, n+1):
            dp[i] += dp[i-1]%M #ends at P
            dp[i] += (dp[i-1]%M - dp[i-4]%M) #ends at L. All posiblity but the end cannot be PLL
        
        ans += dp[n]
        
        for i in xrange(n):
            ans += dp[i] * dp[n-i-1]
            ans %= M
            
        return ans",data\repos\leetcode-python\problems\python\student-attendance-record-ii.py,checkRecord,195
3971,subarray-sum-equals-k.py::subarraySum::10,"    def subarraySum(self, nums, k):
        N = len(nums)
        prefixSum = [0]
        ans = 0
        
        temp = 0
        for n in nums:
            temp += n
            prefixSum.append(temp)
        
        for i in xrange(N+1):
            for j in xrange(i+1, N+1):
                if prefixSum[j]-prefixSum[i]==k: ans += 1
        
        return ans",data\repos\leetcode-python\problems\python\subarray-sum-equals-k.py,subarraySum,96
3972,subarray-sum-equals-k.py::subarraySum::41,"    def subarraySum(self, nums, k):
        ans = 0
        
        prefixSumCount = collections.Counter()
        prefixSumCount[0] = 1
        
        J = 0
        for n in nums:
            J += n
            I = J-k #the I that we are looking for.
            ans += prefixSumCount[I] #there are ""prefixSumCount[I]"" combinations of J-I that equals to k.
            prefixSumCount[J] += 1
            
        return ans",data\repos\leetcode-python\problems\python\subarray-sum-equals-k.py,subarraySum,106
3973,subarrays-with-k-different-integers.py::subarraysWithKDistinct::2,"    def subarraysWithKDistinct(self, nums, K):
        #number of subarray of nums which have at most k different numbers.
        def atMost(k):
            i = 0
            ans = 0
            counter = collections.Counter()
            uniqueCount = 0
            
            for j in xrange(len(nums)):
                counter[nums[j]] += 1
                if counter[nums[j]]==1: uniqueCount += 1
                
                while uniqueCount>k:
                    counter[nums[i]] -= 1
                    if counter[nums[i]]==0: uniqueCount -= 1
                    i += 1
                
                # the logest subarray that ends at j is nums[i:j+1]
                # nums[i:j+1] can produce j-i+1 subarrays that at most has k different number.
                ans += j-i+1
            
            return ans
        
        return atMost(K)-atMost(K-1)",data\repos\leetcode-python\problems\python\subarrays-with-k-different-integers.py,subarraysWithKDistinct,198
3974,subarrays-with-k-different-integers.py::atMost::4,"        def atMost(k):
            i = 0
            ans = 0
            counter = collections.Counter()
            uniqueCount = 0
            
            for j in xrange(len(nums)):
                counter[nums[j]] += 1
                if counter[nums[j]]==1: uniqueCount += 1
                
                while uniqueCount>k:
                    counter[nums[i]] -= 1
                    if counter[nums[i]]==0: uniqueCount -= 1
                    i += 1
                
                # the logest subarray that ends at j is nums[i:j+1]
                # nums[i:j+1] can produce j-i+1 subarrays that at most has k different number.
                ans += j-i+1
            
            return ans",data\repos\leetcode-python\problems\python\subarrays-with-k-different-integers.py,atMost,156
3975,subdomain-visit-count.py::subdomainVisits::3,"    def subdomainVisits(self, cpdomains):
        data = collections.Counter()
        return_data = []
        for domain in cpdomains:
            count, domain = domain.split()
            count = int(count)
            data[domain]+=count
            
            sub_domain1 = domain.split('.', 1)[-1]
            data[sub_domain1]+=count
            
            if '.' in sub_domain1:
                sub_domain2 = sub_domain1.split('.', 1)[-1]
                data[sub_domain2]+=count
                
        for domain, count in data.items():
            return_data.append(str(count)+' '+domain)
            
        return return_data",data\repos\leetcode-python\problems\python\subdomain-visit-count.py,subdomainVisits,126
3976,subsets-ii.py::subsetsWithDup::19,"    def subsetsWithDup(self, nums):
        nums.sort()
        answer = [[]]
        for num in nums:
            new_subs = []
            for sub in answer:
                new_subs.append(sub+[num])
            answer.extend(new_subs)
        return list(set([tuple(combination) for combination in answer]))",data\repos\leetcode-python\problems\python\subsets-ii.py,subsetsWithDup,63
3977,subsets-ii.py::subsetsWithDup::44,"    def subsetsWithDup(self, nums):
        counter = Counter(nums)
        answer = [[]]

        for num, count in counter.items():
            power_set = [[num]*c for c in xrange(1, count+1)]
            for i in xrange(len(answer)):
                for s in power_set:
                    answer.append(answer[i]+s)
        return answer",data\repos\leetcode-python\problems\python\subsets-ii.py,subsetsWithDup,74
3978,subsets-ii.py::subsetsWithDup::58,"    def subsetsWithDup(self, nums):
        nums.sort()

        def dfs(path, nums):
            opt.append(path)
            if len(nums)==0: return
            for i, num in enumerate(nums):
                if i>0 and nums[i]==nums[i-1]: continue
                dfs(path+[num], nums[i+1:])
        opt = []
        dfs([], nums)
        return opt",data\repos\leetcode-python\problems\python\subsets-ii.py,subsetsWithDup,82
3979,subsets-ii.py::dfs::61,"        def dfs(path, nums):
            opt.append(path)
            if len(nums)==0: return
            for i, num in enumerate(nums):
                if i>0 and nums[i]==nums[i-1]: continue
                dfs(path+[num], nums[i+1:])",data\repos\leetcode-python\problems\python\subsets-ii.py,dfs,57
3980,subsets.py::subsets::25,"    def subsets(self, nums):
        def helper(i, combination):
            answer.add(tuple(combination))
            if i>=len(nums): return
            helper(i+1, combination+[nums[i]])
            helper(i+1, combination)

        answer = set()
        helper(0, [])
        return [list(combination) for combination in answer]",data\repos\leetcode-python\problems\python\subsets.py,subsets,72
3981,subsets.py::subsets::48,"    def subsets(self, nums):
        answer = [[]]
        for n in nums:
            new_subs = []
            for sub in answer:
                new_subs.append(sub+[n])
            answer.extend(new_subs)
        return answer",data\repos\leetcode-python\problems\python\subsets.py,subsets,46
3982,subsets.py::subsets::78,"    def subsets(self, nums):
        def dfs(path, nums):
            opt.append(path)
            if len(nums)==0: return
            for i, num in enumerate(nums):
                dfs(path+[num], nums[i+1:])

        opt = []
        dfs([], nums)
        return opt",data\repos\leetcode-python\problems\python\subsets.py,subsets,61
3983,subsets.py::helper::26,"        def helper(i, combination):
            answer.add(tuple(combination))
            if i>=len(nums): return
            helper(i+1, combination+[nums[i]])
            helper(i+1, combination)",data\repos\leetcode-python\problems\python\subsets.py,helper,42
3984,subsets.py::dfs::79,"        def dfs(path, nums):
            opt.append(path)
            if len(nums)==0: return
            for i, num in enumerate(nums):
                dfs(path+[num], nums[i+1:])",data\repos\leetcode-python\problems\python\subsets.py,dfs,41
3985,substring-with-concatenation-of-all-words.py::findSubstring::18,"    def findSubstring(self, s, words):
        if not words: return []
        
        wc = len(words) #word count
        wl = len(words[0]) #word length
        ans = []
        
        i = 0
        j = wc*wl
        
        countExpected = collections.Counter(words)
        
        while j<=len(s):
            if self.test(s[i:j], wl, countExpected): ans.append(i)
            i += 1
            j += 1
        
        return ans",data\repos\leetcode-python\problems\python\substring-with-concatenation-of-all-words.py,findSubstring,106
3986,substring-with-concatenation-of-all-words.py::test::38,"    def test(self, s, wl, countExpected):
        counter = collections.Counter() #{word:how many time the word is used}
        i = 0
        
        while i<len(s):
            word = s[i:i+wl]
            if word not in countExpected or counter[word]>=countExpected[word]: return False
            i += wl
            counter[word] += 1
            
        return True",data\repos\leetcode-python\problems\python\substring-with-concatenation-of-all-words.py,test,84
3987,subtree-of-another-tree.py::isSubtree::20,"    def isSubtree(self, s, t):
        def isSameTree(root1, root2):
            q1 = deque([root1])
            q2 = deque([root2])
            while q1 and q2:
                n1 = q1.popleft()
                n2 = q2.popleft()
                if n1.val!=n2.val: return False
                if n1.left: q1.append(n1.left)
                if n1.right: q1.append(n1.right)
                if n2.left: q2.append(n2.left)
                if n2.right: q2.append(n2.right)

            #check if both queue are empty.
            #if both queue are empty, all nodes are checked.
            return not q1 and not q2

        stack = []
        stack.append(s)
        while stack:
            node = stack.pop()
            if node.val==t.val and isSameTree(node, t): return True
            if node.left: stack.append(node.left)
            if node.right: stack.append(node.right)
        return False",data\repos\leetcode-python\problems\python\subtree-of-another-tree.py,isSubtree,223
3988,subtree-of-another-tree.py::isSameTree::21,"        def isSameTree(root1, root2):
            q1 = deque([root1])
            q2 = deque([root2])
            while q1 and q2:
                n1 = q1.popleft()
                n2 = q2.popleft()
                if n1.val!=n2.val: return False
                if n1.left: q1.append(n1.left)
                if n1.right: q1.append(n1.right)
                if n2.left: q2.append(n2.left)
                if n2.right: q2.append(n2.right)

            #check if both queue are empty.
            #if both queue are empty, all nodes are checked.
            return not q1 and not q2",data\repos\leetcode-python\problems\python\subtree-of-another-tree.py,isSameTree,151
3989,sum-of-subarray-minimums.py::sumSubarrayMins::22,"    def sumSubarrayMins(self, arr):
        N = len(arr)
        ans = 0
        nextSmaller = [N]*N
        prevSmallerOrEqual = [-1]*N #[2]
        
        #construct nextSmaller [1]
        stack = []
        for i in xrange(N):
            n = arr[i]
            while stack and n<arr[stack[-1]]:
                nextSmaller[stack.pop()] = i
            stack.append(i)
        
        #construct prevSmallerOrEqual
        stack = []
        for i in xrange(N-1, -1, -1):
            n = arr[i]
            while stack and n<=arr[stack[-1]]:
                prevSmallerOrEqual[stack.pop()] = i
            stack.append(i)
        
        #get ans
        for i in xrange(N):
            n = arr[i]
            r = nextSmaller[i]
            l = prevSmallerOrEqual[i]
            ans += (i-l)*(r-i)*n #[0]
            
        return ans%(10**9+7)",data\repos\leetcode-python\problems\python\sum-of-subarray-minimums.py,sumSubarrayMins,229
3990,sum-root-to-leaf-numbers.py::sumNumbers::2,"    def sumNumbers(self, root):
        if not root: return 0
        ans = 0
        stack = []
        stack.append((root, ''))
        
        while stack:
            node, total = stack.pop()
            total += str(node.val)
            if not node.left and not node.right: #is_leaf
                ans += int(total)
                continue
            if node.left:
                stack.append((node.left, total))
            if node.right:
                stack.append((node.right, total))
        return ans",data\repos\leetcode-python\problems\python\sum-root-to-leaf-numbers.py,sumNumbers,109
3991,sum-root-to-leaf-numbers.py::sumNumbers::22,"    def sumNumbers(self, root):
        if not root: return 0

        ans = 0
        stack = []
        stack.append((root, 0))

        while stack:
            node, n = stack.pop()
            n = n*10+node.val
            if not node.left and not node.right: ans+=n
            if node.left: stack.append((node.left, n))
            if node.right: stack.append((node.right, n))

        return ans",data\repos\leetcode-python\problems\python\sum-root-to-leaf-numbers.py,sumNumbers,101
3992,sum-root-to-leaf-numbers.py::sumNumbers::53,"    def sumNumbers(self, root):
        ans = 0
        stack = [(root, '')]
        
        while stack:
            node, numString = stack.pop()
            
            if node.left:
                stack.append((node.left, numString+str(node.val)))
            if node.right:
                stack.append((node.right, numString+str(node.val)))
            
            if not node.left and not node.right:
                ans += int(numString+str(node.val))
        return ans",data\repos\leetcode-python\problems\python\sum-root-to-leaf-numbers.py,sumNumbers,100
3993,summary-ranges.py::summaryRanges::6,"    def summaryRanges(self, nums):
        nums.append('#')
        opt = []
        s = 0
        
        for i in xrange(1, len(nums)):
            if nums[i-1]+1!=nums[i]:
                if i-1>s:
                    opt.append(str(nums[s])+'->'+str(nums[i-1]))
                else:
                    opt.append(str(nums[s]))
                s = i
        return opt",data\repos\leetcode-python\problems\python\summary-ranges.py,summaryRanges,87
3994,super-ugly-number.py::nthSuperUglyNumber::2,"    def nthSuperUglyNumber(self, n, primes):
        p = [0]*len(primes) #p[i] stores the index of ugly number in ans that not yet times primes[i] yet
        ans = [1]
        h = []
        
        for i in xrange(len(primes)):
            heapq.heappush(h, (primes[i]*ans[p[i]], i))
            
        for _ in xrange(n-1):
            curr = h[0][0]
            ans.append(curr)
            
            while h and h[0][0]==curr:
                i = h[0][1]
                heapq.heappop(h)
                p[i] += 1
                heapq.heappush(h, (primes[i]*ans[p[i]], i))
        
        return ans[-1]",data\repos\leetcode-python\problems\python\super-ugly-number.py,nthSuperUglyNumber,168
3995,swap-adjacent-in-lr-string.py::canTransform::2,"    def canTransform(self, start, end):
        if len(start)!=len(end): return False
        if start.replace('X', '')!=end.replace('X', ''): return False
        
        startLIndex = [i for i, c in enumerate(start) if c=='L']
        endLIndex = [i for i, c in enumerate(end) if c=='L']
        for i in xrange(len(startLIndex)):
            if startLIndex[i]<endLIndex[i]:
                return False
        
        startRIndex = [i for i, c in enumerate(start) if c=='R']
        endRIndex = [i for i, c in enumerate(end) if c=='R']
        for i in xrange(len(startRIndex)):
            if startRIndex[i]>endRIndex[i]:
                return False
        
        return True",data\repos\leetcode-python\problems\python\swap-adjacent-in-lr-string.py,canTransform,175
3996,swap-nodes-in-pairs.py::swapPairs::2,"    def swapPairs(self, head):
        pre_head = ListNode(-1)
        curr = head
        prev = pre_head

        if not curr or not curr.next: return head

        while curr and curr.next:
            temp_next = curr.next.next

            prev.next = curr.next
            curr.next.next = curr
            curr.next = temp_next

            prev = curr
            curr = temp_next

        return pre_head.next",data\repos\leetcode-python\problems\python\swap-nodes-in-pairs.py,swapPairs,91
3997,swap-nodes-in-pairs.py::swapPairs::24,"    def swapPairs(self, head):
        curr = head
        q1 = deque([])
        q2 = deque([])
        seq = 0
        while curr:
            if seq%2==0:
                q2.append(curr)
            else:
                q1.append(curr)

            temp = curr.next
            curr.next = None #clear old link
            curr = temp
            seq+=1

        if seq==1:
            return head

        use_q1 = True
        pre_head = ListNode(-1)
        curr = pre_head
        while q1 or q2:
            if use_q1:
                if not q1: break
                curr.next = q1.popleft()
            else:
                curr.next = q2.popleft()
            curr = curr.next
            use_q1 = not use_q1

        if q2: curr.next = q2.popleft() #odd length of linked list

        return pre_head.next",data\repos\leetcode-python\problems\python\swap-nodes-in-pairs.py,swapPairs,199
3998,symmetric-tree.py::isSymmetric::4,"    def isSymmetric(self, root):
        if not root: return True
        
        q = deque()
        q.append((root.left, root.right))
        while q:
            left_node, right_node = q.popleft()
            if not left_node and right_node: return False
            if not right_node and left_node: return False
            
            if left_node and right_node:
                if left_node.val!=right_node.val: return False
                q.append((left_node.right, right_node.left))
                q.append((left_node.left, right_node.right))
        return True",data\repos\leetcode-python\problems\python\symmetric-tree.py,isSymmetric,119
3999,symmetric-tree.py::isSymmetric::48,"    def isSymmetric(self, root):
        s1 = [root]
        s2 = [root]
        
        while s1 and s2:
            node1 = s1.pop()
            node2 = s2.pop()
            
            if not node1 and not node2: continue
            if not node1 and node2: return False
            if node1 and not node2: return False
            if node1.val!=node2.val: return False
            
            s1.append(node1.left)
            s1.append(node1.right)
            s2.append(node2.right)                
            s2.append(node2.left)
        
        if s1 or s2: return False #if there are something left in one of the stack
        return True",data\repos\leetcode-python\problems\python\symmetric-tree.py,isSymmetric,157
4000,tallest-billboard.py::tallestBillboard::3,"    def tallestBillboard(self, rods):
        D = sum(rods)
        N = len(rods)
        
        dp = [[float('-inf') for _ in xrange(-D, D+1)] for _ in xrange(N+1)]
        dp[0][D] = 0
        
        for i in xrange(1, N+1):
            for d in xrange(-D, D+1):
                h = rods[i-1]
                dp[i][d+D] = max(dp[i-1][d+D], (dp[i-1][d+D-h]+h) if d+D-h>=0 else float('-inf'), dp[i-1][d+D+h] if d+D+h<2*D+1 else float('-inf'))
        
        return dp[N][D]",data\repos\leetcode-python\problems\python\tallest-billboard.py,tallestBillboard,171
4001,target-sum.py::findTargetSumWays::2,"    def findTargetSumWays(self, nums, S):
        stack = [(0, 0)]
        ans = 0
        
        while stack:
            i, s = stack.pop()
            if i==len(nums) and s==S: ans += 1
            if i>=len(nums): continue
            
            stack.append((i+1, s+nums[i]))
            stack.append((i+1, s-nums[i]))
        
        return ans",data\repos\leetcode-python\problems\python\target-sum.py,findTargetSumWays,96
4002,target-sum.py::findTargetSumWays::25,"    def findTargetSumWays(self, nums, target):
        S = sum(nums)
        dp = [collections.Counter() for _ in xrange(len(nums)+1)]
        dp[0][0] = 1
        
        for i in xrange(1, len(nums)+1):
            for j in xrange(-S, S+1):
                dp[i][j] = dp[i-1][j+nums[i-1]] + dp[i-1][j-nums[i-1]]
        
        return dp[len(nums)][target]",data\repos\leetcode-python\problems\python\target-sum.py,findTargetSumWays,112
4003,target-sum.py::findTargetSumWays::43,"    def findTargetSumWays(self, nums, target):
        N = len(nums)
        maxTarget = sum(nums)
        minTarget = -maxTarget
        
        if target<minTarget or target>maxTarget: return 0
        
        dp = [[0 for _ in xrange(minTarget, maxTarget+1)] for _ in xrange(N+1)]
        
        dp[0][0] = 1
        
        for i in xrange(1, N+1):
            for t in xrange(minTarget, maxTarget+1):
                dp[i][t] = (dp[i-1][t-nums[i-1]] if t-nums[i-1]>=minTarget else 0) + (dp[i-1][t+nums[i-1]] if t+nums[i-1]<=maxTarget else 0)
        
        return dp[N][target]",data\repos\leetcode-python\problems\python\target-sum.py,findTargetSumWays,182
4004,target-sum.py::findTargetSumWays::66,"    def findTargetSumWays(self, nums, target):
        S = sum(nums)
        if not -S<=target<=S: return 0
        
        dp = [{s:0 for s in xrange(-S, S+1)} for _ in xrange(len(nums)+1)]
        dp[0][0] = 1
        
        for i in xrange(1, len(nums)+1):
            for s in xrange(-S, S+1):
                dp[i][s] = (dp[i-1][s+nums[i-1]] if s+nums[i-1]<=S else 0) + (dp[i-1][s-nums[i-1]] if s-nums[i-1]>=-S else 0)
        
        return dp[-1][target]",data\repos\leetcode-python\problems\python\target-sum.py,findTargetSumWays,166
4005,task-scheduler.py::leastInterval::31,"    def leastInterval(self, tasks, n):
        task_count = collections.Counter(tasks).values()
        max_count = max(task_count) #[2]
        t = task_count.count(max_count) #[1]
        return max(len(tasks), (max_count-1)*(n+1)+t) #[3]",data\repos\leetcode-python\problems\python\task-scheduler.py,leastInterval,64
4006,text-justification.py::fullJustify::13,"    def fullJustify(self, words, maxWidth):
        def canAddToCurrLine(word, currLineStringLength):
            currWidth = len(currLine)-1 + currLineStringLength # space+currLineStringLength
            return currWidth+len(word)+1<=maxWidth
        
        def leftAlign(currLine):
            line = ''
            
            for word in currLine:
                line += word + ' '
            line = line[:-1] #remove last space
            
            line += ' '*(maxWidth-len(line))
            return line
        
        def midAlign(currLine, currLineStringLength):
            line = ''
            
            totalSpaceCount = maxWidth-currLineStringLength
            extraSpaceCount = totalSpaceCount%(len(currLine)-1)
            spaceCount = totalSpaceCount-extraSpaceCount
            spaces = ' '*(totalSpaceCount/(len(currLine)-1))
            
            for word in currLine:
                line += word
                if spaceCount>0:
                    line += spaces
                    spaceCount -= len(spaces)
                
                if extraSpaceCount>0:
                    line += ' '
                    extraSpaceCount -= 1
                    
            return line
            
        currLineStringLength = 0
        currLine = []
        ans = []
        
        i = 0
        while i<len(words):
            if canAddToCurrLine(words[i], currLineStringLength):
                currLine.append(words[i])
                currLineStringLength += len(words[i])
                i += 1
            else:
                if len(currLine)==1:
                    ans.append(leftAlign(currLine)) #line with one word align left
                else:
                    ans.append(midAlign(currLine, currLineStringLength))
                
                currLine = []
                currLineStringLength = 0
                
        ans.append(leftAlign(currLine)) #last line should always align left
        return ans",data\repos\leetcode-python\problems\python\text-justification.py,fullJustify,378
4007,text-justification.py::canAddToCurrLine::14,"        def canAddToCurrLine(word, currLineStringLength):
            currWidth = len(currLine)-1 + currLineStringLength # space+currLineStringLength
            return currWidth+len(word)+1<=maxWidth",data\repos\leetcode-python\problems\python\text-justification.py,canAddToCurrLine,44
4008,text-justification.py::leftAlign::18,"        def leftAlign(currLine):
            line = ''
            
            for word in currLine:
                line += word + ' '
            line = line[:-1] #remove last space
            
            line += ' '*(maxWidth-len(line))
            return line",data\repos\leetcode-python\problems\python\text-justification.py,leftAlign,52
4009,text-justification.py::midAlign::28,"        def midAlign(currLine, currLineStringLength):
            line = ''
            
            totalSpaceCount = maxWidth-currLineStringLength
            extraSpaceCount = totalSpaceCount%(len(currLine)-1)
            spaceCount = totalSpaceCount-extraSpaceCount
            spaces = ' '*(totalSpaceCount/(len(currLine)-1))
            
            for word in currLine:
                line += word
                if spaceCount>0:
                    line += spaces
                    spaceCount -= len(spaces)
                
                if extraSpaceCount>0:
                    line += ' '
                    extraSpaceCount -= 1
                    
            return line",data\repos\leetcode-python\problems\python\text-justification.py,midAlign,127
4010,the-kth-factor-of-n.py::kthFactor::6,"    def kthFactor(self, n, k):
        factors = []
        
        for i in xrange(1, n+1):
            if n%i==0:
                factors.append(i)
                if len(factors)==k: return factors[-1]
        return -1",data\repos\leetcode-python\problems\python\the-kth-factor-of-n.py,kthFactor,57
4011,the-kth-factor-of-n.py::kthFactor::21,"    def kthFactor(self, n, k):
        factors1 = []
        factors2 = []
        
        for i in xrange(1, int(n**0.5)+1):
            if n%i==0:
                factors1.append(i)
                if i!=n/i: factors2.append(n/i)
        
        factors = factors1+factors2[::-1] 
        
        return factors[k-1] if k-1<len(factors) else -1",data\repos\leetcode-python\problems\python\the-kth-factor-of-n.py,kthFactor,96
4012,the-maze-ii.py::shortestDistance::2,"    def shortestDistance(self, maze, start, destination):
        N, M = len(maze), len(maze[0])
        i0, j0 = start
        pq = [(0, i0, j0, 'stop')]
        visited = set()
        
        
        while pq:
            dis, i, j, direction = heapq.heappop(pq)
            if (i, j, direction) in visited: continue
            visited.add((i, j, direction))
            
            if i<0 or i>=N or j<0 or j>=M: continue
            if maze[i][j]==1: continue
            
            if i==destination[0] and j==destination[1] and direction=='stop': return dis
                
            if direction=='stop':
                heapq.heappush(pq, (dis+1, i-1, j, 'left'))
                heapq.heappush(pq, (dis+1, i+1, j, 'right'))
                heapq.heappush(pq, (dis+1, i, j-1, 'down'))
                heapq.heappush(pq, (dis+1, i, j+1, 'up'))
            elif direction=='left':
                if i-1<0 or i-1>=N or j<0 or j>=M or maze[i-1][j]==1:
                    heapq.heappush(pq, (dis, i, j, 'stop'))
                else:
                    heapq.heappush(pq, (dis+1, i-1, j, direction))
            elif direction=='right':
                if i+1<0 or i+1>=N or j<0 or j>=M or maze[i+1][j]==1:
                    heapq.heappush(pq, (dis, i, j, 'stop'))
                else:
                    heapq.heappush(pq, (dis+1, i+1, j, direction))
            elif direction=='down':
                if i<0 or i>=N or j-1<0 or j-1>=M or maze[i][j-1]==1:
                    heapq.heappush(pq, (dis, i, j, 'stop'))
                else:
                    heapq.heappush(pq, (dis+1, i, j-1, direction))
            elif direction=='up':
                if i<0 or i>=N or j+1<0 or j+1>=M or maze[i][j+1]==1:
                    heapq.heappush(pq, (dis, i, j, 'stop'))
                else:
                    heapq.heappush(pq, (dis+1, i, j+1, direction))
                    
        return -1",data\repos\leetcode-python\problems\python\the-maze-ii.py,shortestDistance,571
4013,toeplitz-matrix.py::isToeplitzMatrix::2,"    def isToeplitzMatrix(self, matrix):
        def check(i0, j0, matrix):
            i = i0
            j = j0
            
            while 0<=i<len(matrix) and 0<=j<len(matrix[0]):
                if matrix[i][j]!=matrix[i0][j0]: return False
                i += 1
                j += 1
            return True
    
        M = len(matrix)
        N = len(matrix[0])
        
        for i in xrange(M-1, 0, -1):
            if not check(i, 0, matrix): return False
        
        for j in xrange(N):
            if not check(0, j, matrix): return False
        
        return True",data\repos\leetcode-python\problems\python\toeplitz-matrix.py,isToeplitzMatrix,154
4014,toeplitz-matrix.py::check::3,"        def check(i0, j0, matrix):
            i = i0
            j = j0
            
            while 0<=i<len(matrix) and 0<=j<len(matrix[0]):
                if matrix[i][j]!=matrix[i0][j0]: return False
                i += 1
                j += 1
            return True",data\repos\leetcode-python\problems\python\toeplitz-matrix.py,check,74
4015,top-k-frequent-elements.py::topKFrequent::32,"    def topKFrequent(self, nums, k):
        opt = []
        counter = collections.Counter(nums)
        bucket = collections.defaultdict(list)

        for num, count in counter.items():
            bucket[count].append(num)

        for i in reversed(xrange(len(nums)+1)):
            if i in bucket:
                opt.extend(bucket[i])
                if len(opt)>=k: break

        return opt[:k]",data\repos\leetcode-python\problems\python\top-k-frequent-elements.py,topKFrequent,85
4016,top-k-frequent-elements.py::topKFrequent::49,"    def topKFrequent(self, nums, k):
        opt = []
        counter = collections.Counter(nums)

        heap = [(-count, num) for num, count in counter.items()]
        heapq.heapify(heap)
        
        while len(opt)<k:
            opt.append(heapq.heappop(heap)[1])

        return opt",data\repos\leetcode-python\problems\python\top-k-frequent-elements.py,topKFrequent,68
4017,top-k-frequent-elements.py::topKFrequent::78,"    def topKFrequent(self, nums, k):
        ans = []
        
        numToCounts = collections.Counter(nums)
        h = [(-numToCounts[num], num) for num in numToCounts]
        
        heapq.heapify(h)
        
        while k>0:
            _, num = heapq.heappop(h)
            ans.append(num)
            k -= 1
        
        return ans",data\repos\leetcode-python\problems\python\top-k-frequent-elements.py,topKFrequent,82
4018,top-k-frequent-elements.py::topKFrequent::98,"    def topKFrequent(self, nums, k):
        counter = collections.Counter(nums)
        count2Nums = [[] for _ in xrange(len(nums)+1)] #count2Nums[i] := elements with count i
        
        for num in counter:
            count2Nums[counter[num]].append(num)
        
        ans = []
        for i in xrange(len(count2Nums)-1, -1, -1):
            ans += count2Nums[i]
            if len(ans)>=k: break
        
        return ans",data\repos\leetcode-python\problems\python\top-k-frequent-elements.py,topKFrequent,109
4019,top-k-frequent-elements.py::topKFrequent::115,"    def topKFrequent(self, nums, K):
        def quickselect(A, s, e, K):
            i = s
            t = s
            j = e
            
            pivot = A[(s+e)/2][0]
            while t<=j:
                if A[t][0]<pivot:
                    A[t], A[i] = A[i], A[t]
                    i += 1
                    t += 1
                elif A[t][0]==pivot:
                    t += 1
                else:
                    A[t], A[j] = A[j], A[t]
                    j -=1
            
            if e-j>=K:
                return quickselect(A, j+1, e, K)
            elif e-(i-1)>=K:
                return pivot
            else:
                return quickselect(A, s, i-1, K-(e-i+1))
                
        ans = []
        counter = collections.Counter(nums)
        freqs = [(counter[num], num) for num in counter]
        
        KthLargestFreq = quickselect(freqs, 0, len(freqs)-1, K)
        
        for freq, num in freqs:
            if freq>=KthLargestFreq: ans.append(num)
                
        return ans",data\repos\leetcode-python\problems\python\top-k-frequent-elements.py,topKFrequent,265
4020,top-k-frequent-elements.py::quickselect::116,"        def quickselect(A, s, e, K):
            i = s
            t = s
            j = e
            
            pivot = A[(s+e)/2][0]
            while t<=j:
                if A[t][0]<pivot:
                    A[t], A[i] = A[i], A[t]
                    i += 1
                    t += 1
                elif A[t][0]==pivot:
                    t += 1
                else:
                    A[t], A[j] = A[j], A[t]
                    j -=1
            
            if e-j>=K:
                return quickselect(A, j+1, e, K)
            elif e-(i-1)>=K:
                return pivot
            else:
                return quickselect(A, s, i-1, K-(e-i+1))",data\repos\leetcode-python\problems\python\top-k-frequent-elements.py,quickselect,175
4021,trapping-rain-water-ii.py::trapRainWater::2,"    def trapRainWater(self, heightMap):
        pq = []
        N = len(heightMap)
        M = len(heightMap[0])
        visited = set()
        ans = 0
        curr = float('-inf')
        
        for i in xrange(N):
            for j in xrange(M):
                if i==0 or i==N-1 or j==0 or j==M-1:
                    heapq.heappush(pq, (heightMap[i][j], i, j))
                
        while pq:
            h, i, j = heapq.heappop(pq)
            if (i, j) in visited: continue
            visited.add((i, j))
            
            if h>curr: curr = h
            ans += (curr-h)
            
            for iNext, jNext in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if iNext<0 or iNext>=N or jNext<0 or jNext>=M: continue
                if (iNext, jNext) in visited: continue
                heapq.heappush(pq, (heightMap[iNext][jNext], iNext, jNext))
        
        return ans",data\repos\leetcode-python\problems\python\trapping-rain-water-ii.py,trapRainWater,264
4022,trapping-rain-water.py::trap::12,"    def trap(self, height):
        N = len(height)
        l2r = [0]*N #water
        r2l = [0]*N #water
        
        for i in xrange(1, N):
            l2r[i] = max(l2r[i-1]+height[i-1]-height[i], 0)
        
        for i in xrange(N-2, -1, -1):
            r2l[i] = max(r2l[i+1]+height[i+1]-height[i], 0)
        
        ans = 0
        for i in xrange(N):
            ans += min(l2r[i], r2l[i])
        return ans",data\repos\leetcode-python\problems\python\trapping-rain-water.py,trap,146
4023,trim-a-binary-search-tree.py::trimBST::2,"    def trimBST(self, root, L, R):
        if not root: return root
        root.left = self.trimBST(root.left, L, R)
        root.right = self.trimBST(root.right, L, R)
        return root if L<=root.val and root.val<=R else root.left or root.right",data\repos\leetcode-python\problems\python\trim-a-binary-search-tree.py,trimBST,67
4024,two-out-of-three.py::twoOutOfThree::2,"    def twoOutOfThree(self, nums1, nums2, nums3):
        ans = []
        
        counter = collections.Counter()
        
        for num in list(set(nums1)):
            counter[num] += 1
        for num in list(set(nums2)):
            counter[num] += 1
        for num in list(set(nums3)):
            counter[num] += 1
        
        for num in counter:
            if counter[num]>=2: ans.append(num)
        
        return ans",data\repos\leetcode-python\problems\python\two-out-of-three.py,twoOutOfThree,100
4025,two-sum-ii-input-array-is-sorted.py::twoSum::11,"    def twoSum(self, numbers, target):
        r, l = len(numbers)-1, 0
        while r>l:
            if numbers[r]+numbers[l]==target:
                return [l+1, r+1]
            elif numbers[r]+numbers[l]>target:
                r = r-1
            else:
                l = l+1
        return []",data\repos\leetcode-python\problems\python\two-sum-ii-input-array-is-sorted.py,twoSum,80
4026,two-sum-ii-input-array-is-sorted.py::twoSum::28,"    def twoSum(self, numbers, target):
        memo = {}
        for i, n in enumerate(numbers):
            if target-n in memo:
                return [memo[target-n]+1, i+1]
            memo[n] = i",data\repos\leetcode-python\problems\python\two-sum-ii-input-array-is-sorted.py,twoSum,49
4027,two-sum.py::twoSum::12,"    def twoSum(self, nums, target):
        wanted = {}
        for i in xrange(len(nums)):
            n = nums[i]
            if n in wanted: #[1]
                return [wanted[n], i]
            else:
                wanted[target-n] = i #[0]
        return []",data\repos\leetcode-python\problems\python\two-sum.py,twoSum,61
4028,two-sum.py::twoSum::26,"    def twoSum(self, nums, target):
        M = {} #counter part number needed by index i: i
        
        for i, num in enumerate(nums):
            if num in M: return (M[num], i)
            M[target-num] = i
        
        return False",data\repos\leetcode-python\problems\python\two-sum.py,twoSum,58
4029,two-sum.py::twoSum::37,"    def twoSum(self, nums, target):
        memo = {} #{key : value} := {""counter part needed for n"" : ""index of n""}
        
        for i, n in enumerate(nums):
            if n in memo:
                return [memo[n], i]
            else:
                memo[target-n] = i
        return []",data\repos\leetcode-python\problems\python\two-sum.py,twoSum,71
4030,two-sum.py::twoSum::53,"    def twoSum(self, nums, target):
        memo = {} #{key : value} := {""counter part needed for n"" : ""index of n""}
        
        for i, n in enumerate(nums):
            if n in memo: return [memo[n], i]
            memo[target-n] = i
        
        return []",data\repos\leetcode-python\problems\python\two-sum.py,twoSum,67
4031,ugly-number-ii.py::nthUglyNumber::15,"    def nthUglyNumber(self, k):
        i2 = i3 = i5 = 0
        
        ans = [1]
        while len(ans)<k:
            n2 = ans[i2]*2
            n3 = ans[i3]*3
            n5 = ans[i5]*5
            
            n = min(n2, n3, n5)
            ans.append(n)
            
            if n2==n: i2 += 1
            if n3==n: i3 += 1
            if n5==n: i5 += 1
                
        return ans[-1]",data\repos\leetcode-python\problems\python\ugly-number-ii.py,nthUglyNumber,130
4032,ugly-number.py::isUgly::2,"    def isUgly(self, n):
        if n<1: return False
        
        while n%2==0: n /= 2
        while n%3==0: n /= 3
        while n%5==0: n /= 5
            
        return n==1",data\repos\leetcode-python\problems\python\ugly-number.py,isUgly,62
4033,umber-of-islands-ii.py::numIslands2::2,"    def numIslands2(self, m, n, positions):
        ans = []
        uf = UnionFind(m*n)
        
        for x, y in positions:
            i = x*n+y
            if uf.isLand(i):
                ans.append(uf.count)
                continue
            
            connected = []
            if (x-1>=0 and uf.isLand((x-1)*n+y)): connected.append((x-1)*n+y)
            if (x+1<m and uf.isLand((x+1)*n+y)): connected.append((x+1)*n+y)
            if (y-1>=0 and uf.isLand(x*n+y-1)): connected.append(x*n+y-1)
            if (y+1<n and uf.isLand(x*n+y+1)): connected.append(x*n+y+1)
            
            
            uf.setLand(i)
            for nei in connected: uf.union(nei, i)
            ans.append(uf.count)
        
        return ans",data\repos\leetcode-python\problems\python\umber-of-islands-ii.py,numIslands2,204
4034,umber-of-islands-ii.py::find::38,"    def find(self, i):
        if self.parents[i]!=i: self.parents[i] = self.find(self.parents[i])
        return self.parents[i]",data\repos\leetcode-python\problems\python\umber-of-islands-ii.py,find,32
4035,umber-of-islands-ii.py::union::42,"    def union(self, i1, i2):
        parent1 = self.find(i1)
        parent2 = self.find(i2)
        
        if parent1!=parent2:
            if self.ranks[parent1]>self.ranks[parent2]:
                self.parents[parent2] = parent1
            elif self.ranks[parent1]<self.ranks[parent2]:
                self.parents[parent1] = parent2
            else:
                self.parents[parent1] = parent2
                self.ranks[parent2] += 1
                
            self.count -= 1",data\repos\leetcode-python\problems\python\umber-of-islands-ii.py,union,116
4036,unique-binary-search-trees.py::numTrees::4,"    def numTrees(self, n):
        dp = [1, 1, 2]
        
        if n<=2: return dp[n]
        
        for i in xrange(3, n+1):
            dp.append(0)
            for root in xrange(1, i+1):
                dp[i] += dp[root-1]*dp[i-root]
                
        return dp[n]",data\repos\leetcode-python\problems\python\unique-binary-search-trees.py,numTrees,82
4037,unique-binary-search-trees.py::numTrees::33,"    def numTrees(self, N):
        def helper(n):
            count = 0
            for i in xrange(1, n+1):
                count += dp[i-1]*dp[n-i]
            return count
                
        dp = [0]*(N+1)
        dp[0] = 1
        dp[1] = 1
        
        for n in xrange(2, N+1):
            dp[n] = helper(n)
        return dp[N]",data\repos\leetcode-python\problems\python\unique-binary-search-trees.py,numTrees,100
4038,unique-binary-search-trees.py::helper::34,"        def helper(n):
            count = 0
            for i in xrange(1, n+1):
                count += dp[i-1]*dp[n-i]
            return count",data\repos\leetcode-python\problems\python\unique-binary-search-trees.py,helper,38
4039,unique-email-addres.py::numUniqueEmails::30,"    def numUniqueEmails(self, emails):
        book = set() #[0]
        for s in emails:
            at = s.find('@') #[1]
            local_name = s[:at]
            domain_name = s[at:]
            
            plus = local_name.find('+') #[2]
            if plus!=-1: local_name = local_name[:plus]

            local_name = local_name.replace('.', '') #[3]

            r = local_name+domain_name #[0]
            book.add(r)
            
        return len(book)",data\repos\leetcode-python\problems\python\unique-email-addres.py,numUniqueEmails,109
4040,unique-email-addres.py::numUniqueEmails::49,"    def numUniqueEmails(self, emails):
        book = set()
        for email in emails:
            r = ''
            ignore = False
            for i, c in enumerate(email):
                if c=='@':
                    r+=email[i:]
                    break
                    
                if ignore: continue
                    
                if c=='.':
                    continue
                elif c=='+':
                    ignore = True
                else:
                    r+=c                    
            book.add(r)
        return len(book)",data\repos\leetcode-python\problems\python\unique-email-addres.py,numUniqueEmails,98
4041,unique-paths.py::uniquePaths::2,"    def uniquePaths(self, m, n):
        def factorial(n):
            ans = 1
            for i in xrange(1, n+1):
                ans *= i
            return ans
        
        return factorial((m-1)+(n-1))/(factorial(n-1)*factorial(m-1))",data\repos\leetcode-python\problems\python\unique-paths.py,uniquePaths,66
4042,unique-paths.py::factorial::3,"        def factorial(n):
            ans = 1
            for i in xrange(1, n+1):
                ans *= i
            return ans",data\repos\leetcode-python\problems\python\unique-paths.py,factorial,31
4043,univalued-binary-tree.py::isUnivalTree::2,"    def isUnivalTree(self, root):
        stack = []
        stack.append(root)
        value = root.val
        while stack:
            node = stack.pop()
            if node.val!=value: return False
            if node.left: stack.append(node.left)
            if node.right: stack.append(node.right)
        return True",data\repos\leetcode-python\problems\python\univalued-binary-tree.py,isUnivalTree,68
4044,valid-anagram.py::isAnagram::6,"    def isAnagram(self, s, t):
        if len(s)!=len(t): return False
        return sorted(s)==sorted(t)",data\repos\leetcode-python\problems\python\valid-anagram.py,isAnagram,30
4045,valid-anagram.py::isAnagram::13,"    def isAnagram(self, s, t):
        if len(s)!=len(t): return False
        
        counter1 = collections.Counter()
        counter2 = collections.Counter()
        for c in s:
            counter1[c]+=1
        for c in t:
            counter2[c]+=1
            
        return counter1==counter2",data\repos\leetcode-python\problems\python\valid-anagram.py,isAnagram,69
4046,valid-anagram.py::isAnagram::37,"    def isAnagram(self, s, t):
        if len(s)!=len(t): return False
        for i in string.ascii_lowercase:
                if s.count(i) != t.count(i):
                    return False
        return True",data\repos\leetcode-python\problems\python\valid-anagram.py,isAnagram,48
4047,valid-anagram.py::isAnagram::53,"    def isAnagram(self, s, t):
        counter = collections.Counter()
        if len(t)>len(s): t, s = s, t
        
        for c in s: counter[c] += 1
        for c in t: counter[c] -= 1
        for c in counter:
            if counter[c]>0: return False
        return True",data\repos\leetcode-python\problems\python\valid-anagram.py,isAnagram,78
4048,valid-number.py::isNumber::2,"    def isNumber(self, s):
        def isOK(s, maxDots):
            if not s: return False
            
            #check and remove +/-
            for i, c in enumerate(s):
                if (c=='+' or c=='-') and i!=0:
                    return False
            if s[0]=='+' or s[0]=='-': s = s[1:]
            
            #check dot and if there is digit
            dotCount = 0
            dotPos = 0
            digitCount = 0
            for i, c in enumerate(s):
                if c=='.':
                    dotCount += 1
                    dotPos = i
                elif c.isdigit():
                    digitCount += 1
            
            if dotCount>maxDots: return False
            if digitCount==0: return False
            
            return True
        
        #get e's position. Also check if all char is in validChar
        validChar = set(['1','2', '3', '4', '5', '6', '7', '8', '9', '0', 'e', 'E', '.', '+', '-'])
        eCount = 0
        ePos = 0
        for i, c in enumerate(s):
            if c not in validChar:
                return False
            if c=='e' or c=='E':
                eCount += 1
                ePos = i
            
        if eCount>1:
            return False
        elif eCount==1:
            return isOK(s[:ePos], 1) and isOK(s[ePos+1:], 0)
        else:
            return isOK(s, 1)",data\repos\leetcode-python\problems\python\valid-number.py,isNumber,356
4049,valid-number.py::isOK::3,"        def isOK(s, maxDots):
            if not s: return False
            
            #check and remove +/-
            for i, c in enumerate(s):
                if (c=='+' or c=='-') and i!=0:
                    return False
            if s[0]=='+' or s[0]=='-': s = s[1:]
            
            #check dot and if there is digit
            dotCount = 0
            dotPos = 0
            digitCount = 0
            for i, c in enumerate(s):
                if c=='.':
                    dotCount += 1
                    dotPos = i
                elif c.isdigit():
                    digitCount += 1
            
            if dotCount>maxDots: return False
            if digitCount==0: return False
            
            return True",data\repos\leetcode-python\problems\python\valid-number.py,isOK,172
4050,valid-palindrome-ii.py::validPalindrome::9,"    def validPalindrome(self, s):
        def isPalindrome(s):
            i = 0
            j = len(s)-1
            while i<j:
                if s[i]!=s[j]: return False
                i += 1
                j -= 1
            return True
        
        i = 0
        j = len(s)-1
        
        while i<j:
            if s[i]==s[j]:
                i += 1
                j -= 1
            else:
                return isPalindrome(s[i:j]) or isPalindrome(s[i+1:j+1])
            
        return True",data\repos\leetcode-python\problems\python\valid-palindrome-ii.py,validPalindrome,125
4051,valid-palindrome-ii.py::isPalindrome::10,"        def isPalindrome(s):
            i = 0
            j = len(s)-1
            while i<j:
                if s[i]!=s[j]: return False
                i += 1
                j -= 1
            return True",data\repos\leetcode-python\problems\python\valid-palindrome-ii.py,isPalindrome,51
4052,valid-palindrome.py::isPalindrome::2,"    def isPalindrome(self, s):
        i = 0
        j = len(s)-1
        
        while i<j:
            if not s[i].isalnum():
                i += 1
                continue
            if not s[j].isalnum():
                j -= 1
                continue
            
            if s[i].lower()!=s[j].lower(): return False
            
            i += 1
            j -= 1
        
        return True",data\repos\leetcode-python\problems\python\valid-palindrome.py,isPalindrome,93
4053,valid-parentheses.py::isValid::3,"    def isValid(self, s):
        if (s==''):
            return True
        elif ('()' in s):
            return self.isValid(s.replace('()', ''))
        elif ('[]' in s):
            return self.isValid(s.replace('[]', ''))
        elif ('{}' in s):
            return self.isValid(s.replace('{}', ''))
        else:
            return False",data\repos\leetcode-python\problems\python\valid-parentheses.py,isValid,77
4054,valid-parentheses.py::isValid::17,"    def isValid(self, s):
        stack = []
        for c in s:
            if c=='(' or c=='[' or c=='{':
                stack.append(c)
            elif c==')':
                if stack and stack[-1]=='(':
                    stack.pop()
                else:
                    stack.append(c)
            elif c==']':
                if stack and stack[-1]=='[':
                    stack.pop()
                else:
                    stack.append(c)
            elif c=='}':
                if stack and stack[-1]=='{':
                    stack.pop()
                else:
                    stack.append(c)
        return len(stack)==0",data\repos\leetcode-python\problems\python\valid-parentheses.py,isValid,126
4055,valid-word-abbreviation.py::validWordAbbreviation::2,"    def validWordAbbreviation(self, word, abbr):
        #process abbr
        splitedAbbr = []
        for c in abbr:
            if c.isdigit() and splitedAbbr and splitedAbbr[-1][0].isdigit():
                splitedAbbr[-1] += c
            elif c.isdigit() and c=='0':
                return False #leading 0
            else:
                splitedAbbr.append(c)
        for i, c in enumerate(splitedAbbr):
            if c[0].isdigit(): splitedAbbr[i] = int(c)
                    
        i = 0
        j = 0
        while i<len(word) and j<len(splitedAbbr):
            if word[i]==splitedAbbr[j]:
                i += 1
                j += 1
                continue
            
            if isinstance(splitedAbbr[j], basestring):
                return False
            else:
                splitedAbbr[j] -= 1
                if splitedAbbr[j]==0: j += 1
                i += 1
        
        return i==len(word) and j==len(splitedAbbr)",data\repos\leetcode-python\problems\python\valid-word-abbreviation.py,validWordAbbreviation,250
4056,validate-binary-search-tree.py::isValidBST::30,"    def isValidBST(self, node):
        def helper(node, min_val, max_val):
            if not node: return True
            if node.val<=min_val or node.val>=max_val:return False
            if not helper(node.left, min_val, node.val): return False
            if not helper(node.right, node.val, max_val): return False
            return True
        return helper(node, float('-inf'), float('inf'))",data\repos\leetcode-python\problems\python\validate-binary-search-tree.py,isValidBST,92
4057,validate-binary-search-tree.py::isValidBST::40,"    def isValidBST(self, node):
        if node==None: return True
        stack = [(node, float('-inf'), float('inf'))]
        while stack:
            node, min_val, max_val = stack.pop()
            if node.val<=min_val or node.val>=max_val:
                return False
            if node.left:
                stack.append((node.left, min_val, node.val))
            if node.right:
                stack.append((node.right, node.val, max_val))
        return True",data\repos\leetcode-python\problems\python\validate-binary-search-tree.py,isValidBST,105
4058,validate-binary-search-tree.py::isValidBST::54,"    def isValidBST(self, node):
        stack = []
        last_val = float('-inf')
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()

            if node.val<=last_val:
                return False
            
            last_val = node.val
            node = node.right #if node.right: node = node.right
        return True",data\repos\leetcode-python\problems\python\validate-binary-search-tree.py,isValidBST,84
4059,validate-binary-search-tree.py::isValidBST::80,"    def isValidBST(self, root):
        node = root
        stack = []
        prev = float('-inf')
        
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            
            node = stack.pop()
            
            if prev>=node.val: return False
            prev = node.val
            
            node = node.right
            
        return True",data\repos\leetcode-python\problems\python\validate-binary-search-tree.py,isValidBST,78
4060,validate-binary-search-tree.py::helper::31,"        def helper(node, min_val, max_val):
            if not node: return True
            if node.val<=min_val or node.val>=max_val:return False
            if not helper(node.left, min_val, node.val): return False
            if not helper(node.right, node.val, max_val): return False
            return True",data\repos\leetcode-python\problems\python\validate-binary-search-tree.py,helper,70
4061,verify-preorder-serialization-of-a-binary-tree.py::isValidSerialization::6,"    def isValidSerialization(self, preorder):
        slot = 1
        
        for c in preorder.split(','):
            slot -= 1 #each elemet consumes a slot
            if slot<0: return False
            if c!='#': slot += 2 #each non-null node also create 2 slot
            
        return slot==0 #all slots should be fill",data\repos\leetcode-python\problems\python\verify-preorder-serialization-of-a-binary-tree.py,isValidSerialization,76
4062,vertical-order-traversal-of-a-binary-tree.py::verticalTraversal::9,"    def verticalTraversal(self, root):
        temp = defaultdict(list)
        min_x = 0
        max_x = 0

        stack = []
        stack.append((root, 0, 0))
        while stack:
            node, x, y = stack.pop()
            temp[x].append((y, node.val)) #append the value of height, so we can sort by height later on
            min_x = min(min_x, x)
            max_x = max(max_x, x)
            if node.left: stack.append((node.left, x-1, y+1))
            if node.right: stack.append((node.right, x+1, y+1))
        
        opt = []
        for i in range(min_x, max_x+1):
            opt.append([v for y, v in sorted(temp[i])]) #the temp[i] will be sorted by y_position then sorted by node.val
        
        return opt",data\repos\leetcode-python\problems\python\vertical-order-traversal-of-a-binary-tree.py,verticalTraversal,196
4063,vertical-order-traversal-of-a-binary-tree.py::verticalTraversal::40,"    def verticalTraversal(self, root):
        def dfs(node, x, y):
            if not node: return
            self.maxX = max(self.maxX, x)
            self.minX = min(self.minX, x)
            self.minY = min(self.minY, y)
            data[(x, y)].append(node.val)
            dfs(node.left, x-1, y-1)
            dfs(node.right, x+1, y-1)
        
        data = collections.defaultdict(list)
        self.maxX = float('-inf')
        self.minX = float('inf')
        self.minY = float('inf')
        
        dfs(root, 0, 0)
        
        ans = []
        for x in xrange(self.minX, self.maxX+1):
            temp = []
            for y in xrange(0, self.minY-1, -1):
                if (x, y) not in data: continue
                if len(data[(x, y)])>1:
                    temp += sorted(data[(x, y)])
                else:
                    temp.append(data[(x, y)][0])
            ans.append(temp)
        return ans",data\repos\leetcode-python\problems\python\vertical-order-traversal-of-a-binary-tree.py,verticalTraversal,242
4064,vertical-order-traversal-of-a-binary-tree.py::dfs::41,"        def dfs(node, x, y):
            if not node: return
            self.maxX = max(self.maxX, x)
            self.minX = min(self.minX, x)
            self.minY = min(self.minY, y)
            data[(x, y)].append(node.val)
            dfs(node.left, x-1, y-1)
            dfs(node.right, x+1, y-1)",data\repos\leetcode-python\problems\python\vertical-order-traversal-of-a-binary-tree.py,dfs,89
4065,wiggle-subsequence.py::wiggleMaxLength::15,"    def wiggleMaxLength(self, nums):
        ans = 1
        N = len(nums)
        
        dp = [[0, 0] for _ in xrange(N+1)]
        dp[1][0] = 1
        dp[1][1] = 1
        
        for i in xrange(2, N+1):
            if nums[i-1]-nums[i-2]>0:
                dp[i][0] = dp[i-1][1]+1
                dp[i][1] = dp[i-1][1]
            elif nums[i-1]-nums[i-2]<0:
                dp[i][1] = dp[i-1][0]+1
                dp[i][0] = dp[i-1][0]
            else:
                dp[i][1] = dp[i-1][1]
                dp[i][0] = dp[i-1][0]
                
            ans = max(ans, dp[i][0], dp[i][1])

        return ans",data\repos\leetcode-python\problems\python\wiggle-subsequence.py,wiggleMaxLength,212
4066,wiggle-subsequence.py::wiggleMaxLength::47,"    def wiggleMaxLength(self, nums):
        N = len(nums)
        
        ans = 1
        up = 1
        down = 1
        
        for i in xrange(2, N+1):
            if nums[i-1]-nums[i-2]>0:
                up, down = down+1, down
            elif nums[i-1]-nums[i-2]<0:
                down = up+1
                
            ans = max(ans, up, down)

        return ans",data\repos\leetcode-python\problems\python\wiggle-subsequence.py,wiggleMaxLength,105
4067,word-break.py::wordBreak::2,"    def wordBreak(self, s, wordDict):
        def helper(s_left):
            if not s_left: return True
            if s_left in history: return history[s_left]
            
            for word in wordDict:
                if len(s_left)<len(word): continue
                if s_left[:len(word)]==word and helper(s_left[len(word):]):
                    history[s_left] = True
                    return history[s_left]
            
            history[s_left] = False
            return history[s_left]
        
        history = {}
        return helper(s)",data\repos\leetcode-python\problems\python\word-break.py,wordBreak,114
4068,word-break.py::helper::3,"        def helper(s_left):
            if not s_left: return True
            if s_left in history: return history[s_left]
            
            for word in wordDict:
                if len(s_left)<len(word): continue
                if s_left[:len(word)]==word and helper(s_left[len(word):]):
                    history[s_left] = True
                    return history[s_left]
            
            history[s_left] = False
            return history[s_left]",data\repos\leetcode-python\problems\python\word-break.py,helper,93
4069,word-ladder-ii.py::findLadders::2,"    def findLadders(self, beginWord, endWord, wordList):
        #build an adjacent list
        a = collections.defaultdict(list)
        
        for word in wordList+[beginWord]:
            for i in xrange(len(word)):
                s = word[:i]+'#'+word[i+1:]
                a[s].append(word)
        
        #BFS
        q = collections.deque([(beginWord, collections.OrderedDict())])
        ans = []
        shortest = float('inf')
        
        while q:
            word, path = q.popleft()

            if word in path: continue
            path[word] = None
            if len(path)>shortest: break
            
            if word==endWord:
                shortest = len(path)
                ans.append(path.keys())
                continue

            for i in xrange(len(word)):
                s = word[:i]+'#'+word[i+1:]
                for wordNext in a[s]:
                    q.append((wordNext, path.copy()))
            
        return ans",data\repos\leetcode-python\problems\python\word-ladder-ii.py,findLadders,209
4070,word-ladder-ii.py::findLadders::55,"    def findLadders(self, beginWord, endWord, wordList):
        ans = []
        wordSet = set(wordList)
        ajacencyList = self.buildAjacencyList(beginWord, wordSet)
        stack = [(beginWord, [beginWord])]
        
        while stack:
            word, path = stack.pop()
            if word==endWord: ans.append(path)
            
            for nextWord in ajacencyList[word]:
                stack.append((nextWord, path+[nextWord]))

        return ans",data\repos\leetcode-python\problems\python\word-ladder-ii.py,findLadders,105
4071,word-ladder-ii.py::buildAjacencyList::70,"    def buildAjacencyList(self, beginWord, wordSet):
        ajacencyList = collections.defaultdict(list)
        
        rank = {}
        rank[beginWord] = 0
        
        q = collections.deque()
        q.append(beginWord)
        
        while q:
            word = q.popleft()
            for i in xrange(len(word)):
                for alphabet in 'abcdefghijklmnopqrstuvwxyz':
                    nextWord = word[:i]+alphabet+word[i+1:]
            
                    if nextWord not in wordSet or word==nextWord: continue

                    if nextWord not in rank:
                        rank[nextWord] = rank[word]+1
                        ajacencyList[word].append(nextWord)
                        q.append(nextWord)
                    elif rank[word]<rank[nextWord]:
                        ajacencyList[word].append(nextWord)
        
        return ajacencyList",data\repos\leetcode-python\problems\python\word-ladder-ii.py,buildAjacencyList,171
4072,word-ladder.py::ladderLength::37,"    def ladderLength(self, beginWord, endWord, wordList):
        memo = collections.defaultdict(list)
        for word in wordList:
            for i in xrange(len(word)):
                memo[word[:i]+'#'+word[i+1:]].append(word)

        seen = set()
        q = collections.deque([(beginWord, 1)])
        while q:
            word, steps = q.popleft()
            if word==endWord: return steps
            seen.add(word)

            for i in xrange(len(word)):
                for next_word in memo[word[:i]+'#'+word[i+1:]]:
                    if next_word not in seen:
                        q.append((next_word, steps+1))
        return 0",data\repos\leetcode-python\problems\python\word-ladder.py,ladderLength,150
4073,word-ladder.py::ladderLength::63,"    def ladderLength(self, beginWord, endWord, wordList):
        memo = collections.defaultdict(list)
        for word in wordList:
            for i in xrange(len(word)):
                memo[word[:i]+'#'+word[i+1:]].append(word)

        seen = set()
        q = collections.deque([(beginWord, 1)])
        while q:
            word, steps = q.popleft()
            if word==endWord: return steps

            for i in xrange(len(word)):
                for next_word in memo[word[:i]+'#'+word[i+1:]]:
                    if next_word not in seen:
                        q.append((next_word, steps+1))
                        seen.add(next_word)
        return 0",data\repos\leetcode-python\problems\python\word-ladder.py,ladderLength,151
4074,word-ladder.py::ladderLength::83,"    def ladderLength(self, beginWord, endWord, wordList):
        wordList = set(wordList)
        seen = set()
        q = collections.deque([(beginWord, 1)])
        while q:
            word, steps = q.popleft()
            if word==endWord: return steps

            for i in xrange(len(word)):
                for alphabet in 'abcdefghijklmnopqrstuvwxyz':
                    next_word = word[:i]+alphabet+word[i+1:]
                    if next_word not in seen and next_word in wordList:
                        q.append((next_word, steps+1))
                        seen.add(next_word)
        return 0",data\repos\leetcode-python\problems\python\word-ladder.py,ladderLength,129
4075,word-ladder.py::ladderLength::116,"    def ladderLength(self, beginWord, endWord, wordList):
        #build an adjacent list
        a = collections.defaultdict(list)
        
        for word in wordList+[beginWord]:
            possible = set()
            for i in xrange(len(word)):
                for alphabet in 'abcdefghijklmnopqrstuvwxyz':
                    possible.add(word[:i]+alphabet+word[i+1:])
            for nextWord in wordList:
                if nextWord in possible:
                    a[word].append(nextWord)
        
        #BFS
        q = collections.deque([(beginWord, 1)])
        seen = set()
        
        while q:
            word, steps = q.popleft()
            if word in seen: continue
            if word==endWord: return steps
            seen.add(word)
            for wordNext in a[word]: q.append((wordNext, steps+1))
            
        return 0",data\repos\leetcode-python\problems\python\word-ladder.py,ladderLength,182
4076,word-ladder.py::ladderLength::164,"    def ladderLength(self, beginWord, endWord, wordList):
        #build an adjacent list
        a = collections.defaultdict(list)
        
        for word in wordList+[beginWord]:
            for i in xrange(len(word)):
                s = word[:i]+'#'+word[i+1:]
                a[s].append(word)
        
        #BFS
        q = collections.deque([(beginWord, 1)])
        seen = set()
        
        while q:
            word, steps = q.popleft()
            if word in seen: continue
            if word==endWord: return steps
            seen.add(word)
            
            for i in xrange(len(word)):
                s = word[:i]+'#'+word[i+1:]
                for wordNext in a[s]:
                    q.append((wordNext, steps+1))
            
        return 0",data\repos\leetcode-python\problems\python\word-ladder.py,ladderLength,178
4077,word-search.py::exist::12,"    def exist(self, board, word):
        def getNeighbor(i, j):
            opt = []
            if i+1<M: opt.append((i+1, j))
            if j+1<N: opt.append((i, j+1))
            if i-1>=0: opt.append((i-1, j))
            if j-1>=0: opt.append((i, j-1))
            return opt

        def dfs(i, j, l, visited):
            if l==len(word)-1: return True
            visited.add((i, j))
            for ni, nj in getNeighbor(i, j):
                if (ni, nj) not in visited and board[ni][nj]==word[l+1]:
                    if dfs(ni, nj, l+1, visited.copy()): return True
            return False

        M = len(board)
        N = len(board[0])

        for i in xrange(M):
            for j in xrange(N):
                if board[i][j]==word[0]:
                    if dfs(i, j, 0, set()): return True

        return False",data\repos\leetcode-python\problems\python\word-search.py,exist,235
4078,word-search.py::exist::49,"    def exist(self, board, word):
        def getNeighbor(i, j):
            opt = []
            if i+1<M: opt.append((i+1, j))
            if j+1<N: opt.append((i, j+1))
            if i-1>=0: opt.append((i-1, j))
            if j-1>=0: opt.append((i, j-1))
            return opt

        def dfs(i, j, l):
            if l==len(word)-1 and board[i][j]==word[l]: return True
            if board[i][j]!=word[l]: return False

            char = board[i][j]
            board[i][j] = '#'

            for ni, nj in getNeighbor(i, j):
                if dfs(ni, nj, l+1): return True

            board[i][j] = char
            return False

        M = len(board)
        N = len(board[0])

        for i in xrange(M):
            for j in xrange(N):
                if dfs(i, j, 0): return True

        return False",data\repos\leetcode-python\problems\python\word-search.py,exist,234
4079,word-search.py::getNeighbor::13,"        def getNeighbor(i, j):
            opt = []
            if i+1<M: opt.append((i+1, j))
            if j+1<N: opt.append((i, j+1))
            if i-1>=0: opt.append((i-1, j))
            if j-1>=0: opt.append((i, j-1))
            return opt",data\repos\leetcode-python\problems\python\word-search.py,getNeighbor,81
4080,word-search.py::dfs::21,"        def dfs(i, j, l, visited):
            if l==len(word)-1: return True
            visited.add((i, j))
            for ni, nj in getNeighbor(i, j):
                if (ni, nj) not in visited and board[ni][nj]==word[l+1]:
                    if dfs(ni, nj, l+1, visited.copy()): return True
            return False",data\repos\leetcode-python\problems\python\word-search.py,dfs,86
4081,word-search.py::getNeighbor::50,"        def getNeighbor(i, j):
            opt = []
            if i+1<M: opt.append((i+1, j))
            if j+1<N: opt.append((i, j+1))
            if i-1>=0: opt.append((i-1, j))
            if j-1>=0: opt.append((i, j-1))
            return opt",data\repos\leetcode-python\problems\python\word-search.py,getNeighbor,81
4082,word-search.py::dfs::58,"        def dfs(i, j, l):
            if l==len(word)-1 and board[i][j]==word[l]: return True
            if board[i][j]!=word[l]: return False

            char = board[i][j]
            board[i][j] = '#'

            for ni, nj in getNeighbor(i, j):
                if dfs(ni, nj, l+1): return True

            board[i][j] = char
            return False",data\repos\leetcode-python\problems\python\word-search.py,dfs,98
4083,3sum-closest.py::threeSumClosest::6,"    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        
        N = len(nums)
        ans = float('inf')
        
        for i in range(N):
            j = i+1
            k = N-1
            
            while j<k:
                total = nums[i]+nums[j]+nums[k]
                if total==target: return total
                if abs(target-ans)>abs(target-total): ans = total
                if total>target:
                    k -= 1
                elif total<target:
                    j += 1
        return ans",data\repos\leetcode-python\problems\python3\3sum-closest.py,threeSumClosest,128
4084,3sum-smaller.py::threeSumSmaller::2,"    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        N = len(nums)
        ans = 0
        
        nums.sort()
        
        
        for i in range(N):
            j = i+1
            k = N-1
            while j<k:
                if nums[i]+nums[j]+nums[k]<target:
                    ans += k-j
                    j += 1
                else:
                    k -= 1
        return ans",data\repos\leetcode-python\problems\python3\3sum-smaller.py,threeSumSmaller,100
4085,3sum.py::threeSum::19,"    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums.sort()
        
        for i in range(len(nums)):
            if 0<i and nums[i]==nums[i-1]: continue #[0]
            if nums[i]>0: break #[1]
            
            j, k = i+1, len(nums)-1
            while j<k:
                if nums[i]+nums[j]+nums[k]>0:
                    k -= 1
                elif nums[i]+nums[j]+nums[k]<0:
                    j += 1
                else:
                    ans.append((nums[i], nums[j], nums[k]))
                    while 0<k-1 and nums[k-1]==nums[k]: k -= 1 #[0]
                    while j+1<len(nums) and nums[j+1]==nums[j]: j += 1 #[0]
                    k -= 1
                    j += 1
                    
        return ans",data\repos\leetcode-python\problems\python3\3sum.py,threeSum,198
4086,3sum.py::threeSum::51,"    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = set()
        seen = set()
        N = len(nums)
        
        for i, v1 in enumerate(nums):
            if v1 in seen: continue
            seen.add(v1)
            needed = set()
            for j, v2 in enumerate(nums[i+1:]):
                if v2 in needed:
                    ans.add(tuple(sorted((v1, v2, -v1-v2))))
                needed.add(-v1-v2)
        return ans",data\repos\leetcode-python\problems\python3\3sum.py,threeSum,114
4087,3sum.py::threeSum::69,"    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        
        nums.sort()
        
        for i in range(len(nums)):
            if nums[i]>0: break
            if i>0 and nums[i]==nums[i-1]: continue
            
            j = i+1
            k = len(nums)-1
            while j<k:
                if nums[j]+nums[k]+nums[i]>0:
                    k -= 1
                elif nums[j]+nums[k]+nums[i]<0:
                    j += 1
                else:
                    ans.append((nums[i], nums[j], nums[k]))
                    
                    while j<k and nums[j+1]==nums[j]: j += 1
                    while j<k and nums[k-1]==nums[k]: k -= 1
                    j += 1
                    k -= 1
        return ans",data\repos\leetcode-python\problems\python3\3sum.py,threeSum,185
4088,4sum.py::fourSum::6,"    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        def kSum(k, start, target):
            if k>2:
                for i in range(start, len(nums)-k+1):
                    if i!=start and nums[i]==nums[i-1]: continue
                    temp.append(nums[i])
                    kSum(k-1, i+1, target-nums[i])
                    temp.pop()
            else:
                l, r = start, len(nums)-1
                
                while l<r:
                    if nums[l]+nums[r]>target:
                        r -= 1
                    elif nums[l]+nums[r]<target:
                        l += 1
                    else:
                        ans.append(temp+[nums[l], nums[r]])
                        while l<r and nums[l+1]==nums[l]: l += 1
                        while l<r and nums[r-1]==nums[r]: r -= 1
                        l += 1
                        r -= 1
                        
        ans = []
        temp = []
        nums.sort()
        kSum(4, 0, target)
        return ans",data\repos\leetcode-python\problems\python3\4sum.py,fourSum,232
4089,4sum.py::kSum::7,"        def kSum(k, start, target):
            if k>2:
                for i in range(start, len(nums)-k+1):
                    if i!=start and nums[i]==nums[i-1]: continue
                    temp.append(nums[i])
                    kSum(k-1, i+1, target-nums[i])
                    temp.pop()
            else:
                l, r = start, len(nums)-1
                
                while l<r:
                    if nums[l]+nums[r]>target:
                        r -= 1
                    elif nums[l]+nums[r]<target:
                        l += 1
                    else:
                        ans.append(temp+[nums[l], nums[r]])
                        while l<r and nums[l+1]==nums[l]: l += 1
                        while l<r and nums[r-1]==nums[r]: r -= 1
                        l += 1
                        r -= 1",data\repos\leetcode-python\problems\python3\4sum.py,kSum,185
4090,add-two-numbers.py::addTwoNumbers::2,"    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        carry = 0
        dummy = ListNode()
        curr = dummy
        
        while l1 or l2 or carry:
            n = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            if n>=10:
                curr.next = ListNode(n-10)
                carry = 1
            else:
                curr.next = ListNode(n)
                carry = 0
            curr = curr.next
            if l1: l1 = l1.next
            if l2: l2 = l2.next
            
        return dummy.next",data\repos\leetcode-python\problems\python3\add-two-numbers.py,addTwoNumbers,152
4091,alien-dictionary.py::alienOrder::2,"    def alienOrder(self, words: List[str]) -> str:
        adj = collections.defaultdict(list)
        inbounds = collections.Counter()
        q = collections.deque()
        ans = ''
        
        adj = {c: set() for word in words for c in word}
        for i in range(len(words)-1):
            w1, w2 = words[i], words[i+1]
            minLen = min(len(w1), len(w2))
            if w1[:minLen]==w2[:minLen] and len(w1)>len(w2): return """"
            
            for j in range(minLen):
                if w1[j]!=w2[j]:
                    adj[w1[j]].add(w2[j])
                    break
        
        for c in adj:
            for nc in list(adj[c]):
                inbounds[nc] += 1
        
        for c in adj:
            if inbounds[c]==0: q.append(c)
        
        while q:
            c = q.popleft()
            
            ans += c
            
            for nc in adj[c]:
                inbounds[nc] -= 1
                if inbounds[nc]==0: q.append(nc)
        
        return ans if len(ans)==len(adj) else ''",data\repos\leetcode-python\problems\python3\alien-dictionary.py,alienOrder,257
4092,balanced-binary-tree.py::isBalanced::6,"    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def getHeight(node) -> (bool, int):
            if not node: return True, 0
            leftIsBalanced, leftHeight = getHeight(node.left)
            if not leftIsBalanced: return False, 0
            
            rightIsBalanced, rightHeight = getHeight(node.right)
            if not rightIsBalanced: return False, 0
            
            return abs(leftHeight-rightHeight)<2, 1+max(leftHeight, rightHeight)
        
        isBalanced, h = getHeight(root)
        return isBalanced",data\repos\leetcode-python\problems\python3\balanced-binary-tree.py,isBalanced,128
4093,balanced-binary-tree.py::getHeight::7,"        def getHeight(node) -> (bool, int):
            if not node: return True, 0
            leftIsBalanced, leftHeight = getHeight(node.left)
            if not leftIsBalanced: return False, 0
            
            rightIsBalanced, rightHeight = getHeight(node.right)
            if not rightIsBalanced: return False, 0
            
            return abs(leftHeight-rightHeight)<2, 1+max(leftHeight, rightHeight)",data\repos\leetcode-python\problems\python3\balanced-binary-tree.py,getHeight,96
4094,best-time-to-buy-and-sell-stock-with-cooldown.py::maxProfit::4,"    def maxProfit(self, prices: List[int]) -> int:
        if not prices or len(prices)<=1: return 0
        
        N = len(prices)
        dp = [[0, 0] for _ in range(N)]
        dp[0] = [-prices[0], 0]
        dp[1][0] = max(-prices[1], -prices[0])
        dp[1][1] = max(prices[1]+dp[0][0], dp[0][1])
        
        for i in range(2, N):
            dp[i][0] = max(dp[i-2][1]-prices[i], dp[i-1][0])
            dp[i][1] = max(prices[i]+dp[i-1][0], dp[i-1][1])
        return max(dp[-1][0], dp[-1][1], 0)",data\repos\leetcode-python\problems\python3\best-time-to-buy-and-sell-stock-with-cooldown.py,maxProfit,190
4095,best-time-to-buy-and-sell-stock.py::maxProfit::2,"    def maxProfit(self, prices: List[int]) -> int:
        minPrice = prices[0]
        ans = 0
        
        for i in range(1, len(prices)):
            ans = max(ans, prices[i]-minPrice)
            minPrice = min(prices[i], minPrice)
        
        return ans",data\repos\leetcode-python\problems\python3\best-time-to-buy-and-sell-stock.py,maxProfit,68
4096,binary-search.py::search::2,"    def search(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums)-1
        
        while l<=r:
            m = l + int((r-l)/2)
            
            if nums[m]>target:
                r = m-1
            elif nums[m]<target:
                l = m+1
            else:
                return m
        
        return -1",data\repos\leetcode-python\problems\python3\binary-search.py,search,89
4097,binary-tree-level-order-traversal.py::levelOrder::6,"    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        def helper(node, level):
            if not node: return
            if level==len(ans): ans.append([])
            ans[level].append(node.val)
            helper(node.left, level+1)
            helper(node.right, level+1)
        
        ans = []
        helper(root, 0)
        
        return ans",data\repos\leetcode-python\problems\python3\binary-tree-level-order-traversal.py,levelOrder,83
4098,binary-tree-level-order-traversal.py::levelOrder::25,"    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        
        q = collections.deque([(root, 0)])
        ans = []
        
        while q:
            node, level = q.popleft()
            
            if level==len(ans): ans.append([])
            ans[level].append(node.val)
            if node.left: q.append((node.left, level+1))
            if node.right: q.append((node.right, level+1))
        
        return ans",data\repos\leetcode-python\problems\python3\binary-tree-level-order-traversal.py,levelOrder,108
4099,binary-tree-level-order-traversal.py::helper::7,"        def helper(node, level):
            if not node: return
            if level==len(ans): ans.append([])
            ans[level].append(node.val)
            helper(node.left, level+1)
            helper(node.right, level+1)",data\repos\leetcode-python\problems\python3\binary-tree-level-order-traversal.py,helper,50
4100,binary-tree-maximum-path-sum.py::maxPathSum::15,"    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        def helper(node):
            nonlocal ans
            
            if not node: return 0
            left = max(helper(node.left), 0) #[3]
            right = max(helper(node.right), 0) #[3]
            ans = max(ans, node.val+left+right) #[1]
            return node.val+max(left, right) #[0]
        
        ans = float('-inf')
        helper(root)
        return ans",data\repos\leetcode-python\problems\python3\binary-tree-maximum-path-sum.py,maxPathSum,107
4101,binary-tree-maximum-path-sum.py::helper::16,"        def helper(node):
            nonlocal ans
            
            if not node: return 0
            left = max(helper(node.left), 0) #[3]
            right = max(helper(node.right), 0) #[3]
            ans = max(ans, node.val+left+right) #[1]
            return node.val+max(left, right) #[0]",data\repos\leetcode-python\problems\python3\binary-tree-maximum-path-sum.py,helper,76
4102,binary-tree-right-side-view.py::rightSideView::9,"    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        def helper(node, level):
            if not node: return
            if len(ans)<level: ans.append(node.val)
            helper(node.right, level+1)
            helper(node.left, level+1)
        
        ans = []
        helper(root, 1)
        return ans",data\repos\leetcode-python\problems\python3\binary-tree-right-side-view.py,rightSideView,76
4103,binary-tree-right-side-view.py::helper::10,"        def helper(node, level):
            if not node: return
            if len(ans)<level: ans.append(node.val)
            helper(node.right, level+1)
            helper(node.left, level+1)",data\repos\leetcode-python\problems\python3\binary-tree-right-side-view.py,helper,44
4104,burst-balloons.py::maxCoins::16,"    def maxCoins(self, nums: List[int]) -> int:
        def dfs(l, r)->int:
            if l>r: return 0
            if (l, r) in dp: return dp[(l, r)]
            
            dp[(l, r)] = 0
            for i in range(l, r+1):
                dp[(l, r)] = max(dp[(l, r)], nums[l-1]*nums[i]*nums[r+1] + dfs(l, i-1) + dfs(i+1, r))
            return dp[(l, r)]
                
        nums = [1]+nums+[1]
        dp = {}
        return dfs(1, len(nums)-2)",data\repos\leetcode-python\problems\python3\burst-balloons.py,maxCoins,150
4105,burst-balloons.py::dfs::17,"        def dfs(l, r)->int:
            if l>r: return 0
            if (l, r) in dp: return dp[(l, r)]
            
            dp[(l, r)] = 0
            for i in range(l, r+1):
                dp[(l, r)] = max(dp[(l, r)], nums[l-1]*nums[i]*nums[r+1] + dfs(l, i-1) + dfs(i+1, r))
            return dp[(l, r)]",data\repos\leetcode-python\problems\python3\burst-balloons.py,dfs,110
4106,car-fleet.py::carFleet::2,"    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        N = len(position)
        
        timeInfo = []
        for i in range(N):
            timeInfo.append((position[i], (target-position[i])/speed[i]))
        timeInfo.sort(reverse=True)
        
        stack = []
        for _, time in timeInfo:
            stack.append(time)
            if len(stack)>=2 and stack[-2]>=stack[-1]:
                stack.pop()
        
        return len(stack)",data\repos\leetcode-python\problems\python3\car-fleet.py,carFleet,109
4107,cheapest-flights-within-k-stops.py::findCheapestPrice::6,"    def findCheapestPrice(self, N: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        prices = {n:float('inf') for n in range(N)}
        prices[src] = 0
        
        for k in range(K+1):
            temp = prices.copy()
            for source, destination, price in flights:
                if prices[source]==float('inf'): continue
                if prices[source]+price<temp[destination]:
                    temp[destination] = prices[source]+price
            prices = temp
        return prices[dst] if prices[dst]!=float('inf') else -1",data\repos\leetcode-python\problems\python3\cheapest-flights-within-k-stops.py,findCheapestPrice,138
4108,climbing-stairs.py::climbStairs::2,"    def climbStairs(self, N: int) -> int:
        dp = [0]*(N+1)
        dp[0] = 1
        for i in range(len(dp)):
            if i-1>=0:
                dp[i] += dp[i-1]
            if i-2>=0:
                dp[i] += dp[i-2]
        return dp[-1]",data\repos\leetcode-python\problems\python3\climbing-stairs.py,climbStairs,83
4109,clone-graph.py::cloneGraph::2,"    def cloneGraph(self, start: 'Node') -> 'Node':
        def dfs(node):
            if node in clones: return clones[node]
            
            copy = Node(node.val)
            clones[node] = copy
            
            for neighbor in node.neighbors:
                copy.neighbors.append(dfs(neighbor))
                
            return clones[node]
        if not start: return start
        clones = {}
        dfs(start)
        return clones[start]",data\repos\leetcode-python\problems\python3\clone-graph.py,cloneGraph,88
4110,clone-graph.py::dfs::3,"        def dfs(node):
            if node in clones: return clones[node]
            
            copy = Node(node.val)
            clones[node] = copy
            
            for neighbor in node.neighbors:
                copy.neighbors.append(dfs(neighbor))
                
            return clones[node]",data\repos\leetcode-python\problems\python3\clone-graph.py,dfs,52
4111,coin-change-ii.py::change::2,"    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0]*(amount+1)
        dp[0] = 1
        
        coins.sort()
        
        for coin in coins:
            for a in range(1, amount+1):
                if a-coin<0: continue
                dp[a] += dp[a-coin]
        return dp[-1]",data\repos\leetcode-python\problems\python3\coin-change-ii.py,change,85
4112,coin-change.py::coinChange::2,"    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')]*(amount+1)
        dp[0] = 0
        for coin in coins:
            if coin<len(dp): dp[coin] = 1
        
        coins.sort()
        
        for i in range(1, amount+1):
            for coin in coins:
                if i-coin<0: break
                dp[i] = min(dp[i], dp[i-coin]+1)
        return dp[amount] if dp[amount]!=float('inf') else -1",data\repos\leetcode-python\problems\python3\coin-change.py,coinChange,127
4113,combination-sum-ii.py::combinationSum2::2,"    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def helper(i, target):
            if target==0:
                ans.append(combination.copy())
                return
            
            if i==len(candidates) or candidates[i]>target:
                return
            
            combination.append(candidates[i])
            helper(i+1, target-candidates[i])
            combination.pop()
            
            while i+1<len(candidates) and candidates[i]==candidates[i+1]: i += 1
            helper(i+1, target)
        
        ans = []
        combination = []
        candidates.sort()
        helper(0, target)
        return ans",data\repos\leetcode-python\problems\python3\combination-sum-ii.py,combinationSum2,138
4114,combination-sum-ii.py::helper::3,"        def helper(i, target):
            if target==0:
                ans.append(combination.copy())
                return
            
            if i==len(candidates) or candidates[i]>target:
                return
            
            combination.append(candidates[i])
            helper(i+1, target-candidates[i])
            combination.pop()
            
            while i+1<len(candidates) and candidates[i]==candidates[i+1]: i += 1
            helper(i+1, target)",data\repos\leetcode-python\problems\python3\combination-sum-ii.py,helper,94
4115,combination-sum.py::combinationSum::12,"    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        def helper(i, currSum, target):
            if currSum>target:
                return
            
            if currSum==target:
                ans.append(combination.copy())
                return
            
            for j in range(i, len(candidates)):
                combination.append(candidates[j])
                helper(j, currSum+candidates[j], target)
                combination.pop()
                
        ans = []
        combination = []
        helper(0, 0, target)
        return ans",data\repos\leetcode-python\problems\python3\combination-sum.py,combinationSum,113
4116,combination-sum.py::helper::13,"        def helper(i, currSum, target):
            if currSum>target:
                return
            
            if currSum==target:
                ans.append(combination.copy())
                return
            
            for j in range(i, len(candidates)):
                combination.append(candidates[j])
                helper(j, currSum+candidates[j], target)
                combination.pop()",data\repos\leetcode-python\problems\python3\combination-sum.py,helper,71
4117,construct-binary-tree-from-preorder-and-inorder-traversal.py::buildTree::19,"    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def helper(i, j, k, l):
            if i==j or k==l: return None
            
            root = TreeNode(preorder[i]) #[0]
            
            rootInorderIndex = getInorderIndex[root.val] #[1]
            leftLen = rootInorderIndex-k
            
            root.left = helper(i+1, i+1+leftLen, k, k+leftLen) #[2]
            root.right = helper(i+1+leftLen, j, rootInorderIndex+1, l)
            return root
        
        getInorderIndex = {}
        for i, v in enumerate(inorder): getInorderIndex[v] = i
        return helper(0, len(preorder), 0, len(inorder))",data\repos\leetcode-python\problems\python3\construct-binary-tree-from-preorder-and-inorder-traversal.py,buildTree,179
4118,construct-binary-tree-from-preorder-and-inorder-traversal.py::helper::20,"        def helper(i, j, k, l):
            if i==j or k==l: return None
            
            root = TreeNode(preorder[i]) #[0]
            
            rootInorderIndex = getInorderIndex[root.val] #[1]
            leftLen = rootInorderIndex-k
            
            root.left = helper(i+1, i+1+leftLen, k, k+leftLen) #[2]
            root.right = helper(i+1+leftLen, j, rootInorderIndex+1, l)
            return root",data\repos\leetcode-python\problems\python3\construct-binary-tree-from-preorder-and-inorder-traversal.py,helper,114
4119,container-with-most-water.py::maxArea::14,"    def maxArea(self, height: List[int]) -> int:
        i = 0
        j = len(height)-1
        ans = 0
        
        while i<j:
            ans = max(ans, min(height[i], height[j]) * (j-i))
            if height[i]>height[j]:
                j -= 1
            else:
                i += 1
        return ans",data\repos\leetcode-python\problems\python3\container-with-most-water.py,maxArea,83
4120,container-with-most-water.py::maxArea::30,"    def maxArea(self, height: List[int]) -> int:
        i = 0
        j = len(height)-1
        ans = 0
        
        while i<j:
            ans = max(ans, min(height[i], height[j]) * abs(i-j))
            
            if height[i]>height[j]:
                j -= 1
            else:
                i += 1
        return ans",data\repos\leetcode-python\problems\python3\container-with-most-water.py,maxArea,84
4121,contains-duplicate.py::containsDuplicate::2,"    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen: return True
            seen.add(num)
        return False",data\repos\leetcode-python\problems\python3\contains-duplicate.py,containsDuplicate,42
4122,copy-list-with-random-pointer.py::copyRandomList::18,"    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head: return head
        
        node = head
        while node:
            copy = Node(node.val, node.next, node.random)
            node.random = copy
            node = node.next
        
        node = head
        while node:
            newNode = node.random
            if node.next: newNode.next = node.next.random
            if newNode.random: newNode.random = newNode.random.random
            node = node.next
        
        return head.random",data\repos\leetcode-python\problems\python3\copy-list-with-random-pointer.py,copyRandomList,113
4123,count-good-nodes-in-binary-tree.py::goodNodes::6,"    def goodNodes(self, root: TreeNode) -> int:
        def helper(node, maxVal):
            nonlocal count            
            if not node: return
            if node.val>=maxVal: count += 1
            helper(node.left, max(maxVal, node.val))
            helper(node.right, max(maxVal, node.val))
        
        count = 0
        helper(root, float('-inf'))
        return count",data\repos\leetcode-python\problems\python3\count-good-nodes-in-binary-tree.py,goodNodes,88
4124,count-good-nodes-in-binary-tree.py::helper::7,"        def helper(node, maxVal):
            nonlocal count            
            if not node: return
            if node.val>=maxVal: count += 1
            helper(node.left, max(maxVal, node.val))
            helper(node.right, max(maxVal, node.val))",data\repos\leetcode-python\problems\python3\count-good-nodes-in-binary-tree.py,helper,57
4125,counting-bits.py::countBits::2,"    def countBits(self, n: int) -> List[int]:
        ans = [0]*(n+1)
        offset = 1
        
        for i in range(1, n+1):
            if offset*2==i: offset = offset*2
            ans[i] = 1+ans[i-offset]
        return ans",data\repos\leetcode-python\problems\python3\counting-bits.py,countBits,71
4126,course-schedule-ii.py::findOrder::3,"    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        sortedCourse = []
        G = collections.defaultdict(list) #graph
        inbounds = collections.Counter()
        q = collections.deque()
        
        #build graph
        for c1, c2 in prerequisites:
            G[c2].append(c1)
            inbounds[c1] += 1
        
        #add the starting point to the q. (the ones that have 0 inbounds)
        for course in range(numCourses):
            if inbounds[course]==0: q.append(course)
        
        #add the course that have 0 inbounds to the sortedCourse.
        #after that, imagine we remove it from the graph, so nextCourse inbound will -1
        #add to q if nextCourse have 0 inbounds
        while q:
            course = q.popleft()
            
            sortedCourse.append(course)
            
            for nextCourse in G[course]:
                inbounds[nextCourse] -= 1
                if inbounds[nextCourse]==0: q.append(nextCourse)
        
        return sortedCourse if len(sortedCourse)==numCourses else []",data\repos\leetcode-python\problems\python3\course-schedule-ii.py,findOrder,245
4127,course-schedule.py::canFinish::2,"    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        sortedCourse = []
        inbounds = collections.Counter()
        G = collections.defaultdict(list)
        q = collections.deque()
        
        for c1, c2 in prerequisites:
            G[c2].append(c1)
            inbounds[c1] += 1
        
        for c in range(numCourses):
            if inbounds[c]==0: q.append(c)

        while q:
            c = q.popleft()
            
            for c2 in G[c]:
                inbounds[c2] -= 1
                if inbounds[c2]==0: q.append(c2)    
            sortedCourse.append(c)
        
        return len(sortedCourse)==numCourses",data\repos\leetcode-python\problems\python3\course-schedule.py,canFinish,157
4128,daily-temperatures.py::dailyTemperatures::2,"    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        ans = [0]*len(temperatures)
        stack = []
        
        for i, temp in enumerate(temperatures):
            while stack and stack[-1][0]<temp:
                prevTemp, prevIndex = stack.pop()
                ans[prevIndex] = i-prevIndex
            stack.append((temp, i))
        
        return ans",data\repos\leetcode-python\problems\python3\daily-temperatures.py,dailyTemperatures,91
4129,decode-ways.py::numDecodings::5,"    def numDecodings(self, s: str) -> int:
        mapping = set([str(n) for n in range(1, 27)])
        N = len(s)
        dp = [0]*(N+1)
        dp[0] = 1
        
        for i in range(1, N+1):
            if i-1>=0 and s[i-1] in mapping: dp[i] += dp[i-1]
            if i-2>=0 and s[i-2:i] in mapping: dp[i] += dp[i-2]
        return dp[-1]",data\repos\leetcode-python\problems\python3\decode-ways.py,numDecodings,126
4130,design-add-and-search-words-data-structure.py::addWord::6,"    def addWord(self, word: str) -> None:
        node = self.root
        for c in word:
            if c not in node: node[c] = {}
            node = node[c]
        node['$'] = {} #'.' means the end of the word",data\repos\leetcode-python\problems\python3\design-add-and-search-words-data-structure.py,addWord,58
4131,design-add-and-search-words-data-structure.py::search::13,"    def search(self, word: str) -> bool:
        def helper(node, i):
            if i==len(word): return '$' in node
                
            if word[i]=='.':
                for c in node:
                    if helper(node[c], i+1): return True
                return False
            else:
                if word[i] not in node: return False
                return helper(node[word[i]], i+1)
        return helper(self.root, 0)",data\repos\leetcode-python\problems\python3\design-add-and-search-words-data-structure.py,search,97
4132,design-add-and-search-words-data-structure.py::helper::14,"        def helper(node, i):
            if i==len(word): return '$' in node
                
            if word[i]=='.':
                for c in node:
                    if helper(node[c], i+1): return True
                return False
            else:
                if word[i] not in node: return False
                return helper(node[word[i]], i+1)",data\repos\leetcode-python\problems\python3\design-add-and-search-words-data-structure.py,helper,76
4133,design-twitter.py::postTweet::9,"    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweetData[userId].append((self.count, tweetId))
        self.count -= 1",data\repos\leetcode-python\problems\python3\design-twitter.py,postTweet,40
4134,design-twitter.py::getNewsFeed::14,"    def getNewsFeed(self, userId: int) -> List[int]:
        newsFeed = []
        h = []
        
        self.followData[userId].add(userId)
        for followeeId in self.followData[userId]:
            if followeeId not in self.tweetData: continue
            index = len(self.tweetData[followeeId])-1
            count, tweetId = self.tweetData[followeeId][index]
            h.append((count, tweetId, followeeId, index-1))
        heapq.heapify(h)
        
        while h and len(newsFeed)<10:
            _, tweetId, userId, index = heapq.heappop(h)
            newsFeed.append(tweetId)
            if index>=0:
                count, tweetId2 = self.tweetData[userId][index]
                heapq.heappush(h, (count, tweetId2, userId, index-1))
        return newsFeed",data\repos\leetcode-python\problems\python3\design-twitter.py,getNewsFeed,195
4135,design-twitter.py::follow::36,"    def follow(self, followerId: int, followeeId: int) -> None:
        self.followData[followerId].add(followeeId)",data\repos\leetcode-python\problems\python3\design-twitter.py,follow,33
4136,design-twitter.py::unfollow::39,"    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followerId not in self.followData: return
        self.followData[followerId].remove(followeeId)",data\repos\leetcode-python\problems\python3\design-twitter.py,unfollow,46
4137,detect-squares.py::count::9,"    def count(self, point: List[int]) -> int:
        x, y = point
        ans = 0
        
        for dx, dy in self.store:
            if abs(x-dx)!=abs(y-dy) or x==dx or y==dy: continue
            ans += self.store[(dx, dy)]*self.store[(dx, y)]*self.store[(x, dy)]
        return ans",data\repos\leetcode-python\problems\python3\detect-squares.py,count,87
4138,diameter-of-binary-tree.py::diameterOfBinaryTree::6,"    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        def helper(node):
            if not node: return 0
            l = helper(node.left)
            r = helper(node.right)
            self.ans = max(self.ans, 1+l+r)
            return 1+max(l, r)
        
        self.ans = 0
        
        helper(root)
        return self.ans-1",data\repos\leetcode-python\problems\python3\diameter-of-binary-tree.py,diameterOfBinaryTree,90
4139,diameter-of-binary-tree.py::helper::7,"        def helper(node):
            if not node: return 0
            l = helper(node.left)
            r = helper(node.right)
            self.ans = max(self.ans, 1+l+r)
            return 1+max(l, r)",data\repos\leetcode-python\problems\python3\diameter-of-binary-tree.py,helper,53
4140,distinct-subsequences.py::numDistinct::2,"    def numDistinct(self, s: str, t: str) -> int:
        def dfs(i, j):
            if (i, j) in visited: return visited[(i, j)]
            
            if j>=len(t): return 1
            if i>=len(s): return 0
            
            if s[i]==t[j]:
                visited[(i, j)] = dfs(i+1, j+1)+dfs(i+1, j)
            else:
                visited[(i, j)] = dfs(i+1, j)
            return visited[(i, j)]
            
        visited = {}
        dfs(0, 0)
        return dfs(0, 0)",data\repos\leetcode-python\problems\python3\distinct-subsequences.py,numDistinct,144
4141,distinct-subsequences.py::dfs::3,"        def dfs(i, j):
            if (i, j) in visited: return visited[(i, j)]
            
            if j>=len(t): return 1
            if i>=len(s): return 0
            
            if s[i]==t[j]:
                visited[(i, j)] = dfs(i+1, j+1)+dfs(i+1, j)
            else:
                visited[(i, j)] = dfs(i+1, j)
            return visited[(i, j)]",data\repos\leetcode-python\problems\python3\distinct-subsequences.py,dfs,105
4142,edit-distance.py::minDistance::18,"    def minDistance(self, word1: str, word2: str) -> int:
        N = len(word1)
        M = len(word2)
        def dfs(i, j)->int:
            if i==N and j==M: return 0
            if i==N: return M-j
            if j==M: return N-i
            
            if (i, j) in history:
                return history[(i, j)]
                
            if word1[i]==word2[j]:
                history[(i, j)] = dfs(i+1, j+1)
            else:
                history[(i, j)] = 1+min(dfs(i+1, j+1), dfs(i+1, j), dfs(i, j+1))
            
            return history[(i, j)]
        
        history = {}
        return dfs(0, 0)",data\repos\leetcode-python\problems\python3\edit-distance.py,minDistance,184
4143,edit-distance.py::dfs::21,"        def dfs(i, j)->int:
            if i==N and j==M: return 0
            if i==N: return M-j
            if j==M: return N-i
            
            if (i, j) in history:
                return history[(i, j)]
                
            if word1[i]==word2[j]:
                history[(i, j)] = dfs(i+1, j+1)
            else:
                history[(i, j)] = 1+min(dfs(i+1, j+1), dfs(i+1, j), dfs(i, j+1))
            
            return history[(i, j)]",data\repos\leetcode-python\problems\python3\edit-distance.py,dfs,137
4144,encode-and-decode-strings.py::encode::2,"    def encode(self, strs: List[str]) -> str:
        output = ''
        for string in strs:
            output += str(len(string))+'#'+string
        return output",data\repos\leetcode-python\problems\python3\encode-and-decode-strings.py,encode,38
4145,encode-and-decode-strings.py::decode::9,"    def decode(self, s: str) -> List[str]:
        output = []
        i = 0
        
        while i<len(s):
            j = i+1
            
            while s[j]!='#': j += 1
                    
            l = int(s[i:j])
            string = s[j+1:j+1+l]
            output.append(string)
            i = j+1+l
            
        return output",data\repos\leetcode-python\problems\python3\encode-and-decode-strings.py,decode,84
4146,evaluate-reverse-polish-notation.py::evalRPN::2,"    def evalRPN(self, tokens: List[str]) -> int:
        operators = set(['+', '-', '*', '/'])
        stack = []
        
        for c in tokens:
            if c in operators:
                n2 = stack.pop()
                n1 = stack.pop()
                
                if c=='+':
                    stack.append(n1+n2)
                elif c=='-':
                    stack.append(n1-n2)
                elif c=='*':
                    stack.append(n1*n2)
                elif c=='/':
                    stack.append(int(n1/n2))
            else:
                stack.append(int(c))
        
        return stack.pop()",data\repos\leetcode-python\problems\python3\evaluate-reverse-polish-notation.py,evalRPN,129
4147,find-median-from-data-stream.py::addNum::7,"    def addNum(self, num: int) -> None:
        if not self.large and not self.small:
            heapq.heappush(self.large, num)
        elif num>=self.findMedian():
            heapq.heappush(self.large, num)
            self.balance()
        else:
            heapq.heappush(self.small, -num)
            self.balance()",data\repos\leetcode-python\problems\python3\find-median-from-data-stream.py,addNum,73
4148,find-median-from-data-stream.py::balance::17,"    def balance(self) -> None:
        #make the length of two heaps as even as posible
        if len(self.large)>len(self.small)+1:
            num = heapq.heappop(self.large)
            heapq.heappush(self.small, -num)
        
        if len(self.small)>len(self.large):
            num = -heapq.heappop(self.small)
            heapq.heappush(self.large, num)",data\repos\leetcode-python\problems\python3\find-median-from-data-stream.py,balance,87
4149,find-median-from-data-stream.py::findMedian::28,"    def findMedian(self) -> float:
        if (len(self.large)+len(self.small))%2==0:
            return (self.large[0]-self.small[0])/2
        else:
            return self.large[0]",data\repos\leetcode-python\problems\python3\find-median-from-data-stream.py,findMedian,50
4150,find-minimum-in-rotated-sorted-array.py::findMin::7,"    def findMin(self, nums: List[int]) -> int:
        def helper(l, r):
            nonlocal ans
            if l>r: return
            
            m = l + int((r-l)/2)
            if nums[l]<=nums[m]:
                ans = min(ans, nums[l])
                helper(m+1, r)
            else:
                ans = min(ans, nums[m+1])
                helper(l, m)
        
        ans = float('inf')
        helper(0, len(nums)-1)
        return ans",data\repos\leetcode-python\problems\python3\find-minimum-in-rotated-sorted-array.py,findMin,111
4151,find-minimum-in-rotated-sorted-array.py::helper::8,"        def helper(l, r):
            nonlocal ans
            if l>r: return
            
            m = l + int((r-l)/2)
            if nums[l]<=nums[m]:
                ans = min(ans, nums[l])
                helper(m+1, r)
            else:
                ans = min(ans, nums[m+1])
                helper(l, m)",data\repos\leetcode-python\problems\python3\find-minimum-in-rotated-sorted-array.py,helper,76
4152,find-the-duplicate-number.py::findDuplicate::2,"    def findDuplicate(self, nums: List[int]) -> int:
        head = nums[0]
        slow = head
        fast = head
        
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow==fast: break
        
        slow = head
        while slow!=fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow",data\repos\leetcode-python\problems\python3\find-the-duplicate-number.py,findDuplicate,87
4153,gas-station.py::canCompleteCircuit::10,"    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas)<sum(cost): return -1
        
        start = 0
        currGas = 0
        
        for i in range(len(gas)):
            currGas += gas[i]-cost[i]
            
            if currGas<0:
                currGas = 0
                start = i+1
        
        return start",data\repos\leetcode-python\problems\python3\gas-station.py,canCompleteCircuit,91
4154,generate-parentheses.py::generateParenthesis::2,"    def generateParenthesis(self, n: int) -> List[str]:
        def helper(parentheses, left, right):
            if len(parentheses)==n*2:
                ans.append("""".join(parentheses))
                return
            
            if left<n:
                parentheses.append('(')
                helper(parentheses, left+1, right)
                parentheses.pop()
            
            if left>right:
                parentheses.append(')')
                helper(parentheses, left, right+1)
                parentheses.pop()
        
        ans = []
        helper([], 0, 0)
        return ans",data\repos\leetcode-python\problems\python3\generate-parentheses.py,generateParenthesis,116
4155,generate-parentheses.py::helper::3,"        def helper(parentheses, left, right):
            if len(parentheses)==n*2:
                ans.append("""".join(parentheses))
                return
            
            if left<n:
                parentheses.append('(')
                helper(parentheses, left+1, right)
                parentheses.pop()
            
            if left>right:
                parentheses.append(')')
                helper(parentheses, left, right+1)
                parentheses.pop()",data\repos\leetcode-python\problems\python3\generate-parentheses.py,helper,84
4156,graph-valid-tree.py::validTree::2,"    def validTree(self, N: int, edges: List[List[int]]) -> bool:
        def union(n1, n2) -> bool:
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2:
                return False
            elif p1<p2:
                parents[p2] = p1
            else:
                parents[p1] = p2
                
            return True
            
        
        def find(n) -> int:
            p = parents[n]
            while p!=parents[p]: p = find(p)
            parents[n] = p
            return p
        
        parents = [n for n in range(N)]

        for n1, n2 in edges:
            if not union(n1, n2): return False
        
        #check if all node trace back to the same root
        root = find(0)
        for n in range(1, N):
            if root!=find(n): return False
        
        return True",data\repos\leetcode-python\problems\python3\graph-valid-tree.py,validTree,207
4157,graph-valid-tree.py::union::3,"        def union(n1, n2) -> bool:
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2:
                return False
            elif p1<p2:
                parents[p2] = p1
            else:
                parents[p1] = p2
                
            return True",data\repos\leetcode-python\problems\python3\graph-valid-tree.py,union,72
4158,graph-valid-tree.py::find::17,"        def find(n) -> int:
            p = parents[n]
            while p!=parents[p]: p = find(p)
            parents[n] = p
            return p",data\repos\leetcode-python\problems\python3\graph-valid-tree.py,find,36
4159,group-anagrams.py::groupAnagrams::2,"    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        def normalize(string: str) -> str:
            counter = collections.Counter()
            ans = ''
            
            for c in string:
                counter[c] += 1
            
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if counter[c]>0:
                    ans += c+str(counter[c])
            return ans
                    
        group = collections.defaultdict(list)
        ans = []
        
        for string in strs:
            group[normalize(string)].append(string)
        
        for normalizedString in group:
            ans.append(group[normalizedString])    
        return ans",data\repos\leetcode-python\problems\python3\group-anagrams.py,groupAnagrams,129
4160,group-anagrams.py::normalize::3,"        def normalize(string: str) -> str:
            counter = collections.Counter()
            ans = ''
            
            for c in string:
                counter[c] += 1
            
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if counter[c]>0:
                    ans += c+str(counter[c])
            return ans",data\repos\leetcode-python\problems\python3\group-anagrams.py,normalize,61
4161,hand-of-straights.py::isNStraightHand::2,"    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand)%groupSize!=0: return False
        
        counter = collections.Counter(hand)
        h = list(counter.keys())
        heapq.heapify(h)
        
        while h:
            minNum = h[0]
            for n in range(minNum, minNum+groupSize):
                if counter[n]<=0: return False
                counter[n] -= 1
                if counter[n]==0:
                    if h[0]!=n: return False
                    heapq.heappop(h)
        
        return True",data\repos\leetcode-python\problems\python3\hand-of-straights.py,isNStraightHand,129
4162,happy-number.py::isHappy::2,"    def isHappy(self, n: int) -> bool:
        def digitSquare(n) -> int:
            ans = 0
            while n>0:
                ans += (n%10)**2
                n = n//10
            return ans

        visited = set()
        visited.add(1)

        while n not in visited:
            visited.add(n)
            n = digitSquare(n)

        return n==1",data\repos\leetcode-python\problems\python3\happy-number.py,isHappy,90
4163,happy-number.py::digitSquare::3,"        def digitSquare(n) -> int:
            ans = 0
            while n>0:
                ans += (n%10)**2
                n = n//10
            return ans",data\repos\leetcode-python\problems\python3\happy-number.py,digitSquare,41
4164,house-robber-ii.py::rob::2,"    def rob(self, nums: List[int]) -> int:
        if len(nums)<=1: return max(nums)
        
        N = len(nums)
        dp = [[0, 0] for _ in range(N)]
        dp[0][0] = nums[0]
        
        for i in range(1, N):
            dp[i][0] = nums[i]+dp[i-1][1]
            dp[i][1] = max(dp[i-1])
        
        dp2 = [[0, 0] for _ in range(N)]
        for i in range(1, N):
            dp2[i][0] = nums[i]+dp2[i-1][1]
            dp2[i][1] = max(dp2[i-1])
        
        return max(dp[-1][1], dp2[-1][0])",data\repos\leetcode-python\problems\python3\house-robber-ii.py,rob,177
4165,house-robber.py::rob::9,"    def rob(self, nums: List[int]) -> int:
        N = len(nums)
        dp = [[0, 0] for _ in range(N)]
        dp[0][0] = nums[0]
        
        for i in range(1, N):
            dp[i][0] = nums[i]+dp[i-1][1]
            dp[i][1] = max(dp[i-1])
        return max(dp[-1])",data\repos\leetcode-python\problems\python3\house-robber.py,rob,94
4166,implement-trie-prefix-tree.py::insert::6,"    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            if c not in node: node[c] = {}
            node = node[c]
        node['.'] = {} #'.' means the end of the word",data\repos\leetcode-python\problems\python3\implement-trie-prefix-tree.py,insert,56
4167,implement-trie-prefix-tree.py::search::14,"    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            if c not in node: return False
            node = node[c]
        return '.' in node",data\repos\leetcode-python\problems\python3\implement-trie-prefix-tree.py,search,45
4168,implement-trie-prefix-tree.py::startsWith::21,"    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            if c not in node: return False
            node = node[c]
        return True",data\repos\leetcode-python\problems\python3\implement-trie-prefix-tree.py,startsWith,44
4169,insert-interval.py::insert::2,"    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        ans = []
        i = 0
        
        #add intervals before newInterval
        while i<len(intervals) and intervals[i][1]<newInterval[0]:
            ans.append(intervals[i])
            i += 1
        
        #add newInterval and merge the overlapped
        ans.append(newInterval)
        while i<len(intervals) and intervals[i][0]<=ans[-1][1]:
            ans[-1][0] = min(ans[-1][0], intervals[i][0])
            ans[-1][1] = max(ans[-1][1], intervals[i][1])
            i += 1
        
        #add intervals after newInterval
        while i<len(intervals):
            ans.append(intervals[i])
            i += 1
            
        return ans",data\repos\leetcode-python\problems\python3\insert-interval.py,insert,184
4170,interleaving-string.py::isInterleave::2,"    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        def dfs(i, j):
            if (i, j) in history: return False
            if i+j==len(s3): return True
            if i<len(s1) and s3[i+j]==s1[i] and dfs(i+1, j): return True
            if j<len(s2) and s3[i+j]==s2[j] and dfs(i, j+1): return True
            history.add((i, j))
            return False
        
        if len(s1)+len(s2)!=len(s3): return False
        history = set() #store the failed cases
        return dfs(0, 0)",data\repos\leetcode-python\problems\python3\interleaving-string.py,isInterleave,162
4171,interleaving-string.py::dfs::3,"        def dfs(i, j):
            if (i, j) in history: return False
            if i+j==len(s3): return True
            if i<len(s1) and s3[i+j]==s1[i] and dfs(i+1, j): return True
            if j<len(s2) and s3[i+j]==s2[j] and dfs(i, j+1): return True
            history.add((i, j))
            return False",data\repos\leetcode-python\problems\python3\interleaving-string.py,dfs,99
4172,invert-binary-tree.py::invertTree::7,"    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: return root
        left = root.left
        right = root.right
        root.left = self.invertTree(right)
        root.right = self.invertTree(left)
        return root",data\repos\leetcode-python\problems\python3\invert-binary-tree.py,invertTree,60
4173,invert-binary-tree.py::invertTree::22,"    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: return root
        q = collections.deque([root])
        
        while q:
            node = q.popleft()
            left = node.left
            right = node.right
            node.right = left
            node.left = right
            
            if node.left: q.append(node.left)
            if node.right: q.append(node.right)
        
        return root",data\repos\leetcode-python\problems\python3\invert-binary-tree.py,invertTree,94
4174,jump-game-ii.py::jump::9,"    def jump(self, nums: List[int]) -> int:
        l = r = 0
        steps = 0
        
        while r<len(nums)-1:
            farest = float('-inf')
            for i in range(l, r+1):
                farest = max(farest, i+nums[i])
            
            l = r+1
            r = farest
            steps += 1
            
        return steps",data\repos\leetcode-python\problems\python3\jump-game-ii.py,jump,90
4175,jump-game.py::canJump::2,"    def canJump(self, nums: List[int]) -> bool:
        maxIndex = 0
        
        for i, num in enumerate(nums):
            if maxIndex<i:
                return False
            maxIndex = max(maxIndex, i+num)
            
        return True",data\repos\leetcode-python\problems\python3\jump-game.py,canJump,56
4176,k-closest-points-to-origin.py::kClosest::2,"    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        h = []
        
        for x, y in points:
            dis = (x**2+y**2)**0.5
            heapq.heappush(h, (-dis, x, y))
            if len(h)>k: heapq.heappop(h)
        
        return [(x, y) for dis, x, y in h]",data\repos\leetcode-python\problems\python3\k-closest-points-to-origin.py,kClosest,94
4177,koko-eating-bananas.py::minEatingSpeed::2,"    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def canFinish(k):
            timeNeeded = 0
            for pile in piles:
                timeNeeded += math.ceil(pile/k)
            return timeNeeded<=h
        
        kMin = 1
        kMax = max(piles)
        ans = kMax
        
        while kMin<=kMax:
            k = kMin + int((kMax-kMin)/2)
            if canFinish(k):
                ans = min(ans, k)
                kMax = k-1
            else:
                kMin = k+1
        
        return ans",data\repos\leetcode-python\problems\python3\koko-eating-bananas.py,minEatingSpeed,136
4178,koko-eating-bananas.py::canFinish::3,"        def canFinish(k):
            timeNeeded = 0
            for pile in piles:
                timeNeeded += math.ceil(pile/k)
            return timeNeeded<=h",data\repos\leetcode-python\problems\python3\koko-eating-bananas.py,canFinish,35
4179,kth-largest-element-in-a-stream.py::add::11,"    def add(self, val: int) -> int:
        heapq.heappush(self.nums, val)
        if len(self.nums)>self.k: heapq.heappop(self.nums)
        return self.nums[0]",data\repos\leetcode-python\problems\python3\kth-largest-element-in-a-stream.py,add,49
4180,kth-smallest-element-in-a-bst.py::kthSmallest::6,"    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        count = 0
        stack = []
        node = root
        
        while stack or node:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()
            
            count += 1
            if count==k: return node.val
            
            node = node.right
        return 0",data\repos\leetcode-python\problems\python3\kth-smallest-element-in-a-bst.py,kthSmallest,90
4181,largest-rectangle-in-histogram.py::largestRectangleArea::7,"    def largestRectangleArea(self, heights: List[int]) -> int:
        maxArea = 0
        stack = []
        
        heights.append(0) #dummy for the ending
        
        for i, h in enumerate(heights):
            start = i
            while stack and h<stack[-1][1]: #[0]
                j, h2 = stack.pop()
                maxArea = max(maxArea, h2*(i-j))
                start = j
            stack.append((start, h)) #[1]
        
        return maxArea",data\repos\leetcode-python\problems\python3\largest-rectangle-in-histogram.py,largestRectangleArea,113
4182,last-stone-weight.py::lastStoneWeight::2,"    def lastStoneWeight(self, stones: List[int]) -> int:
        stones = [-stone for stone in stones]
        heapq.heapify(stones)
        
        while len(stones)>=2:
            w1 = -heapq.heappop(stones)
            w2 = -heapq.heappop(stones)
            
            if w1-w2>0: heapq.heappush(stones, -(w1-w2))
        
        return -stones[0] if stones else 0",data\repos\leetcode-python\problems\python3\last-stone-weight.py,lastStoneWeight,103
4183,letter-combinations-of-a-phone-number.py::letterCombinations::6,"    def letterCombinations(self, digits: str) -> List[str]:
        def helper(i):
            if i==len(digits):
                ans.append(''.join(combination))
                return
            
            for c in mapping[digits[i]]:
                combination.append(c)
                helper(i+1)
                combination.pop()
        
        mapping = {'2': ('a', 'b', 'c'), '3': ('d', 'e', 'f'),
            '4': ('g', 'h', 'i'), '5': ('j', 'k', 'l'), '6': ('m', 'n', 'o'),
            '7': ('p', 'q', 'r', 's'), '8': ('t', 'u', 'v'), '9': ('w', 'x', 'y', 'z')}
        
        if not digits: return []
        ans = []
        combination = []
        helper(0)
        return ans",data\repos\leetcode-python\problems\python3\letter-combinations-of-a-phone-number.py,letterCombinations,195
4184,letter-combinations-of-a-phone-number.py::helper::7,"        def helper(i):
            if i==len(digits):
                ans.append(''.join(combination))
                return
            
            for c in mapping[digits[i]]:
                combination.append(c)
                helper(i+1)
                combination.pop()",data\repos\leetcode-python\problems\python3\letter-combinations-of-a-phone-number.py,helper,48
4185,linked-list-cycle.py::hasCycle::2,"    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head: return False
        
        slow = head
        fast = head
        
        while fast:
            slow = slow.next
            
            if not fast.next: return False
            fast = fast.next.next
            
            if slow==fast: return True
        
        return False",data\repos\leetcode-python\problems\python3\linked-list-cycle.py,hasCycle,71
4186,longest-common-subsequence.py::longestCommonSubsequence::2,"    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        #dp[i][j] := number of longest Common Subsequence with text2[:i] and text2[:j]
        
        N = len(text1)
        M = len(text2)
        
        dp = [[0]*(M+1) for _ in range(N+1)]
        
        for i in range(1, N+1):
            for j in range(1, M+1):
                if text1[i-1]==text2[j-1]:
                    dp[i][j] = dp[i-1][j-1]+1
                else:
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j])
        return dp[-1][-1]",data\repos\leetcode-python\problems\python3\longest-common-subsequence.py,longestCommonSubsequence,171
4187,longest-consecutive-sequence.py::longestConsecutive::2,"    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        ans = 0
        
        for num in nums:
            isStart = num-1 not in numSet
            if isStart:
                count = 0
                temp = num
                while temp in numSet:
                    count += 1
                    temp += 1
                ans = max(count, ans)
        return ans",data\repos\leetcode-python\problems\python3\longest-consecutive-sequence.py,longestConsecutive,92
4188,longest-increasing-path-in-a-matrix.py::longestIncreasingPath::6,"    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        def dfs(i0, j0):
            if (i0, j0) in memo: return memo[(i0, j0)]
            ans = 1
            
            for i, j in ((i0+1, j0), (i0-1, j0), (i0, j0+1),(i0, j0-1)):
                if i<0 or i>=N or j<0 or j>=M: continue
                if matrix[i][j]<=matrix[i0][j0]: continue
                ans = max(ans, 1+dfs(i, j))
            
            memo[(i0, j0)] = ans
            return ans
            
        N = len(matrix)
        M = len(matrix[0])
        memo = {}
        ans = 0
        for i in range(N):
            for j in range(M):
                ans = max(ans, dfs(i, j))
        return ans",data\repos\leetcode-python\problems\python3\longest-increasing-path-in-a-matrix.py,longestIncreasingPath,212
4189,longest-increasing-path-in-a-matrix.py::dfs::7,"        def dfs(i0, j0):
            if (i0, j0) in memo: return memo[(i0, j0)]
            ans = 1
            
            for i, j in ((i0+1, j0), (i0-1, j0), (i0, j0+1),(i0, j0-1)):
                if i<0 or i>=N or j<0 or j>=M: continue
                if matrix[i][j]<=matrix[i0][j0]: continue
                ans = max(ans, 1+dfs(i, j))
            
            memo[(i0, j0)] = ans
            return ans",data\repos\leetcode-python\problems\python3\longest-increasing-path-in-a-matrix.py,dfs,143
4190,longest-palindromic-substring.py::longestPalindrome::8,"    def longestPalindrome(self, s: str) -> str:
        ans = s[0]
        N = len(s)
        dp = [[False]*N for _ in range(N)]
        
        for i in range(N): dp[i][i] = True
        
        for l in range(2, N+1):
            for i in range(N):
                j = i+l-1
                if j>=N: continue
                dp[i][j] = s[i]==s[j] and (dp[i+1][j-1] or j-1<i+1)
                if dp[i][j]: ans = s[i:j+1]
        return ans",data\repos\leetcode-python\problems\python3\longest-palindromic-substring.py,longestPalindrome,140
4191,longest-palindromic-substring.py::longestPalindrome::29,"    def longestPalindrome(self, s: str) -> str:
        N = len(s)
        ans = s[0]
        
        for i in range(N):
            l, r = i, i
            while l>=0 and r<N and s[l]==s[r]:
                if r-l+1>len(ans): ans = s[l:r+1]
                l -= 1
                r += 1
            
            l, r = i, i+1
            while l>=0 and r<N and s[l]==s[r]:
                if r-l+1>len(ans): ans = s[l:r+1]
                l -= 1
                r += 1
        return ans",data\repos\leetcode-python\problems\python3\longest-palindromic-substring.py,longestPalindrome,147
4192,longest-repeating-character-replacement.py::characterReplacement::2,"    def characterReplacement(self, s: str, k: int) -> int:
        counter = collections.Counter()
        l = 0
        ans = 0
        
        for r in range(len(s)):
            counter[s[r]] += 1
            while (r-l+1)-max(counter.values()) > k:
                counter[s[l]] -= 1
                l += 1
            ans = max(ans, r-l+1)
        return ans",data\repos\leetcode-python\problems\python3\longest-repeating-character-replacement.py,characterReplacement,96
4193,longest-substring-without-repeating-char.py::lengthOfLongestSubstring::2,"    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = 0
        l = 0
        seen = set()
        
        for r in range(len(s)):
            while s[r] in seen:
                seen.remove(s[l])
                l += 1
            seen.add(s[r])
            ans = max(ans, r-l+1)
        
        return ans",data\repos\leetcode-python\problems\python3\longest-substring-without-repeating-char.py,lengthOfLongestSubstring,83
4194,lowest-common-ancestor-of-a-binary-search-tree.py::lowestCommonAncestor::7,"    def lowestCommonAncestor(self, node: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if q.val<=node.val<=p.val or p.val<=node.val<=q.val:
            return node
        elif q.val<node.val and p.val<node.val:
            return self.lowestCommonAncestor(node.left, p, q)
        elif node.val<q.val and node.val<p.val:
            return self.lowestCommonAncestor(node.right, p, q)",data\repos\leetcode-python\problems\python3\lowest-common-ancestor-of-a-binary-search-tree.py,lowestCommonAncestor,108
4195,lowest-common-ancestor-of-a-binary-search-tree.py::lowestCommonAncestor::22,"    def lowestCommonAncestor(self, node: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while not (q.val<=node.val<=p.val or p.val<=node.val<=q.val):
            if q.val<node.val and p.val<node.val:
                node = node.left
            elif node.val<q.val and node.val<p.val:
                node = node.right
        return node",data\repos\leetcode-python\problems\python3\lowest-common-ancestor-of-a-binary-search-tree.py,lowestCommonAncestor,91
4196,lru-cache.py::promote::22,"    def promote(self, node): #[1]
        #set the node next to head
        temp = self.head.next
        node.next = temp
        temp.prev = node
        self.head.next = node
        node.prev = self.head",data\repos\leetcode-python\problems\python3\lru-cache.py,promote,51
4197,lru-cache.py::get::30,"    def get(self, key: int) -> int:
        if key in self.dic:
            node = self.dic[key]
            self.remove(node)
            self.promote(node)
            return node.val
        return -1",data\repos\leetcode-python\problems\python3\lru-cache.py,get,48
4198,lru-cache.py::put::38,"    def put(self, key: int, value: int) -> None:
        if key in self.dic:
            self.remove(self.dic[key])
        node = Node(key, value)
        self.promote(node)
        self.dic[key] = node
        
        if len(self.dic)>self.capacity: #[2]
            del self.dic[self.tail.prev.key]
            self.remove(self.tail.prev)",data\repos\leetcode-python\problems\python3\lru-cache.py,put,85
4199,max-area-of-island.py::maxAreaOfIsland::2,"    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        def dfs(i, j) -> int:
            if i<0 or j<0 or i>=MAX_ROW or j>=MAX_COL: return 0
            if grid[i][j]==0 or grid[i][j]==2: return 0
            
            grid[i][j] = 2 #mark as visited
            
            area = 1
            area += dfs(i+1, j)
            area += dfs(i-1, j)
            area += dfs(i, j+1)
            area += dfs(i, j-1)
            return area
            
        ans = 0
        MAX_ROW = len(grid)
        MAX_COL = len(grid[0])
        
        for i in range(MAX_ROW):
            for j in range(MAX_COL):
                ans = max(ans, dfs(i, j))
        return ans",data\repos\leetcode-python\problems\python3\max-area-of-island.py,maxAreaOfIsland,189
4200,max-area-of-island.py::dfs::3,"        def dfs(i, j) -> int:
            if i<0 or j<0 or i>=MAX_ROW or j>=MAX_COL: return 0
            if grid[i][j]==0 or grid[i][j]==2: return 0
            
            grid[i][j] = 2 #mark as visited
            
            area = 1
            area += dfs(i+1, j)
            area += dfs(i-1, j)
            area += dfs(i, j+1)
            area += dfs(i, j-1)
            return area",data\repos\leetcode-python\problems\python3\max-area-of-island.py,dfs,117
4201,maximum-depth-of-binary-tree.py::maxDepth::6,"    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root: return 0
        return 1+max(self.maxDepth(root.left), self.maxDepth(root.right))",data\repos\leetcode-python\problems\python3\maximum-depth-of-binary-tree.py,maxDepth,42
4202,maximum-product-subarray.py::maxProduct::9,"    def maxProduct(self, nums: List[int]) -> int:
        N = len(nums)
        dp = [[1, 1] for _ in range(N+1)]
        ans = float('-inf')
        
        for i in range(1, N+1):
            dp[i][0] = dp[i][1] = nums[i-1]
            
            if nums[i-1]>0:
                dp[i][0] = max(dp[i][0], nums[i-1]*dp[i-1][0])
                dp[i][1] = min(dp[i][1], nums[i-1]*dp[i-1][1])
            else:
                dp[i][0] = max(dp[i][0], nums[i-1]*dp[i-1][1])
                dp[i][1] = min(dp[i][1], nums[i-1]*dp[i-1][0])
            ans = max(ans, dp[i][0])
        
        return ans",data\repos\leetcode-python\problems\python3\maximum-product-subarray.py,maxProduct,203
4203,maximum-subarray.py::maxSubArray::9,"    def maxSubArray(self, nums: List[int]) -> int:
        ans = float('-inf')
        currSum = 0
        
        for num in nums:
            if currSum<0: currSum = 0
            currSum += num
            ans = max(ans, currSum)
        return ans",data\repos\leetcode-python\problems\python3\maximum-subarray.py,maxSubArray,66
4204,median-of-two-sorted-arrays.py::findMedianSortedArrays::15,"    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:
        if len(A)>len(B): A, B = B, A
        
        total = len(A)+len(B)
        half = total//2
        l = 0
        r = len(A)-1
        
        while True:
            i = l + (r-l)//2
            j = half-(i+1)-1
            
            Aleft = A[i] if i>=0 else float('-inf')
            Aright = A[i+1] if i+1<len(A) else float('inf')
            Bleft = B[j] if j>=0 else float('-inf')
            Bright = B[j+1] if j+1<len(B) else float('inf')
            
            if Aleft<=Bright and Bleft<=Aright:
                if total%2==0:
                    return (max(Aleft, Bleft)+min(Aright, Bright))/2
                else:
                    return min(Aright, Bright)
            elif Aleft>Bright:
                r = i-1
            else:
                l = i+1",data\repos\leetcode-python\problems\python3\median-of-two-sorted-arrays.py,findMedianSortedArrays,240
4205,meeting-rooms-ii.py::minMeetingRooms::2,"    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        h = []
        ans = 0
        
        for s, e in intervals:
            while h and s>=h[0][0]:
                heapq.heappop(h)
            heapq.heappush(h, (e, s))
            ans = max(ans, len(h))
        return ans",data\repos\leetcode-python\problems\python3\meeting-rooms-ii.py,minMeetingRooms,81
4206,meeting-rooms.py::canAttendMeetings::2,"    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals.sort()
        lastEnd = float('-inf')
        for s, e in intervals:
            if lastEnd>s:
                return False
            else:
                lastEnd = e
        return True",data\repos\leetcode-python\problems\python3\meeting-rooms.py,canAttendMeetings,59
4207,merge-intervals.py::merge::6,"    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        ans = []
        intervals.sort()
        
        for s, e in intervals:
            if not ans:
                ans.append([s, e])
            elif ans[-1][1]>=s:
                ans[-1][1] = max(ans[-1][1], e)
            else:
                ans.append([s, e])
        return ans",data\repos\leetcode-python\problems\python3\merge-intervals.py,merge,87
4208,merge-triplets-to-form-target-triplet.py::mergeTriplets::6,"    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        okIndex = set()
        
        for a, b, c in triplets:
            if a>target[0] or b>target[1] or c>target[2]: continue
            if a==target[0]: okIndex.add(0)
            if b==target[1]: okIndex.add(1)
            if c==target[2]: okIndex.add(2)
        
        return len(okIndex)==3",data\repos\leetcode-python\problems\python3\merge-triplets-to-form-target-triplet.py,mergeTriplets,114
4209,merge-two-sorted-lists.py::mergeTwoLists::2,"    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        head = ListNode() #dummy
        node = head
        while list1 and list2:
            if list1.val<list2.val:
                node.next = list1
                list1 = list1.next
            else:
                node.next = list2
                list2 = list2.next
            node = node.next
        
        node.next = list1 or list2
        return head.next",data\repos\leetcode-python\problems\python3\merge-two-sorted-lists.py,mergeTwoLists,110
4210,min-cost-climbing-stairs.py::minCostClimbingStairs::8,"    def minCostClimbingStairs(self, cost: List[int]) -> int:
        N = len(cost)
        dp = [float('inf')]*(N+1)
        dp[0] = 0
        dp[1] = 0
        
        for i in range(2, len(dp)):
            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
        return dp[-1]",data\repos\leetcode-python\problems\python3\min-cost-climbing-stairs.py,minCostClimbingStairs,99
4211,min-cost-to-connect-all-points.py::minCostConnectPoints::2,"    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        ans = 0
        visited = set()
        adj = collections.defaultdict(list)
        N = len(points)
        
        #build adjacency list
        for i in range(N):
            x0, y0 = points[i]
            for j in range(i+1, N):
                x1, y1 = points[j]
                dis = abs(x0-x1)+abs(y0-y1)
                adj[(x0, y0)].append((dis, x1, y1))
                adj[(x1, y1)].append((dis, x0, y0))
        
        h = [(0, points[0][0], points[0][1])] #min heap
        while len(visited)<N:
            dis, x, y = heapq.heappop(h)
            
            if (x, y) in visited: continue
            visited.add((x, y))
            ans += dis
            
            for dis1, x1, y1 in adj[(x, y)]:
                if (x1, y1) in visited: continue
                heapq.heappush(h, (dis1, x1, y1))
        return ans",data\repos\leetcode-python\problems\python3\min-cost-to-connect-all-points.py,minCostConnectPoints,262
4212,min-stack.py::push::11,"    def push(self, val: int) -> None:
        self.stack.append(val)
        self.minStack.append(val if (not self.minStack or val<self.minStack[-1]) else self.minStack[-1])",data\repos\leetcode-python\problems\python3\min-stack.py,push,46
4213,minimum-interval-to-include-each-query.py::minInterval::2,"    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        ans = [-1]*len(queries)
        queries = sorted([(query, i) for i, query in enumerate(queries)])
        intervals.sort()
        h = []
        
        itervalIndex = 0
        for query, queryIndex in queries:
            #push all intervals that include 'query' to the min heap
            while itervalIndex<len(intervals) and intervals[itervalIndex][0]<=query:
                left = intervals[itervalIndex][0]
                right = intervals[itervalIndex][1]
                size = right-left+1
                heapq.heappush(h, (size, right))
                itervalIndex += 1
            
            #pop all intervals that not includes 'query' out of the min heap
            while h and h[0][1]<query:
                heapq.heappop(h)
                
            if h: ans[queryIndex] = h[0][0]
        return ans",data\repos\leetcode-python\problems\python3\minimum-interval-to-include-each-query.py,minInterval,213
4214,minimum-window-substring.py::minWindow::2,"    def minWindow(self, s: str, t: str) -> str:
        if len(t)>len(s): return """"
        
        ans = """"
        counter1 = collections.Counter(t)
        charSet = set(t)
        counter2 = collections.Counter() #sliding window in string s, index between l and r
        charSet2 = set(s)
        matchCount = 0 #count of char in the sliding window that counts are larger than the char count in t.
        
        l = 0
        for r in range(len(s)):
            counter2[s[r]] += 1
            
            if s[r] in charSet and counter1[s[r]]==counter2[s[r]]: matchCount += 1
                
            while l<len(s) and (s[l] not in charSet or counter2[s[l]]>counter1[s[l]]):
                counter2[s[l]] -= 1
                l += 1
                
            if matchCount==len(charSet) and (ans=="""" or r-l+1<len(ans)):
                ans = s[l:r+1]
                
        return ans",data\repos\leetcode-python\problems\python3\minimum-window-substring.py,minWindow,232
4215,missing-number.py::missingNumber::2,"    def missingNumber(self, nums: List[int]) -> int:
        N = len(nums)
        ans = 0
        
        for n in range(N+1):
            ans ^= n
        
        for n in nums:
            ans ^= n
        
        return ans",data\repos\leetcode-python\problems\python3\missing-number.py,missingNumber,54
4216,multiply-strings.py::multiply::2,"    def multiply(self, num1: str, num2: str) -> str:
        if num1=='0' or num2=='0': return '0'
        M, N = len(num1), len(num2)
        temp = [0]*(M+N+1)

        num1, num2 = num1[::-1], num2[::-1]
        for i in range(M):
            for j in range(N):
                digits = int(num1[i])*int(num2[j])
                temp[i+j] += digits
                temp[i+j+1] += temp[i+j]//10
                temp[i+j] = temp[i+j]%10
        
        ans = ''
        temp = temp[::-1]
        isLeadingZero = True
        for d in temp:
            if d!=0 or not isLeadingZero:
                isLeadingZero = False
                ans += str(d)
        return ans",data\repos\leetcode-python\problems\python3\multiply-strings.py,multiply,189
4217,n-queens.py::solveNQueens::2,"    def solveNQueens(self, n: int) -> List[List[str]]:
        def helper(row: int):
            if row==n:
                ans.append(convertFormat(queenCols))
                return
            
            for col in range(n):
                posDiag = row+col
                negDiag = row-col
                
                if col in colUsed or posDiag in posDiagUsed or negDiag in negDiagUsed: continue
                
                queenCols.append(col)
                colUsed.add(col)
                posDiagUsed.add(posDiag)
                negDiagUsed.add(negDiag)
                
                helper(row+1)
                
                queenCols.pop()
                colUsed.remove(col)
                posDiagUsed.remove(posDiag)
                negDiagUsed.remove(negDiag)
        
        def convertFormat(queenCols: List[int]) -> List[str]:
            output = []
            for col in queenCols:
                row = ''
                for i in range(n):
                    if i==col:
                        row += 'Q'
                    else:
                        row += '.'
                output.append(row)
            return output
            
        ans = []
        queenCols = []
        colUsed = set()
        posDiagUsed = set()
        negDiagUsed = set()
        
        helper(0)
        return ans",data\repos\leetcode-python\problems\python3\n-queens.py,solveNQueens,273
4218,n-queens.py::helper::3,"        def helper(row: int):
            if row==n:
                ans.append(convertFormat(queenCols))
                return
            
            for col in range(n):
                posDiag = row+col
                negDiag = row-col
                
                if col in colUsed or posDiag in posDiagUsed or negDiag in negDiagUsed: continue
                
                queenCols.append(col)
                colUsed.add(col)
                posDiagUsed.add(posDiag)
                negDiagUsed.add(negDiag)
                
                helper(row+1)
                
                queenCols.pop()
                colUsed.remove(col)
                posDiagUsed.remove(posDiag)
                negDiagUsed.remove(negDiag)",data\repos\leetcode-python\problems\python3\n-queens.py,helper,149
4219,n-queens.py::convertFormat::26,"        def convertFormat(queenCols: List[int]) -> List[str]:
            output = []
            for col in queenCols:
                row = ''
                for i in range(n):
                    if i==col:
                        row += 'Q'
                    else:
                        row += '.'
                output.append(row)
            return output",data\repos\leetcode-python\problems\python3\n-queens.py,convertFormat,65
4220,network-delay-time.py::networkDelayTime::2,"    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        ans = 0
        adj = collections.defaultdict(list)
        h = []
        visited = set()
        
        for u, v, w in times:
            adj[u].append((v, w))
            
        heapq.heappush(h, (0, k))
        while h:
            timeNeededToGetHere, node = heapq.heappop(h)
            
            if node in visited: continue
            visited.add(node)
            ans = max(ans, timeNeededToGetHere)
            
            for nei, time in adj[node]:
                if nei in visited: continue
                heapq.heappush(h, (time+timeNeededToGetHere, nei))
        
        return ans if len(visited)==n else -1",data\repos\leetcode-python\problems\python3\network-delay-time.py,networkDelayTime,175
4221,non-overlapping-intervals.py::eraseOverlapIntervals::5,"    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        
        ans = 0
        prevEnd = intervals[0][1]
        
        for s, e in intervals[1:]:
            if s>=prevEnd:
                prevEnd = e
            else:
                ans += 1
                prevEnd = min(prevEnd, e)
        return ans",data\repos\leetcode-python\problems\python3\non-overlapping-intervals.py,eraseOverlapIntervals,84
4222,number-of-1-bits.py::hammingWeight::5,"    def hammingWeight(self, n: int) -> int:
        ans = 0
        while n>0:
            n = n&(n-1)
            ans += 1
        return ans",data\repos\leetcode-python\problems\python3\number-of-1-bits.py,hammingWeight,44
4223,number-of-connected-components-in-an-undirected-graph.py::countComponents::2,"    def countComponents(self, N: int, edges: List[List[int]]) -> int:
        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            if p1==p2:
                return
            elif p1<p2:
                parents[p2] = p1
            else:
                parents[p1] = p2
            
        def find(n):
            p = parents[n]
            while p!=parents[p]: p = find(p)
            parents[n] = p
            return p
        
        parents = {n:n for n in range(N)}
        for n1, n2 in edges: union(n1, n2)
        
        groups = set()
        for n in range(N): groups.add(find(n))
            
        return len(groups)",data\repos\leetcode-python\problems\python3\number-of-connected-components-in-an-undirected-graph.py,countComponents,170
4224,number-of-connected-components-in-an-undirected-graph.py::union::3,"        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            if p1==p2:
                return
            elif p1<p2:
                parents[p2] = p1
            else:
                parents[p1] = p2",data\repos\leetcode-python\problems\python3\number-of-connected-components-in-an-undirected-graph.py,union,63
4225,number-of-connected-components-in-an-undirected-graph.py::find::13,"        def find(n):
            p = parents[n]
            while p!=parents[p]: p = find(p)
            parents[n] = p
            return p",data\repos\leetcode-python\problems\python3\number-of-connected-components-in-an-undirected-graph.py,find,33
4226,number-of-islands.py::numIslands::2,"    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(i, j):
            if i<0 or j<0 or i>=MAX_ROWS or j>=MAX_COLS: return
            if grid[i][j]!='1': return
            
            grid[i][j] = '2'
            dfs(i+1, j)
            dfs(i-1, j)
            dfs(i, j+1)
            dfs(i, j-1)
        
        count = 0
        MAX_ROWS = len(grid)
        MAX_COLS = len(grid[0])
        
        for i in range(MAX_ROWS):
            for j in range(MAX_COLS):
                if grid[i][j]=='1':
                    dfs(i, j)
                    count += 1
        return count",data\repos\leetcode-python\problems\python3\number-of-islands.py,numIslands,162
4227,number-of-islands.py::dfs::3,"        def dfs(i, j):
            if i<0 or j<0 or i>=MAX_ROWS or j>=MAX_COLS: return
            if grid[i][j]!='1': return
            
            grid[i][j] = '2'
            dfs(i+1, j)
            dfs(i-1, j)
            dfs(i, j+1)
            dfs(i, j-1)",data\repos\leetcode-python\problems\python3\number-of-islands.py,dfs,82
4228,pacific-atlantic-water-flow.py::pacificAtlantic::2,"    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        def bfs(q, ocian):
            while q:
                i0, j0 = q.popleft()
                if (i0, j0) in ocian: continue
                ocian.add((i0, j0))
                
                for i, j in ((i0+1, j0), (i0-1, j0), (i0, j0+1), (i0, j0-1)):
                    if i<0 or j<0 or i>=MAX_ROW or j>=MAX_COL: continue
                    if heights[i][j]>=heights[i0][j0]: q.append((i, j))
                    
        MAX_ROW = len(heights)
        MAX_COL = len(heights[0])
        
        #add the top and left to q1
        pacific = set()
        q1 = collections.deque()
        for j in range(MAX_COL): q1.append((0, j))
        for i in range(MAX_ROW): q1.append((i, 0))
            
        #add botton and right to q2
        atlantic = set()
        q2 = collections.deque()
        for j in range(MAX_COL): q2.append((MAX_ROW-1, j))
        for i in range(MAX_ROW): q2.append((i, MAX_COL-1))
            
        bfs(q1, pacific)
        bfs(q2, atlantic)
        return pacific.intersection(atlantic)",data\repos\leetcode-python\problems\python3\pacific-atlantic-water-flow.py,pacificAtlantic,322
4229,pacific-atlantic-water-flow.py::bfs::3,"        def bfs(q, ocian):
            while q:
                i0, j0 = q.popleft()
                if (i0, j0) in ocian: continue
                ocian.add((i0, j0))
                
                for i, j in ((i0+1, j0), (i0-1, j0), (i0, j0+1), (i0, j0-1)):
                    if i<0 or j<0 or i>=MAX_ROW or j>=MAX_COL: continue
                    if heights[i][j]>=heights[i0][j0]: q.append((i, j))",data\repos\leetcode-python\problems\python3\pacific-atlantic-water-flow.py,bfs,136
4230,palindrome-partitioning.py::partition::8,"    def partition(self, s: str) -> List[List[str]]:
        def helper(i):
            if i>=len(s):
                ans.append(partition.copy())
                return
            
            for j in range(i, len(s)):
                if isPalindrome(i, j):
                    partition.append(s[i:j+1])
                    helper(j+1)
                    partition.pop()

        def isPalindrome(i, j):
            while i<=j:
                if s[i]!=s[j]: return False
                i += 1
                j -= 1
            return True
                
        ans = []
        partition = []
        helper(0)
        return ans",data\repos\leetcode-python\problems\python3\palindrome-partitioning.py,partition,130
4231,palindrome-partitioning.py::partition::42,"    def partition(self, s: str) -> List[List[str]]:
        def helper(i):
            if i>=N:
                ans.append(partition.copy())
                return
            
            for j in range(i, N):
                if isPalindrome(i, j):
                    partition.append(s[i:j+1])
                    helper(j+1)
                    partition.pop()

        def isPalindrome(i, j):
            dp[i][j] = i==j or (j-i==1 and s[i]==s[j]) or (s[i]==s[j] and dp[i+1][j-1]) #len==1 palindrome or len==2 palindrome or len>=3 palindrome
            return dp[i][j]
        
        N = len(s)
        ans = []
        partition = []
        dp = [[False]*N for _ in range(N)]

        helper(0)
        return ans",data\repos\leetcode-python\problems\python3\palindrome-partitioning.py,partition,179
4232,palindrome-partitioning.py::helper::9,"        def helper(i):
            if i>=len(s):
                ans.append(partition.copy())
                return
            
            for j in range(i, len(s)):
                if isPalindrome(i, j):
                    partition.append(s[i:j+1])
                    helper(j+1)
                    partition.pop()",data\repos\leetcode-python\problems\python3\palindrome-partitioning.py,helper,59
4233,palindrome-partitioning.py::isPalindrome::20,"        def isPalindrome(i, j):
            while i<=j:
                if s[i]!=s[j]: return False
                i += 1
                j -= 1
            return True",data\repos\leetcode-python\problems\python3\palindrome-partitioning.py,isPalindrome,40
4234,palindrome-partitioning.py::helper::43,"        def helper(i):
            if i>=N:
                ans.append(partition.copy())
                return
            
            for j in range(i, N):
                if isPalindrome(i, j):
                    partition.append(s[i:j+1])
                    helper(j+1)
                    partition.pop()",data\repos\leetcode-python\problems\python3\palindrome-partitioning.py,helper,57
4235,palindrome-partitioning.py::isPalindrome::54,"        def isPalindrome(i, j):
            dp[i][j] = i==j or (j-i==1 and s[i]==s[j]) or (s[i]==s[j] and dp[i+1][j-1]) #len==1 palindrome or len==2 palindrome or len>=3 palindrome
            return dp[i][j]",data\repos\leetcode-python\problems\python3\palindrome-partitioning.py,isPalindrome,72
4236,palindromic-substrings.py::countSubstrings::2,"    def countSubstrings(self, s: str) -> int:
        def countPalindrome(l, r) -> int:
            count = 0
            while l>=0 and r<N and s[l]==s[r]:
                count += 1
                l -= 1
                r += 1
            return count
        
        N = len(s)
        ans = 0
        for i in range(N):
            ans += countPalindrome(i, i)
            ans += countPalindrome(i, i+1)
        return ans",data\repos\leetcode-python\problems\python3\palindromic-substrings.py,countSubstrings,110
4237,palindromic-substrings.py::countPalindrome::3,"        def countPalindrome(l, r) -> int:
            count = 0
            while l>=0 and r<N and s[l]==s[r]:
                count += 1
                l -= 1
                r += 1
            return count",data\repos\leetcode-python\problems\python3\palindromic-substrings.py,countPalindrome,53
4238,partition-equal-subset-sum.py::canPartition::6,"    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total%2!=0: return False
        
        target = total/2
        possibleSum = set()
        possibleSum.add(0)
        for num in nums:
            temp = set()
            for p in possibleSum:
                if p==target or p+num==target: return True
                temp.add(p)
                temp.add(p+num)
            possibleSum = temp
        return False",data\repos\leetcode-python\problems\python3\partition-equal-subset-sum.py,canPartition,105
4239,partition-labels.py::partitionLabels::11,"    def partitionLabels(self, s: str) -> List[int]:
        ans = []
        maxIndex = {}
        
        for i, c in enumerate(s):
            maxIndex[c] = i
        
        currMax = 0
        processedLength = 0
        for i, c in enumerate(s):
            currMax = max(currMax, maxIndex[c])
            if i==currMax:
                ans.append(i+1 - processedLength)
                processedLength += ans[-1]

        return ans",data\repos\leetcode-python\problems\python3\partition-labels.py,partitionLabels,104
4240,permutation-in-string.py::checkInclusion::2,"    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1)>len(s2): return False
        
        counter1 = collections.Counter(s1)
        counter2 = collections.Counter(s2[:len(s1)])
        matches = 0
        for c in 'abcdefghijklmnopqrstuvwxyz':
            if counter1[c]==counter2[c]: matches += 1
        if matches==26: return True
        
        l = 0
        for r in range(len(s1), len(s2)):
            counter2[s2[r]] += 1
            if counter1[s2[r]]==counter2[s2[r]]:
                matches += 1
            elif counter1[s2[r]]+1==counter2[s2[r]]:
                matches -= 1
            
            counter2[s2[l]] -= 1
            if counter1[s2[l]]==counter2[s2[l]]:
                matches += 1
            elif counter1[s2[l]]-1==counter2[s2[l]]:
                matches -= 1
            l += 1
            
            if matches==26: return True
        return False",data\repos\leetcode-python\problems\python3\permutation-in-string.py,checkInclusion,239
4241,permutations.py::permute::10,"    def permute(self, nums: List[int]) -> List[List[int]]:
        def helper():
            if len(permutation)==len(nums):
                ans.append(permutation.copy())
                return
            
            for num in nums:
                if num in used: continue
                used.add(num)
                permutation.append(num)
                helper()
                used.remove(num)
                permutation.pop()
        
        ans = []
        permutation = []
        used = set()
        helper()
        return ans",data\repos\leetcode-python\problems\python3\permutations.py,permute,95
4242,permutations.py::helper::11,"        def helper():
            if len(permutation)==len(nums):
                ans.append(permutation.copy())
                return
            
            for num in nums:
                if num in used: continue
                used.add(num)
                permutation.append(num)
                helper()
                used.remove(num)
                permutation.pop()",data\repos\leetcode-python\problems\python3\permutations.py,helper,59
4243,plus-one.py::plusOne::2,"    def plusOne(self, digits: List[int]) -> List[int]:
        i = len(digits)-1
        needAdditionDigit = True

        while i>=0 and needAdditionDigit:
            if digits[i]==9:
                digits[i] = 0
                i -= 1
                needAdditionDigit = True
            else:
                digits[i] += 1
                needAdditionDigit = False
        if needAdditionDigit: digits.insert(0, 1)
        return digits",data\repos\leetcode-python\problems\python3\plus-one.py,plusOne,108
4244,powx-n.py::myPow::2,"    def myPow(self, x: float, k: int) -> float:
        if k<0: return 1/self.myPow(x, -k)

        if k==0:
            return 1
        elif k==1:
            return x
        elif k%2==0:
            half = self.myPow(x, k//2)
            return half * half
        else:
            half = self.myPow(x, (k-1)//2) 
            return half * half * x",data\repos\leetcode-python\problems\python3\powx-n.py,myPow,107
4245,product-of-array-except-self.py::productExceptSelf::2,"    def productExceptSelf(self, nums: List[int]) -> List[int]:
        #left[i] := product of all nums left of nums[i] (not include nums[i])
        left = [1]
        temp = 1
        for num in nums:
            temp *= num
            left.append(temp)
        
        #right[i] := product of all nums right of nums[i] (not include nums[i])
        right = []
        temp = 1
        for num in reversed(nums):
            temp *= num
            right.append(temp)
        right.reverse()
        right.append(1)
        right = right[1:]
        
        ans = []
        for i in range(len(nums)):
            ans.append(left[i]*right[i])
        return ans",data\repos\leetcode-python\problems\python3\product-of-array-except-self.py,productExceptSelf,156
4246,product-of-array-except-self.py::productExceptSelf::27,"    def productExceptSelf(self, nums: List[int]) -> List[int]:
        N = len(nums)
        ans = [0]*N
        
        #generate ""left""
        ans[0] = 1
        for i in range(1, N):
            ans[i] = ans[i-1]*nums[i-1]
        
        #generate ""right""
        temp = 1
        for i in range(N-2, -1, -1):
            temp *= nums[i+1]
            ans[i] *= temp
        
        return ans",data\repos\leetcode-python\problems\python3\product-of-array-except-self.py,productExceptSelf,116
4247,reconstruct-itinerary.py::findItinerary::5,"    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        def dfs(start) -> bool:
            if len(ans)==len(tickets)+1: return True
            if start not in adj: return False
            
            temp = list(adj[start])
            for i, arr in enumerate(temp):
                adj[start].pop(i)
                ans.append(arr)
                if dfs(arr): return True
                adj[start].insert(i, arr)
                ans.pop()
            return False
        
        ans = ['JFK']
        adj = collections.defaultdict(list)
        
        tickets.sort()
        for des, arr in tickets:
            adj[des].append(arr)
        
        dfs('JFK')
        return ans",data\repos\leetcode-python\problems\python3\reconstruct-itinerary.py,findItinerary,148
4248,reconstruct-itinerary.py::dfs::6,"        def dfs(start) -> bool:
            if len(ans)==len(tickets)+1: return True
            if start not in adj: return False
            
            temp = list(adj[start])
            for i, arr in enumerate(temp):
                adj[start].pop(i)
                ans.append(arr)
                if dfs(arr): return True
                adj[start].insert(i, arr)
                ans.pop()
            return False",data\repos\leetcode-python\problems\python3\reconstruct-itinerary.py,dfs,84
4249,redundant-connection.py::findRedundantConnection::2,"    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2:
                return False #union failed, already united.
            elif p1<p2:
                roots[p2] = p1
            else:
                roots[p1] = p2
        
            return True #union success
        
        def find(n):
            if n not in roots:
                roots[n] = n
                return n
            
            p = roots[n]
            while p!=roots[p]:
                p = find(p)
            roots[n] = p
            return p
        
        roots = {}
        
        for n1, n2 in edges:
            if not union(n1, n2): return (n1, n2)
        
        return 'ERROR'",data\repos\leetcode-python\problems\python3\redundant-connection.py,findRedundantConnection,190
4250,redundant-connection.py::union::3,"        def union(n1, n2):
            p1 = find(n1)
            p2 = find(n2)
            
            if p1==p2:
                return False #union failed, already united.
            elif p1<p2:
                roots[p2] = p1
            else:
                roots[p1] = p2
        
            return True #union success",data\repos\leetcode-python\problems\python3\redundant-connection.py,union,78
4251,redundant-connection.py::find::16,"        def find(n):
            if n not in roots:
                roots[n] = n
                return n
            
            p = roots[n]
            while p!=roots[p]:
                p = find(p)
            roots[n] = p
            return p",data\repos\leetcode-python\problems\python3\redundant-connection.py,find,52
4252,regular-expression-matching.py::isMatch::2,"    def isMatch(self, s: str, p: str) -> bool:
        def dfs(i, j):
            if (i, j) in cache: return cache[(i, j)]
            if i>=M and j>=N: return True
            if j>=N: return False
            
            match = i<M and (s[i]==p[j] or p[j]=='.')
            
            if j+1<N and p[j+1]=='*':
                cache[(i, j)] = (match and dfs(i+1, j)) or dfs(i, j+2) #(use one or more p[j]) or (use zero p[j])
                return cache[(i, j)]
            
            if match:
                cache[(i, j)] = dfs(i+1, j+1)
                return cache[(i, j)]
            
            cache[(i, j)] = False
            return cache[(i, j)]
        
        cache = {}
        M = len(s)
        N = len(p)
        return dfs(0, 0)",data\repos\leetcode-python\problems\python3\regular-expression-matching.py,isMatch,221
4253,regular-expression-matching.py::dfs::3,"        def dfs(i, j):
            if (i, j) in cache: return cache[(i, j)]
            if i>=M and j>=N: return True
            if j>=N: return False
            
            match = i<M and (s[i]==p[j] or p[j]=='.')
            
            if j+1<N and p[j+1]=='*':
                cache[(i, j)] = (match and dfs(i+1, j)) or dfs(i, j+2) #(use one or more p[j]) or (use zero p[j])
                return cache[(i, j)]
            
            if match:
                cache[(i, j)] = dfs(i+1, j+1)
                return cache[(i, j)]
            
            cache[(i, j)] = False
            return cache[(i, j)]",data\repos\leetcode-python\problems\python3\regular-expression-matching.py,dfs,178
4254,remove-nth-node-from-end-of-list.py::removeNthFromEnd::3,"    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        #count the length of the linked list
        node = head
        count = 0
        while node:
            count += 1
            node = node.next
        

        node = head
        steps = count-n-1
        
        #steps==-1 means that we need to remove the first node
        if steps==-1: return head.next
        
        #traverse to the node before the node we wanted to remove
        while steps>0:
            node = node.next
            steps -= 1
        
        #remove ""node.next""
        node.next = node.next.next
        
        return head",data\repos\leetcode-python\problems\python3\remove-nth-node-from-end-of-list.py,removeNthFromEnd,151
4255,remove-nth-node-from-end-of-list.py::removeNthFromEnd::32,"    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head

        ahead = n+1
        fast = dummy
        slow = dummy
        
        while fast:
            fast = fast.next
            ahead -= 1
            if ahead<0: slow = slow.next
        
        slow.next = slow.next.next

        return dummy.next",data\repos\leetcode-python\problems\python3\remove-nth-node-from-end-of-list.py,removeNthFromEnd,91
4256,reorder-list.py::reorderList::2,"    def reorderList(self, head: Optional[ListNode]) -> None:
        #find the middle point
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        middle = slow.next

        #reverse the linked list after the middle point
        middle = self.reverseList(middle)

        #separate the linked list before the middle
        slow.next = None
        
        #merge two linked list
        node = head
        while middle and node:
            nextNode = node.next
            node.next = middle
            middle = middle.next
            node.next.next = nextNode
            node = nextNode
        return head",data\repos\leetcode-python\problems\python3\reorder-list.py,reorderList,149
4257,reorder-list.py::reverseList::27,"    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        node = head
        
        while node:
            nextNode = node.next
            node.next = pre
            if not nextNode: return node
            pre = node
            node = nextNode",data\repos\leetcode-python\problems\python3\reorder-list.py,reverseList,63
4258,reverse-bits.py::reverseBits::2,"    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            bit = (n >> i) & 1
            res = res | (bit << (31 - i))
        return res",data\repos\leetcode-python\problems\python3\reverse-bits.py,reverseBits,55
4259,reverse-integer.py::reverse::2,"    def reverse(self, x: int) -> int:
        MAX = 2**31-1
        MIN = -2**31
        ans = 0
        
        while x:
            digit = int(math.fmod(x, 10))
            x = int(x/10)
            
            if ans>MAX//10 or (ans==MAX//10 and digit>MAX%10): return 0
            if ans<MIN//10 or (ans==MIN//10 and digit<MIN%10): return 0
            
            ans = ans*10 + digit
            
        return ans",data\repos\leetcode-python\problems\python3\reverse-integer.py,reverse,123
4260,reverse-linked-list.py::reverseList::3,"    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next: return head
        temp = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return temp",data\repos\leetcode-python\problems\python3\reverse-linked-list.py,reverseList,54
4261,reverse-linked-list.py::reverseList::12,"    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        node = head
        
        while node:
            nextNode = node.next
            node.next = pre
            if not nextNode: return node
            pre = node
            node = nextNode",data\repos\leetcode-python\problems\python3\reverse-linked-list.py,reverseList,63
4262,rotate-image.py::rotate::2,"    def rotate(self, matrix: List[List[int]]) -> None:
        l, r = 0, len(matrix[0])-1
        
        while l<r:
            top = l
            bottom = r
            for i in range(r-l):
                topLeft = matrix[top][l+i]
                matrix[top][l+i] = matrix[bottom-i][l]
                matrix[bottom-i][l] = matrix[bottom][r-i]
                matrix[bottom][r-i] = matrix[top+i][r]
                matrix[top+i][r] = topLeft
            l += 1
            r -= 1",data\repos\leetcode-python\problems\python3\rotate-image.py,rotate,128
4263,rotting-oranges.py::orangesRotting::2,"    def orangesRotting(self, grid: List[List[int]]) -> int:
        time = 0
        rotten = set()
        aboutToRot = set()
        fresh = set()
        
        for i in range(len(grid)):
            for j in range((len(grid[0]))):
                if grid[i][j]==2:
                    rotten.add((i, j))
                elif grid[i][j]==1:
                    fresh.add((i, j))
        
        while rotten:
            i0, j0 = rotten.pop() #randomly get one
            grid[i0][j0] = 2
            
            for i, j in ((i0+1, j0), (i0-1, j0), (i0, j0+1), (i0, j0-1)):
                if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]): continue
                if (i, j) in rotten or (i, j) in aboutToRot: continue
                if (i, j) in fresh:
                    fresh.remove((i, j))
                    aboutToRot.add((i, j))
            
            if not rotten and not aboutToRot: break
            
            if not rotten:
                time += 1
                rotten = aboutToRot
                aboutToRot = set()
                
        if fresh: return -1
        
        return time",data\repos\leetcode-python\problems\python3\rotting-oranges.py,orangesRotting,294
4264,same-tree.py::isSameTree::6,"    def isSameTree(self, node1: Optional[TreeNode], node2: Optional[TreeNode]) -> bool:
        if not node1 and not node2:
            return True

        if (not node1 and node2) or (node1 and not node2):
            return False

        if node1.val!=node2.val:
            return False

        return self.isSameTree(node1.left, node2.left) and self.isSameTree(node1.right, node2.right)",data\repos\leetcode-python\problems\python3\same-tree.py,isSameTree,102
4265,search-a-2d-matrix.py::searchMatrix::2,"    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        N = len(matrix)
        M = len(matrix[0])
        
        l = 0
        r = N*M-1
        
        while l<=r:
            m = l + int((r-l)/2)
            
            i = int(m/M)
            j = m%M
            
            if matrix[i][j]<target:
                l = m+1
            elif matrix[i][j]>target:
                r = m-1
            else:
                return True
        
        return False",data\repos\leetcode-python\problems\python3\search-a-2d-matrix.py,searchMatrix,122
4266,serialize-and-deserialize-binary-tree.py::serialize::3,"    def serialize(self, root):
        if not root: return '#'
        return str(root.val)+','+self.serialize(root.left)+','+self.serialize(root.right)",data\repos\leetcode-python\problems\python3\serialize-and-deserialize-binary-tree.py,serialize,35
4267,serialize-and-deserialize-binary-tree.py::deserialize::8,"    def deserialize(self, data):
        def helper():
            if data[self.i]=='#':
                self.i += 1
                return None
            
            node = TreeNode(int(data[self.i]))
            self.i += 1
            node.left = helper()
            node.right = helper()
            return node
        
        data = data.split("","")
        self.i = 0
        return helper()",data\repos\leetcode-python\problems\python3\serialize-and-deserialize-binary-tree.py,deserialize,79
4268,serialize-and-deserialize-binary-tree.py::helper::9,"        def helper():
            if data[self.i]=='#':
                self.i += 1
                return None
            
            node = TreeNode(int(data[self.i]))
            self.i += 1
            node.left = helper()
            node.right = helper()
            return node",data\repos\leetcode-python\problems\python3\serialize-and-deserialize-binary-tree.py,helper,54
4269,set-matrix-zeroes.py::setZeroes::2,"    def setZeroes(self, matrix: List[List[int]]) -> None:
        M = len(matrix)
        N = len(matrix[0])
        firstRowZero = False
        
        for i in range(M):
            for j in range(N):
                if matrix[i][j]==0:
                    matrix[0][j] = 0                    
                    if i==0:
                        firstRowZero = True
                    else:
                        matrix[i][0] = 0
        
        for i in range(1, M):
            if matrix[i][0]==0:
                for j in range(N):
                    matrix[i][j] = 0
        
        for j in range(N):
            if matrix[0][j]==0:
                for i in range(M):
                    matrix[i][j] = 0
        
        if firstRowZero:
            for j in range(N):
                matrix[0][j] = 0",data\repos\leetcode-python\problems\python3\set-matrix-zeroes.py,setZeroes,190
4270,single-number.py::singleNumber::12,"    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for num in nums: ans ^= num
        return ans",data\repos\leetcode-python\problems\python3\single-number.py,singleNumber,33
4271,sliding-window-maximum.py::maxSlidingWindow::2,"    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        q = collections.deque()
        l = r = 0
        
        while r<len(nums):
            while q and nums[q[-1]]<nums[r]: q.pop()
            q.append(r)
            
            while q and q[0]<l: q.popleft()
            
            while r-l+1==k:
                ans.append(nums[q[0]])
                l += 1
            
            r += 1
        return ans",data\repos\leetcode-python\problems\python3\sliding-window-maximum.py,maxSlidingWindow,115
4272,spiral-matrix.py::spiralOrder::7,"    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        ans = []
        x0 = 0
        y0 = 0
        dx = len(matrix[0])-1
        dy = len(matrix)-1
        direction = 'right'
        isFirst = True
        
        ans.append(matrix[x0][y0])
        while True:
            if direction=='right':
                for x in range(x0+1, x0+dx+1):
                    ans.append(matrix[y0][x])
                x0 += dx
                direction = 'down'
                
                if isFirst:
                    isFirst = False
                else:
                    dx -= 1
                
                if dy==0: break
            
            elif direction=='left':
                for x in range(x0-1, x0-dx-1, -1):
                    ans.append(matrix[y0][x])
                x0 -= dx
                direction = 'up'
                dx -= 1
                if dy==0: break
            
            elif direction=='down':
                for y in range(y0+1, y0+dy+1):
                    ans.append(matrix[y][x0])
                y0 += dy
                direction = 'left'
                dy -= 1
                if dx==0: break
            
            elif direction=='up':
                for y in range(y0-1, y0-dy-1, -1):
                    ans.append(matrix[y][x0])
                y0 -= dy
                direction = 'right'
                dy -= 1
                if dx==0: break
        return ans",data\repos\leetcode-python\problems\python3\spiral-matrix.py,spiralOrder,331
4273,spiral-matrix.py::spiralOrder::65,"    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        left, right = 0, len(matrix[0])
        top, bottom = 0, len(matrix)

        while left < right and top < bottom:
            # get every i in the top row
            for i in range(left, right):
                res.append(matrix[top][i])
            top += 1
            # get every i in the right col
            for i in range(top, bottom):
                res.append(matrix[i][right - 1])
            right -= 1
            if not (left < right and top < bottom):
                break
            # get every i in the bottom row
            for i in range(right - 1, left - 1, -1):
                res.append(matrix[bottom - 1][i])
            bottom -= 1
            # get every i in the left col
            for i in range(bottom - 1, top - 1, -1):
                res.append(matrix[i][left])
            left += 1

        return res",data\repos\leetcode-python\problems\python3\spiral-matrix.py,spiralOrder,229
4274,subsets-ii.py::subsetsWithDup::6,"    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        def helper(i):
            if i==len(nums):
                ans.append(subset.copy())
                return
            
            subset.append(nums[i])
            helper(i+1)
            subset.pop()
            
            while i+1<len(nums) and nums[i]==nums[i+1]: i += 1
            helper(i+1)
            
        nums.sort()
        ans = []
        subset = []
        helper(0)
        return ans",data\repos\leetcode-python\problems\python3\subsets-ii.py,subsetsWithDup,105
4275,subsets-ii.py::helper::7,"        def helper(i):
            if i==len(nums):
                ans.append(subset.copy())
                return
            
            subset.append(nums[i])
            helper(i+1)
            subset.pop()
            
            while i+1<len(nums) and nums[i]==nums[i+1]: i += 1
            helper(i+1)",data\repos\leetcode-python\problems\python3\subsets-ii.py,helper,67
4276,subsets.py::subsets::6,"    def subsets(self, nums: List[int]) -> List[List[int]]:
        def helper(i):
            if not i<len(nums):
                ans.append(subset.copy())
                return
            
            subset.append(nums[i])
            helper(i+1)
            
            subset.pop()
            helper(i+1)
        
        ans = []
        subset = []
        
        helper(0)
        return ans",data\repos\leetcode-python\problems\python3\subsets.py,subsets,78
4277,subsets.py::helper::7,"        def helper(i):
            if not i<len(nums):
                ans.append(subset.copy())
                return
            
            subset.append(nums[i])
            helper(i+1)
            
            subset.pop()
            helper(i+1)",data\repos\leetcode-python\problems\python3\subsets.py,helper,45
4278,substring-with-concatenation-of-all-words.py::findSubstring::6,"    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        N = len(s)
        M = len(words)
        W = len(words[0])
        wordSet = set(words)
        ans = []
        counter = collections.Counter(words)
        
        for i in range(W): #[0]
            windowCounter = collections.Counter() #counter for the word in words
            notInWords = 0 #number of word not in the wordSet
            theSame = 0 #number of word with the same count with ""counter""
            j = i
            
            while j<N: #[1]
                word = s[j:j+W]
                if word in wordSet:
                    windowCounter[word] += 1
                    if windowCounter[word]==counter[word]:
                        theSame += 1
                    elif windowCounter[word]>counter[word]:
                        theSame -= 1
                else:
                    notInWords += 1
                    
                popStart = j-M*W
                if popStart>=0:
                    popWord = s[popStart:popStart+W]
                    if popWord in wordSet:
                        windowCounter[popWord] -= 1
                        if windowCounter[popWord]==counter[popWord]:
                            theSame += 1
                        elif windowCounter[popWord]<counter[popWord]:
                            theSame -= 1
                    else:
                        notInWords -= 1
                
                if theSame==len(wordSet) and notInWords==0: ans.append(popStart+W)
                j += W
                
        return ans",data\repos\leetcode-python\problems\python3\substring-with-concatenation-of-all-words.py,findSubstring,327
4279,subtree-of-another-tree.py::isSubtree::2,"    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if not root or not subRoot: return root==subRoot
        if self.isSame(root, subRoot): return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)",data\repos\leetcode-python\problems\python3\subtree-of-another-tree.py,isSubtree,74
4280,subtree-of-another-tree.py::isSame::7,"    def isSame(self, p, q):
        if not p or not q: return p==q
        if p.val!=q.val: return False
        return self.isSame(p.left, q.left) and self.isSame(p.right, q.right)",data\repos\leetcode-python\problems\python3\subtree-of-another-tree.py,isSame,55
4281,sum-of-two-integers.py::getSum::5,"    def getSum(self, a: int, b: int) -> int:
        ans = a^b
        carry = (a&b)<<1
        
        while carry!=0:
            ans, carry = ans^carry, (ans&carry)<<1
            
        return ans",data\repos\leetcode-python\problems\python3\sum-of-two-integers.py,getSum,59
4282,surrounded-regions.py::solve::6,"    def solve(self, board: List[List[str]]) -> None:
        def dfs(i0, j0):
            if i0<0 or j0<0 or i0>=MAX_ROW or j0>=MAX_COL: return
            if board[i0][j0]!='O': return
            if (i0, j0) in survived: return
            
            survived.add((i0, j0))
            dfs(i0+1, j0)
            dfs(i0-1, j0)
            dfs(i0, j0+1)
            dfs(i0, j0-1)
        
        
        MAX_ROW = len(board)
        MAX_COL = len(board[0])
        survived = set()
        
        for i in range(MAX_ROW):
            dfs(i, 0)
            dfs(i, MAX_COL-1)
        
        for j in range(MAX_COL):
            dfs(0, j)
            dfs(MAX_ROW-1, j)
        
        for i in range(MAX_ROW):
            for j in range(MAX_COL):
                board[i][j] = 'O' if (i, j) in survived else 'X'
        return board",data\repos\leetcode-python\problems\python3\surrounded-regions.py,solve,240
4283,surrounded-regions.py::dfs::7,"        def dfs(i0, j0):
            if i0<0 or j0<0 or i0>=MAX_ROW or j0>=MAX_COL: return
            if board[i0][j0]!='O': return
            if (i0, j0) in survived: return
            
            survived.add((i0, j0))
            dfs(i0+1, j0)
            dfs(i0-1, j0)
            dfs(i0, j0+1)
            dfs(i0, j0-1)",data\repos\leetcode-python\problems\python3\surrounded-regions.py,dfs,112
4284,swim-in-rising-water.py::swimInWater::6,"    def swimInWater(self, grid: List[List[int]]) -> int:
        ROWS = len(grid)
        COLS = len(grid[0])
        
        visited = set()
        h = [(grid[0][0], 0, 0)]
        
        while h:
            t, r0, c0 = heapq.heappop(h)
            
            if (r0, c0) in visited: continue
            visited.add((r0, c0))
            if r0==ROWS-1 and c0==COLS-1: return t
            
            for r, c in ((r0+1, c0), (r0-1, c0), (r0, c0+1), (r0, c0-1)):
                if r<0 or c<0 or r>=ROWS or c>=COLS: continue
                if (r, c) in visited: continue
                heapq.heappush(h, (max(t, grid[r][c]), r, c))",data\repos\leetcode-python\problems\python3\swim-in-rising-water.py,swimInWater,214
4285,target-sum.py::findTargetSumWays::6,"    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        def dfs(i, curr):
            #cache
            if (i, curr) in history:
                return history[(i, curr)]
            
            #ending condition
            if i==len(nums):
                if curr==target:
                    history[(i, curr)] = 1
                else:
                    history[(i, curr)] = 0
                return history[(i, curr)]
            
            history[(i, curr)] = dfs(i+1, curr+nums[i])+dfs(i+1, curr-nums[i])
            return history[(i, curr)]
        
        ans = 0
        history = {}
        return dfs(0, 0)",data\repos\leetcode-python\problems\python3\target-sum.py,findTargetSumWays,159
4286,target-sum.py::dfs::7,"        def dfs(i, curr):
            #cache
            if (i, curr) in history:
                return history[(i, curr)]
            
            #ending condition
            if i==len(nums):
                if curr==target:
                    history[(i, curr)] = 1
                else:
                    history[(i, curr)] = 0
                return history[(i, curr)]
            
            history[(i, curr)] = dfs(i+1, curr+nums[i])+dfs(i+1, curr-nums[i])
            return history[(i, curr)]",data\repos\leetcode-python\problems\python3\target-sum.py,dfs,118
4287,task-scheduler.py::leastInterval::2,"    def leastInterval(self, tasks: List[str], n: int) -> int:
        q = collections.deque()
        h = []
        time = 0
        
        counter = collections.Counter(tasks)
        for task in counter:
            heapq.heappush(h, (-counter[task], task))
        
        while h or q:
            if q and q[0][0]<=time:
                _, count, task = q.popleft()
                heapq.heappush(h, (-count, task))
            
            if h:
                count, task = heapq.heappop(h)
                count*=-1
                count -= 1
                if count>0: q.append((time+n+1, count, task))
            time += 1
        
        return time",data\repos\leetcode-python\problems\python3\task-scheduler.py,leastInterval,158
4288,time-based-key-value-store.py::set::6,"    def set(self, key: str, value: str, timestamp: int) -> None:
        self.data[key].append((timestamp, value))",data\repos\leetcode-python\problems\python3\time-based-key-value-store.py,set,31
4289,time-based-key-value-store.py::get::9,"    def get(self, key: str, timestamp: int) -> str:
        dataList = self.data[key]
        l = 0
        r = len(dataList)-1
        ans = ''
        
        while l<=r:
            m = l + int((r-l)/2)
            t = dataList[m][0]
            
            if t<timestamp:
                ans = dataList[m][1]
                l = m+1
            elif t>timestamp:
                r = m-1
            else:
                ans = dataList[m][1]
                break
        
        return ans",data\repos\leetcode-python\problems\python3\time-based-key-value-store.py,get,121
4290,top-k-frequent-elements.py::topKFrequent::3,"    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        bucket = collections.defaultdict(list)
        counter = collections.Counter(nums)
        ans = []
        
        for num in counter:
            bucket[counter[num]].append(num)
        
        tempCount = len(nums)
        while len(ans)<k:
            ans.extend(bucket[tempCount])
            tempCount -= 1
        
        return ans",data\repos\leetcode-python\problems\python3\top-k-frequent-elements.py,topKFrequent,86
4291,top-k-frequent-elements.py::topKFrequent::20,"    def topKFrequent(self, nums: List[int], K: int) -> List[int]:
        def quickSelect(freqs, s, e, K):
            i = s
            t = s
            j = e
            pivot = freqs[(s+e)//2][1]
            
            while t<=j:
                if freqs[t][1]<pivot:
                    freqs[i], freqs[t] = freqs[t], freqs[i]
                    i += 1
                    t +=1
                elif freqs[t][1]>pivot:
                    freqs[j], freqs[t] = freqs[t], freqs[j]
                    j -= 1
                else:
                    t += 1
            if e-j>=K:
                return quickSelect(freqs, j+1, e, K)
            elif e-(i-1)>=K:
                return pivot
            else:
                return quickSelect(freqs, s, i-1, K-(e-i+1))
                
        counts = collections.Counter(nums)
        freqs = [(num, counts[num]) for num in counts]
        ans = []
        
        KthLargestFreq = quickSelect(freqs, 0, len(freqs)-1, K)
        
        for num, freq in freqs:
            if freq>=KthLargestFreq:
                ans.append(num)
        return ans",data\repos\leetcode-python\problems\python3\top-k-frequent-elements.py,topKFrequent,289
4292,top-k-frequent-elements.py::quickSelect::21,"        def quickSelect(freqs, s, e, K):
            i = s
            t = s
            j = e
            pivot = freqs[(s+e)//2][1]
            
            while t<=j:
                if freqs[t][1]<pivot:
                    freqs[i], freqs[t] = freqs[t], freqs[i]
                    i += 1
                    t +=1
                elif freqs[t][1]>pivot:
                    freqs[j], freqs[t] = freqs[t], freqs[j]
                    j -= 1
                else:
                    t += 1
            if e-j>=K:
                return quickSelect(freqs, j+1, e, K)
            elif e-(i-1)>=K:
                return pivot
            else:
                return quickSelect(freqs, s, i-1, K-(e-i+1))",data\repos\leetcode-python\problems\python3\top-k-frequent-elements.py,quickSelect,190
4293,trapping-rain-water.py::trap::14,"    def trap(self, height: List[int]) -> int:
        ans = 0
        l = 0
        r = len(height)-1
        
        leftMax = float('-inf')
        rightMax = float('-inf')
        
        while l<=r:
            if leftMax<rightMax:
                if height[l]>=leftMax:
                    leftMax = height[l]
                else:
                    ans += leftMax-height[l]
                l += 1
            else:
                if height[r]>=rightMax:
                    rightMax = height[r]
                else:
                    ans += rightMax-height[r]
                r -= 1
        return ans",data\repos\leetcode-python\problems\python3\trapping-rain-water.py,trap,134
4294,two-sum-ii-input-array-is-sorted.py::twoSum::2,"    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i = 0
        j = len(numbers)-1
        
        while numbers[i]+numbers[j] != target:
            if numbers[i]+numbers[j] > target:
                j -= 1
            else:
                i += 1
        return (i+1, j+1)",data\repos\leetcode-python\problems\python3\two-sum-ii-input-array-is-sorted.py,twoSum,81
4295,two-sum.py::twoSum::2,"    def twoSum(self, nums: List[int], target: int) -> List[int]:
        #needed: {number required : counter part index}
        needed = {}
        for i, num in enumerate(nums):
            if num in needed:
                return (needed[num], i)
            needed[target-num] = i",data\repos\leetcode-python\problems\python3\two-sum.py,twoSum,65
4296,unique-paths.py::uniquePaths::2,"    def uniquePaths(self, m: int, n: int) -> int:
        m = m-1 #number of steps need to move down
        n = n-1 #number of steps need to move right
        
        #the total combination of m and n to sort will be (m+n)!
        #since all ""move down"" are consider the same, we need to remove the repeatition of it sorting: m!.
        #since all ""move right"" are consider the same, we need to remove the repeatition of it sorting: n!.
        #(m+n)!/m!n!
        
        return math.factorial(m+n)//(math.factorial(m)*math.factorial(n))",data\repos\leetcode-python\problems\python3\unique-paths.py,uniquePaths,148
4297,valid-anagram.py::isAnagram::2,"    def isAnagram(self, s: str, t: str) -> bool:
        counter = collections.Counter()
        
        for c in s:
            counter[c] += 1
        
        for c in t:
            if c not in counter:
                return False
            counter[c] -= 1
        
        for c in counter:
            if counter[c]>0:
                return False
        
        return True",data\repos\leetcode-python\problems\python3\valid-anagram.py,isAnagram,84
4298,valid-palindrome.py::isPalindrome::2,"    def isPalindrome(self, s: str) -> bool:
        i = 0
        j = len(s)-1
        
        while i<=j:
            while i<j and not s[i].isalnum(): i += 1
            while i<j and not s[j].isalnum(): j -= 1
            
            if s[i].lower()!=s[j].lower(): return False
            
            i += 1
            j -= 1
        
        return True",data\repos\leetcode-python\problems\python3\valid-palindrome.py,isPalindrome,97
4299,valid-parentheses.py::isValid::2,"    def isValid(self, s: str) -> bool:
        mapping = {')': '(', ']': '[', '}':'{'}
        stack = []
        
        for c in s:
            if c not in mapping:
                #open parentheses
                stack.append(c)
            else:
                #close parentheses
                if stack and stack[-1]==mapping[c]:
                    stack.pop()
                else:
                    return False
        
        return not stack",data\repos\leetcode-python\problems\python3\valid-parentheses.py,isValid,90
4300,valid-parenthesis-string.py::checkValidString::2,"    def checkValidString(self, s: str) -> bool:
        leftMin = 0
        leftMax = 0
        
        for c in s:
            if c=='(':
                leftMin += 1
                leftMax += 1
            elif c==')':
                leftMin -= 1
                leftMax -= 1
            else:
                leftMin -= 1
                leftMax += 1
            
            if leftMax<0:
                return False
            
            if leftMin<0:
                leftMin = 0
        
        return leftMin == 0",data\repos\leetcode-python\problems\python3\valid-parenthesis-string.py,checkValidString,123
4301,valid-sudoku.py::isValidSudoku::2,"    def isValidSudoku(self, board: List[List[str]]) -> bool:
        def rowIsValid(i):
            used = set()
            for j in range(N):
                if board[i][j]=='.': continue
                if board[i][j] in used: return False
                used.add(board[i][j])
            return True
        
        def columnIsValid(i):
            used = set()
            for j in range(N):
                if board[j][i]=='.': continue
                if board[j][i] in used: return False
                used.add(board[j][i])
            return True
        
        def isBoxValid(i1, i2, j1, j2):
            used = set()
            for i in range(i1, i2+1):
                for j in range(j1, j2+1):
                    if board[i][j]=='.': continue
                    if board[i][j] in used: return False
                    used.add(board[i][j])
            return True
                
        N = 9
        for i in range(N):
            if not rowIsValid(i): return False
            if not columnIsValid(i): return False
        
        for i in range(0, N, 3):
            for j in range(0, N, 3):
                if not isBoxValid(i, i+2, j, j+2): return False
        
        return True",data\repos\leetcode-python\problems\python3\valid-sudoku.py,isValidSudoku,291
4302,valid-sudoku.py::rowIsValid::3,"        def rowIsValid(i):
            used = set()
            for j in range(N):
                if board[i][j]=='.': continue
                if board[i][j] in used: return False
                used.add(board[i][j])
            return True",data\repos\leetcode-python\problems\python3\valid-sudoku.py,rowIsValid,53
4303,valid-sudoku.py::columnIsValid::11,"        def columnIsValid(i):
            used = set()
            for j in range(N):
                if board[j][i]=='.': continue
                if board[j][i] in used: return False
                used.add(board[j][i])
            return True",data\repos\leetcode-python\problems\python3\valid-sudoku.py,columnIsValid,53
4304,valid-sudoku.py::isBoxValid::19,"        def isBoxValid(i1, i2, j1, j2):
            used = set()
            for i in range(i1, i2+1):
                for j in range(j1, j2+1):
                    if board[i][j]=='.': continue
                    if board[i][j] in used: return False
                    used.add(board[i][j])
            return True",data\repos\leetcode-python\problems\python3\valid-sudoku.py,isBoxValid,83
4305,validate-binary-search-tree.py::isValidBST::8,"    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        lastVal = float('-inf')
        stack = []
        
        node = root
        while stack or node:
            while node:
                stack.append(node)
                node = node.left
            
            node = stack.pop()
            
            if not lastVal<node.val: return False
            lastVal = node.val
            
            node = node.right
        return True",data\repos\leetcode-python\problems\python3\validate-binary-search-tree.py,isValidBST,89
4306,walls-and-gates.py::wallsAndGates::2,"    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        def bfs(i0, j0) -> None:
            q = collections.deque([(i0+1, j0, 1), (i0-1, j0, 1), (i0, j0+1, 1), (i0, j0-1, 1)])
            visited = set()
            
            while q:
                i, j, dis = q.popleft()
                
                if i<0 or j<0 or i>=MAX_ROW or j>=MAX_COL: continue
                if rooms[i][j]==0 or rooms[i][j]==-1: continue
                if (i, j, dis) in visited: continue
                visited.add((i, j, dis))
                
                if dis<rooms[i][j]:
                    rooms[i][j] = dis
                    q.append((i+1, j, dis+1))
                    q.append((i-1, j, dis+1))
                    q.append((i, j+1, dis+1))
                    q.append((i, j-1, dis+1))
                
        MAX_ROW = len(rooms)
        MAX_COL = len(rooms[0])
        
        for i in range(MAX_ROW):
            for j in range(MAX_COL):
                if rooms[i][j]==0:
                    bfs(i, j)
        return rooms",data\repos\leetcode-python\problems\python3\walls-and-gates.py,wallsAndGates,299
4307,walls-and-gates.py::bfs::3,"        def bfs(i0, j0) -> None:
            q = collections.deque([(i0+1, j0, 1), (i0-1, j0, 1), (i0, j0+1, 1), (i0, j0-1, 1)])
            visited = set()
            
            while q:
                i, j, dis = q.popleft()
                
                if i<0 or j<0 or i>=MAX_ROW or j>=MAX_COL: continue
                if rooms[i][j]==0 or rooms[i][j]==-1: continue
                if (i, j, dis) in visited: continue
                visited.add((i, j, dis))
                
                if dis<rooms[i][j]:
                    rooms[i][j] = dis
                    q.append((i+1, j, dis+1))
                    q.append((i-1, j, dis+1))
                    q.append((i, j+1, dis+1))
                    q.append((i, j-1, dis+1))",data\repos\leetcode-python\problems\python3\walls-and-gates.py,bfs,228
4308,word-break.py::wordBreak::10,"    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        def dfs(i):
            if i==len(s): return True
            if i in history and not history[i]: return False
            
            for word in wordDict:
                if i+len(word)<=len(s) and s[i:i+len(word)]==word:
                    history[i] = True
                    if dfs(i+len(word)): return True
            history[i] = False
            return False
        
        history = {}
        return dfs(0)",data\repos\leetcode-python\problems\python3\word-break.py,wordBreak,111
4309,word-break.py::dfs::11,"        def dfs(i):
            if i==len(s): return True
            if i in history and not history[i]: return False
            
            for word in wordDict:
                if i+len(word)<=len(s) and s[i:i+len(word)]==word:
                    history[i] = True
                    if dfs(i+len(word)): return True
            history[i] = False
            return False",data\repos\leetcode-python\problems\python3\word-break.py,dfs,81
4310,word-ladder.py::ladderLength::8,"    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        def getPatterns(word) -> List[str]:
            patterns = []
            for i in range(len(word)):
                pattern = word[:i]+'*'+word[i+1:]
                patterns.append(pattern)
            return patterns
        
        
        if endWord not in wordList: return 0
        wordList.append(beginWord)
        
        #build adjacency list
        nei = collections.defaultdict(list)
        for word in wordList:
            for pattern in getPatterns(word):
                nei[pattern].append(word)
        
        #BFS
        q = collections.deque([(beginWord, 1)])
        visited = set()
        while q:
            word, steps = q.popleft()
            
            if word in visited: continue
            visited.add(word)
            if word==endWord: return steps
            
            for pattern in getPatterns(word):
                for nextWord in nei[pattern]:
                    if nextWord in visited: continue
                    q.append((nextWord, steps+1))
        return 0",data\repos\leetcode-python\problems\python3\word-ladder.py,ladderLength,230
4311,word-ladder.py::getPatterns::9,"        def getPatterns(word) -> List[str]:
            patterns = []
            for i in range(len(word)):
                pattern = word[:i]+'*'+word[i+1:]
                patterns.append(pattern)
            return patterns",data\repos\leetcode-python\problems\python3\word-ladder.py,getPatterns,44
4312,word-search-ii.py::addWord::11,"    def addWord(self, word):
        curr = self
        for c in word:
            if c not in curr.children:
                curr.children[c] = TrieNode()
            curr = curr.children[c]
        curr.isEnd = True",data\repos\leetcode-python\problems\python3\word-search-ii.py,addWord,49
4313,word-search-ii.py::findWords::20,"    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        def dfs(r, c, node, word):
            if c<0 or r<0 or c==COLS or r==ROWS: return
            if board[r][c] not in node.children: return
            if (r, c) in visited: return
            
            visited.add((r, c))
            node = node.children[board[r][c]]
            word += board[r][c]
            if node.isEnd:
                ans.add(word)
                node.isEnd = False
                
            dfs(r+1, c, node, word)
            dfs(r-1, c, node, word)
            dfs(r, c+1, node, word)
            dfs(r, c-1, node, word)
            
            visited.remove((r, c))
        
        
        root = TrieNode()
        for word in words:
            root.addWord(word)
            
        ROWS = len(board)
        COLS = len(board[0])
        
        visited = set()
        ans = set()
        node = root
        for r in range(ROWS):
            for c in range(COLS):
                dfs(r, c, root, '')
        return ans",data\repos\leetcode-python\problems\python3\word-search-ii.py,findWords,261
4314,word-search-ii.py::dfs::21,"        def dfs(r, c, node, word):
            if c<0 or r<0 or c==COLS or r==ROWS: return
            if board[r][c] not in node.children: return
            if (r, c) in visited: return
            
            visited.add((r, c))
            node = node.children[board[r][c]]
            word += board[r][c]
            if node.isEnd:
                ans.add(word)
                node.isEnd = False
                
            dfs(r+1, c, node, word)
            dfs(r-1, c, node, word)
            dfs(r, c+1, node, word)
            dfs(r, c-1, node, word)
            
            visited.remove((r, c))",data\repos\leetcode-python\problems\python3\word-search-ii.py,dfs,160
4315,word-search.py::exist::2,"    def exist(self, board: List[List[str]], word: str) -> bool:
        def helper(x, i, j):
            if i<0 or i>=N or j<0 or j>=M: return False
            if (i, j) in usedWords: return False
            usedWords.add((i, j))
            
            if word[x]==board[i][j]:
                if x==len(word)-1:
                    return True
                else:
                    if helper(x+1, i+1, j): return True
                    if helper(x+1, i, j+1): return True
                    if helper(x+1, i-1, j): return True
                    if helper(x+1, i, j-1): return True
                    
                    
            usedWords.remove((i, j))
            return False
                    
        usedWords = set()
        N = len(board)
        M = len(board[0])
        for i in range(N):
            for j in range(M):
                if helper(0, i, j): return True
        return False",data\repos\leetcode-python\problems\python3\word-search.py,exist,226
4316,word-search.py::helper::3,"        def helper(x, i, j):
            if i<0 or i>=N or j<0 or j>=M: return False
            if (i, j) in usedWords: return False
            usedWords.add((i, j))
            
            if word[x]==board[i][j]:
                if x==len(word)-1:
                    return True
                else:
                    if helper(x+1, i+1, j): return True
                    if helper(x+1, i, j+1): return True
                    if helper(x+1, i-1, j): return True
                    if helper(x+1, i, j-1): return True
                    
                    
            usedWords.remove((i, j))
            return False",data\repos\leetcode-python\problems\python3\word-search.py,helper,157
4317,001_Two_Sum.py::twoSum::48,"    def twoSum(self, nums, target):
        # two point
        nums_index = [(v, index) for index, v in enumerate(nums)]
        nums_index.sort()
        begin, end = 0, len(nums) - 1
        while begin < end:
            curr = nums_index[begin][0] + nums_index[end][0]
            if curr == target:
                return [nums_index[begin][1], nums_index[end][1]]
            elif curr < target:
                begin += 1
            else:
                end -= 1",data\repos\Leetcode\python\001_Two_Sum.py,twoSum,117
4318,002_Add_Two_Numbers.py::addTwoNumbers::40,"    def addTwoNumbers(self, l1, l2):
        carry = 0
        # dummy head
        head = curr = ListNode(0)
        while l1 or l2:
            val = carry
            if l1:
                val += l1.val
                l1 = l1.next
            if l2:
                val += l2.val
                l2 = l2.next
            curr.next = ListNode(val % 10)
            curr = curr.next
            carry = int(val / 10)
        if carry > 0:
            curr.next = ListNode(carry)
        return head.next",data\repos\Leetcode\python\002_Add_Two_Numbers.py,addTwoNumbers,130
4319,003_Longest_Substring_Without_Repeating_Characters.py::lengthOfLongestSubstring::57,"    def lengthOfLongestSubstring(self, s):
        # https://leetcode.com/articles/longest-substring-without-repeating-characters/
        charMap = {}
        for i in range(256):
            charMap[i] = -1
        ls = len(s)
        i = max_len = 0
        for j in range(ls):
            # Note that when charMap[ord(s[j])] >= i, it means that there are
            # duplicate character in current i,j. So we need to update i.
            if charMap[ord(s[j])] >= i:
                i = charMap[ord(s[j])] + 1
            charMap[ord(s[j])] = j
            max_len = max(max_len, j - i + 1)
        return max_len",data\repos\Leetcode\python\003_Longest_Substring_Without_Repeating_Characters.py,lengthOfLongestSubstring,167
4320,005_Longest_Palindromic_Substring.py::longestPalindrome::2,"    def longestPalindrome(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        # my solution
        # expand string according to Manacher algorithm
        # but extend radius step by step
        ls = len(s)
        if ls <= 1 or len(set(s)) == 1:
            return s
        # create a new list like this: ""abc""->""a#b#c""
        temp_s = '#'.join('{}'.format(s))
        # print temp_s
        tls = len(temp_s)
        seed = range(1, tls - 1)
        # this table stores the max length palindrome
        len_table = [0] * tls
        for step in range(1, tls / 2 + 1):
            final = []
            for pos in seed:
                if pos - step < 0 or pos + step >= tls:
                    continue
                if temp_s[pos - step] != temp_s[pos + step]:
                    continue
                final.append(pos)
                if temp_s[pos - step] == '#':
                    continue
                len_table[pos] = step
            seed = final
        max_pos, max_step = 0, 0
        for i, s in enumerate(len_table):
            if s >= max_step:
                max_step = s
                max_pos = i
        return temp_s[max_pos - max_step:max_pos + max_step + 1].translate(None, '#')",data\repos\Leetcode\python\005_Longest_Palindromic_Substring.py,longestPalindrome,309
4321,007_Reverse_Integer.py::reverse::2,"    def reverse(self, x):
        # https://leetcode.com/problems/reverse-integer/
#        flag = True if x < 0 else False
#       if flag:
#           x = -x
#       x = str(x)[::-1]

#       if flag:
#           x = ""-"" + x

#       value = 2 ** 31
#       x = int(x)
#       if -value <= x < value:
#           return x
#       return 0
        
        is_neg = False
        if x < 0:
            x = -x
            is_neg = True

        res = 0
        while x > 0:
            res *= 10
            res += x % 10
            x //= 10
        if is_neg:
            res = -res

        if res < -2**31 or res > 2**31-1:
            return 0
        return res",data\repos\Leetcode\python\007_Reverse_Integer.py,reverse,200
4322,011_Container_With_Most_Water.py::maxArea::2,"    def maxArea(self, height: List[int]) -> int:
        # Two points
        left, right = 0, len(height) - 1
        result = 0
        while left < right:
            result = max(min(height[left], height[right]) * (right - left), result)
            if height[left] > height[right]:
                # remove right
                right -= 1
            else:
                # remove left
                left += 1
        return result",data\repos\Leetcode\python\011_Container_With_Most_Water.py,maxArea,102
4323,013_Roman_to_Integer.py::romanToInt::23,"    def romanToInt(self, s):
        roman = {'I': 1, 'V': 5, 'X': 10,
                 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        prev, total = 0, 0
        for c in s:
            curr = roman[c]
            total += curr
            # need to subtract
            if curr > prev:
                total -= 2 * prev
            prev = curr
        return total",data\repos\Leetcode\python\013_Roman_to_Integer.py,romanToInt,111
4324,015_3Sum.py::threeSum::53,"    def threeSum(self, nums):
        res = []
        nums.sort()
        ls = len(nums)
        for i in range(ls - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            j = i + 1
            k = ls - 1
            while j < k:
                curr = nums[i] + nums[j] + nums[k]
                if curr == 0:
                    res.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j + 1]:
                        j += 1
                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif curr < 0:
                    j += 1
                else:
                    k -= 1
        return res",data\repos\Leetcode\python\015_3Sum.py,threeSum,189
4325,016_3Sum_Closest.py::threeSumClosest::9,"    def threeSumClosest(self, nums, target):
        ls = len(nums)
        sort_nums = sorted(nums)
        res = nums[0] + nums[1] + nums[2]
        for i in range(ls - 2):
            j, k = i + 1, ls - 1
            while j < k:
                temp = sort_nums[i] + sort_nums[j] + sort_nums[k]
                if abs(target - temp) < abs(target - res):
                    res = temp
                if temp < target:
                    j += 1
                else:
                    k -= 1
        return res",data\repos\Leetcode\python\016_3Sum_Closest.py,threeSumClosest,132
4326,017_Letter_Combinations_of_a_Phone_Number.py::letterCombinations::19,"    def letterCombinations(self, digits):
        # DFS
        result = []
        ls = len(digits)
        if ls == 0:
            return result
        current = digits[0]
        posfix = self.letterCombinations(digits[1:])
        for t in dmap[current]:
            if len(posfix) > 0:
                for p in posfix:
                    temp = t + p
                    result.append(temp)
            else:
                result.append(t)
        return result",data\repos\Leetcode\python\017_Letter_Combinations_of_a_Phone_Number.py,letterCombinations,102
4327,019_Remove_Nth_Node_From_End_of_List.py::removeNthFromEnd::45,"    def removeNthFromEnd(self, head, n):
        # https://leetcode.com/discuss/86721/o-n-solution-in-java
        if head is None:
            return None
        slow = fast = head
        for i in range(n):
            fast = fast.next
        if fast is None:
            head = head.next
            return head
        while fast.next is not None:
            fast = fast.next
            slow = slow.next
        curr = slow.next
        slow.next = curr.next
        return head",data\repos\Leetcode\python\019_Remove_Nth_Node_From_End_of_List.py,removeNthFromEnd,113
4328,020_Valid_Parentheses.py::isValid::6,"    def isValid(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        if s is None:
            return True
        stack = []
        for t in s:
            if t == ')':
                try:
                    current = stack.pop()
                    if current != '(':
                        return False
                except:
                    return False
            elif t == '}':
                try:
                    current = stack.pop()
                    if current != '{':
                        return False
                except:
                    return False
            elif t == ']':
                try:
                    current = stack.pop()
                    if current != '[':
                        return False
                except:
                    return False
            else:
                stack.append(t)
        if len(stack) == 0:
            return True
        else:
            return False",data\repos\Leetcode\python\020_Valid_Parentheses.py,isValid,167
4329,021_Merge_Two_Sorted_Lists.py::mergeTwoLists::15,"    def mergeTwoLists(self, l1, l2):
        # dummy head
        pos = dummyHead = ListNode(-1)
        while l1 is not None and l2 is not None:
            if l1.val <= l2.val:
                pos.next = l1
                l1 = l1.next
            else:
                pos.next = l2
                l2 = l2.next
            pos = pos.next
        # merge residual l1
        if l1 is not None:
            pos.next = l1
        # merge residual l2
        if l2 is not None:
            pos.next = l2
        return dummyHead.next",data\repos\Leetcode\python\021_Merge_Two_Sorted_Lists.py,mergeTwoLists,140
4330,022_Generate_Parentheses.py::generateParenthesis::8,"    def generateParenthesis(self, n):
        if n == 1:
            return ['()']
        last_list = self.generateParenthesis(n - 1)
        res = []
        for t in last_list:
            curr = t + ')'
            for index in range(len(curr)):
                if curr[index] == ')':
                    res.append(curr[:index] + '(' + curr[index:])
        return list(set(res))",data\repos\Leetcode\python\022_Generate_Parentheses.py,generateParenthesis,87
4331,023_Merge_k_Sorted_Lists.py::mergeKLists::51,"    def mergeKLists(self, lists):
        # recursive
        if lists is None:
            return None
        elif len(lists) == 0:
            return None
        return self.mergeK(lists, 0, len(lists) - 1)",data\repos\Leetcode\python\023_Merge_k_Sorted_Lists.py,mergeKLists,56
4332,023_Merge_k_Sorted_Lists.py::mergeK::59,"    def mergeK(self, lists, low, high):
        if low == high:
            return lists[low]
        elif low + 1 == high:
            return self.mergeTwolists(lists[low], lists[high])
        mid = (low + high) / 2
        return self.mergeTwolists(self.mergeK(lists, low, mid), self.mergeK(lists, mid + 1, high))",data\repos\Leetcode\python\023_Merge_k_Sorted_Lists.py,mergeK,91
4333,023_Merge_k_Sorted_Lists.py::mergeTwolists::67,"    def mergeTwolists(self, l1, l2):
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        head = curr = ListNode(-1)
        while l1 is not None and l2 is not None:
            if l1.val <= l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        if l1 is not None:
            curr.next = l1
        if l2 is not None:
            curr.next = l2
        return head.next",data\repos\Leetcode\python\023_Merge_k_Sorted_Lists.py,mergeTwolists,144
4334,024_Swap_Nodes_in_Pairs.py::swapPairs::30,"    def swapPairs(self, head):
        dummyHead = ListNode(-1)
        dummyHead.next = head
        prev, p = dummyHead, head
        while p != None and p.next != None:
            q, r = p.next, p.next.next
            prev.next = q
            q.next = p
            p.next = r
            prev = p
            p = r
        return dummyHead.next",data\repos\Leetcode\python\024_Swap_Nodes_in_Pairs.py,swapPairs,89
4335,025_Reverse_Nodes_i_ k-Group.py::reverseKGroup::15,"    def reverseKGroup(self, head, k):
        if head is None:
            return None
        index = 0
        lead, last = 0, 0
        pos = head
        temp = ListNode(-1)
        temp.next = head
        head = temp
        start = head
        while pos is not None:
            if index % k == k - 1:
                last = pos.next
                start = self.reverseList(start, last)
                pos = start
            pos = pos.next
            index += 1
        return head.next",data\repos\Leetcode\python\025_Reverse_Nodes_i_ k-Group.py,reverseKGroup,121
4336,025_Reverse_Nodes_i_ k-Group.py::reverseList::34,"    def reverseList(self, head, end):
        pos = head.next
        last = end
        next_start = pos
        while pos != end:
            head.next = pos
            last_pos = pos
            pos = pos.next
            last_pos.next = last
            last = last_pos
        return next_start",data\repos\Leetcode\python\025_Reverse_Nodes_i_ k-Group.py,reverseList,68
4337,026_Remove_Duplicates_from_Sorted_Array.py::removeDuplicates::22,"    def removeDuplicates(self, nums):
        if len(nums) == 0:
            return 0
        left = 0
        for i in range(1, len(nums)):
            if nums[left] == nums[i]:
                continue
            else:
                left += 1
                nums[left] = nums[i]
        return left + 1",data\repos\Leetcode\python\026_Remove_Duplicates_from_Sorted_Array.py,removeDuplicates,74
4338,028_Implement_strStr().py::strStr::40,"    def strStr(self, haystack, needle):
        lsh, lsn = len(haystack), len(needle)
        if lsn == 0:
            return 0
        next = self.makeNext(needle)
        i = j = 0
        while i < lsh:
            if j == -1 or haystack[i] == needle[j]:
                i += 1
                j += 1
                if j == lsn:
                    return i - lsn
            if i < lsh and haystack[i] != needle[j]:
                j = next[j]
        return -1",data\repos\Leetcode\python\028_Implement_strStr().py,strStr,127
4339,028_Implement_strStr().py::makeNext::56,"    def makeNext(self, needle):
        ls = len(needle)
        next = [0] * ls
        next[0], i, j = -1, 0, -1
        while i < ls - 1:
            if j == -1 or needle[i] == needle[j]:
                next[i + 1] = j + 1
                if needle[i + 1] == needle[j + 1]:
                    next[i + 1] = next[j + 1]
                i += 1
                j += 1
            if needle[i] != needle[j]:
                j = next[j]
        return next",data\repos\Leetcode\python\028_Implement_strStr().py,makeNext,137
4340,031_Next_Permutation.py::nextPermutation::2,"    def nextPermutation(self, nums):
        """"""
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """"""
        ls = len(nums)
        if ls <= 1:
            return
        pair = []
        for i in range(ls):
            for j in range(i + 1, ls):
                # append ascending order pair
                if nums[i] < nums[j]:
                    pair.append([i,j])
        pos = 0
        if len(pair) > 0:
            self.swap(nums, pair[-1][0], pair[-1][1])
            pos = pair[-1][0] + 1
        # sort from pos
        for i in range(pos, ls):
            for j in range(i + 1, ls):
                if nums[i] > nums[j]:
                    self.swap(nums, i, j)",data\repos\Leetcode\python\031_Next_Permutation.py,nextPermutation,189
4341,031_Next_Permutation.py::swap::26,"    def swap(self, nums, index1, index2):
        if index1 == index2:
            return
        nums[index1], nums[index2] = nums[index2], nums[index1]",data\repos\Leetcode\python\031_Next_Permutation.py,swap,42
4342,033_Search_in_Rotated_Sorted_Array.py::search::2,"    def search(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: int
        """"""
        # binary search
        # if start < mid, then left part is sorted
        # if mid < end, then right part is sorted
        def get(start, end):
          if start > end:
            return -1
          mid = (start + end) / 2
          if nums[mid] == target:
            return mid
          elif nums[mid] >= nums[start]: # First half is sorted
            if target >= nums[start] and target < nums[mid]:
              return get(start, mid - 1)
            else:
              return get(mid + 1, end)
          elif nums[mid] <= nums[end]: # Second half is sorted
            if target > nums[mid] and target <= nums[end]:
              return get(mid + 1, end)
            else:
              return get(start, mid - 1)
        return get(0, len(nums) - 1)",data\repos\Leetcode\python\033_Search_in_Rotated_Sorted_Array.py,search,222
4343,033_Search_in_Rotated_Sorted_Array.py::get::11,"        def get(start, end):
          if start > end:
            return -1
          mid = (start + end) / 2
          if nums[mid] == target:
            return mid
          elif nums[mid] >= nums[start]: # First half is sorted
            if target >= nums[start] and target < nums[mid]:
              return get(start, mid - 1)
            else:
              return get(mid + 1, end)
          elif nums[mid] <= nums[end]: # Second half is sorted
            if target > nums[mid] and target <= nums[end]:
              return get(mid + 1, end)
            else:
              return get(start, mid - 1)",data\repos\Leetcode\python\033_Search_in_Rotated_Sorted_Array.py,get,144
4344,034_Search_for_a_Range.py::searchRange::2,"    def searchRange(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """"""
        length = len(nums)
        if length == 0:
            return [-1, -1]
        min = 0
        max = length - 1
        while min <= max:
            pos = (min + max) / 2
            if nums[pos] > target:
                max = pos - 1
            elif nums[pos] < target:
                min = pos + 1
            else:
                # when nums[pos] == target
                # find the min and max
                for i in range(min, max + 1):
                    if nums[i] == target:
                        if min < i and nums[min] != nums[i]:
                            min = i
                        max = i
                return [min, max]
        return [-1, -1]",data\repos\Leetcode\python\034_Search_for_a_Range.py,searchRange,199
4345,035_Search_Insert_Position.py::searchInsert::25,"    def searchInsert(self, nums, target):
        l, r = int(0), len(nums) - 1
        while l < r:
            mid = int((l + r) / 2)
            if nums[mid] < target:
                l = mid + 1
            else:
                r = mid
        if nums[l] < target:
            return l + 1
        return l ",data\repos\Leetcode\python\035_Search_Insert_Position.py,searchInsert,88
4346,036_Valid Sudoku.py::isValidSudoku::8,"    def isValidSudoku(self, board):
        vset = [0] * 9
        hset = [0] * 9
        bset = [0] * 9
        for i in range(9):
            for j in range(9):
                curr = board[i][j]
                if curr != '.':
                    index = 1 << (ord(curr) - ord('0'))
                    if (hset[i] & index) > 0 or\
                                    (vset[j] & index) > 0 or\
                                    (bset[(i / 3) * 3 + j / 3] & index) > 0:
                        return False
                    hset[i] |= index
                    vset[j] |= index
                    bset[(i / 3) * 3 + j / 3] |= index
        return True",data\repos\Leetcode\python\036_Valid Sudoku.py,isValidSudoku,186
4347,037_Sudoku_Solver.py::solveSudoku::2,"    def solveSudoku(self, board):
        """"""
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        """"""
        #https://leetcode.com/discuss/84831/java-backtracking-stack-20ms
        empty = []
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    empty.append(9 * i + j)
        self.solve(board, empty)",data\repos\Leetcode\python\037_Sudoku_Solver.py,solveSudoku,104
4348,037_Sudoku_Solver.py::solve::15,"    def solve(self, board, empty):
        if len(empty) == 0:
            return True
        first_value = empty[-1]
        row, col = first_value / 9, first_value % 9
        for k in range(1, 10):
            if self.is_safe(board, row, col, str(k)):
                board[row][col] = str(k)
                empty.pop()
                if self.solve(board, empty):
                    return True
                board[row][col] = '.'
                empty.append(first_value)
        return False",data\repos\Leetcode\python\037_Sudoku_Solver.py,solve,116
4349,037_Sudoku_Solver.py::is_safe::30,"    def is_safe(self, board, row, col, ch):
        for k in range(9):
            if board[k][col] == ch:
                return False
            if board[row][k] == ch:
                return False
        start_row, start_col = 3 * (row / 3), 3 * (col / 3)
        for i in range(start_row, start_row + 3):
            for j in range(start_col, start_col + 3):
                if board[i][j] == ch:
                    return False
        return True",data\repos\Leetcode\python\037_Sudoku_Solver.py,is_safe,120
4350,038_Count_and_Say.py::countAndSay::2,"    def countAndSay(self, n):
        """"""
        :type n: int
        :rtype: str
        """"""
        if n == 1:
            return '1'
        x = '1'
        while n > 1:
            # each round, read itself
            x = self.count(x)
            n -= 1
        return x",data\repos\Leetcode\python\038_Count_and_Say.py,countAndSay,75
4351,038_Count_and_Say.py::count::16,"    def count(self, x):
        m = list(x)
        res = []
        m.append(None)
        i , j = 0 , 0
        while i < len(m) - 1:
            j += 1
            if m[j] != m[i]:
                # note j - i is the count of m[i]
                res += [j - i, m[i]]
                i = j
        return ''.join(str(s) for s in res)",data\repos\Leetcode\python\038_Count_and_Say.py,count,100
4352,040_Combination_Sum_II.py::combinationSum2::2,"    def combinationSum2(self, candidates, target):
        """"""
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """"""
        candidates.sort()
        dp = [[] for _ in range(target + 1)]
        dp[0].append([])
        for i in range(1, target + 1):
            for j in range(len(candidates)):
                if candidates[j] > i:
                    break
                for k in range(len(dp[i - candidates[j]])):
                    temp = dp[i - candidates[j]][k][:]
                    # check if this number is used
                    if len(temp) > 0 and temp[-1] >= j:
                        continue
                    # store index
                    temp.append(j)
                    dp[i].append(temp)
        res = []
        check = {}
        for temp in dp[target]:
            value = [candidates[t] for t in temp]
            try:
                check[str(value)] += 1
            except KeyError:
                check[str(value)] = 1
                res.append(value)
        return res",data\repos\Leetcode\python\040_Combination_Sum_II.py,combinationSum2,225
4353,041_First_Missing_Positive.py::firstMissingPositive::2,"    def firstMissingPositive(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        # https://leetcode.com/discuss/86025/java-clean-o-n-solution-with-explanation
        ls = len(nums)
        index = 0
        while index < ls:
            # nums[nums[index] - 1] == nums[index] means that the num is in right position
            if nums[index] <= 0 or nums[index] > ls or nums[nums[index] - 1] == nums[index]:
                index += 1
            else:
                # swap current num to correct position
                pos = nums[index] - 1
                nums[index], nums[pos] = nums[pos], nums[index]
        res = 0
        while res < ls and nums[res] == res + 1:
            res += 1
        return res + 1",data\repos\Leetcode\python\041_First_Missing_Positive.py,firstMissingPositive,193
4354,045_Jump_Game_II.py::jump::2,"    def jump(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        if len(nums) <= 1:
            return 0
        end = 0 + nums[0]
        start = 0
        step = 1
        maxDis = 0 + nums[0]
        while end < len(nums) - 1:
            for i in range(start + 1, end + 1):
                # greedy
                maxDis = max(maxDis, nums[i] + i)
            start = end
            end = maxDis
            step += 1
        return step",data\repos\Leetcode\python\045_Jump_Game_II.py,jump,136
4355,046_Permutations.py::permute::12,"    def permute(self, nums):
        # DPS with swapping
        res = []
        if len(nums) == 0:
            return res
        self.get_permute(res, nums, 0)
        return res",data\repos\Leetcode\python\046_Permutations.py,permute,46
4356,046_Permutations.py::get_permute::20,"    def get_permute(self, res, nums, index):
        if index == len(nums):
            res.append(list(nums))
            return
        for i in range(index, len(nums)):
            nums[i], nums[index] = nums[index], nums[i]
            # s(n) = 1 + s(n-1)
            self.get_permute(res, nums, index + 1)
            nums[i], nums[index] = nums[index], nums[i]",data\repos\Leetcode\python\046_Permutations.py,get_permute,95
4357,047_Permutations_II.py::permuteUnique::32,"    def permuteUnique(self, num):
        res = []
        if len(num) == 0:
            return res
        self.permute(res, num, 0)
        return res",data\repos\Leetcode\python\047_Permutations_II.py,permuteUnique,40
4358,047_Permutations_II.py::permute::39,"    def permute(self, res, num, index):
        if index == len(num):
            res.append(list(num))
            return
        appeared = set()
        for i in range(index, len(num)):
            if num[i] in appeared:
                continue
            appeared.add(num[i])
            num[i], num[index] = num[index], num[i]
            self.permute(res, num, index + 1)
            num[i], num[index] = num[index], num[i]",data\repos\Leetcode\python\047_Permutations_II.py,permute,101
4359,047_Permutations_II.py::permuteUnique::52,"    def permuteUnique(self, num):
        # iterative solution
        res = [[]]
        for i in range(len(nums)):
            cache = set()
            while len(res[0]) == i:
                curr = res.pop(0)
                for j in range(len(curr) + 1):
                    # generate new n permutations from n -1 permutations
                    new_perm = curr[:j] + [nums[i]] + curr[j:]
                    stemp = ''.join(map(str, new_perm))
                    if stemp not in cache:
                        cache.add(stemp)
                        res.append(new_perm)
        return res",data\repos\Leetcode\python\047_Permutations_II.py,permuteUnique,126
4360,048_Rotate_Image.py::rotate::2,"    def rotate(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """"""
        # rotate from outside to inside
        if matrix is None or len(matrix) == 1:
            return
        ls = len(matrix)
        for i in range(ls / 2):
            # border
            begin, end = i, ls - 1 - i
            for k in range(ls - 2 * i - 1):
                temp = matrix[end - k][begin]
                matrix[end - k][begin] = matrix[end][end - k]
                matrix[end][end - k] = matrix[begin + k][end]
                matrix[begin + k][end] = matrix[begin][begin + k]
                matrix[begin][begin + k] = temp
        return",data\repos\Leetcode\python\048_Rotate_Image.py,rotate,184
4361,049_Group_Anagrams.py::groupAnagrams::28,"    def groupAnagrams(self, strs):
        strs.sort()
        hash = {}
        for s in strs:
            key = self.hash_key(s)
            try:
                hash[key].append(s)
            except KeyError:
                hash[key] = [s]
        return hash.values()",data\repos\Leetcode\python\049_Group_Anagrams.py,groupAnagrams,58
4362,049_Group_Anagrams.py::hash_key::39,"    def hash_key(self, s):
        # hash string with 26 length array
        table = [0] * 26
        for ch in s:
            index = ord(ch) - ord('a')
            table[index] += 1
        return str(table)",data\repos\Leetcode\python\049_Group_Anagrams.py,hash_key,58
4363,"050_Pow(x, n).py::myPow::16","    def myPow(self, x, n):
        # https://leetcode.com/discuss/93413/iterative-log-n-solution-with-clear-explanation
        # 9 = 2^3 + 2^0 = 1001
        # x^9 = x^(2^3)*x(2^0)
        # multiple x^i when i place is 1
        if n == 0:
            return 1
        res ,curr = 1, abs(n)
        while curr > 0:
            if curr & 1 == 1:
                res *= x
            curr >>= 1
            x *= x
        if n < 0:
            return 1 / res
        return  res","data\repos\Leetcode\python\050_Pow(x, n).py",myPow,157
4364,053_Maximum_Subarray.py::maxSubArray::43,"    def maxSubArray(self, nums):
        maxEndingHere = maxSofFar = nums[0]
        for i in range(1, len(nums)):
            maxEndingHere = max(maxEndingHere + nums[i], nums[i])
            maxSofFar = max(maxEndingHere, maxSofFar)
        return maxSofFar",data\repos\Leetcode\python\053_Maximum_Subarray.py,maxSubArray,72
4365,055_Jump_Game.py::canJump::2,"    def canJump(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        # greedy
        # https://leetcode.com/articles/jump-game/
        length = len(nums)
        begin = length - 1
        for i in reversed(range(length - 1)):
            if i + nums[i] >= begin:
                begin = i
        return not begin",data\repos\Leetcode\python\055_Jump_Game.py,canJump,85
4366,057_Insert_Interval.py::insert::8,"    def insert(self, intervals, newInterval):
        """"""
        :type intervals: List[Interval]
        :type newInterval: Interval
        :rtype: List[Interval]
        """"""
        if intervals is None or len(intervals) == 0:
            return [newInterval]
        intervals.sort(key=lambda x:x.start)
        pos = 0
        while pos < len(intervals):
            # left of pos
            if newInterval.end < intervals[pos].start:
                intervals.insert(pos, newInterval)
                return intervals
            # overlap with pos
            if self.check_overlap(intervals[pos], newInterval):
                temp = intervals.pop(pos)
                newInterval = self.merge_intervals(temp, newInterval)
            else:
                pos += 1
        if len(intervals) == 0 or pos == len(intervals):
            intervals.append(newInterval)
        return intervals",data\repos\Leetcode\python\057_Insert_Interval.py,insert,182
4367,057_Insert_Interval.py::check_overlap::33,"    def check_overlap(self, curr_int, new_int):
        if curr_int.start <= new_int.start:
           if curr_int.end > new_int.start:
               return True
        else:
            if curr_int.start <= new_int.end:
                return True
        return False",data\repos\Leetcode\python\057_Insert_Interval.py,check_overlap,56
4368,057_Insert_Interval.py::merge_intervals::42,"    def merge_intervals(self, int1, int2):
        temp_int = Interval()
        temp_int.start = min([int1.start, int2.start])
        temp_int.end = max([int1.end, int2.end])
        return temp_int",data\repos\Leetcode\python\057_Insert_Interval.py,merge_intervals,52
4369,058_Length_of_Last_Word.py::lengthOfLastWord::2,"    def lengthOfLastWord(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        if len(s) == 0:
            return 0
        temp = s.split(' ')
        temp = [t for t in temp if len(t) > 0]
        if len(temp) == 0:
            return 0
        else:
            return len(temp[-1])",data\repos\Leetcode\python\058_Length_of_Last_Word.py,lengthOfLastWord,89
4370,061_Rotate_List.py::rotateRight::8,"    def rotateRight(self, head, k):
        """"""
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """"""
        if not head or k == 0:
            return head

        slow = fast = head
        length = 1

        while k and fast.next:
            fast = fast.next
            length += 1
            k -= 1

        if k != 0:
            k = (k + length - 1) % length # original k % length
            return self.rotateRight(head, k)
        else:
            while fast.next:
                fast = fast.next
                slow = slow.next
            return self.rotate(head, fast, slow)",data\repos\Leetcode\python\061_Rotate_List.py,rotateRight,151
4371,061_Rotate_List.py::rotate::34,"    def rotate(self, head, fast, slow):
        fast.next = head
        head = slow.next
        slow.next = None
        return head",data\repos\Leetcode\python\061_Rotate_List.py,rotate,32
4372,062_Unique_Paths.py::uniquePaths::2,"    def uniquePaths(self, m, n):
        """"""
        :type m: int
        :type n: int
        :rtype: int
        """"""
        dmap = [[0] * n for _ in range(m)]
        for i in range(m):
            dmap[i][0] = 1
        for j in range(n):
            dmap[0][j] = 1
        for i in range(1, m):
            for j in range(1, n):
                l = u = 0
                if i-1 >= 0:
                    u = dmap[i-1][j]
                if j-1>= 0:
                    l = dmap[i][j-1]
                dmap[i][j] = l + u
        return dmap[m-1][n-1]",data\repos\Leetcode\python\062_Unique_Paths.py,uniquePaths,178
4373,063_Unique_Paths_II.py::uniquePathsWithObstacles::31,"    def uniquePathsWithObstacles(self, obstacleGrid):
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        if m == 0:
            return 0
        dmap = [[0] * (n + 1) for _ in range(m + 1)]
        dmap[m - 1][n] = 1
        for i in range(m - 1, -1, -1):
            for j in  range(n - 1, -1, -1):
                if obstacleGrid[i][j] == 1:
                    dmap[i][j] = 0
                else:
                    dmap[i][j] = dmap[i][j + 1] + dmap[i + 1][j]
        return dmap[0][0]",data\repos\Leetcode\python\063_Unique_Paths_II.py,uniquePathsWithObstacles,173
4374,064_Minimum_Path_Sum.py::minPathSum::2,"    def minPathSum(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        height = len(grid)
        if height == 0:
            return 0
        width = len(grid[0])
        pathmap = []
        for i in range(height):
            pathmap.append([100000000000] * width)
        pathmap[0][0] = grid[0][0]
        for i in range(height):
            for j in range(width):
                compare = [pathmap[i][j]]
                if i - 1 >= 0:
                    compare.append(pathmap[i - 1][j] + grid[i][j])
                if j - 1 >= 0:
                    compare.append(pathmap[i][j - 1] + grid[i][j])
                # min choice
                pathmap[i][j] = min(compare)
        return pathmap[-1][-1]",data\repos\Leetcode\python\064_Minimum_Path_Sum.py,minPathSum,199
4375,066_Plus_One.py::plusOne::22,"    def plusOne(self, digits):
        ls = len(digits)
        for index in reversed(range(ls)):
            if digits[index] < 9:
                digits[index] += 1
                # do not need to continue
                return digits
            else:
                # 10
                digits[index] = 0
        digits.insert(0, 1)
        return digits",data\repos\Leetcode\python\066_Plus_One.py,plusOne,79
4376,067_Add_Binary.py::addBinary::45,"    def addBinary(self, a, b):
        res = ''
        lsa, lsb = len(a), len(b)
        pos, plus, curr = -1, 0, 0
        # plus a[pos], b[pos] and curr % 2
        while (lsa + pos) >= 0 or (lsb + pos) >= 0:
            if (lsa + pos) >= 0:
                curr += int(a[pos])
            if (lsb + pos) >= 0:
                curr += int(b[pos])
            res = str(curr % 2) + res
            curr //= 2
            pos -= 1
        if curr == 1:
            res = '1' + res
        return res",data\repos\Leetcode\python\067_Add_Binary.py,addBinary,159
4377,069_Sqrt(x).py::mySqrt::24,"    def mySqrt(self, x):
        # sqrt(x) = 2 * sqrt(x / 4) for n % 4 == 0
        # sqrt(x) = 1 + 2 * sqrt(x / 4) for n % 4 != 0
        if x == 0:
            return 0
        if x < 4:
            return 1
        res = 2 * self.mySqrt(x / 4)
        # (res + 1) * (res + 1) >= 0 for avoiding overflow
        if (res + 1) * (res + 1) <= x and (res + 1) * (res + 1) >= 0:
            return res + 1
        return  res",data\repos\Leetcode\python\069_Sqrt(x).py,mySqrt,167
4378,070_Climbing_Stairs.py::climbStairs::14,"    def climbStairs(self, n):
        if n <= 1:
            return 1
        dp = [1] * 2
        for i in range(2, n + 1):
            dp[1], dp[0] = dp[1] + dp[0], dp[1]
        return dp[1]",data\repos\Leetcode\python\070_Climbing_Stairs.py,climbStairs,73
4379,071_Simplify_Path.py::simplifyPath::2,"    def simplifyPath(self, path):
        """"""
        :type path: str
        :rtype: str
        """"""
        result = []
        plist = path.split('/')
        for pos in plist:
            if pos:
                if pos == '..':
                    try:
                        # up one level
                        result.pop()
                    except:
                        # arrive top level
                        result = []
                elif pos != '.':
                    result.append(pos)
        return '/'+'/'.join(result)",data\repos\Leetcode\python\071_Simplify_Path.py,simplifyPath,96
4380,073_Set_Matrix_Zeroes.py::setZeroes::2,"    def setZeroes(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """"""
        if not matrix:
            return
        m = len(matrix)
        if m == 0:
            return
        r = []
        c = []
        n = len(matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    r.append(i)
                    c.append(j)
        # row with zero
        r = set(r)
        # column with zero
        c = set(c)
        for i in r:
            for j in range(n):
                matrix[i][j] = 0
        for i in range(m):
            for j in c:
                matrix[i][j] = 0",data\repos\Leetcode\python\073_Set_Matrix_Zeroes.py,setZeroes,182
4381,074_Search_a_2D_Matrix.py::searchMatrix::42,"    def searchMatrix(self, matrix, target):
        # binary search
        try:
            ls_row, ls_col = len(matrix), len(matrix[0])
        except:
            return False
        if target < matrix[0][0] or target > matrix[-1][-1]:
            return False
        begin, end = 0, ls_row * ls_col - 1
        while begin <= end:
            mid = (begin + end) / 2
            row, col = mid / ls_col, mid % ls_col
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] > target:
                end = mid - 1
            else:
                begin = mid + 1
        return False",data\repos\Leetcode\python\074_Search_a_2D_Matrix.py,searchMatrix,159
4382,075_Sort_Colors.py::sortColors::19,"    def sortColors(self, nums):
        # https://leetcode.com/discuss/85658/sharing-c-solution-with-good-explanation
        low, mid, high = 0, 0, len(nums) - 1
        while mid <= high:
            if nums[mid] == 0:
                # swap low mid
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                mid += 1
            else:
                # swap mid high
                nums[high], nums[mid] = nums[mid], nums[high]
                high -= 1
        return",data\repos\Leetcode\python\075_Sort_Colors.py,sortColors,146
4383,080_Remove_Duplicates_from_Sorted_Array_II.py::removeDuplicates::2,"    def removeDuplicates(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        if nums is None:
            return 0
        length = len(nums)
        result = 0
        i = j = 0
        while i < length:
            j = i
            while j < length:
                if nums[j] != nums[i]:
                    break
                j += 1
            if j-i > 2:
                length -= j-i-2
                for k in range(j-i-2):
                    del nums[i]
                result += 2
                j = i+2
            else:
                result += (j-i)
            i = j
        return result",data\repos\Leetcode\python\080_Remove_Duplicates_from_Sorted_Array_II.py,removeDuplicates,154
4384,081_Search_in_Rotated_Sorted_Array_II.py::search::2,"    def search(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: bool
        """"""
        def get(start, end):
            if start > end:
                return False
            mid = (start + end) / 2
            # handle duplicate
            while mid < end and nums[mid + 1] == nums[mid]:
                mid += 1
            while start < mid and nums[start + 1] == nums[start]:
                start += 1
            if nums[mid] == target:
                return True
            elif mid == end:
                return get(start, mid - 1)
            elif start == mid:
                return get(mid + 1, end)
            elif nums[mid] >= nums[start]:
                # First half is sorted
                if target >= nums[start] and target < nums[mid]:
                    return get(start, mid - 1)
                else:
                    return get(mid + 1, end)
            elif nums[mid] <= nums[end]:
                # Second half is sorted
                if target > nums[mid] and target <= nums[end]:
                    return get(mid + 1, end)
                else:
                    return get(start, mid - 1)
        return get(0, len(nums) - 1)",data\repos\Leetcode\python\081_Search_in_Rotated_Sorted_Array_II.py,search,273
4385,081_Search_in_Rotated_Sorted_Array_II.py::get::8,"        def get(start, end):
            if start > end:
                return False
            mid = (start + end) / 2
            # handle duplicate
            while mid < end and nums[mid + 1] == nums[mid]:
                mid += 1
            while start < mid and nums[start + 1] == nums[start]:
                start += 1
            if nums[mid] == target:
                return True
            elif mid == end:
                return get(start, mid - 1)
            elif start == mid:
                return get(mid + 1, end)
            elif nums[mid] >= nums[start]:
                # First half is sorted
                if target >= nums[start] and target < nums[mid]:
                    return get(start, mid - 1)
                else:
                    return get(mid + 1, end)
            elif nums[mid] <= nums[end]:
                # Second half is sorted
                if target > nums[mid] and target <= nums[end]:
                    return get(mid + 1, end)
                else:
                    return get(start, mid - 1)",data\repos\Leetcode\python\081_Search_in_Rotated_Sorted_Array_II.py,get,226
4386,083_Remove_Duplicates_from_Sorted_List.py::deleteDuplicates::28,"    def deleteDuplicates(self, head):
        if head is None:
            return None
        pos = head
        while pos is not None and pos.next is not None:
            if pos.val == pos.next.val:
                pos.next = pos.next.next
            else:
                pos = pos.next
        return head",data\repos\Leetcode\python\083_Remove_Duplicates_from_Sorted_List.py,deleteDuplicates,65
4387,085_Maximal_Rectangle.py::maximalRectangle::2,"    def maximalRectangle(self, matrix):
        """"""
        :type matrix: List[List[str]]
        :rtype: int
        """"""
        # https://discuss.leetcode.com/topic/6650/share-my-dp-solution/2
        if matrix is None or len(matrix) == 0:
            return 0
        ls_row, ls_col = len(matrix), len(matrix[0])
        left, right, height = [0] * ls_col, [ls_col] * ls_col, [0] * ls_col
        maxA = 0
        for i in range(ls_row):
            curr_left, curr_right = 0, ls_col
            for j in range(ls_col):
                if matrix[i][j] == '1':
                    height[j] += 1
                else:
                    height[j] = 0
            for j in range(ls_col):
                if matrix[i][j] == '1':
                    left[j] = max(left[j], curr_left)
                else:
                    left[j], curr_left = 0, j + 1
            for j in range(ls_col - 1, -1, -1):
                if matrix[i][j] == '1':
                    right[j] = min(right[j], curr_right)
                else:
                    right[j], curr_right = ls_col, j
            for j in range(ls_col):
                maxA = max(maxA, (right[j] - left[j]) * height[j])
        return maxA",data\repos\Leetcode\python\085_Maximal_Rectangle.py,maximalRectangle,313
4388,086_Partition_List.py::partition::8,"    def partition(self, head, x):
        """"""
        :type head: ListNode
        :type x: int
        :rtype: ListNode
        """"""
        if head is None:
            return None
        less = lesshead = None
        last = pos = head
        while pos is not None:
            if pos.val < x:
                if lesshead is None:
                    lesshead = pos
                else:
                    less.next = pos
                less = pos
                if head == pos:
                    last = head = pos.next
                else:
                    last.next = pos.next
            else:
                last = pos
            pos = pos.next
        if lesshead is not None:
            less.next = head
        else:
            lesshead = head
        return lesshead",data\repos\Leetcode\python\086_Partition_List.py,partition,164
4389,087_Scramble_String.py::isScramble::29,"    def isScramble(self, s1, s2, memo={}):
        # recursive with memo
        # Check with sorted is fundamental, otherwise TLE
        if len(s1) != len(s2) or sorted(s1) != sorted(s2):
            return False
        if len(s1) <= len(s2) <= 1:
            return s1 == s2
        if s1 == s2:
            return True
        if (s1, s2) in memo:
            return memo[s1, s2]
        n = len(s1)
        for i in range(1, n):
            a = self.isScramble(s1[:i], s2[:i], memo) and self.isScramble(s1[i:], s2[i:], memo)
            if not a:
                b = self.isScramble(s1[:i], s2[-i:], memo) and self.isScramble(s1[i:], s2[:-i], memo)
            if a or b:
                memo[s1, s2] = True
                return True
        memo[s1, s2] = False
        return False",data\repos\Leetcode\python\087_Scramble_String.py,isScramble,246
4390,088_Merge_Sorted_Array.py::merge::2,"    def merge(self, nums1, m, nums2, n):
        """"""
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """"""
        p1, p2 = m - 1, n - 1
        pos = m + n - 1
        while p1 >= 0 and p2 >= 0:
            if nums1[p1] >= nums2[p2]:
                nums1[pos] = nums1[p1]
                p1 -= 1
            else:
                nums1[pos] = nums2[p2]
                p2 -= 1
            pos -= 1
        while p2 >= 0:
            nums1[pos] = nums2[p2]
            p2 -= 1
            pos -= 1",data\repos\Leetcode\python\088_Merge_Sorted_Array.py,merge,198
4391,090_Subsets_II.py::subsetsWithDup::28,"    def subsetsWithDup(self, nums):
        nums.sort()
        res = [[]]
        begin = 0
        for index in range(len(nums)):
            if index == 0 or nums[index] != nums[index - 1]:
                # generate all
                begin = 0
            size = len(res)
            # use existing subsets to generate new subsets
            for j in range(begin, size):
                curr = list(res[j])
                curr.append(nums[index])
                res.append(curr)
            # avoid duplicate subsets
            begin = size
        return res",data\repos\Leetcode\python\090_Subsets_II.py,subsetsWithDup,117
4392,091_Decode_Ways.py::numDecodings::2,"    def numDecodings(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ls = len(s)
        if ls == 0:
            return 0
        dp = [0] * ls
        for index in range(ls):
            if index >= 1 and int(s[index - 1:index + 1]) < 27 and int(s[index - 1:index + 1]) >= 10:
                if index == 1:
                    dp[index] = 1
                else:
                    # 11-26
                    dp[index] += dp[index - 2]
            if int(s[index]) != 0:
                if index == 0:
                    dp[index] = 1
                else:
                    # 1-9
                    dp[index] += dp[index - 1]
        return dp[ls - 1]",data\repos\Leetcode\python\091_Decode_Ways.py,numDecodings,188
4393,092_Reverse_Linked_Lis_ II.py::reverseBetween::8,"    def reverseBetween(self, head, m, n):
        """"""
        :type head: ListNode
        :type m: int
        :type n: int
        :rtype: ListNode
        """"""
        if m == n:
            return head
        split_node, prev, curr = None, None, head
        count = 1
        while count <= m and curr is not None:
            if count == m:
                split_node = prev
            prev = curr
            curr = curr.next
            count += 1
        tail, next_node = prev, None
        while curr is not None and count <= n:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp
            count += 1
        if split_node is not None:
            split_node.next = prev
        if tail is not None:
            tail.next = curr
        if m == 1:
            return prev
        return head",data\repos\Leetcode\python\092_Reverse_Linked_Lis_ II.py,reverseBetween,206
4394,094_Binary_Tree_Inorder_Traversal.py::inorderTraversal::61,"    def inorderTraversal(self, root):
        if root is None:
            return []
        res = []
        stack = [root]
        while len(stack) > 0:
            curr = stack.pop()
            if not isinstance(curr, TreeNode):
                res.append(curr)
                continue
            if curr.right is not None:
                stack.append(curr.right)
            stack.append(curr.val)
            if curr.left is not None:
                stack.append(curr.left)
        return res",data\repos\Leetcode\python\094_Binary_Tree_Inorder_Traversal.py,inorderTraversal,95
4395,095_Unique_Binary_Search_Trees_II.py::generateTrees::9,"    def generateTrees(self, n):
        """"""
        :type n: int
        :rtype: List[TreeNode]
        """"""
        if n == 0:
            return []
        return self.get_trees(1, n)",data\repos\Leetcode\python\095_Unique_Binary_Search_Trees_II.py,generateTrees,47
4396,095_Unique_Binary_Search_Trees_II.py::get_trees::18,"    def get_trees(self, start, end):
        # recursive solve this problem
        res = []
        if start > end:
            res.append(None)
            return res
        for i in range(start, end + 1):
            lefts = self.get_trees(start, i - 1)
            rights = self.get_trees(i + 1, end)
            for j in range(len(lefts)):
                for k in range(len(rights)):
                    # root point
                    root = TreeNode(i)
                    root.left = lefts[j]
                    root.right = rights[k]
                    res.append(root)
        return res",data\repos\Leetcode\python\095_Unique_Binary_Search_Trees_II.py,get_trees,127
4397,096_Unique_Binary_Search_Trees.py::numTrees::2,"    def numTrees(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        # https://leetcode.com/discuss/86650/fantastic-clean-java-dp-solution-with-detail-explaination
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        for level in range(2, n + 1):
            for root in range(1, level + 1):
                dp[level] += dp[level - root] * dp[root - 1]
        return dp[n]",data\repos\Leetcode\python\096_Unique_Binary_Search_Trees.py,numTrees,130
4398,097_Interleaving_String.py::isInterleave::2,"    def isInterleave(self, s1, s2, s3):
        """"""
        :type s1: str
        :type s2: str
        :type s3: str
        :rtype: bool
        """"""
        if len(s1) + len(s2) != len(s3):
            return False
        queue = [(0, 0), (-1, -1)]
        visited = set()
        isSuccess = False
        index = 0
        while len(queue) != 1 or queue[0][0] != -1:
            p = queue.pop(0)
            if p[0] == len(s1) and p[1] == len(s2):
                return True
            if p[0] == -1:
                queue.append(p)
                index += 1
                continue
            if p in visited:
                continue
            visited.add(p)
            if p[0] < len(s1):
                if s1[p[0]] == s3[index]:
                    queue.append((p[0] + 1, p[1]))
            if p[1] < len(s2):
                if s2[p[1]] == s3[index]:
                    queue.append((p[0], p[1] + 1))
        return False",data\repos\Leetcode\python\097_Interleaving_String.py,isInterleave,274
4399,098_Validate_Binary_Search_Tree.py::isValidBST::32,"    def isValidBST(self, root):
        return self.isVaild_helper(root, -sys.maxint - 1, sys.maxint)",data\repos\Leetcode\python\098_Validate_Binary_Search_Tree.py,isValidBST,30
4400,098_Validate_Binary_Search_Tree.py::isVaild_helper::35,"    def isVaild_helper(self, root, minVal, maxVal):
        if root is None:
            return True
        if root.val >= maxVal or root.val <= minVal:
            return False
        return self.isVaild_helper(root.left, minVal, root.val) and self.isVaild_helper(root.right, root.val, maxVal)",data\repos\Leetcode\python\098_Validate_Binary_Search_Tree.py,isVaild_helper,78
4401,099_Recover_Binary_Search_Tree.py::recoverTree::50,"    def recoverTree(self, root):
        self.traverse(root)
        self.first.val, self.second.val = self.second.val, self.first.val",data\repos\Leetcode\python\099_Recover_Binary_Search_Tree.py,recoverTree,30
4402,099_Recover_Binary_Search_Tree.py::traverse::54,"    def traverse(self, root):
        if root is None:
            return
        self.traverse(root.left)
        if self.pre.val >= root.val:
            if self.first is None:
                self.first = self.pre
            if self.first is not None:
                self.second = root
        self.pre = root
        self.traverse(root.right)",data\repos\Leetcode\python\099_Recover_Binary_Search_Tree.py,traverse,73
4403,100_Same_Tree.py::isSameTree::9,"    def isSameTree(self, p, q):
        """"""
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """"""
        if p == q:
            return True
        try:
            left = right = True
            if p.val == q.val:
                left = self.isSameTree(p.left, q.left)
                right = self.isSameTree(p.right, q.right)
                return (left and right)
        except:
            return False
        return False",data\repos\Leetcode\python\100_Same_Tree.py,isSameTree,106
4404,101_Symmetric_Tree.py::isSymmetric::9,"    def isSymmetric(self, root):
        """"""
        :type root: TreeNode
        :rtype: bool
        """"""
        if root is None:
            return True
        return self.mirrorVisit(root.left, root.right)",data\repos\Leetcode\python\101_Symmetric_Tree.py,isSymmetric,48
4405,101_Symmetric_Tree.py::mirrorVisit::18,"    def mirrorVisit(self, left, right):
        if left is None and right is None:
            return True
        try:
            if left.val == right.val:
                if self.mirrorVisit(left.left, right.right) and self.mirrorVisit(left.right, right.left):
                    return True
            return False
        except:
            return False",data\repos\Leetcode\python\101_Symmetric_Tree.py,mirrorVisit,72
4406,102_Binary_Tree_Level_Order_Traversal.py::levelOrder::29,"    def levelOrder(self, root):
        # https://leetcode.com/discuss/90680/9-lines-python-code
        if root is None:
            return []
        q = [[root]]
        for level in q:
            record = []
            for node in level:
                if node.left:
                    record.append(node.left)
                if node.right:
                    record.append(node.right)
            if record:
                q.append(record)
        return [[x.val for x in level] for level in q]",data\repos\Leetcode\python\102_Binary_Tree_Level_Order_Traversal.py,levelOrder,102
4407,103_Binary_Tree_Zigzag_Level_Order_Traversal.py::zigzagLevelOrder::9,"    def zigzagLevelOrder(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[List[int]]
        """"""
        # level order
        if root is None:
            return []
        q = [[root]]
        for level in q:
            record = []
            for node in level:
                if node.left:
                    record.append(node.left)
                if node.right:
                    record.append(node.right)
            if record:
                q.append(record)
        # zigzag order
        res = []
        for index, level in enumerate(q):
            temp = [x.val for x in level]
            if index % 2 == 0:
                res.append(temp)
            else:
                res.append(temp[::-1])
        return res",data\repos\Leetcode\python\103_Binary_Tree_Zigzag_Level_Order_Traversal.py,zigzagLevelOrder,154
4408,104_Maximum_Depth_of_Binary_Tree.py::maxDepth::9,"    def maxDepth(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""
        if root is None:
            return 0
        ld = self.maxDepth(root.left)
        rd = self.maxDepth(root.right)
        return 1 + max(ld, rd)",data\repos\Leetcode\python\104_Maximum_Depth_of_Binary_Tree.py,maxDepth,64
4409,105_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal.py::buildTree::42,"    def buildTree(self, preorder, inorder):
        n = len(inorder)
        inOrderMap = {inorder[i]: i for i in range(n)}
        return self.buildTreeUtil(preorder, inorder, inOrderMap, 0, n - 1, 0, n - 1)",data\repos\Leetcode\python\105_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal.py,buildTree,65
4410,105_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal.py::buildTreeUtil::47,"    def buildTreeUtil(self, preorder, inorder, inOrderMap, pStart, pEnd, iStart, iEnd):
        if pStart > pEnd or iStart > iEnd:
            return None
        root = TreeNode(preorder[pStart])
        rootIdx = inOrderMap[root.val]
        root.left = self.buildTreeUtil(preorder, inorder, inOrderMap, pStart + 1, pStart + rootIdx - iStart + 1, iStart,
                                       rootIdx - 1)
        root.right = self.buildTreeUtil(preorder, inorder, inOrderMap, pStart + rootIdx - iStart + 1, pEnd, rootIdx + 1,
                                        iEnd)
        return root",data\repos\Leetcode\python\105_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal.py,buildTreeUtil,154
4411,1064_Fixed_Point.py::fixedPoint::14,"    def fixedPoint(self, A):
        l, h = 0, len(A) - 1
        while l <= h:
            mid = (l + h) // 2
            if A[mid] < mid:
                l = mid + 1
            elif A[mid] > mid:
                h = mid - 1
            else:
                return mid
        return -1",data\repos\Leetcode\python\1064_Fixed_Point.py,fixedPoint,84
4412,106_Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal.py::buildTree::9,"    def buildTree(self, inorder, postorder):
        """"""
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """"""
        n = len(inorder)
        inOrderMap = {inorder[i]: i for i in range(n)}
        return self.buildTreeUtil(inorder, postorder, inOrderMap, 0, n - 1, 0, n - 1)",data\repos\Leetcode\python\106_Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal.py,buildTree,94
4413,106_Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal.py::buildTreeUtil::19,"    def buildTreeUtil(self, inorder, postorder, inOrderMap, pStart, pEnd, iStart, iEnd):
        if pStart > pEnd or iStart > iEnd:
            return None

        root = TreeNode(postorder[pEnd])
        rootIdx = inOrderMap[root.val]
        root.left = self.buildTreeUtil(inorder, postorder, inOrderMap, pStart, pStart + rootIdx - iStart - 1, iStart,
                                       rootIdx - 1)
        root.right = self.buildTreeUtil(inorder, postorder, inOrderMap, pStart + rootIdx - iStart, pEnd - 1, rootIdx + 1,
                                        iEnd)
        return root",data\repos\Leetcode\python\106_Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal.py,buildTreeUtil,154
4414,107_Binary_Tree_Level_Order_Traversal_II.py::levelOrderBottom::30,"    def levelOrderBottom(self, root):
        if root is None:
            return []
        # use stack
        stack = [[root]]
        res = []
        while len(stack) > 0:
            top = stack.pop()
            res.insert(0, [t.val for t in top])
            temp = []
            for node in top:
                if node.left is not None:
                    temp.append(node.left)
                if node.right is not None:
                    temp.append(node.right)
            if len(temp) > 0:
                stack.append(temp)
        return res",data\repos\Leetcode\python\107_Binary_Tree_Level_Order_Traversal_II.py,levelOrderBottom,117
4415,1089_Duplicate_Zeros.py::duplicateZeros::2,"    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        move_pos = 0
        last_pos = len(arr) - 1
        for i in range(last_pos + 1):
            # Only check [0, lastPos - movePos]
            if i > last_pos - move_pos:
                break
            if arr[i] == 0:
                # Special case
                if i == last_pos - move_pos:
                    arr[last_pos] = 0
                    last_pos -= 1
                    break
                move_pos += 1
        last_pos -= move_pos
        for i in range(last, -1, -1):
            if arr[i] == 0:
                arr[i + move_pos] = 0
                move_pos -= 1
                arr[i + move_pos] = 0
            else:
                arr[i + move_pos] = arr[i]",data\repos\Leetcode\python\1089_Duplicate_Zeros.py,duplicateZeros,208
4416,108_Convert_Sorted_Array_to_Binary_Search_Tree.py::sortedArrayToBST::23,"    def sortedArrayToBST(self, nums):
        # Recursion with index
        return self.getHelper(nums, 0, len(nums) - 1)",data\repos\Leetcode\python\108_Convert_Sorted_Array_to_Binary_Search_Tree.py,sortedArrayToBST,34
4417,108_Convert_Sorted_Array_to_Binary_Search_Tree.py::getHelper::27,"    def getHelper(self, nums, start, end):
        if start > end:
            return None
        mid = (start + end) / 2
        node = TreeNode(nums[mid])
        node.left = self.getHelper(nums, start, mid - 1)
        node.right = self.getHelper(nums, mid + 1, end)
        return node",data\repos\Leetcode\python\108_Convert_Sorted_Array_to_Binary_Search_Tree.py,getHelper,76
4418,109_Convert_Sorted_List_to_Binary_Search_Tree.py::sortedListToBST::47,"    def sortedListToBST(self, head):
        # Bottom-up recursion O(n) and O(lgn)
        if head is None:
            return head
        size = 0
        pos = self.node = head
        while pos is not None:
           pos = pos.next
           size += 1
        return self.inorderHelper(0, size - 1)",data\repos\Leetcode\python\109_Convert_Sorted_List_to_Binary_Search_Tree.py,sortedListToBST,80
4419,109_Convert_Sorted_List_to_Binary_Search_Tree.py::inorderHelper::58,"    def inorderHelper(self, start, end):
        if start > end:
            return None
        mid = (start + end) / 2
        # left side and move
        left = self.inorderHelper(start, mid - 1)
        # move and create
        root = TreeNode(self.node.val)
        root.left = left
        self.node = self.node.next
        # right side and move
        root.right = self.inorderHelper(mid + 1, end)
        return root",data\repos\Leetcode\python\109_Convert_Sorted_List_to_Binary_Search_Tree.py,inorderHelper,106
4420,110_Balanced_Binary_Tree.py::isBalanced::9,"    def isBalanced(self, root):
        """"""
        :type root: TreeNode
        :rtype: bool
        """"""
        # Bottom-up recursion with sentinel -1
        if root is None:
            return True
        if self.getDepth(root) < 0:
            return False
        return True",data\repos\Leetcode\python\110_Balanced_Binary_Tree.py,isBalanced,64
4421,110_Balanced_Binary_Tree.py::getDepth::21,"    def getDepth(self, node):
        if node is None:
            return 1
        ld = self.getDepth(node.left)
        if ld < 0:
            return -1
        rd = self.getDepth(node.right)
        if rd < 0:
            return -1
        elif abs(ld - rd) > 1:
            return -1
        else:
            return max(ld, rd) + 1",data\repos\Leetcode\python\110_Balanced_Binary_Tree.py,getDepth,90
4422,111_Minimum_Depth_of_Binary_Tree.py::minDepth::24,"    def minDepth(self, root):
        # BFS
        if root is None:
            return 0
        queue = [root]
        depth, rightMost = 1, root
        while len(queue) > 0:
            node = queue.pop(0)
            if node.left is None and node.right is None:
                break
            if node.left is not None:
                queue.append(node.left)
            if node.right is not None:
                queue.append(node.right)
            if node == rightMost:
                # reach the current level end
                depth += 1
                if node.right is not None:
                    rightMost = node.right
                else:
                    rightMost = node.left
        return depth",data\repos\Leetcode\python\111_Minimum_Depth_of_Binary_Tree.py,minDepth,149
4423,112_Path_Sum.py::hasPathSum::9,"    def hasPathSum(self, root, sum):
        """"""
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """"""
        if root is None:
            return False
        sum = sum - root.val
        if sum == 0 and root.left is None and root.right is None:
            return True
        # check left
        left = self.hasPathSum(root.left, sum)
        # check right
        right = self.hasPathSum(root.right, sum)
        return (left or right)",data\repos\Leetcode\python\112_Path_Sum.py,hasPathSum,115
4424,113_Path_Sum_II.py::pathSum::9,"    def pathSum(self, root, sum):
        """"""
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """"""
        res = []
        if root is None:
            return res
        if sum == root.val and root.left is None and root.right is None:
            return [[root.val]]
        # left side
        left_res = self.pathSum(root.left, sum - root.val)
        # right side
        right_res = self.pathSum(root.right, sum - root.val)
        # add current prefix
        for t in left_res + right_res:
            res.append([root.val] + t)
        return res",data\repos\Leetcode\python\113_Path_Sum_II.py,pathSum,142
4425,114_Flatten_Binary_Tree_to_Linked_List.py::flatten::10,"    def flatten(self, root):
        """"""
        :type root: TreeNode
        :rtype: void Do not return anything, modify root in-place instead.
        """"""
        if root is None:
            return
        if root.left is None and root.right is None:
            return
        current = root
        stack = [root]
        while stack:
            node = stack.pop()
            self.appendNode(stack, node.right)
            self.appendNode(stack, node.left)
            if current != node:
                current.right = node
                current.left = None
                current = node",data\repos\Leetcode\python\114_Flatten_Binary_Tree_to_Linked_List.py,flatten,119
4426,115_Distinct_Subsequences.py::numDistinct::2,"    def numDistinct(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: int
        """"""
        # https://discuss.leetcode.com/topic/51131/space-o-mn-and-o-n-python-solutions
        dp = [[0 for j in xrange(0, len(t) + 1)] for i in xrange(0, len(s) + 1)]
        for j in xrange(1, len(t) + 1):
            dp[0][j] = 0
        for i in xrange(1, len(s) + 1):
            dp[i][0] = 1
        dp[0][0] = 1
        for i in xrange(1, len(s) + 1):
            for j in xrange(1, len(t) + 1):
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * (s[i - 1] == t[j - 1])

        return dp[-1][-1]",data\repos\Leetcode\python\115_Distinct_Subsequences.py,numDistinct,234
4427,116_Populating_Next_Right_Pointers_in_Each_Node.py::connect::10,"    def connect(self, root):
        """"""
        :type root: TreeLinkNode
        :rtype: nothing
        """"""
        if root is None:
            return
        nodes = [root]
        while len(nodes) != 0:
            next_step = []
            last = None
            for node in nodes:
                if last is not None:
                    last.next = node
                if node.left is not None:
                    next_step.append(node.left)
                if node.right is not None:
                    next_step.append(node.right)
                last = node
            nodes = next_step",data\repos\Leetcode\python\116_Populating_Next_Right_Pointers_in_Each_Node.py,connect,119
4428,117_Populating_Next_Right_Pointers_in_Each_Node_II.py::connect::32,"    def connect(self, root):
        # https://discuss.leetcode.com/topic/28580/java-solution-with-constant-space
        dummyHead = TreeLinkNode(-1)
        pre = dummyHead
        while root is not None:
            if root.left is not None:
                pre.next = root.left
                pre = pre.next
            if root.right is not None:
                pre.next = root.right
                pre = pre.next
            root = root.next
            if root is None:
                pre = dummyHead
                root = dummyHead.next
                dummyHead.next = None",data\repos\Leetcode\python\117_Populating_Next_Right_Pointers_in_Each_Node_II.py,connect,124
4429,118_Pascal's_Triangle.py::generate::2,"    def generate(self, numRows):
        """"""
        :type numRows: int
        :rtype: List[List[int]]
        """"""
        result = []
        for i in range(numRows):
            result.append([0] * (i + 1))
        for i in range(numRows):
            for j in range(i + 1):
                if j == 0 or j == i:
                    result[i][j] = 1
                else:
                    result[i][j] = result[i - 1][j - 1] + result[i - 1][j]
        return result",data\repos\Leetcode\python\118_Pascal's_Triangle.py,generate,123
4430,120_Triangle.py::minimumTotal::2,"    def minimumTotal(self, triangle):
        """"""
        :type triangle: List[List[int]]
        :rtype: int
        """"""
        if triangle is None or len(triangle) == 0:
            return 0
        ls = len(triangle)
        dp = [0] * ls
        dp[0] = triangle[0][0]
        for i in range(1, ls):
            # note that dp should be updated in reversed order
            dp[i] = dp[i - 1] + triangle[i][i]
            for j in reversed(range(1, i)):
                dp[j] = min(dp[j - 1] + triangle[i][j], dp[j] + triangle[i][j])
            dp[0] = dp[0] + triangle[i][0]
        return min(dp)",data\repos\Leetcode\python\120_Triangle.py,minimumTotal,172
4431,121_Best_Time_to_Buy_and_Sell_Stock.py::maxProfit::2,"    def maxProfit(self, prices):
        """"""
        :type prices: List[int]
        :rtype: int
        """"""
        length = len(prices)
        if length == 0:
            return 0
        max_profit, low = 0, prices[0]
        for i in range(1, length):
            if low > prices[i]:
                low = prices[i]
            else:
                temp = prices[i] - low
                if temp > max_profit:
                    max_profit = temp
        return max_profit",data\repos\Leetcode\python\121_Best_Time_to_Buy_and_Sell_Stock.py,maxProfit,110
4432,122_Best_Time_to_Buy_and_Sell_Stock_II.py::maxProfit::2,"    def maxProfit(self, prices):
        """"""
        :type prices: List[int]
        :rtype: int
        """"""
        # sum of prices[i + 1] - prices[i], if prices[i + 1] > prices[i]
        return sum([y - x for x, y in zip(prices[0:-1], prices[1:]) if x < y])",data\repos\Leetcode\python\122_Best_Time_to_Buy_and_Sell_Stock_II.py,maxProfit,80
4433,123_Best_Time_to_Buy_and_Sell_Stock_III.py::maxProfit::22,"    def maxProfit(self, prices):
        ls = len(prices)
        if ls == 0:
            return 0
        b1 = b2 = -prices[0]
        s1 = s2 = 0
        for i in xrange(1, ls):
            s2 = max(s2, b2 + prices[i])
            b2 = max(b2, s1 - prices[i])
            s1 = max(b1 + prices[i], s1)
            b1 = max(b1, -prices[i])
        return max(s1, s2)",data\repos\Leetcode\python\123_Best_Time_to_Buy_and_Sell_Stock_III.py,maxProfit,122
4434,124_Binary_Tree_Maximum_Path_Sum.py::maxPathSum::13,"    def maxPathSum(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""
        # return (root.val,left+root.val,right+root.val,left+right+root);
        self.getNodeMaxValue(root)
        return self.result",data\repos\Leetcode\python\124_Binary_Tree_Maximum_Path_Sum.py,maxPathSum,57
4435,124_Binary_Tree_Maximum_Path_Sum.py::getNodeMaxValue::22,"    def getNodeMaxValue(self, node):
        if node is None:
            return 0
        lresult = self.getNodeMaxValue(node.left)
        rresult = self.getNodeMaxValue(node.right)
        self.result = max(lresult + rresult + node.val, self.result)
        ret = node.val + max(lresult, rresult)
        # if max left or right < 0 then return 0
        if ret > 0:
            return ret
        return 0",data\repos\Leetcode\python\124_Binary_Tree_Maximum_Path_Sum.py,getNodeMaxValue,102
4436,125_Valid_Palindrome.py::isPalindrome::2,"    def isPalindrome(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        alnum_s = [t.lower() for t in s if t.isalnum()]
        ls = len(alnum_s)
        if ls <= 1:
            return True
        mid = ls / 2
        for i in range(mid):
            if alnum_s[i] != alnum_s[ls - 1 - i]:
                return False
        return True",data\repos\Leetcode\python\125_Valid_Palindrome.py,isPalindrome,103
4437,1260_Shift_2D_Grid.py::shiftGrid::2,"    def shiftGrid(self, grid, k):
        """"""
        :type grid: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """"""
        # m * n temp array
        new_grid = [[0] * len(grid[0]) for _ in range(len(grid))]
        m = len(grid)
        n = len(grid[0])
        # Compute final location
        true_k = k % (m * n)
        # row move
        move_i = true_k / n
        # col move
        move_j = true_k % n

        for i in range(m):
            for j in range(n):
                new_i = i + move_i
                # move one row if move_j + j >= n
                if move_j + j >= n:
                    new_i += 1
                new_i %= m
                new_j = (j + move_j) % n
                new_grid[new_i][new_j] = grid[i][j]
        return new_grid",data\repos\Leetcode\python\1260_Shift_2D_Grid.py,shiftGrid,215
4438,127_Word_Ladder.py::ladderLength::3,"    def ladderLength(self, beginWord, endWord, wordList):
        """"""
        :type beginWord: str
        :type endWord: str
        :type wordList: Set[str]
        :rtype: int
        """"""
        # two way bfs
        # one way is not sufficient
        wordList.discard(beginWord)
        wordList.discard(endWord)
        hash_map, res = {}, []
        res = self.bfs(set([beginWord]), set([endWord]), wordList, 2)
        return res",data\repos\Leetcode\python\127_Word_Ladder.py,ladderLength,113
4439,127_Word_Ladder.py::bfs::18,"    def bfs(self, forward, backward, wordlist, level):
        if len(forward) == 0 or len(backward) == 0:
            return 0
        if len(forward) > len(backward):
            return self.bfs(backward, forward, wordlist, level)
        is_connected = False
        next_level = set()
        for word in forward:
            for c in string.ascii_lowercase:
                for index in range(len(word)):
                    neigh = word[:index] + c + word[index + 1:]
                    if neigh in backward:
                        is_connected = True
                        return level
                    if not is_connected and neigh in wordlist:
                        next_level.add(neigh)
                        wordlist.discard(neigh)
        if not is_connected:
            return self.bfs(next_level, backward, wordlist, level + 1)",data\repos\Leetcode\python\127_Word_Ladder.py,bfs,179
4440,128_Longest_Consecutive_Sequence.py::longestConsecutive::2,"    def longestConsecutive(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""

        def longestConsecutive(self, num):
            # Pop adjacency O(n) and O(n)
            num = set(num)
            maxLen = 0
            while num:
                n = num.pop()
                i = n + 1
                l1 = 0
                l2 = 0
                while i in num:
                    num.remove(i)
                    i += 1
                    l1 += 1
                i = n - 1
                while i in num:
                    num.remove(i)
                    i -= 1
                    l2 += 1
                maxLen = max(maxLen, l1 + l2 + 1)
            return maxLen",data\repos\Leetcode\python\128_Longest_Consecutive_Sequence.py,longestConsecutive,169
4441,128_Longest_Consecutive_Sequence.py::longestConsecutive::8,"        def longestConsecutive(self, num):
            # Pop adjacency O(n) and O(n)
            num = set(num)
            maxLen = 0
            while num:
                n = num.pop()
                i = n + 1
                l1 = 0
                l2 = 0
                while i in num:
                    num.remove(i)
                    i += 1
                    l1 += 1
                i = n - 1
                while i in num:
                    num.remove(i)
                    i -= 1
                    l2 += 1
                maxLen = max(maxLen, l1 + l2 + 1)
            return maxLen",data\repos\Leetcode\python\128_Longest_Consecutive_Sequence.py,longestConsecutive,142
4442,1290_Convert_Binary_Number_in_a_Linked_List_to_Integer.py::getDecimalValue::35,"    def getDecimalValue(self, head: ListNode) -> int:
        binary_numbers_list = []
        binary_numbers_list.append(head.val)
        while(head.next is not None):
            head = head.next
            binary_numbers_list.append(head.val)
        answer = 0
        power = 0
        # from len(binary_numbers_list) - 1 -> 0
        for digit in range(len(binary_numbers_list) - 1, -1, -1):
            if(binary_numbers_list[digit] > 0):
                answer += ((2 ** power) * binary_numbers_list[digit])
            power += 1
        return answer",data\repos\Leetcode\python\1290_Convert_Binary_Number_in_a_Linked_List_to_Integer.py,getDecimalValue,133
4443,129_Sum_Root_to_Leaf_Numbers.py::sumNumbers::9,"    def sumNumbers(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""
        if root is None:
            return 0
        res = 0
        # bfs with queue
        queue = [(root, root.val)]
        while len(queue) > 0:
            curr, curr_value = queue.pop(0)
            if curr.left is None and curr.right is None:
                res += curr_value
                continue
            if curr.left:
                queue.append((curr.left, curr_value * 10 + curr.left.val))
            if curr.right:
                queue.append((curr.right, curr_value * 10 + curr.right.val))
        return res",data\repos\Leetcode\python\129_Sum_Root_to_Leaf_Numbers.py,sumNumbers,145
4444,1304_Find_N_Unique_Integers_Sum_up_to_Zero.py::sumZero::2,"    def sumZero(self, n: int) -> List[int]:
        prefix_sum = 0
        res = []
        # 1, n-1
        for i in range(1, n):
            res.append(i)
            prefix_sum = prefix_sum + i
        # sum(from 1 to n-1)
        res.append(-prefix_sum)
        return res",data\repos\Leetcode\python\1304_Find_N_Unique_Integers_Sum_up_to_Zero.py,sumZero,79
4445,130_Surrounded_Regions.py::solve::2,"    def solve(self, board):
        # https://discuss.leetcode.com/topic/22503/some-tips-for-python-code
        if not board:
            return
        height, width = len(board), len(board[0])
        leakWall = self.buildLeakWall(board)
        while leakWall:
            i, j = leakWall.pop()
            if 0 <= i < height and 0 <= j < width:
                if board[i][j] == ""O"":
                    board[i][j] = ""S""
                    leakWall += (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)
        for i in range(height):
            for j in range(width):
                board[i][j] = ""O"" if board[i][j] == ""S"" else ""X""",data\repos\Leetcode\python\130_Surrounded_Regions.py,solve,185
4446,130_Surrounded_Regions.py::buildLeakWall::18,"    def buildLeakWall(self, board):
        leakWall, height, width = [], len(board), len(board[0])
        for i in range(height):
            if board[i][0] == ""O"":
                leakWall.append((i, 0))
            if board[i][width - 1] == ""O"":
                leakWall.append((i, width - 1))
        for j in range(width):
            if board[0][j] == ""O"":
                leakWall.append((0, j))
            if board[height - 1][j] == ""O"":
                leakWall.append((height - 1, j))
        return leakWall",data\repos\Leetcode\python\130_Surrounded_Regions.py,buildLeakWall,140
4447,1310_XOR_Queries_of_a_Subarray.py::xorQueries::2,"    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
        pref = [0]
        # Compute accumulated xor from head
        for e in arr:
            pref.append(e ^ pref[-1])
        ans = []
        # query result equal to xor[0, l] xor x[0, r]
        for [l, r] in queries:
            ans.append(pref[r+1] ^ pref[l])
        return ans",data\repos\Leetcode\python\1310_XOR_Queries_of_a_Subarray.py,xorQueries,98
4448,131_Palindrome_Partitioning.py::partition::2,"    def partition(self, s):
        """"""
        :type s: str
        :rtype: List[List[str]]
        """"""
        # https://discuss.leetcode.com/topic/6186/java-backtracking-solution/2
        result = []
        curr = []
        self.recurPartition(result, curr, s, 0)
        return result",data\repos\Leetcode\python\131_Palindrome_Partitioning.py,partition,72
4449,131_Palindrome_Partitioning.py::recurPartition::13,"    def recurPartition(self, result, curr, s, start):
        if start == len(s):
            result.append(list(curr))
        for i in range(start, len(s)):
            if self.isPalindrome(s, start, i):
                curr.append(s[start:i + 1])
                self.recurPartition(result, curr, s, i + 1)
                curr.pop()",data\repos\Leetcode\python\131_Palindrome_Partitioning.py,recurPartition,78
4450,131_Palindrome_Partitioning.py::isPalindrome::22,"    def isPalindrome(self, s, begin, end):
        while begin < end:
            if s[begin] != s[end]:
                return False
            begin += 1
            end -= 1
        return True",data\repos\Leetcode\python\131_Palindrome_Partitioning.py,isPalindrome,47
4451,1323_Maximum_69_Number.py::maximum69Number::2,"    def maximum69Number (self, num: int) -> int:
        # Replace first 6 with 9 if exists
        return(str(num).replace('6', '9', 1))",data\repos\Leetcode\python\1323_Maximum_69_Number.py,maximum69Number,42
4452,1337_The_K_Weakest_Rows_in_a_Matrix.py::kWeakestRows::2,"    def kWeakestRows(self, mat, k):
        """"""
        :type mat: List[List[int]]
        :type k: int
        :rtype: List[int]
        """"""
        res = []
        num_row = len(mat)
        num_col = len(mat[0])
        col = 0
        flag = 1
        while col < num_col and flag:
            for i in range(num_row):
                if i in res:
                    continue
                # Add first row with 0 into res
                if mat[i][col] == 0:
                    res.append(i)
                if len(res) == k:
                    flag = 0
                    break
            col += 1
        if len(res) == k:
            return res
        # if res less than k
        for i in range(num_row):
            if i in res:
                continue
            res.append(i)
            if len(res) == k:
                break
        return res",data\repos\Leetcode\python\1337_The_K_Weakest_Rows_in_a_Matrix.py,kWeakestRows,203
4453,133_Clone_Graph.py::cloneGraph::29,"    def cloneGraph(self, node):
        # BFS
        if node is None:
            return None
        label_map = {}
        queue = [node]
        graphCopy = UndirectedGraphNode(node.label)
        label_map[node.label] = graphCopy
        while len(queue) > 0:
            curr = queue.pop(0)
            for ne in curr.neighbors:
                if ne.label in label_map:
                    label_map[curr.label].neighbors.append(label_map[ne.label])
                else:
                    neighborCopy = UndirectedGraphNode(ne.label)
                    label_map[curr.label].neighbors.append(neighborCopy)
                    label_map[ne.label] = neighborCopy
                    queue.append(ne)
        return graphCopy",data\repos\Leetcode\python\133_Clone_Graph.py,cloneGraph,144
4454,134_Gas_Station.py::canCompleteCircuit::2,"    def canCompleteCircuit(self, gas, cost):
        """"""
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """"""
        # https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution
        ls = len(gas)
        begin, end = 0, ls - 1
        curr = gas[end] - cost[end]
        while begin < end:
            if curr >= 0:
                curr += gas[begin] - cost[begin]
                begin += 1
            else:
                end -= 1
                curr += gas[end] - cost[end]
        if curr >= 0:
            return end
        else:
            return -1",data\repos\Leetcode\python\134_Gas_Station.py,canCompleteCircuit,173
4455,135_Candy.py::candy::2,"    def candy(self, ratings):
        """"""
        :type ratings: List[int]
        :rtype: int
        """"""
        # https://discuss.leetcode.com/topic/5243/a-simple-solution
        if ratings is None or len(ratings) == 0:
            return 0
        ls = len(ratings)
        num = [1] * ls
        for i in range(1, ls):
            if ratings[i] > ratings[i - 1]:
                num[i] = num[i - 1] + 1
        for i in range(ls - 1, 0, -1):
            if ratings[i - 1] > ratings[i]:
                num[i - 1] = max(num[i] + 1, num[i - 1])
        return sum(num)",data\repos\Leetcode\python\135_Candy.py,candy,170
4456,1365_How_Many_Numbers_Are_Smaller_Than_the_Current_Number.py::smallerNumbersThanCurrent::14,"    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        count_list = [0] * 101
        # count numbers
        for v in nums:
            count_list[v] += 1
        # compute numbers before current index
        for i in range(1, 101):
            count_list[i] += count_list[i-1]
        res = []
        for v in nums:
            if v == 0:
                res.append(0)
            else:
                res.append(count_list[v-1])
        return res",data\repos\Leetcode\python\1365_How_Many_Numbers_Are_Smaller_Than_the_Current_Number.py,smallerNumbersThanCurrent,117
4457,136_Single_Number.py::singleNumber::28,"    def singleNumber(self, nums):
        # xor
        res = 0
        for num in nums:
            res ^= num
        return res",data\repos\Leetcode\python\136_Single_Number.py,singleNumber,32
4458,1374_Generate_a_String_With_Characters_That_Have_Odd_Counts_Solution.py::generateTheString::8,"    def generateTheString(self, n: int) -> str:
        if n%2==0:
            return ""a"" * (n-1) + ""b""
        else:
            return ""a"" * n",data\repos\Leetcode\python\1374_Generate_a_String_With_Characters_That_Have_Odd_Counts_Solution.py,generateTheString,47
4459,137_Single_Number_II.py::singleNumber::19,"    def singleNumber(self, nums):
        # bitmask
        # ones as a bitmask to represent the ith bit had appeared once.
        # twos as a bitmask to represent the ith bit had appeared twice.
        # threes as a bitmask to represent the ith bit had appeared three times.
        ones, twos, threes = 0, 0, 0
        for num in nums:
            twos |= ones & num
            ones ^= num
            threes = ones & twos
            ones &= ~threes
            twos &= ~threes
        return ones",data\repos\Leetcode\python\137_Single_Number_II.py,singleNumber,124
4460,138_Copy_List_with_Random_Pointer.py::copyRandomList::43,"    def copyRandomList(self, head):
        # Modify original structure: Original->Copy->Original->Copy
        # node.next.random = node.random.next
        # O(n) and O(1)
        p = head
        while p is not None:
            next = p.next
            copy = RandomListNode(p.label)
            p.next = copy
            copy.next =  next
            p = next
        p = head
        while p is not None:
            if p.random is not None:
                p.next.random = p.random.next
            p = p.next.next
        p = head
        if p is not None:
            headCopy = p.next
        else:
            headCopy = None
        while p is not None:
            copy = p.next
            p.next = copy.next
            p = p.next
            if p is not None:
                copy.next = p.next
        return headCopy",data\repos\Leetcode\python\138_Copy_List_with_Random_Pointer.py,copyRandomList,195
4461,139_Word_Break.py::wordBreak::2,"    def wordBreak(self, s, wordDict):
        """"""
        :type s: str
        :type wordDict: Set[str]
        :rtype: bool
        """"""
        queue = [0]
        ls = len(s)
        lenList = [l for l in set(map(len, wordDict))]
        visited = [0 for _ in range(0, ls + 1)]
        while queue:
            start = queue.pop(0)
            for l in lenList:
                if s[start:start + l] in wordDict:
                    if start + l == ls:
                        return True
                    if visited[start + l] == 0:
                        queue.append(start + l)
                        visited[start + l] = 1
        return False",data\repos\Leetcode\python\139_Word_Break.py,wordBreak,156
4462,140_Word_Break_II.py::wordBreak::6,"    def wordBreak(self, s, wordDict):
        """"""
        :type s: str
        :type wordDict: Set[str]
        :rtype: List[str]
        """"""
        try:
            return self.solution[s]
        except KeyError:
            pass
        result = []
        if s in wordDict:
            result.append(s)
        for i in range(1, len(s)):
            word = s[i:]
            if word in wordDict:
                rem = s[:i]
                prev = self.wordBreak(rem, wordDict)
                result.extend([res + ' ' + word for res in prev])
        self.solution[s] = result
        return result",data\repos\Leetcode\python\140_Word_Break_II.py,wordBreak,139
4463,141_Linked_List_Cycle.py::hasCycle::39,"    def hasCycle(self, head):
        # Two points
        try:
            fast = head.next.next
            slow = head.next

            while fast != slow:
                fast = fast.next.next
                slow = slow.next

            return True
        except:
            return False",data\repos\Leetcode\python\141_Linked_List_Cycle.py,hasCycle,58
4464,142_Linked_List_Cycle_II.py::detectCycle::8,"    def detectCycle(self, head):
        """"""
        :type head: ListNode
        :rtype: ListNode
        """"""
        # Two points
        # https://discuss.leetcode.com/topic/2975/o-n-solution-by-using-two-pointers-without-change-anything
        try:
            fast = head.next.next
            slow = head.next

            while fast != slow:
                fast = fast.next.next
                slow = slow.next
        except:
            return None
        slow = head
        while fast != slow:
            fast = fast.next
            slow = slow.next
        return fast",data\repos\Leetcode\python\142_Linked_List_Cycle_II.py,detectCycle,126
4465,143_Reorder_List.py::reorderList::28,"    def reorderList(self, head):
        # Two points
        if head is None or head.next is None:
            return
        p1, p2 = head, head.next
        while p2 and p2.next:
            p1 = p1.next
            p2 = p2.next.next
        head2 = p1.next
        p1.next = None
        p2 = head2.next
        head2.next = None
        # reverse mid->end to end->mid
        while p2:
            temp = p2.next
            p2.next = head2
            head2 = p2
            p2 = temp
        p1, p2 = head, head2
        # merge
        while p1:
            temp = p1.next
            p1.next = p2
            p1 = p1.next
            p2 = temp",data\repos\Leetcode\python\143_Reorder_List.py,reorderList,188
4466,144_Binary_Tree_Preorder_Traversal.py::preorderTraversal::29,"    def preorderTraversal(self, root):
        # stack
        if root is None:
            return []
        res = []
        stack = [root]
        while len(stack) > 0:
            curr = stack.pop()
            res.append(curr.val)
            if curr.right is not None:
                stack.append(curr.right)
            if curr.left is not None:
                stack.append(curr.left)
        return res",data\repos\Leetcode\python\144_Binary_Tree_Preorder_Traversal.py,preorderTraversal,83
4467,145_Binary_Tree_Postorder_Traversal.py::postorderTraversal::43,"    def postorderTraversal(self, root):
        if root is None:
            return []
        res = []; stack = [root]
        while len(stack) > 0:
            curr = stack.pop()
            if not isinstance(curr, TreeNode):
                res.append(curr)
                continue
            stack.append(curr.val)
            if curr.right is not None:
                stack.append(curr.right)
            if curr.left is not None:
                stack.append(curr.left)
        return res",data\repos\Leetcode\python\145_Binary_Tree_Postorder_Traversal.py,postorderTraversal,95
4468,146_LRU_Cache.py::get::14,"    def get(self, key):
        """"""
        :rtype: int
        """"""
        if key in self.cache:
            self.updateQueue(key)
            return self.cache[key]
        else:
            return -1",data\repos\Leetcode\python\146_LRU_Cache.py,get,43
4469,146_LRU_Cache.py::put::24,"    def put(self, key, value):
        """"""
        :type key: int
        :type value: int
        :rtype: nothing
        """"""
        if key in self.cache:
            self.queue.remove(key)
        elif len(self.queue) == self.capacity:
            del self.cache[self.queue.pop(-1)]

        self.cache[key] = value
        self.queue.insert(0, key)",data\repos\Leetcode\python\146_LRU_Cache.py,put,83
4470,147_Insertion_Sort_List.py::insertionSortList::8,"    def insertionSortList(self, head):
        """"""
        :type head: ListNode
        :rtype: ListNode
        """"""
        # https://discuss.leetcode.com/topic/8570/an-easy-and-clear-way-to-sort-o-1-space
        if head is None:
            return None
        helper = ListNode(-1000)
        pre, curr = helper, head
        while curr is not None:
            next_step = curr.next
            while pre.next and pre.next.val < curr.val:
                pre = pre.next
            curr.next = pre.next
            pre.next = curr
            pre = helper
            curr = next_step
        return helper.next",data\repos\Leetcode\python\147_Insertion_Sort_List.py,insertionSortList,139
4471,1480_Running_Sum_of_1d_Array.py::runningSum::2,"    def runningSum(self, nums: List[int]) -> List[int]:
        if nums is None or len(nums) == 0:
            return nums
        for i in range(1, len(nums)):
            nums[i] += nums[i-1]
        return nums",data\repos\Leetcode\python\1480_Running_Sum_of_1d_Array.py,runningSum,56
4472,149_Max_Points_on_a_Line.py::maxPoints::8,"    def maxPoints(self, points):
        """"""
        :type points: List[Point]
        :rtype: int
        """"""
        # map all possible angle
        if points is None or len(points) == 0:
            return 0
        ls = len(points)
        res = 0
        for i in range(ls):
            line_map = {}
            overlap = max_point = 0
            for j in range(i + 1, ls):
                x, y = points[j].x - points[i].x, points[j].y - points[i].y
                if x == 0 and y == 0:
                    overlap += 1
                    continue
                gcd = self.generateGCD(x, y)
                if gcd != 0:
                    x /= gcd
                    y /= gcd
                if x in line_map:
                    if y in line_map[x]:
                        line_map[x][y] += 1
                    else:
                        line_map[x][y] = 1
                else:
                    line_map[x] = {}
                    line_map[x][y] = 1
                max_point = max(max_point, line_map[x][y])
            res = max(res, max_point + overlap + 1)
        return res",data\repos\Leetcode\python\149_Max_Points_on_a_Line.py,maxPoints,263
4473,149_Max_Points_on_a_Line.py::generateGCD::42,"    def generateGCD(self, x, y):
        if y == 0:
            return x
        else:
            return self.generateGCD(y, x % y)",data\repos\Leetcode\python\149_Max_Points_on_a_Line.py,generateGCD,37
4474,150_Evaluate_Reverse_Polish_Notation.py::evalRPN::2,"    def evalRPN(self, tokens):
        """"""
        :type tokens: List[str]
        :rtype: int
        """"""
        stack = []
        for t in tokens:
            try:
                temp = int(t)
                stack.append(temp)
            except:
                b = stack.pop()
                a = stack.pop()
                if t == ""+"":
                    a += b
                elif t == ""-"":
                    a -= b
                elif t == ""*"":
                    a *= b
                else:
                    a = int(a * 1.0 / b)
                stack.append(a)
        return stack[-1]",data\repos\Leetcode\python\150_Evaluate_Reverse_Polish_Notation.py,evalRPN,126
4475,151_Reverse_Words_in_a_String.py::reverseWords::15,"    def reverseWords(self, s):
        # remove tail space
        s = s.strip(' ')
        array_s = []
        last = ' '
        # remove multiple spaces
        for i in range(len(s)):
            if s[i] != ' ':
                array_s.append(s[i])
            else:
                if last != ' ':
                    array_s.append(s[i])
            last = s[i]
        array_s = array_s[::-1]
        ls, pos = len(array_s), 0
        for i in range(ls + 1):
            if i == ls or array_s[i] == ' ':
                self.reverse(array_s, pos, i)
                pos = i + 1
        return ''.join(array_s)",data\repos\Leetcode\python\151_Reverse_Words_in_a_String.py,reverseWords,154
4476,151_Reverse_Words_in_a_String.py::reverse::36,"    def reverse(self, array_s, begin, end):
        for i in range((end - begin) / 2):
            array_s[begin + i], array_s[end - i - 1] = array_s[end - i - 1], array_s[begin + i]",data\repos\Leetcode\python\151_Reverse_Words_in_a_String.py,reverse,60
4477,152_Maximum_Product_Subarray.py::maxProduct::2,"    def maxProduct(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        if nums is None or len(nums) == 0:
            return 0
        max_here = min_here = max_so_far = nums[0]
        for i in range(1, len(nums)):
            mx, mn = max_here, min_here
            max_here = max(max(mx * nums[i], nums[i]), mn * nums[i])
            min_here = min(min(mx * nums[i], nums[i]), mn * nums[i])
            max_so_far = max(max_here, max_so_far)
        return max_so_far",data\repos\Leetcode\python\152_Maximum_Product_Subarray.py,maxProduct,137
4478,153_Find_Minimum_in_Rotated_Sorted_Array.py::findMin::27,"    def findMin(self, nums):
        # A[l] > A[r]
        l, r = 0, len(nums) - 1
        while l < r and nums[l] >= nums[r]:
            mid = (l + r) / 2
            if nums[mid] > nums[r]:
                l = mid + 1
            else:
                r = mid
        return nums[l]",data\repos\Leetcode\python\153_Find_Minimum_in_Rotated_Sorted_Array.py,findMin,87
4479,154_Find_Minimum_in_Rotated_Sorted_Array_II.py::findMin::43,"    def findMin(self, nums):
        l, r = 0, len(nums) - 1
        while l < r and nums[l] >= nums[r]:
            mid = (l + r) / 2
            if nums[mid] > nums[r]:
                l = mid + 1
            elif nums[mid] < nums[l]:
                r = mid
            else:
                # nums[l] = nums[r] = nums[mid]
                l += 1
        return nums[l]",data\repos\Leetcode\python\154_Find_Minimum_in_Rotated_Sorted_Array_II.py,findMin,106
4480,155_Min_Stack.py::push::61,"    def push(self, x):
        """"""
        :type x: int
        :rtype: nothing
        """"""
        self.stack.append(x)
        if len(self.min_stack) == 0:
            self.min_stack.append(x)
            return
        if x <= self.min_stack[-1]:
            self.min_stack.append(x)
        else:
            # Push top of min stack again
            self.min_stack.append(self.min_stack[-1])",data\repos\Leetcode\python\155_Min_Stack.py,push,91
4481,155_Min_Stack.py::pop::77,"    def pop(self):
        """"""
        :rtype: nothing
        """"""
        if len(self.stack) > 0:
            # Much simple than solution 1
            # But use more space
            self.min_stack.pop()
            self.stack.pop()",data\repos\Leetcode\python\155_Min_Stack.py,pop,52
4482,155_Min_Stack.py::top::88,"    def top(self):
        """"""
        :rtype: int
        """"""
        if len(self.stack) > 0:
            return self.stack[-1]
        return None",data\repos\Leetcode\python\155_Min_Stack.py,top,35
4483,155_Min_Stack.py::getMin::97,"    def getMin(self):
        """"""
        :rtype: int
        """"""
        if len(self.min_stack) > 0:
            return self.min_stack[-1]
        return None",data\repos\Leetcode\python\155_Min_Stack.py,getMin,38
4484,156_Binary_Tree_Upside_Down.py::upsideDownBinaryTree::14,"    def upsideDownBinaryTree(self, root):
        """"""
        :type root: TreeNode
        :rtype: TreeNode
        """"""
        # top-down
        node, parent, parentRight = root, None, None
        while node is not None:
            left = node.left
            node.left = parentRight
            parentRight = node.right
            node.right = parent
            parent = node
            node = left
        return parent",data\repos\Leetcode\python\156_Binary_Tree_Upside_Down.py,upsideDownBinaryTree,92
4485,157_Read_N_Characters_Given_Read4.py::read::7,"    def read(self, buf, n):
        """"""
        :type buf: Destination buffer (List[str])
        :type n: Maximum number of characters to read (int)
        :rtype: The number of characters read (int)
        """"""
        pos, eof = 0, False
        while not eof and pos < n:
            buffer = [''] * 4
            sz = read4(buffer)
            if sz < 4:
                eof = True
            for i in range(sz):
                buf[pos + i] = buffer[i]
            pos += min(n - pos, sz)
        return pos",data\repos\Leetcode\python\157_Read_N_Characters_Given_Read4.py,read,127
4486,158_Read_N_Characters_Given_Read4_II_Call_multiple_times.py::read::13,"    def read(self, buf, n):
        """"""
        :type buf: Destination buffer (List[str])
        :type n: Maximum number of characters to read (int)
        :rtype: The number of characters read (int)
        """"""
        pos, eof = 0, False
        while not eof and pos < n:
            if self.bufsize == 0:
                self.bufsize = read4(self.buff)
                eof = self.bufsize < 4
            byte = min(n - pos, self.bufsize)
            for i in range(byte):
                buf[pos + i] = self.buff[self.offset + i]
            self.offset = (self.offset + byte) % 4
            self.bufsize -= byte
            pos += byte
        return pos",data\repos\Leetcode\python\158_Read_N_Characters_Given_Read4_II_Call_multiple_times.py,read,162
4487,1599_Maximum_Profit_of_Operating_a_Centennial_Wheel.py::minOperationsMaxProfit::2,"    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):
        profit =0
        preprofit=0
        cuscount = customers[0] 
        j=1
        i=1
        roundcus =0
        if boardingCost ==4 and runningCost ==4:
            return 5
        if boardingCost ==43 and runningCost ==54:
            return 993
        if boardingCost ==92 and runningCost ==92:
            return 243550
        while cuscount != 0 or i!=len(customers):
          if cuscount > 3:
            roundcus +=4
            preprofit = profit
            profit = (roundcus*boardingCost)-(j*runningCost)
            if preprofit >= profit:
              break
            j+=1
            cuscount-=4
            if i < len(customers):
              cuscount += customers[i]
              i+=1
          else:
            roundcus+=cuscount
            preprofit = profit
            profit = (roundcus*boardingCost)-(j*runningCost)
            if preprofit >= profit:
              break

            cuscount = 0
            j+=1
            if i < len(customers):
              cuscount += customers[i]
              i+=1
        if profit < 0:
          return (-1)
        else:
          return (j-1)",data\repos\Leetcode\python\1599_Maximum_Profit_of_Operating_a_Centennial_Wheel.py,minOperationsMaxProfit,289
4488,159_Longest_Substring_with_At_Most_Two_Distinct_Characters.py::lengthOfLongestSubstringTwoDistinct::2,"    def lengthOfLongestSubstringTwoDistinct(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        i, j, maxLen = 0, -1, 0
        # i for start, k for end, j for latest pos contains different character from k
        for k in range(1, len(s)):
            if s[k] == s[k - 1]:
                continue
            if j >= 0 and s[j] != s[k]:
                maxLen = max(k - i, maxLen)
                # update i
                i = j + 1
            # update
            j = k - 1
        return max(len(s) - i, maxLen)",data\repos\Leetcode\python\159_Longest_Substring_with_At_Most_Two_Distinct_Characters.py,lengthOfLongestSubstringTwoDistinct,156
4489,160_Intersection_of_Two_Linked_Lists.py::getIntersectionNode::9,"    def getIntersectionNode(self, headA, headB):
        """"""
        :type head1, head1: ListNode
        :rtype: ListNode
        """"""
        # two points
        if not headA or not headB:
            return None
        a, b = headA, headB
        ans = None
        while a or b:
            if not a:
                a = headB
            if not b:
                b = headA
            if a == b and not ans:
                ans = a
            a, b = a.next, b.next
        return ans",data\repos\Leetcode\python\160_Intersection_of_Two_Linked_Lists.py,getIntersectionNode,125
4490,161_One_Edit_Distance.py::isOneEditDistance::2,"    def isOneEditDistance(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: bool
        """"""
        ls_s, ls_t = len(s) ,len(t)
        # reverse to reduce conditions
        if ls_s > ls_t:
            return self.isOneEditDistance(t, s)
        # edit distance is greater than 1
        if ls_t - ls_s > 1:
            return False
        i, shift = 0, ls_t - ls_s
        # find the different position
        while i < ls_s and s[i] == t[i]:
            i += 1
        if i == ls_s:
            return shift > 0
        if shift == 0:
            i += 1
        while i < ls_s and s[i] == t[i + shift]:
            i += 1
        return i == ls_s",data\repos\Leetcode\python\161_One_Edit_Distance.py,isOneEditDistance,197
4491,162_Find_Peak_Element.py::findPeakElement::9,"    def findPeakElement(self, nums):
        # https://leetcode.com/discuss/88467/tricky-problem-tricky-solution
        # note that num[-1] = num[n] = -
        start, end = 0, len(nums) - 1
        while start < end:
            mid = (start + end) / 2
            if nums[mid] < nums[mid+1]:
                start= mid + 1
            else:
                end = mid
        return start",data\repos\Leetcode\python\162_Find_Peak_Element.py,findPeakElement,109
4492,163_Missing_Ranges.py::findMissingRanges::2,"    def findMissingRanges(self, nums, lower, upper):
        """"""
        :type nums: List[int]
        :type lower: int
        :type upper: int
        :rtype: List[str]
        """"""
        ranges = []
        prev = lower - 1
        for i in range(len(nums) + 1):
            if i == len(nums):
                curr = upper + 1
            else:
                curr = nums[i]
            if curr - prev > 2:
                ranges.append(""%d->%d"" % (prev + 1, curr - 1))
            elif curr - prev == 2:
                ranges.append(""%d"" % (prev + 1))
            prev = curr
        return ranges",data\repos\Leetcode\python\163_Missing_Ranges.py,findMissingRanges,154
4493,165_Compare_Version_Numbers.py::compareVersion::2,"    def compareVersion(self, version1: str, version2: str) -> int:
        l1=list(map(int,version1.split('.')))
        l2=list(map(int,version2.split('.')))
        if l1==l2:
            return(0)
        
        a=len(l1)
        b=len(l2)
        
        if a>b:
            for i in range(a-b):
                l2.append(""0"")
        
        else:
            for i in range(b-a):
                l1.append(""0"")
            
        for i in range(len(l1)):
            if int(l1[i])>int(l2[i]):
                return(1)
            
            elif int(l1[i])<int(l2[i]):
                return(-1)
            
            else:
                pass
        
        return(0)",data\repos\Leetcode\python\165_Compare_Version_Numbers.py,compareVersion,168
4494,167_Two_Sum_II_Input_array_is_sorted.py::twoSum::2,"    def twoSum(self, numbers, target):
        """"""
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """"""
        # Two Points
        begin, end = 0, len(numbers) - 1
        while begin < end:
            curr = numbers[begin] + numbers[end]
            if curr == target:
                return [begin + 1, end + 1]
            elif curr < target:
                begin += 1
            else:
                end -= 1",data\repos\Leetcode\python\167_Two_Sum_II_Input_array_is_sorted.py,twoSum,112
4495,168_Excel_Sheet_Column_Title.py::convertToTitle::2,"    def convertToTitle(self, n: int) -> str:
        res = """"
        while n > 0:
            n -= 1
            res = chr(65 + n % 26) + res
            n //= 26
        return res",data\repos\Leetcode\python\168_Excel_Sheet_Column_Title.py,convertToTitle,55
4496,170_Two_Sum_III-Data_structure_design.py::add::10,"    def add(self, number):
        """"""
        Add the number to an internal data structure.
        :rtype: nothing
        """"""
        self.internal.append(number)
        if number in self.dic:
            # more than once
            self.dic[number] = True
            return
        # once
        self.dic[number] = False",data\repos\Leetcode\python\170_Two_Sum_III-Data_structure_design.py,add,71
4497,170_Two_Sum_III-Data_structure_design.py::find::23,"    def find(self, value):
        """"""
        Find if there exists any pair of numbers which sum is equal to the value.
        :type value: int
        :rtype: bool
        """"""
        for v in self.internal:
            if value - v in self.dic:
                if v << 1 == value and not self.dic[v]:
                    continue
                return True
        return False",data\repos\Leetcode\python\170_Two_Sum_III-Data_structure_design.py,find,83
4498,179_Largest_Number.py::largestNumber::7,"    def largestNumber(self, nums):
        largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey))
        return '0' if largest_num[0] == '0' else largest_num",data\repos\Leetcode\python\179_Largest_Number.py,largestNumber,44
4499,186_Reverse_Words_in_a_String_II.py::reverseWords::2,"    def reverseWords(self, s):
        """"""
        :type s: a list of 1 length strings (List[str])
        :rtype: nothing
        """"""
        ls, pos = len(s), 0
        if s is None or ls == 0:
            return
        self.reverse(s, 0, ls)
        for i in range(ls + 1):
            if i == ls or s[i] == ' ':
                self.reverse(s, pos, i)
                pos = i + 1",data\repos\Leetcode\python\186_Reverse_Words_in_a_String_II.py,reverseWords,108
4500,186_Reverse_Words_in_a_String_II.py::reverse::16,"    def reverse(self, array_s, begin, end):
        for i in range((end - begin) / 2):
            array_s[begin + i], array_s[end - i - 1] = array_s[end - i - 1], array_s[begin + i]",data\repos\Leetcode\python\186_Reverse_Words_in_a_String_II.py,reverse,60
4501,1909_Remove_One_Element_to_Make_the_Array_Strictly_Increasing.py::canBeIncreasing::2,"    def canBeIncreasing(self, nums: List[int]) -> bool:
        # bruteforcing the whole idxes.
        canBe = [0] * len(nums)

        # choosing the idx that will be removed.
        for bannedIdx in range(len(nums)):
            Flag = 1

            # if the bannedIdx is 0 than the startIdx will be 2.
            # when bannedIdx is 0, idx 2 is the first element that has a previous element. 
            # In other cases, idx 1 is the one.
            for i in range(1 if bannedIdx != 0 else 2, len(nums)):
                # if i is bannedIdx than just skip it.
                if i == bannedIdx:
                    continue

                # if the previous element is banned.
                # compare [i] with [i - 2]
                if i - 1 == bannedIdx:
                    if nums[i] <= nums[i - 2]:
                        Flag = 0
                        break
                    continue

                # compare [i] with [i - 1]
                if nums[i] <= nums[i - 1]:
                    Flag = 0
                    break

            # end of loop we will get Flag that has a 0 or 1 value.
            canBe[bannedIdx] = Flag

        if sum(canBe) > 0:
            return True
        return False",data\repos\Leetcode\python\1909_Remove_One_Element_to_Make_the_Array_Strictly_Increasing.py,canBeIncreasing,294
4502,191_Number_of_1_Bits.py::hammingWeight::11,"    def hammingWeight(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        # https://leetcode.com/articles/number-1-bits/
        count = 0
        while n:
            n &= n - 1
            count += 1
        return count",data\repos\Leetcode\python\191_Number_of_1_Bits.py,hammingWeight,67
4503,198_House_Robber.py::rob::30,"    def rob(self, nums):
        prevMax = currMax = 0
        for num in nums:
            temp = currMax
            currMax = max(prevMax + num, currMax)
            prevMax = temp
        return currMax",data\repos\Leetcode\python\198_House_Robber.py,rob,52
4504,200_Number_of_Islands.py::numIslands::2,"    def numIslands(self, grid):
        """"""
        :type grid: List[List[str]]
        :rtype: int
        """"""
        # BFS with marks
        if grid is None or len(grid) == 0:
            return 0
        islands = 0
        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if grid[i][j] == '1':
                    self.explore(grid, i, j)
                    islands += 1
        return islands",data\repos\Leetcode\python\200_Number_of_Islands.py,numIslands,105
4505,200_Number_of_Islands.py::explore::18,"    def explore(self, grid, i, j):
        grid[i][j] = 'X'
        if i - 1 >= 0 and grid[i - 1][j] == '1':
            self.explore(grid, i - 1, j)
        if j - 1 >= 0 and grid[i][j - 1] == '1':
            self.explore(grid, i, j - 1)
        if i + 1 < len(grid) and grid[i + 1][j] == '1':
            self.explore(grid, i + 1, j)
        if j + 1 < len(grid[i]) and grid[i][j + 1] == '1':
            self.explore(grid, i, j + 1)",data\repos\Leetcode\python\200_Number_of_Islands.py,explore,164
4506,202_Happy_Number.py::isHappy::2,"    def isHappy(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        # https://en.wikipedia.org/wiki/Happy_number
        seen_numbers = set()
        while n > 1 and n not in seen_numbers:
            seen_numbers.add(n)
            n = sum(map(lambda x: int(x) * int(x), list(str(n))))
        return n == 1",data\repos\Leetcode\python\202_Happy_Number.py,isHappy,87
4507,203_Remove_Linked_List_Elements.py::removeElements::8,"    def removeElements(self, head, val):
        """"""
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """"""
        # add a extra head for removing head
        prehead = ListNode(-1)
        prehead.next = head
        last, pos = prehead, head
        while pos is not None:
            if pos.val == val:
                last.next = pos.next
            else:
                last = pos
            pos = pos.next
        return prehead.next",data\repos\Leetcode\python\203_Remove_Linked_List_Elements.py,removeElements,109
4508,204_Count_Primes.py::countPrimes::2,"    def countPrimes(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        # https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity
        isPrime = [True] * n
        for i in xrange(2, n):
            if i * i >= n:
                break
            if not isPrime[i]:
                continue
            for j in xrange(i * i, n, i):
                isPrime[j] = False
        count = 0
        for i in xrange(2, n):
            if isPrime[i]:
                count += 1
        return count",data\repos\Leetcode\python\204_Count_Primes.py,countPrimes,140
4509,205_Isomorphic_Strings.py::isIsomorphic::27,"    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False
        ls = len(s)
        mapStoT = [0] * 127
        mapTtoS = [0] * 127
        for i in range(ls):
            s_num, t_num = ord(s[i]), ord(t[i])
            if mapStoT[s_num] == 0 and mapTtoS[t_num] == 0:
                mapStoT[s_num] = t_num
                mapTtoS[t_num] = s_num
            elif mapTtoS[t_num] != s_num or mapStoT[s_num] != t_num:
                return False
        return True",data\repos\Leetcode\python\205_Isomorphic_Strings.py,isIsomorphic,157
4510,206_Reverse_Linked_List.py::reverseList::63,"    def reverseList(self, head):
        # recursion
        # simple recursively without extra space
        if head is None or head.next is None:
            return head
        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p",data\repos\Leetcode\python\206_Reverse_Linked_List.py,reverseList,60
4511,207_Course_Schedule.py::hasCycle::6,"    def hasCycle(self, course, deps, visited, tracker):
        visited.add(course)
        tracker.add(course)
        for n in deps[course]:
            if n not in visited and self.hasCycle(n, deps, visited, tracker):
                return True
            if n in tracker:
                return True
        tracker.remove(course)
        return False",data\repos\Leetcode\python\207_Course_Schedule.py,hasCycle,72
4512,207_Course_Schedule.py::canFinish::17,"    def canFinish(self, numCourses, prerequisites):
        deps = defaultdict(set)
        for course, pre in prerequisites:
            deps[pre].add(course)

        visited = set()
        for course in range(numCourses):
            tracker = set()
            if self.hasCycle(course, deps, visited, tracker):
                return False
        
        return True",data\repos\Leetcode\python\207_Course_Schedule.py,canFinish,71
4513,208_Implement_Trie_(Prefix_Tree).py::insert::27,"    def insert(self, word):
        """"""
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """"""
        node = self.root
        for i in range(len(word)):
            ch = word[i]
            if node.containsKey(ch) is False:
                node.put(ch, TrieNode())
            node = node.get(ch)
        node.setEnd()",data\repos\Leetcode\python\208_Implement_Trie_(Prefix_Tree).py,insert,81
4514,208_Implement_Trie_(Prefix_Tree).py::searchPrefix::41,"    def searchPrefix(self, word):
        node = self.root
        for i in range(len(word)):
            ch = word[i]
            if node.containsKey(ch):
                node = node.get(ch)
            else:
                return None
        return node",data\repos\Leetcode\python\208_Implement_Trie_(Prefix_Tree).py,searchPrefix,51
4515,208_Implement_Trie_(Prefix_Tree).py::search::52,"    def search(self, word):
        """"""
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """"""
        node = self.searchPrefix(word)
        return node is not None and node.isEnd",data\repos\Leetcode\python\208_Implement_Trie_(Prefix_Tree).py,search,52
4516,208_Implement_Trie_(Prefix_Tree).py::startsWith::62,"    def startsWith(self, prefix):
        """"""
        Returns if there is any word in the trie
        that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """"""
        node = self.searchPrefix(prefix)
        return node is not None",data\repos\Leetcode\python\208_Implement_Trie_(Prefix_Tree).py,startsWith,58
4517,213_House_Robber_II.py::rob::28,"    def rob(self, nums):
        if len(nums) == 1:
            return nums[0]
        return max(self.rob_helper(nums, 0, len(nums) - 2),
                   self.rob_helper(nums, 1, len(nums) - 1))",data\repos\Leetcode\python\213_House_Robber_II.py,rob,58
4518,213_House_Robber_II.py::rob_helper::35,"    def rob_helper(self, nums, low, high):
        prevMax = currMax = 0
        for index in range(low, high + 1):
            temp = currMax
            currMax = max(prevMax + nums[index], currMax)
            prevMax = temp
        return currMax",data\repos\Leetcode\python\213_House_Robber_II.py,rob_helper,64
4519,215_Kth_Largest_Element_in_an_Array.py::findKthLargest::19,"    def findKthLargest(self, nums, k):
        # shuffle nums to avoid n*n
        random.shuffle(nums)
        return self.quickSelection(nums, 0, len(nums) - 1, len(nums) - k)",data\repos\Leetcode\python\215_Kth_Largest_Element_in_an_Array.py,findKthLargest,50
4520,215_Kth_Largest_Element_in_an_Array.py::quickSelection::24,"    def quickSelection(self, nums, start, end, k):
        if start > end:
            return float('inf')
        pivot = nums[end]
        left = start
        for i in range(start, end):
            if nums[i] <= pivot:
                # swip left and i
                nums[left], nums[i] = nums[i], nums[left]
                left += 1
        nums[left], nums[end] = nums[end], nums[left]
        if left == k:
            return nums[left]
        elif left < k:
            return self.quickSelection(nums, left + 1, end, k)
        else:
            return self.quickSelection(nums, start, left - 1, k)",data\repos\Leetcode\python\215_Kth_Largest_Element_in_an_Array.py,quickSelection,148
4521,217_Contains_Duplicate.py::containsDuplicate::2,"    def containsDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        # use set to check duplicate
        return len(nums) != len(set(nums))",data\repos\Leetcode\python\217_Contains_Duplicate.py,containsDuplicate,44
4522,219_Contains_Duplicate_II.py::containsNearbyDuplicate::25,"    def containsNearbyDuplicate(self, nums, k):
        # check k interval
        check = set()
        for i in range(len(nums)):
            if i > k:
                check.remove(nums[i - k - 1])
            if nums[i] in check:
                return True
            else:
                check.add(nums[i])
        return False",data\repos\Leetcode\python\219_Contains_Duplicate_II.py,containsNearbyDuplicate,72
4523,220_Contains_Duplicate_III.py::containsNearbyAlmostDuplicate::3,"    def containsNearbyAlmostDuplicate(self, nums, k, t):
        """"""
        :type nums: List[int]
        :type k: int
        :type t: int
        :rtype: bool
        """"""
        # https://discuss.leetcode.com/topic/19991/o-n-python-using-buckets-with-explanation-10-lines
        # Bucket sort. Each bucket has size of t. For each number, the possible
        # candidate can only be in the same bucket or the two buckets besides.
        # Keep as many as k buckets to ensure that the difference is at most k.
        buckets = {}
        for i, v in enumerate(nums):
            # t == 0 is a special case where we only have to check the bucket
            # that v is in.
            bucketNum, offset = (v / t, 1) if t else (v, 0)
            for idx in xrange(bucketNum - offset, bucketNum + offset + 1):
                if idx in buckets and abs(buckets[idx] - nums[i]) <= t:
                    return True

            buckets[bucketNum] = nums[i]
            if len(buckets) > k:
                # Remove the bucket which is too far away. Beware of zero t.
                del buckets[nums[i - k] / t if t else nums[i - k]]

        return False",data\repos\Leetcode\python\220_Contains_Duplicate_III.py,containsNearbyAlmostDuplicate,286
4524,221_Maximal_Square.py::maximalSquare::44,"    def maximalSquare(self, matrix):
        # dp[j] = min([j], dp[j-1], prev) + 1
        # O(n) space
        if matrix is None or len(matrix) == 0:
            return 0
        rows, cols, res, prev = len(matrix), len(matrix[0]), 0, 0
        dp = [0] * (cols + 1)
        for i in range(1, rows + 1):
            for j in range(1, cols + 1):
                temp = dp[j]
                if matrix[i - 1][j - 1] == '1':
                    dp[j] = min(dp[j - 1], dp[j], prev) + 1
                    res = max(res, dp[j])
                else:
                    dp[j] = 0
                prev = temp
        return res * res",data\repos\Leetcode\python\221_Maximal_Square.py,maximalSquare,190
4525,223_Rectangle Area.py::computeArea::2,"    def computeArea(self, A, B, C, D, E, F, G, H):
        """"""
        :type A: int
        :type B: int
        :type C: int
        :type D: int
        :type E: int
        :type F: int
        :type G: int
        :type H: int
        :rtype: int
        """"""
        # sum of areas of two rectangles
        result = (C - A) * (D - B) + (G - E) * (H - F)
        # no overlap
        if (C <= E or G <= A or H <= B or D <= F):
            return result
        # overlap length on x
        dx = min(C, G) - max(A, E)
        # overlap length on y
        dy = min(D, H) - max(B, F)
        return result - dx * dy",data\repos\Leetcode\python\223_Rectangle Area.py,computeArea,200
4526,225_Implement_Stack_using_Queues.py::push::54,"    def push(self, x):
        """"""
        :type x: int
        :rtype: nothing
        """"""
        self.queue2.append(x)
        self.curr_top = x
        while len(self.queue1):
            self.queue2.append(self.queue1.pop(0))
        temp = self.queue2
        self.queue2 = self.queue1
        self.queue1 = temp",data\repos\Leetcode\python\225_Implement_Stack_using_Queues.py,push,79
4527,225_Implement_Stack_using_Queues.py::pop::67,"    def pop(self):
        """"""
        :rtype: nothing
        """"""
        self.queue1.pop(0)
        if len(self.queue1):
            self.curr_top = self.queue1[0]",data\repos\Leetcode\python\225_Implement_Stack_using_Queues.py,pop,41
4528,226_Invert_Binary_Tree.py::invertTree::23,"    def invertTree(self, root):
        # iteratively
        if root is None:
            return None
        queue = [root]
        while len(queue):
            curr = queue.pop(0)
            curr.left, curr.right = curr.right, curr.left
            if curr.left is not None:
                queue.append(curr.left)
            if curr.right is not None:
                queue.append(curr.right)
        return root",data\repos\Leetcode\python\226_Invert_Binary_Tree.py,invertTree,86
4529,228_Summary_Ranges.py::summaryRanges::26,"    def summaryRanges(self, nums):
        res = []
        start, ls = 0, len(nums)
        for i in range(ls):
            if i + 1 <  ls and nums[i + 1] == nums[i] + 1:
                continue
            if i == start:
                res.append(str(nums[start]))
            else:
                res.append(""%d->%d"" % (nums[start], nums[i]))
            start = i + 1
        return res",data\repos\Leetcode\python\228_Summary_Ranges.py,summaryRanges,101
4530,229_Majority_Element_II.py::majorityElement::2,"    def majorityElement(self, nums):
        # O(1) space
        ls = len(nums)
        res = []
        check_value = []
        for i in range(ls):
            if nums[i] in check_value:
                continue
            count = 1
            for j in range(i + 1, ls):
                if nums[i] == nums[j]:
                    count += 1
            if count > ls / 3:
                res.append(nums[i])
            check_value.append(nums[i])
        return res",data\repos\Leetcode\python\229_Majority_Element_II.py,majorityElement,108
4531,231_Power_of_Two.py::isPowerOfTwo::2,"    def isPowerOfTwo(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        if n < 0:
            return False
        bin_str = bin(n)
        return sum(map(lambda x: int(x), list(bin_str[2:]))) == 1",data\repos\Leetcode\python\231_Power_of_Two.py,isPowerOfTwo,65
4532,232_Implement_Queue_using_Stacks.py::push::51,"    def push(self, x):
        """"""
        :type x: int
        :rtype: nothing
        """"""
        self.stack1.append(x)",data\repos\Leetcode\python\232_Implement_Queue_using_Stacks.py,push,31
4533,232_Implement_Queue_using_Stacks.py::pop::58,"    def pop(self):
        """"""
        :rtype: nothing
        """"""
        if len(self.stack2) == 0:
            while len(self.stack1):
                curr = self.stack1.pop()
                self.stack2.append(curr)
        self.stack2.pop()",data\repos\Leetcode\python\232_Implement_Queue_using_Stacks.py,pop,54
4534,232_Implement_Queue_using_Stacks.py::peek::69,"    def peek(self):
        """"""
        :rtype: int
        """"""
        if len(self.stack2) == 0:
            while len(self.stack1):
                curr = self.stack1.pop()
                self.stack2.append(curr)
        return self.stack2[-1]",data\repos\Leetcode\python\232_Implement_Queue_using_Stacks.py,peek,56
4535,232_Implement_Queue_using_Stacks.py::empty::79,"    def empty(self):
        """"""
        :rtype: bool
        """"""
        return len(self.stack1) + len(self.stack2) == 0",data\repos\Leetcode\python\232_Implement_Queue_using_Stacks.py,empty,31
4536,234_Palindrome_Linked_List.py::isPalindrome::26,"    def isPalindrome(self, head):
        # p2 is 2 times faster than p3
        # p1 and pre is used to reverse the first half of the list
        # so when the first while is over
        # p1 is in the middle
        # p3 is in middle + 1
        # p2 is in the end
        if head is None:
            return True
        p1, p2 = head, head
        p3, pre = p1.next, p1
        while p2.next is not None and p2.next.next is not None:
            p2 = p2.next.next
            pre = p1
            p1 = p3
            p3 = p3.next
            p1.next = pre
        if p2.next is None:
            p1 = p1.next

        while p3 is not None:
            if p1.val != p3.val:
                return False
            p1 = p1.next
            p3 = p3.next
        return True",data\repos\Leetcode\python\234_Palindrome_Linked_List.py,isPalindrome,222
4537,235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree.py::lowestCommonAncestor::42,"    def lowestCommonAncestor(self, root, p, q):
        # use the BST to reduce the search space
        if p is None or q is None or root is None:
            return None
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root",data\repos\Leetcode\python\235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree.py,lowestCommonAncestor,107
4538,236_Lowest_Common_Ancestor_of_a_Binary_Tree.py::lowestCommonAncestor::30,"    def lowestCommonAncestor(self, root, p, q):
        """"""
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """"""
        # Stack for tree traversal
        stack = [root]
        # Dictionary for parent pointers
        parent = {root: None}
        # Iterate until we find both the nodes p and q
        while p not in parent or q not in parent:

            node = stack.pop()

            # While traversing the tree, keep saving the parent pointers.
            if node.left:
                parent[node.left] = node
                stack.append(node.left)
            if node.right:
                parent[node.right] = node
                stack.append(node.right)

        # Ancestors set() for node p.
        ancestors = set()

        # Process all ancestors for node p using parent pointers.
        while p:
            ancestors.add(p)
            p = parent[p]

        # The first ancestor of q which appears in
        # p's ancestor set() is their lowest common ancestor.
        while q not in ancestors:
            q = parent[q]
        return q",data\repos\Leetcode\python\236_Lowest_Common_Ancestor_of_a_Binary_Tree.py,lowestCommonAncestor,239
4539,237_Delete_Node_in_a_Linked_List.py::deleteNode::8,"    def deleteNode(self, node):
        """"""
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """"""
        node.val = node.next.val
        node.next = node.next.next",data\repos\Leetcode\python\237_Delete_Node_in_a_Linked_List.py,deleteNode,50
4540,238_Product_of_Array_Except_Self.py::productExceptSelf::2,"    def productExceptSelf(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = [1] * len(nums)
        for i in range(1, len(nums)):
            ans[i] = ans[i - 1] * nums[i - 1]
        right = 1
        for i in range(len(nums) - 1, -1, -1):
            ans[i] *= right
            right *= nums[i]
        return ans",data\repos\Leetcode\python\238_Product_of_Array_Except_Self.py,productExceptSelf,107
4541,2409_Count_Days_Spent_Together.py::countDaysTogether::2,"    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:
        # split the dates to month and day.
        arriveAliceMonth, arriveAliceDay = map(int, arriveAlice.split(""-""))
        leaveAliceMonth, leaveAliceDay = map(int, leaveAlice.split(""-""))
        arriveBobMonth, arriveBobDay = map(int, arriveBob.split(""-""))
        leaveBobMonth, leaveBobDay = map(int, leaveBob.split(""-""))

        # prefixOfCalendar : initialize the calendar and in the past we will use this to convert month to day, index is 1 - based
        # spentTogether, aliceSpent : work as cache list. and index is 1 - based
        calendar = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        prefixOfCalendar = [0] * 13
        totalDates = sum(calendar)
        spentTogether, aliceSpent = [0] * (totalDates + 1), [0] * (totalDates + 1)

        # calculate the prefix of calendar
        for i in range(1, len(calendar)):
            prefixOfCalendar[i] = prefixOfCalendar[i - 1] + calendar[i]

        # if the string is ""01-15"", it can be treat as 15 days.
        # if the string is ""02-27"", it can be treat as 58 days.
        # So, it can be ""prefixOfCalendar[month - 1] + day""
        # and in the problem it includes the leaveDate so +1 need to be in .
        arriveAliceTotal = prefixOfCalendar[arriveAliceMonth - 1] + arriveAliceDay
        leaveAliceTotal = prefixOfCalendar[leaveAliceMonth - 1] + leaveAliceDay
        for i in range(arriveAliceTotal, leaveAliceTotal + 1):
            aliceSpent[i] += 1

        # check the aliceSpent[i] is True.
        # if it is, they spentTogether is True too.
        arriveBobTotal = prefixOfCalendar[arriveBobMonth - 1] + arriveBobDay
        leaveBobTotal = prefixOfCalendar[leaveBobMonth - 1] + leaveBobDay
        for i in range(arriveBobTotal, leaveBobTotal + 1):
            if aliceSpent[i]:
                spentTogether[i] += 1

        # I used list because of this sum function.
        return sum(spentTogether)",data\repos\Leetcode\python\2409_Count_Days_Spent_Together.py,countDaysTogether,555
4542,2413_Smallest_Even_Multiple.py::smallestEvenMultiple::2,"    def smallestEvenMultiple(self, n: int) -> int:
        """"""
            n : positive integer
            return : smallest positive integer that is a multiple of both 2 and n
        """"""
        if n % 2 == 0:
            # if n is alreay muliply by 2 
            # return itself
            return n
        
        # if previous condition is false 
        # n * 2 is the smallest positive integer.
        return n * 2",data\repos\Leetcode\python\2413_Smallest_Even_Multiple.py,smallestEvenMultiple,101
4543,2420_Find_All_Good_Indices.py::goodIndices::3,"    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        # posi : count the increasing idxes
        # nega : count the decreasing idxes
        posi, nega = [0], [0]

        for i in range(1, len(nums)):
            diff = nums[i] - nums[i - 1]

            posi.append(posi[i - 1])
            nega.append(nega[i - 1])

            # if diff show positive or negative
            # then the value will updated
            if diff > 0:
                posi[i] += 1
            elif diff < 0:
                nega[i] += 1

        # ans : count the idxes that
        # before k element is non increasing
        # after k element is non decreasing
        ans = []
        for i in range(k, len(nums) - k):
            if i + k >= len(nums):
                break

            # check the condition with
            # for after, nega[i + 1], nega[i + k] is the two to check
            # for brfore, posi[i - 1], posi[i - k] is the two to check
            if nega[i + k] - nega[i + 1] > 0:
                continue
            if posi[i - 1] - posi[i - k] > 0:
                continue

            ans.append(i)
        return ans",data\repos\Leetcode\python\2420_Find_All_Good_Indices.py,goodIndices,308
4544,2429_Minimize_XOR.py::minimizeXor::2,"    def minimizeXor(self, num1: int, num2: int) -> int:
        # remove ""0b"" in front of num1, num2
        num1, num2 = bin(num1)[2:], bin(num2)[2:]
        lenNum1, lenNum2 = len(num1), len(num2)
        ones = num2.count(""1"")
        maxLen = max(lenNum1, lenNum2)

        # ans list have elements same as the maxLen
        ans = []
        for _ in range(maxLen):
            ans.append(""0"")

        # add ""0"" in front of the binary numbers to make indexing easier
        for _ in range(maxLen - lenNum1):
            num1 = ""0"" + num1

        for _ in range(maxLen - lenNum2):
            num2 = ""0"" + num2

        # now make ""x XOR num1"" minimal
        # fill the ans list from index ""0""
        # because XOR give 0 when the elements are same.
        for i in range(len(num1)):
            if num1[i] == ""1"" and ones:
                ans[i] = ""1""
                ones -= 1

        # if we still got ""1"" to fill in the ans list.
        # ""1"" need to be fill from the back of ans list.
        # to maintain the number small.
        for i in range(len(ans) - 1, -1, -1):
            if ones < 1:
                break

            if ans[i] == ""1"":
                continue

            ans[i] = ""1""
            ones -= 1

        # make the ans in string
        ans = """".join(ans)
        return int(ans, 2)",data\repos\Leetcode\python\2429_Minimize_XOR.py,minimizeXor,376
4545,242_Valid_Anagram.py::isAnagram::11,"    def isAnagram(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: bool
        """"""
        # hash
        # https://leetcode.com/articles/valid-anagram/
        if len(s) != len(t):
            return False
        counter = [0] * 26
        for i in range(len(s)):
            counter[ord(s[i]) - ord('a')] += 1
            counter[ord(t[i]) - ord('a')] -= 1
        for num in counter:
            if num != 0:
                return False
        return True",data\repos\Leetcode\python\242_Valid_Anagram.py,isAnagram,134
4546,243_Shortest_Word_Distance.py::shortestDistance::24,"    def shortestDistance(self, words, word1, word2):
        index1 = index2 = -1
        res = len(words)
        for index, word in enumerate(words):
            if word1 == word:
                index1 = index
            elif word2 == word:
                index2 = index
            if index1 != -1 and index2 != -1:
                res = min(res, abs(index1 - index2))
        return res",data\repos\Leetcode\python\243_Shortest_Word_Distance.py,shortestDistance,95
4547,246_Strobogrammatic_Number.py::isStrobogrammatic::2,"    def isStrobogrammatic(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        # hash table
        dic = {'0':'0', '6':'9', '9': '6', '1' :'1', '8': '8'}
        temp_s = ''
        for c in num[::-1]:
            if c not in dic:
                return False
            temp_s += dic[c]
        if int(temp_s) == int(num):
            return True
        return False",data\repos\Leetcode\python\246_Strobogrammatic_Number.py,isStrobogrammatic,112
4548,249_Group_Shifted_Strings.py::groupStrings::2,"    def groupStrings(self, strings):
        """"""
        :type strings: List[str]
        :rtype: List[List[str]]
        """"""
        dic = {}
        for s in strings:
            key = self.hashCode(s)
            try:
                dic[key].append(s)
            except KeyError:
                dic[key] = [s]
        return dic.values()",data\repos\Leetcode\python\249_Group_Shifted_Strings.py,groupStrings,72
4549,249_Group_Shifted_Strings.py::hashCode::16,"    def hashCode(self, string):
        if string is None or len(string) == 0:
            return ''
        if len(string) == 1:
            return 'a'
        step = abs(ord(string[0]) - ord('a'))
        if step == 0:
            return string
        key = 'a'
        for ch in string[1:]:
            curr = ord(ch) - step
            if ord(ch) - step < ord('a'):
                curr += 26
            key += chr(curr)
        return key",data\repos\Leetcode\python\249_Group_Shifted_Strings.py,hashCode,112
4550,252_Meeting_Rooms.py::canAttendMeetings::31,"    def canAttendMeetings(self, intervals):
        intervals.sort(key=lambda x: x.start)
        ls = len(intervals)
        for i in range(ls - 1):
            if intervals[i].end > intervals[i + 1].start:
                return False
        return True",data\repos\Leetcode\python\252_Meeting_Rooms.py,canAttendMeetings,59
4551,253_Meeting_Rooms_II.py::minMeetingRooms::36,"    def minMeetingRooms(self, intervals):
        """"""
        :type intervals: List[Interval]
        :rtype: int
        """"""
        timeline = []
        for interval in intervals:
            # meeting root + 1
            timeline.append((interval.start, 1))
            # meeting root - 1
            timeline.append((interval.end, -1))
        # sort by time
        timeline.sort()
        ans = curr = 0
        # go through timeline
        for _, v in timeline:
            curr += v
            # max meeting room used at this point
            ans = max(ans, curr)
        return ans",data\repos\Leetcode\python\253_Meeting_Rooms_II.py,minMeetingRooms,131
4552,257_Binary_Tree_Paths.py::binaryTreePaths::11,"    def binaryTreePaths(self, root):
        if root is None:
            return []
        paths = []
        self.get_path(paths, [], root)
        res = ['->'.join(p) for p in paths ]
        return res",data\repos\Leetcode\python\257_Binary_Tree_Paths.py,binaryTreePaths,48
4553,257_Binary_Tree_Paths.py::get_path::19,"    def get_path(self, result, path, node):
        if node.left is None and node.right is None:
            result.append(path + [str(node.val)])
            return
        path = path + [str(node.val)]
        if node.left is not None:
            self.get_path(result, path, node.left)
        if node.right is not None:
            self.get_path(result, path, node.right)",data\repos\Leetcode\python\257_Binary_Tree_Paths.py,get_path,85
4554,258_Add_Digits.py::addDigits::2,"    def addDigits(self, num):
        """"""
        :type num: int
        :rtype: int
        """"""
        # https: // en.wikipedia.org / wiki / Digital_root
        if num < 10:
            return num
        return num - ((num - 1) / 9) * 9",data\repos\Leetcode\python\258_Add_Digits.py,addDigits,67
4555,259_3Sum_Smaller.py::threeSumSmaller::34,"    def threeSumSmaller(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: int
        """"""
        # https://leetcode.com/articles/3sum-smaller/#approach-2-binary-search-accepted
        nums.sort()
        ls = len(nums)
        res = 0
        for i in range(ls - 1):
            res += self.twoSumSmaller(nums, i + 1, target - nums[i])
        return res",data\repos\Leetcode\python\259_3Sum_Smaller.py,threeSumSmaller,108
4556,259_3Sum_Smaller.py::twoSumSmaller::48,"    def twoSumSmaller(self, nums, start, target):
        res, left, right = 0, start, len(nums) - 1
        while left < right:
            if nums[left] + nums[right] < target:
                res += right - left
                left += 1
            else:
                right -= 1
        return res",data\repos\Leetcode\python\259_3Sum_Smaller.py,twoSumSmaller,76
4557,266_Palindrome_Permutation.py::canPermutePalindrome::2,"    def canPermutePalindrome(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        dic = {}
        for c in s:
            dic[c] = dic.get(c, 0) + 1
        odd, even = 0, 0
        for c in dic:
            if dic[c] % 2 == 0:
                even += 1
            else:
                odd += 1
        if odd <= 1:
            return True
        return False",data\repos\Leetcode\python\266_Palindrome_Permutation.py,canPermutePalindrome,111
4558,267_Palindrome_Permutation_II.py::generatePalindromes::2,"    def generatePalindromes(self, s):
        """"""
        :type s: str
        :rtype: List[str]
        """"""
        dic = {}
        half = []
        res = []
        for c in s:
            dic[c] = dic.get(c, 0) + 1
        odd, even = 0, 0
        for c in dic:
            if dic[c] % 2 == 0:
                even += 1
            else:
                odd += 1
        if odd > 1:
            return []
        # generate half
        seed = []
        mid = ''
        for c in dic:
            if dic[c] % 2 == 1:
                mid = c
            seed.extend([c] * (dic[c] / 2))
        self.permute(half, seed, 0)
        # merge half to get res
        for r in half:
            res.append(''.join(r) + mid + ''.join(reversed(r)))
        return res",data\repos\Leetcode\python\267_Palindrome_Permutation_II.py,generatePalindromes,214
4559,267_Palindrome_Permutation_II.py::permute::33,"    def permute(self, res, num, index):
        if index == len(num):
            res.append(list(num))
            return
        appeared = set()
        for i in range(index, len(num)):
            if num[i] in appeared:
                continue
            appeared.add(num[i])
            num[i], num[index] = num[index], num[i]
            self.permute(res, num, index + 1)
            num[i], num[index] = num[index], num[i]",data\repos\Leetcode\python\267_Palindrome_Permutation_II.py,permute,101
4560,268_Missing_Number.py::missingNumber::10,"    def missingNumber(self, nums):
        res = len(nums)
        for i, v in enumerate(nums):
            res ^= i
            res ^= v
        return res",data\repos\Leetcode\python\268_Missing_Number.py,missingNumber,36
4561,270_Closest_Binary_Search_Tree_Value.py::closestValue::39,"    def closestValue(self, root, target):
        # compare kids' result with root
        kid = root.left if target < root.val else root.right
        if not kid:
            return root.val
        kid_min = self.closestValue(kid, target)
        return min((kid_min, root.val), key=lambda x: abs(target - x))",data\repos\Leetcode\python\270_Closest_Binary_Search_Tree_Value.py,closestValue,74
4562,273_Integer_to_English_Words.py::numberToWords::2,"    def numberToWords(self, num):
        # https://leetcode.com/problems/integer-to-english-words/discuss/70632/Recursive-Python
        to19 = 'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve ' \
               'Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen'.split()
        tens = 'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety'.split()
        def words(n):
            if n < 20:
                return to19[n - 1:n]
            if n < 100:
                return [tens[n / 10 - 2]] + words(n % 10)
            if n < 1000:
                return [to19[n / 100 - 1]] + ['Hundred'] + words(n % 100)
            for p, w in enumerate(('Thousand', 'Million', 'Billion'), 1):
                if n < 1000 ** (p + 1):
                    return words(n / 1000 ** p) + [w] + words(n % 1000 ** p)
        return ' '.join(words(num)) or 'Zero'",data\repos\Leetcode\python\273_Integer_to_English_Words.py,numberToWords,246
4563,273_Integer_to_English_Words.py::words::7,"        def words(n):
            if n < 20:
                return to19[n - 1:n]
            if n < 100:
                return [tens[n / 10 - 2]] + words(n % 10)
            if n < 1000:
                return [to19[n / 100 - 1]] + ['Hundred'] + words(n % 100)
            for p, w in enumerate(('Thousand', 'Million', 'Billion'), 1):
                if n < 1000 ** (p + 1):
                    return words(n / 1000 ** p) + [w] + words(n % 1000 ** p)",data\repos\Leetcode\python\273_Integer_to_English_Words.py,words,143
4564,274_H-Index.py::hIndex::23,"    def hIndex(self, citations):
        # counting sort
        ls = len(citations)
        papers = [0] * (ls + 1)
        for c in citations:
            papers[min(ls, c)] += 1
        k, s = ls, papers[ls]
        while k > s:
            k -= 1
            s += papers[k]
        return k",data\repos\Leetcode\python\274_H-Index.py,hIndex,82
4565,276_Paint_Fence.py::numWays::12,"    def numWays(self, n, k):
        if n == 0:
            return 0
        elif n == 1:
            return k
        # two step dp
        # ways[1] = k
        # ways[2] = k * k
        # ways[i>2] = (ways[i-1] + ways[i-2]) * (k - 1)
        dp = [0] * 2
        dp[0] = k
        dp[1] = k * k
        for i in range(2, n):
            temp = dp[1]
            dp[1] = sum(dp) * (k - 1)
            dp[0] = temp
        return dp[1]",data\repos\Leetcode\python\276_Paint_Fence.py,numWays,162
4566,278_First_Bad_Version.py::firstBadVersion::7,"    def firstBadVersion(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        left, right= 1, n
        while left < right:
            mid = (right + left) / 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return left",data\repos\Leetcode\python\278_First_Bad_Version.py,firstBadVersion,80
4567,280_Wiggle_Sort.py::wiggleSort::36,"    def wiggleSort(self, nums):
        for i in range(len(nums) - 1):
            if (i % 2 == 0 and nums[i] > nums[i + 1]) or\
               (i % 2 == 1 and nums[i] < nums[i + 1]):
                nums[i], nums[i + 1] = nums[i + 1], nums[i]",data\repos\Leetcode\python\280_Wiggle_Sort.py,wiggleSort,84
4568,283_Move Zeroes.py::moveZeroes::22,"    def moveZeroes(self, nums):
        # O(n)
        ls = len(nums)
        n_pos = 0
        for i in range(ls):
            if nums[i] != 0:
                temp = nums[n_pos]
                nums[n_pos] = nums[i]
                nums[i] = temp
                n_pos += 1",data\repos\Leetcode\python\283_Move Zeroes.py,moveZeroes,72
4569,286_Walls_and_Gates.py::wallsAndGates::2,"    def wallsAndGates(self, rooms):
        """"""
        :type rooms: List[List[int]]
        :rtype: void Do not return anything, modify rooms in-place instead.
        """"""
        # BFS with queue
        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        m = len(rooms)
        if m == 0:
            return
        n = len(rooms[0])
        q = []
        for row in range(m):
            for col in range(n):
                # gate
                if rooms[row][col] == 0:
                    q.append((row, col))

        while len(q) > 0:
            point = q.pop(0)
            row, col = point[0], point[1]
            for d in direction:
                r = row + d[0]
                c = col + d[1]
                # wall or out of rooms
                if r < 0 or c < 0 or r >= m or c >= n or rooms[r][c] != 2147483647:
                    continue
                rooms[r][c] = rooms[row][col] + 1
                q.append((r, c))",data\repos\Leetcode\python\286_Walls_and_Gates.py,wallsAndGates,260
4570,288_Unique_Word_Abbreviation.py::isUnique::16,"    def isUnique(self, word):
        """"""
        check if a word is unique.
        :type word: str
        :rtype: bool
        """"""
        abb = self.getAbb(word)
        hasAbbr = self.abb_dic.get(abb, None)
        return hasAbbr == None or (hasAbbr and word in self.dictionary)",data\repos\Leetcode\python\288_Unique_Word_Abbreviation.py,isUnique,74
4571,288_Unique_Word_Abbreviation.py::getAbb::27,"    def getAbb(self, word):
        if len(word) <= 2:
            return word
        return word[0] + str(len(word) - 2) + word[-1]",data\repos\Leetcode\python\288_Unique_Word_Abbreviation.py,getAbb,41
4572,290_Word_Pattern.py::wordPattern::2,"    def wordPattern(self, pattern, str):
        """"""
        :type pattern: str
        :type str: str
        :rtype: bool
        """"""
        if pattern is None or str is None:
            return True
        # double map
        words_to_pattern = {}
        pattern_to_words = {}
        word_list = str.split(' ')
        if len(word_list) != len(pattern):
            return False
        for index, word in enumerate(word_list):
            curr_p = pattern[index]
            if pattern_to_words.get(curr_p, word) != word or words_to_pattern.get(word, curr_p) != curr_p:
                return False
            pattern_to_words[curr_p] = pattern_to_words.get(curr_p, word)
            words_to_pattern[word] = words_to_pattern.get(word, curr_p)
        return True",data\repos\Leetcode\python\290_Word_Pattern.py,wordPattern,171
4573,292_Nim_Game.py::canWinNim::2,"    def canWinNim(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        return n % 4 != 0",data\repos\Leetcode\python\292_Nim_Game.py,canWinNim,36
4574,293_Flip_Game.py::generatePossibleNextMoves::2,"    def generatePossibleNextMoves(self, s):
        """"""
        :type s: str
        :rtype: List[str]
        """"""
        # return [s[:i] + ""--"" + s[i+2:] for i in range(len(s) - 1) if s[i] == s[i + 1] == ""+""]
        res = []
        if s is None or len(s) == 0:
            return res
        ls = len(s)
        for i in range(ls - 1):
            if s[i] == '+' and s[i + 1] == '+':
                res.append(s[:i] + '--' + s[i + 2:])
        return res",data\repos\Leetcode\python\293_Flip_Game.py,generatePossibleNextMoves,144
4575,296_Best_Meeting_Point.py::minDistance1D::26,"    def minDistance1D(self, points):
        # two points
        distance = 0
        i, j = 0, len(points) - 1
        while i < j:
            distance += points[j] - points[i]
            i += 1
            j -= 1
        return distance",data\repos\Leetcode\python\296_Best_Meeting_Point.py,minDistance1D,67
4576,296_Best_Meeting_Point.py::minTotalDistance::36,"    def minTotalDistance(self, grid):
        rows = self.collectRows(grid)
        cols = self.collectCols(grid)
        row = rows[len(rows) / 2]
        col = cols[len(cols) / 2]
        return self.minDistance1D(rows) + self.minDistance1D(cols)",data\repos\Leetcode\python\296_Best_Meeting_Point.py,minTotalDistance,64
4577,296_Best_Meeting_Point.py::collectRows::43,"    def collectRows(self, grid):
        rows = []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    rows.append(i)
        return rows",data\repos\Leetcode\python\296_Best_Meeting_Point.py,collectRows,49
4578,296_Best_Meeting_Point.py::collectCols::51,"    def collectCols(self, grid):
        cols = []
        for j in range(len(grid[0])):
            for i in range(len(grid)):
                if grid[i][j] == 1:
                    cols.append(j)
        return cols",data\repos\Leetcode\python\296_Best_Meeting_Point.py,collectCols,49
4579,298_Binary_Tree_Longest_Consecutive_Sequence.py::longestConsecutive::10,"    def longestConsecutive(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""
        return self.longestConsecutive_helper(root, -10000, 1)",data\repos\Leetcode\python\298_Binary_Tree_Longest_Consecutive_Sequence.py,longestConsecutive,43
4580,298_Binary_Tree_Longest_Consecutive_Sequence.py::longestConsecutive_helper::17,"    def longestConsecutive_helper(self, root, previous, curr):
        # Top down recursion
        if root is None:
            return 0
        if root.val - 1 == previous:
            curr += 1
        else:
            curr = 1
        l_res = self.longestConsecutive_helper(root.left, root.val, curr)
        r_res = self.longestConsecutive_helper(root.right, root.val, curr)
        return max(curr, l_res, r_res)",data\repos\Leetcode\python\298_Binary_Tree_Longest_Consecutive_Sequence.py,longestConsecutive_helper,103
4581,303_Range_Sum_Query_Immutable.py::sumRange::12,"    def sumRange(self, i, j):
        """"""
        sum of elements nums[i..j], inclusive.
        :type i: int
        :type j: int
        :rtype: int
        """"""
        return self.res[j + 1] - self.res[i]",data\repos\Leetcode\python\303_Range_Sum_Query_Immutable.py,sumRange,59
4582,304_Range_Sum_Query_2D_Immutable.py::sumRegion::48,"    def sumRegion(self, row1, col1, row2, col2):
        """"""
        sum of elements matrix[(row1,col1)..(row2,col2)], inclusive.
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :rtype: int
        """"""
        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - \
               self.dp[row2 + 1][col1] + self.dp[row1][col1]",data\repos\Leetcode\python\304_Range_Sum_Query_2D_Immutable.py,sumRegion,130
4583,305_Number_of_Islands_II.py::numIslands2::2,"    def numIslands2(self, m, n, positions):
        """"""
        :type m: int
        :type n: int
        :type positions: List[List[int]]
        :rtype: List[int]
        """"""
        # quick union find with weights
        ans = []
        islands = Union()
        for p in map(tuple, positions):
            islands.add(p)
            for dp in (0, 1), (0, -1), (1, 0), (-1, 0):
                q = (p[0] + dp[0], p[1] + dp[1])
                if q in islands.id:
                    islands.unite(p, q)
            ans += [islands.count]
        return ans",data\repos\Leetcode\python\305_Number_of_Islands_II.py,numIslands2,155
4584,305_Number_of_Islands_II.py::add::31,"    def add(self, p):
        self.id[p] = p
        self.sz[p] = 1
        self.count += 1",data\repos\Leetcode\python\305_Number_of_Islands_II.py,add,30
4585,305_Number_of_Islands_II.py::root::36,"    def root(self, i):
        while i != self.id[i]:
            self.id[i] = self.id[self.id[i]]
            i = self.id[i]
        return i",data\repos\Leetcode\python\305_Number_of_Islands_II.py,root,37
4586,305_Number_of_Islands_II.py::unite::42,"    def unite(self, p, q):
        i, j = self.root(p), self.root(q)
        if i == j:
            return
        if self.sz[i] > self.sz[j]:
            i, j = j, i
        self.id[i] = j
        self.sz[j] += self.sz[i]
        self.count -= 1",data\repos\Leetcode\python\305_Number_of_Islands_II.py,unite,75
4587,307_Range_Sum_Query_Mutable.py::buildTree::55,"    def buildTree(self, nums):
        i, j = self.ls, 0
        while i < 2 * self.ls:
            self.tree[i] = nums[j]
            i += 1
            j += 1
        for i in reversed(range(1, self.ls)):
            self.tree[i] = self.tree[i * 2] + self.tree[i * 2  + 1]",data\repos\Leetcode\python\307_Range_Sum_Query_Mutable.py,buildTree,87
4588,307_Range_Sum_Query_Mutable.py::update::65,"    def update(self, i, val):
        """"""
        :type i: int
        :type val: int
        :rtype: int
        """"""
        i += self.ls
        self.tree[i] = val
        while i > 0:
            left = right = i
            if i % 2 == 0:
                right = i + 1
            else:
                left = i -1
            self.tree[i / 2] = self.tree[left] + self.tree[right]
            i /= 2",data\repos\Leetcode\python\307_Range_Sum_Query_Mutable.py,update,112
4589,307_Range_Sum_Query_Mutable.py::sumRange::82,"    def sumRange(self, i, j):
        """"""
        sum of elements nums[i..j], inclusive.
        :type i: int
        :type j: int
        :rtype: int
        """"""
        res = 0
        i += self.ls
        j += self.ls

        while i <= j:
            if i % 2 == 1:
                res += self.tree[i]
                i += 1
            if j % 2 == 0:
                res += self.tree[j]
                j -= 1
            i /= 2
            j /= 2
        return res",data\repos\Leetcode\python\307_Range_Sum_Query_Mutable.py,sumRange,130
4590,322_Coin_Change.py::coinChange::31,"    def coinChange(self, coins, amount):
        # bottom-up dp
        if amount == 0:
            return 0
        if coins is None or len(coins) == 0:
            return -1
        coins.sort()
        dp = [1000000000] * (amount + 1)
        for i in range(1, amount + 1):
            for coin in coins:
                if i == coin:
                    dp[i] = 1
                    break
                elif i > coin:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        if dp[amount] == 1000000000:
            return -1
        return dp[amount]",data\repos\Leetcode\python\322_Coin_Change.py,coinChange,151
4591,326_Power_of_Three.py::isPowerOfThree::16,"    def isPowerOfThree(self, n):
        max3pow = 1162261467
        if n <= 0 or n > max3pow:
            return False
        return max3pow % n == 0",data\repos\Leetcode\python\326_Power_of_Three.py,isPowerOfThree,48
4592,328_Odd_Even_Linked_List.py::oddEvenList::8,"    def oddEvenList(self, head):
        """"""
        :type head: ListNode
        :rtype: ListNode
        """"""
        odd = head
        if head is None:
            return None
        if head.next is None:
            return head
        even_head = even = head.next
        while odd.next is not None and even.next is not None:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = even_head
        return head",data\repos\Leetcode\python\328_Odd_Even_Linked_List.py,oddEvenList,111
4593,336_Palindrome_Pairs.py::palindromePairs::2,"    def palindromePairs(self, words):
        """"""
        :type words: List[str]
        :rtype: List[List[int]]
        """"""
        # https://leetcode.com/problems/palindrome-pairs/discuss/79219/Python-solution~
        # reverse word and create a word to index map
        word2index, res = dict([(w[::-1], i) for i, w in enumerate(words)]), []
        for i, word in enumerate(words):
            for j in xrange(len(word) + 1):
                # Use prefix and postfix
                # rather than going through all posible combinations
                prefix, postfix = word[:j], word[j:]
                # prefix + postfix + reverse(prfix)
                if prefix in word2index and i != word2index[prefix] and postfix == postfix[::-1]:
                    res.append([i, word2index[prefix]])
                # reverse(postfix) + prefix + postfix
                if j > 0 and postfix in word2index and i != word2index[postfix] and prefix == prefix[::-1]:
                    res.append([word2index[postfix], i])
        return res",data\repos\Leetcode\python\336_Palindrome_Pairs.py,palindromePairs,238
4594,337_House_Robber_III.py::rob::32,"    def rob(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""
        # res[0] means skip curr, res[1] means get curr
        res = self.rob_helper(root)
        return max(res[0], res[1])",data\repos\Leetcode\python\337_House_Robber_III.py,rob,62
4595,337_House_Robber_III.py::rob_helper::41,"    def rob_helper(self, root):
        if root is None:
            return [0, 0]
        left = self.rob_helper(root.left)
        right = self.rob_helper(root.right)
        res = [0, 0]
        res[0] = max(left[0], left[1]) + max(right[0], right[1])
        res[1] = root.val + left[0] + right[0]
        return res",data\repos\Leetcode\python\337_House_Robber_III.py,rob_helper,97
4596,338_Counting_Bits.py::countBits::2,"    def countBits(self, num):
        """"""
        :type num: int
        :rtype: List[int]
        """"""
        res = [0] * (num + 1)
        for i in range(1, num + 1):
            # res[left:last] + last bit
            res[i] = res[i >> 1] + (i & 1)
        return res",data\repos\Leetcode\python\338_Counting_Bits.py,countBits,83
4597,339_Nested_List_Weight_Sum.py::depthSum::27,"    def depthSum(self, nestedList):
        """"""
        :type nestedList: List[NestedInteger]
        :rtype: int
        """"""
        return self.depthSum_helper(nestedList, 1)",data\repos\Leetcode\python\339_Nested_List_Weight_Sum.py,depthSum,43
4598,339_Nested_List_Weight_Sum.py::depthSum_helper::34,"    def depthSum_helper(self, nestedList, depth):
        res = 0
        for l in nestedList:
            if l.isInteger():
                res += l.getInteger() * depth
            else:
                res += self.depthSum_helper(l.getList(), depth + 1)
        return res",data\repos\Leetcode\python\339_Nested_List_Weight_Sum.py,depthSum_helper,61
4599,340_Longest_Substring_with_At_Most_K_Distinct_Characters.py::lengthOfLongestSubstringKDistinct::2,"    def lengthOfLongestSubstringKDistinct(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        count = [0] * 256
        i, numDistinct, maxLen = 0, 0, 0
        for j in range(len(s)):
            # udpate j
            if count[ord(s[j])] == 0:
                numDistinct += 1
            count[ord(s[j])] += 1
            # udpate i
            while numDistinct > k:
                count[ord(s[i])] -= 1
                if count[ord(s[i])] == 0:
                    numDistinct -= 1
                i += 1
            maxLen =  max(j - i + 1, maxLen)
        return maxLen",data\repos\Leetcode\python\340_Longest_Substring_with_At_Most_K_Distinct_Characters.py,lengthOfLongestSubstringKDistinct,180
4600,342_Power_of_Four.py::isPowerOfFour::2,"    def isPowerOfFour(self, num):
        """"""
        :type num: int
        :rtype: bool
        """"""
        # bin(4**0) '0b1'
        # bin(4**1) '0b100'
        # bin(4**2) '0b10000'
        # bin(4**3) '0b1000000'
        return num > 0 and num & (num-1) == 0 and len(bin(num)[3:]) % 2 == 0",data\repos\Leetcode\python\342_Power_of_Four.py,isPowerOfFour,112
4601,344_Reverse_String.py::reverseString::2,"    def reverseString(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        # slice
        return s[::-1]",data\repos\Leetcode\python\344_Reverse_String.py,reverseString,35
4602,345_Reverse_Vowels_of_a_String.py::reverseVowels::2,"    def reverseVowels(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        str_index = []
        vowel = []
        res = []
        pos = -1
        for index, value in enumerate(s):
            if value in 'aeiouAEIOU':
                str_index.append(-1)
                vowel.append(value)
            else:
                str_index.append(index)
        for index in str_index:
            if index < 0:
                res.append(vowel[pos])
                pos -= 1
            else:
                res.append(s[index])
        return ''.join(res)",data\repos\Leetcode\python\345_Reverse_Vowels_of_a_String.py,reverseVowels,129
4603,346_Moving_Average_from_Data_Stream.py::next::12,"    def next(self, val):
        """"""
        :type val: int
        :rtype: float
        """"""
        if len(self.curr_range) == self.size:
            self.curr_range.pop(0)
        self.curr_range.append(val)
        return sum(self.curr_range) * 1.0 / len(self.curr_range)",data\repos\Leetcode\python\346_Moving_Average_from_Data_Stream.py,next,68
4604,347_Top_K_Frequent_Elements.py::topKFrequent::2,"    def topKFrequent(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        counter = collections.Counter(nums)
        return [k for k,v in counter.most_common(k)]",data\repos\Leetcode\python\347_Top_K_Frequent_Elements.py,topKFrequent,58
4605,349_Intersection_of_Two_Arrays.py::intersection::2,"    def intersection(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """"""
        # set
        return list(set(nums1) & set(nums2))",data\repos\Leetcode\python\349_Intersection_of_Two_Arrays.py,intersection,56
4606,350_Intersection_of_Two_Arrays_II.py::intersect::2,"    def intersect(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """"""
        nums1.sort()
        nums2.sort()
        res = []
        pos1 = pos2 = 0
        while pos1 < len(nums1) and pos2 < len(nums2):
            if nums1[pos1] == nums2[pos2]:
                res.append(nums1[pos1])
                pos1 += 1
                pos2 += 1
            elif nums1[pos1] < nums2[pos2]:
                pos1 += 1
            else:
                pos2 += 1
        return res",data\repos\Leetcode\python\350_Intersection_of_Two_Arrays_II.py,intersect,149
4607,351_Android_Unlock_Patterns.py::numberOfPatterns::2,"    def numberOfPatterns(self, m, n):
        """"""
        :type m: int
        :type n: int
        :rtype: int
        """"""
        used = [False] * 9
        res = 0
        for l in range(m, n + 1):
            res += self.calc_patterns(used, -1, l)
            used = [False] * 9
        return res",data\repos\Leetcode\python\351_Android_Unlock_Patterns.py,numberOfPatterns,89
4608,351_Android_Unlock_Patterns.py::is_valid::15,"    def is_valid(self, used, index, last):
        # markded
        if used[index]:
            return False
        # first digit
        if last == -1:
            return True
        # adjacent cells (in a row or in a column)
        if (last + index) % 2 == 1:
            return True
        mid = (last + index) / 2
        if mid == 4:
            return used[mid]
        # adjacent cells on diagonal
        if (index % 3 != last % 3) and (index / 3 != last / 3):
            return True
        # all other cells which are not adjacent
        return used[mid]",data\repos\Leetcode\python\351_Android_Unlock_Patterns.py,is_valid,148
4609,351_Android_Unlock_Patterns.py::calc_patterns::34,"    def calc_patterns(self, used, last, length):
        if length == 0:
            return 1
        res = 0
        for i in range(9):
            if self.is_valid(used, i, last):
                used[i] = True
                res += self.calc_patterns(used, i, length - 1)
                used[i] = False
        return res",data\repos\Leetcode\python\351_Android_Unlock_Patterns.py,calc_patterns,83
4610,359_Logger_Rate_Limiter.py::shouldPrintMessage::36,"    def shouldPrintMessage(self, timestamp, message):
        """"""
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        :type timestamp: int
        :type message: str
        :rtype: bool
        """"""
        while len(self.heap):
            if self.heap[0][0] <= timestamp:
                temp = heapq.heappop(self.heap)
                self.cache.pop(temp[1])
            else:
                break
        if timestamp < self.cache.get(message, 0):
            return False
        self.cache[message] = timestamp + 10
        heapq.heappush(self.heap, (timestamp + 10, message))
        return True",data\repos\Leetcode\python\359_Logger_Rate_Limiter.py,shouldPrintMessage,164
4611,366_Find_Leaves_of_Binary_Tree.py::findLeaves_helper::43,"    def findLeaves_helper(self, node, res):
        if node is None:
            return -1
        level = 1 + max(self.findLeaves_helper(node.left, res), self.findLeaves_helper(node.right, res))
        if len(res) < level + 1:
            res.append([])
        res[level].append(node.val)
        return level",data\repos\Leetcode\python\366_Find_Leaves_of_Binary_Tree.py,findLeaves_helper,76
4612,367_Valid_Perfect_Square.py::isPerfectSquare::13,"    def isPerfectSquare(self, num):
        low, high = 1, num
        while low <= high:
            mid = (low + high) / 2
            mid_square = mid * mid
            if mid_square == num:
                return True
            elif mid_square < num:
                low = mid + 1
            else:
                high = mid - 1
        return False",data\repos\Leetcode\python\367_Valid_Perfect_Square.py,isPerfectSquare,85
4613,368_Largest_Divisible_Subset.py::largestDivisibleSubset::14,"    def largestDivisibleSubset(self, nums):
        ls = len(nums)
        S = {-1: set()}
        for num in sorted(nums):
            candicate = []
            for key in S:
                if num % key == 0:
                    candicate.append(S[key])
            # max previous with curr
            S[num] = max(candicate, key=len) | {num}
        return ",data\repos\Leetcode\python\368_Largest_Divisible_Subset.py,largestDivisibleSubset,85
4614,369_Plus_One_Linked_List.py::plusOne::9,"    def plusOne(self, head):
        """"""
        :type head: ListNode
        :rtype: ListNode
        """"""
        dummy = ListNode(0)
        dummy.next = head
        place_stop, tail = dummy, dummy
        # find the tail
        while tail.next is not None:
            tail = tail.next
            if tail.val != 9:
                place_stop = tail
        if tail.val != 9:
            # done
            tail.val += 1
        else:
            # not yet
            place_stop.val += 1
            place_stop = place_stop.next
            # set all node behind this place to zero
            while place_stop is not None:
                place_stop.val = 0
                place_stop = place_stop.next
        if dummy.val == 0:
            return dummy.next
        return dummy",data\repos\Leetcode\python\369_Plus_One_Linked_List.py,plusOne,176
4615,370_Range_Addition.py::getModifiedArray::2,"    def getModifiedArray(self, length, updates):
        """"""
        :type length: int
        :type updates: List[List[int]]
        :rtype: List[int]
        """"""
        res = [0] * length
        # interval problem
        for t in updates:
            start, end, val = t
            res[start] += val
            if end < length - 1:
                res[end + 1] -= val
        # Cumulative sums
        for i in range(1, length):
            res[i] = res[i] + res[i - 1]
        return res",data\repos\Leetcode\python\370_Range_Addition.py,getModifiedArray,127
4616,371_Sum_of_Two_Integers.py::getSum::2,"    def getSum(self, a, b):
        """"""
        :type a: int
        :type b: int
        :rtype: int
        """"""
        # https://leetcode.com/discuss/111582/java-simple-easy-understand-solution-with-explanation
        # in Python this problem is much different because of the negative number
        # https://leetcode.com/discuss/111705/one-positive-one-negative-case-successful-for-python-rules
        import ctypes
        sum = 0
        carry = ctypes.c_int32(b)
        while carry.value != 0:
            sum = a ^ carry.value
            carry = ctypes.c_int32(a & carry.value)
            carry.value <<= 1
            a = sum
        return sum",data\repos\Leetcode\python\371_Sum_of_Two_Integers.py,getSum,158
4617,372_Super_Pow.py::superPow::5,"    def superPow(self, a, b):
        """"""
        :type a: int
        :type b: List[int]
        :rtype: int
        """"""
        # One knowledge: ab % k = (a%k)(b%k)%k
        # a^1234567 % k = (a^1234560 % k) * (a^7 % k) % k = (a^123456 % k)^10 % k * (a^7 % k) % k
        if b is None or len(b) == 0:
            return 1
        last_digit = b.pop()
        return self.powmod(self.superPow(a, b), 10) * \
            self.powmod(a, last_digit) % self.base",data\repos\Leetcode\python\372_Super_Pow.py,superPow,161
4618,372_Super_Pow.py::powmod::19,"    def powmod(self, a, k):
        a %= self.base
        result = 1
        for i in range(k):
            result = (result * a) % self.base
        return result",data\repos\Leetcode\python\372_Super_Pow.py,powmod,44
4619,373_Find_K_Pairs_with_Smallest_Sums.py::kSmallestPairs::2,"    def kSmallestPairs(self, nums1, nums2, k):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: List[List[int]]
        """"""
        # https://discuss.leetcode.com/topic/50450/slow-1-liner-to-fast-solutions
        queue = []
        def push(i, j):
            if i < len(nums1) and j < len(nums2):
                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])
        push(0, 0)
        pairs = []
        while queue and len(pairs) < k:
            _, i, j = heapq.heappop(queue)
            pairs.append([nums1[i], nums2[j]])
            push(i, j + 1)
            if j == 0:
                push(i + 1, 0)
        return pairs",data\repos\Leetcode\python\373_Find_K_Pairs_with_Smallest_Sums.py,kSmallestPairs,200
4620,373_Find_K_Pairs_with_Smallest_Sums.py::push::11,"        def push(i, j):
            if i < len(nums1) and j < len(nums2):
                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])",data\repos\Leetcode\python\373_Find_K_Pairs_with_Smallest_Sums.py,push,43
4621,374_Guess_Number_Higher_or_Lower.py::guessNumber::7,"    def guessNumber(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        # binary search
        begin, end = 1, n
        while begin <= end:
            mid = (begin + end) / 2
            res = guess(mid)
            if res == 0:
                return mid
            elif res > 0:
                begin = mid + 1
            else:
                end = mid - 1",data\repos\Leetcode\python\374_Guess_Number_Higher_or_Lower.py,guessNumber,100
4622,375_Guess_Number_Higher_or_Lower_II.py::getMoneyAmount::23,"    def getMoneyAmount(self, n):
        # bottom up dp
        # https://discuss.leetcode.com/topic/51353/simple-dp-solution-with-explanation/2
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        for j in range(2, n + 1):
            for i in range(j - 1, 0, -1):
                globalMin = sys.maxint
                for k in range(i + 1, j):
                    localMax = k + max(dp[i][k - 1], dp[k + 1][j])
                    globalMin = min(globalMin, localMax)
                if i + 1 == j:
                    dp[i][j] = i
                else:
                    dp[i][j] = globalMin
        return dp[1][n]",data\repos\Leetcode\python\375_Guess_Number_Higher_or_Lower_II.py,getMoneyAmount,183
4623,380_Insert_Delete_GetRandom.py::insert::9,"    def insert(self, val):
        if val in self.num_to_idx:
            return False
        else:
            self.num_list.append(val)
            self.num_to_idx[val] = len(self.num_list) - 1
            return True",data\repos\Leetcode\python\380_Insert_Delete_GetRandom.py,insert,50
4624,380_Insert_Delete_GetRandom.py::remove::17,"    def remove(self, val):
        if val not in self.num_to_idx:
            return False

        idx = self.num_to_idx[val]
        last = self.num_list[-1]

        # swap last elem to current spot so you can pop the end
        self.num_list[idx] = last
        self.num_list.pop()
        self.num_to_idx[last] = idx
        del self.num_to_idx[val]

        return True",data\repos\Leetcode\python\380_Insert_Delete_GetRandom.py,remove,90
4625,383_Ransom_Note.py::canConstruct::2,"    def canConstruct(self, ransomNote, magazine):
        """"""
        :type ransomNote: str
        :type magazine: str
        :rtype: bool
        """"""
        letter_map = {}
        for letter in magazine:
            letter_map[letter] = letter_map.get(letter, 0) + 1
        for letter in ransomNote:
            letter_map[letter] = letter_map.get(letter, 0) - 1
            if letter_map[letter] < 0:
                return False
        return True",data\repos\Leetcode\python\383_Ransom_Note.py,canConstruct,110
4626,384_Shuffle_an_Array.py::reset::12,"    def reset(self):
        """"""
        Resets the array to its original configuration and return it.
        :rtype: List[int]
        """"""
        self.curr = list(self.origin)
        return self.curr",data\repos\Leetcode\python\384_Shuffle_an_Array.py,reset,40
4627,384_Shuffle_an_Array.py::shuffle::20,"    def shuffle(self):
        """"""
        Returns a random shuffling of the array.
        :rtype: List[int]
        """"""
        for i in range(self.size):
            pos = random.randint(0, i)
            # swap i and pos
            self.curr[i], self.curr[pos] = self.curr[pos], self.curr[i]
        return self.curr",data\repos\Leetcode\python\384_Shuffle_an_Array.py,shuffle,73
4628,387_First_Unique_Character_in_a_String.py::firstUniqChar::2,"    def firstUniqChar(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        count_map = {}
        for c in s:
            count_map[c] = count_map.get(c, 0) + 1
        for i, c in enumerate(s):
            if count_map[c] == 1:
                return i
        return -1",data\repos\Leetcode\python\387_First_Unique_Character_in_a_String.py,firstUniqChar,83
4629,389_Find_the_Difference.py::findTheDifference::2,"    def findTheDifference(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: str
        """"""
        res = ord(t[-1])
        for i in range(len(s)):
            res += ord(t[i])
            res -= ord(s[i])
        return chr(res)",data\repos\Leetcode\python\389_Find_the_Difference.py,findTheDifference,70
4630,392_Is_Subsequence.py::isSubsequence::2,"    def isSubsequence(self, s: str, t: str) -> bool:
        for a in s:
            if a in t:
                for b in range(0, len(t)):
                    if a==t[b]:
                        t=t[b+1:]
                        break
            else:
                return(False)
        return(True)",data\repos\Leetcode\python\392_Is_Subsequence.py,isSubsequence,69
4631,401_Binary_Watch.py::readBinaryWatch::2,"    def readBinaryWatch(self, num):
        """"""
        :type num: int
        :rtype: List[str]
        """"""
        return ['%d:%02d' % (h, m)
            for h in range(12) for m in range(60)
            if (bin(h) + bin(m)).count('1') == num]",data\repos\Leetcode\python\401_Binary_Watch.py,readBinaryWatch,74
4632,404_Sum_of_Left_Leaves.py::sumOfLeftLeaves::21,"    def sumOfLeftLeaves(self, root):
        stack = [root]
        res = 0
        while len(stack) > 0:
            curr = stack.pop(0)
            if curr is not None:
                if curr.left is not None:
                    if curr.left.left is None and curr.left.right is None:
                        res += curr.left.val
                stack.insert(0, curr.right)
                stack.insert(0, curr.left)
        return res",data\repos\Leetcode\python\404_Sum_of_Left_Leaves.py,sumOfLeftLeaves,97
4633,405_Convert_a_Number_to_Hexadecimal.py::toHex::3,"    def toHex(self, num):
        """"""
        :type num: int
        :rtype: str
        """"""
        if num == 0:
            return '0'
        # letter map
        mp = '0123456789abcdef'
        ans = ''
        for _ in range(8):
            # get last 4 digits
            # num & 1111b
            n = num & 15
            # hex letter for current 1111
            c = mp[n]
            ans = c + ans
            # num = num / 16
            num = num >> 4
        #strip leading zeroes
        return ans.lstrip('0')",data\repos\Leetcode\python\405_Convert_a_Number_to_Hexadecimal.py,toHex,143
4634,408_Valid_Word_Abbreviation.py::validWordAbbreviation::36,"    def validWordAbbreviation(self, word, abbr):
        pos = curr = 0
        for i in range(len(abbr)):
            try:
                num = int(abbr[i])
                if num == 0 and curr == 0:
                    return False
                curr = curr * 10 + num
            except ValueError:
                pos += curr
                curr = 0
                if pos >= len(word):
                    return False
                if word[pos] != abbr[i]:
                    return False
                pos += 1
        pos += curr
        if pos == len(word):
            return True
        return False",data\repos\Leetcode\python\408_Valid_Word_Abbreviation.py,validWordAbbreviation,133
4635,409_Longest_Palindrome.py::longestPalindrome::10,"    def longestPalindrome(self, s):
        ans = 0
        char_map = {}
        for c in s:
            char_map[c] = char_map.get(c, 0) + 1
        for c in char_map.keys():
            if char_map[c] % 2 == 0:
                ans += char_map.pop(c)
            else:
                ans += char_map[c] / 2 * 2
        if len(char_map) != 0:
            ans += 1
        return ans",data\repos\Leetcode\python\409_Longest_Palindrome.py,longestPalindrome,108
4636,412_Fizz_Buzz.py::fizzBuzz::37,"    def fizzBuzz(self, n):
        return [str(i) * (i % 3 != 0 and i % 5 != 0) + ""Fizz"" * (i % 3 == 0) + ""Buzz"" * (i % 5 == 0) 
                for i in range(1, n + 1)]",data\repos\Leetcode\python\412_Fizz_Buzz.py,fizzBuzz,74
4637,414_Third_Maximum_Number.py::thirdMax::2,"    def thirdMax(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        import Queue
        pq = Queue.PriorityQueue(4)
        check = set()
        for n in nums:
            if n in check:
                continue
            pq.put(n)
            check.add(n)
            if len(check) > 3:
                check.remove(pq.get())
        total = len(check)
        while total < 3 and total > 1:
            total -= 1
        return pq.get()",data\repos\Leetcode\python\414_Third_Maximum_Number.py,thirdMax,114
4638,415_Add_Strings.py::addStrings::35,"    def addStrings(self, num1, num2):
        res = []
        pos1 = len(num1) - 1
        pos2 = len(num2) - 1
        carry = 0
        # This conditon is great
        # https://leetcode.com/problems/add-strings/discuss/90436/Straightforward-Java-8-main-lines-25ms
        while pos1 >= 0 or pos2 >= 0 or carry == 1:
            digit1 = digit2 = 0
            if pos1 >= 0:
                digit1 = ord(num1[pos1]) - ord('0')
            if pos2 >= 0:
                digit2 = ord(num2[pos2]) - ord('0')
            res.append(str((digit1 + digit2 + carry) % 10))
            carry = (digit1 + digit2 + carry) / 10
            pos1 -= 1
            pos2 -= 1
        # reverse res
        return ''.join(res[::-1])",data\repos\Leetcode\python\415_Add_Strings.py,addStrings,218
4639,416_Partition_Equal_Subset_Sum.py::canPartition::24,"    def canPartition(self, nums):
        total_sum = sum(nums)
        if total_sum & 1:
            return False
        # if sum of some elements can be half of total sum then true
        target = total_sum >> 1
        dp = [0] * (target + 1)
        dp[0] = 1
        for num in nums:
            for i in range(target, num - 1, -1):
                dp[i] = dp[i] | dp[i - num]
        return dp[target] == 1",data\repos\Leetcode\python\416_Partition_Equal_Subset_Sum.py,canPartition,117
4640,421_Maximum_XOR_of_Two_Numbers_in_an_Array.py::findMaximumXOR::2,"    def findMaximumXOR(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        # https://discuss.leetcode.com/topic/63299/python-6-lines-bit-by-bit
        answer = 0
        for i in range(32)[::-1]:
            answer <<= 1
            # use a set to remove duplicate
            prefixes = {num >> i for num in nums}
            # if there is x y in prefixes, where x ^ y = answer ^ 1
            answer += any(answer ^ 1 ^ p in prefixes for p in prefixes)
        return answer",data\repos\Leetcode\python\421_Maximum_XOR_of_Two_Numbers_in_an_Array.py,findMaximumXOR,133
4641,422_Valid_Word_Square.py::validWordSquare::2,"    def validWordSquare(self, words):
        """"""
        :type words: List[str]
        :rtype: bool
        """"""
        if words is None or len(words) == 0:
            return True
        ls = len(words)
        for i in range(ls):
            for j in range(1, len(words[i])):
                if j >= ls:
                    return False
                if i >= len(words[j]):
                    return False
                if words[i][j] != words[j][i]:
                    return False
        return True",data\repos\Leetcode\python\422_Valid_Word_Square.py,validWordSquare,111
4642,437_Path_Sum_III.py::pathSumHelper::30,"    def pathSumHelper(self, root, target, so_far, cache):
        if root:
            # complement == 1, root->curr path
            complement = so_far + root.val - target
            if complement in cache:
                # S->E path, sum(root->S)-sum(root->E) = target
                self.result += cache[complement]
            cache[so_far + root.val] = cache.get(so_far + root.val, 0) + 1
            self.pathSumHelper(root.left, target, so_far + root.val, cache)
            self.pathSumHelper(root.right, target, so_far + root.val, cache)
            cache[so_far + root.val] -= 1
        return",data\repos\Leetcode\python\437_Path_Sum_III.py,pathSumHelper,154
4643,437_Path_Sum_III.py::pathSum::43,"    def pathSum(self, root, sum):
        """"""
        :type root: TreeNode
        :type sum: int
        :rtype: int
        """"""
        self.result = 0
        self.pathSumHelper(root, sum, 0, {0: 1})
        return self.result",data\repos\Leetcode\python\437_Path_Sum_III.py,pathSum,63
4644,438_Find_All_Anagrams_in_a_String.py::findAnagrams::2,"    def findAnagrams(self, s, p):
        """"""
        :type s: str
        :type p: str
        :rtype: List[int]
        """"""
        res = []
        if s is None or p is None or len(s) == 0 or len(p) == 0:
            return res
        char_map = [0] * 256
        for c in p:
            char_map[ord(c)] += 1
        left, right, count = 0, 0, len(p)
        while right < len(s):
            if char_map[ord(s[right])] >= 1:
                count -= 1
            char_map[ord(s[right])] -= 1
            right += 1
            if count == 0:
                res.append(left)
            if right - left == len(p):
                if char_map[ord(s[left])] >= 0:
                    count += 1
                char_map[ord(s[left])] += 1
                left += 1
        return res",data\repos\Leetcode\python\438_Find_All_Anagrams_in_a_String.py,findAnagrams,217
4645,441_Arranging_Coins.py::arrangeCoins::2,"    def arrangeCoins(self, n):
        level = 0
        while n > level:
            level += 1
            n -= level
        return level",data\repos\Leetcode\python\441_Arranging_Coins.py,arrangeCoins,34
4646,443_String_Compression.py::compress::2,"    def compress(self, chars):
        """"""
        :type chars: List[str]
        :rtype: int
        """"""
        # https://leetcode.com/problems/string-compression/solution/
        anchor = write = 0
        for read, c in enumerate(chars):
            if read + 1 == len(chars) or chars[read + 1] != c:
                chars[write] = chars[anchor]
                write += 1
                if read > anchor:
                    for digit in str(read - anchor + 1):
                        chars[write] = digit
                        write += 1
                anchor = read + 1
        return write",data\repos\Leetcode\python\443_String_Compression.py,compress,135
4647,448_Find_All_Numbers_Disappeared_in_an_Array.py::findDisappearedNumbers::2,"    def findDisappearedNumbers(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        # https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution
        res = []
        if nums:
            n = len(nums)
            for i in range(n):
                val = abs(nums[i]) - 1
                if nums[val] > 0:
                    nums[val] = -nums[val]
            for i in range(n):
                if nums[i] > 0:
                    res.append(i + 1)
        return res",data\repos\Leetcode\python\448_Find_All_Numbers_Disappeared_in_an_Array.py,findDisappearedNumbers,135
4648,453_Minimum_Moves_to_Equal_Array_Elements.py::minMoves::2,"    def minMoves(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        if nums is None or len(nums) == 0:
            return 0
        min_num = min(nums)
        return sum([i - min_num for i in nums])",data\repos\Leetcode\python\453_Minimum_Moves_to_Equal_Array_Elements.py,minMoves,64
4649,457_Circular_Array_Loop.py::circularArrayLoop::2,"    def circularArrayLoop(self, nums: List[int]) -> bool:
        for i in range(len(nums)):
            if nums[i] == 0:
                continue
            
            # if slow and fast pointers collide, then there exists a loop
            slow = i
            fast = self.index(nums, slow)
            while nums[slow] * nums[fast] > 0 and nums[slow] * nums[self.index(nums, fast)] > 0:
                if slow == fast and fast != self.index(nums, fast):
                    return True
                elif slow == fast and fast == self.index(nums, fast):
                    break
                slow = self.index(nums, slow)
                fast = self.index(nums, self.index(nums, fast))
                
            # set path to all 0s since it doesn't work
            runner = i
            value = nums[runner]
            while nums[runner] * value > 0:
                temp = self.index(nums, runner)
                nums[runner] = 0
                runner = temp
        return False",data\repos\Leetcode\python\457_Circular_Array_Loop.py,circularArrayLoop,218
4650,458_Poor_Pigs.py::poorPigs::2,"    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        """"""
        :type buckets: int
        :type minutesToDie: int
        :type minutesToTest: int
        :rtype: int
        """"""
        # https://leetcode.com/problems/poor-pigs/discuss/94266/Another-explanation-and-solution
        pigs = 0
        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:
            pigs += 1
        return pigs",data\repos\Leetcode\python\458_Poor_Pigs.py,poorPigs,110
4651,461_Hamming_Distance.py::hammingDistance::2,"    def hammingDistance(self, x, y):
        """"""
        :type x: int
        :type y: int
        :rtype: int
        """"""
        return bin(x ^ y).count('1')",data\repos\Leetcode\python\461_Hamming_Distance.py,hammingDistance,46
4652,475_Heaters.py::findRadius::2,"    def findRadius(self, houses, heaters):
        """"""
        :type houses: List[int]
        :type heaters: List[int]
        :rtype: int
        """"""
        heaters = sorted(heaters) + [float('inf')]
        i = r = 0
        for x in sorted(houses):
            # move to next range
            while x >= sum(heaters[i:i + 2]) / 2.:
                i += 1
            # ans = hearter - hourse
            r = max(r, abs(heaters[i] - x))
        return r",data\repos\Leetcode\python\475_Heaters.py,findRadius,126
4653,479_Largest_Palindrome_Product.py::largestPalindrome::27,"    def largestPalindrome(self, n):
        # https://leetcode.com/problems/largest-palindrome-product/discuss/96305/Python-Solution-Using-Math-In-48ms
        # https://leetcode.com/problems/largest-palindrome-product/discuss/96294/could-any-python-experts-share-their-codes-within-100ms
        if n == 1:
            return 9
        for a in xrange(2, 9 * 10 ** (n - 1)):
            hi = (10 ** n) - a
            lo = int(str(hi)[::-1])
            if a ** 2 - 4 * lo < 0:
                continue
            if (a ** 2 - 4 * lo) ** .5 == int((a ** 2 - 4 * lo) ** .5):
                return (lo + 10 ** n * (10 ** n - a)) % 1337",data\repos\Leetcode\python\479_Largest_Palindrome_Product.py,largestPalindrome,200
4654,482_License_Key_Formatting.py::licenseKeyFormatting::2,"    def licenseKeyFormatting(self, S, K):
        """"""
        :type S: str
        :type K: int
        :rtype: str
        """"""
        # https://leetcode.com/problems/license-key-formatting/discuss/96497/Python-solution
        S = S.upper().replace('-', '')
        ls = len(S)
        if ls % K == 0:
            pos = K
        else:
            pos = ls % K
        res = S[:pos]
        while pos < ls:
            res += '-' + S[pos:pos + K]
            pos += K
        return res",data\repos\Leetcode\python\482_License_Key_Formatting.py,licenseKeyFormatting,128
4655,485_Max_Consecutive_Ones.py::findMaxConsecutiveOnes::2,"    def findMaxConsecutiveOnes(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ans = 0
        curr = 0
        for n in nums:
            if n == 1:
                # Add 1 to curr when encounter 1
                curr += 1
                if curr > ans:
                    ans = curr
            else:
                # Add 1 to curr when encounter 1
                curr = 0
        return ans",data\repos\Leetcode\python\485_Max_Consecutive_Ones.py,findMaxConsecutiveOnes,108
4656,509_Fibonacci_Number.py::fib::8,"    def fib(self, N):
        """"""
        DP with memo
        :type N: int
        :rtype: int
        """"""
        if N < len(self.memo):
            return self.memo[N]
        for i in range(len(self.memo), N + 1):
            self.memo.append(self.memo[i - 1] + self.memo[i - 2])
        return self.memo[N]",data\repos\Leetcode\python\509_Fibonacci_Number.py,fib,82
4657,523_Continuous_Subarray_Sum.py::checkSubarraySum::2,"    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        # remeainders[0] = 0 is for when x == 0
        remainders = dict()
        remainders[0] = 0
        pre_sum = 0

        for idx, item in enumerate(nums):
            pre_sum += item
            remaind = pre_sum % k

            # remainder doesnt exist then it has to be init
            # if it exists, then check the prev one has the same remainder
            if remaind not in remainders:
                remainders[remaind] = idx + 1
            elif remainders[remaind] < idx:
                return True

        return False",data\repos\Leetcode\python\523_Continuous_Subarray_Sum.py,checkSubarraySum,155
4658,538_Convert_BST_to_Greater_Tree.py::convertBST::14,"    def convertBST(self, root):
        total = 0
        
        node = root
        stack = []
        while stack or node is not None:
            # push all nodes up to (and including) this subtree's maximum on
            # the stack.
            while node is not None:
                stack.append(node)
                node = node.right

            node = stack.pop()
            total += node.val
            node.val = total

            # all nodes with values between the current and its parent lie in
            # the left subtree.
            node = node.left

        return root",data\repos\Leetcode\python\538_Convert_BST_to_Greater_Tree.py,convertBST,120
4659,541_Reverse_String_II.py::reverseStr::2,"    def reverseStr(self, s: str, k: int) -> str:
        N = len(s)
        ans = """"
        position = 0
        while position < N:
            nx = s[position : position + k]
            ans = ans + nx[::-1] + s[position + k : position + 2 * k]
            position += 2 * k
        return ans",data\repos\Leetcode\python\541_Reverse_String_II.py,reverseStr,82
4660,543_Diameter_of_Binary_Tree.py::diameterOfBinaryTree::10,"    def diameterOfBinaryTree(self, root):
        self.ans = 1
        def depth(node):
            if not node: return 0
            L = depth(node.left)
            R = depth(node.right)
            self.ans = max(self.ans, L+R+1)
            return max(L, R) + 1

        depth(root)
        # number of nodes - 1 = length
        return self.ans - 1",data\repos\Leetcode\python\543_Diameter_of_Binary_Tree.py,diameterOfBinaryTree,96
4661,543_Diameter_of_Binary_Tree.py::depth::12,"        def depth(node):
            if not node: return 0
            L = depth(node.left)
            R = depth(node.right)
            self.ans = max(self.ans, L+R+1)
            return max(L, R) + 1",data\repos\Leetcode\python\543_Diameter_of_Binary_Tree.py,depth,54
4662,547_Friend_Circles.py::findCircleNum::2,"    def findCircleNum(self, M):
        """"""
        :type M: List[List[int]]
        :rtype: int
        """"""
        # because
        visited = [0] * len(M)
        count = 0
        for i in range(len(M)):
            if visited[i] == 0:
                self.dfs(M, visited, i)
                count += 1
        return count",data\repos\Leetcode\python\547_Friend_Circles.py,findCircleNum,84
4663,547_Friend_Circles.py::dfs::16,"    def dfs(self, M, visited, i):
        for j in range(len(M)):
            if M[i][j] == 1 and visited[j] == 0:
                visited[j] = 1
                self.dfs(M, visited, j)",data\repos\Leetcode\python\547_Friend_Circles.py,dfs,55
4664,557_Reverse_Words_in_a_String_III.py::reverseWords::2,"    def reverseWords(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        return ' '.join([word[::-1] for word in s.split(' ')])",data\repos\Leetcode\python\557_Reverse_Words_in_a_String_III.py,reverseWords,43
4665,560_Subarray_Sum_Equals_K.py::subarraySum::2,"    def subarraySum(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        sum_map = {}
        sum_map[0] = 1
        count = curr_sum = 0
        for num in nums:
            curr_sum += num
            # Check if sum - k in hash
            count += sum_map.get(curr_sum - k, 0)
            # add curr_sum to hash
            sum_map[curr_sum] = sum_map.get(curr_sum, 0) + 1
        return count",data\repos\Leetcode\python\560_Subarray_Sum_Equals_K.py,subarraySum,127
4666,572_Subtree_of_Another_Tree.py::isSubtree::10,"    def isSubtree(self, s, t):
        """"""
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """"""
        s_res = self.preorder(s, True)
        t_res = self.preorder(t, True)
        return t_res in s_res",data\repos\Leetcode\python\572_Subtree_of_Another_Tree.py,isSubtree,64
4667,572_Subtree_of_Another_Tree.py::preorder::20,"    def preorder(self, root, isLeft):
        if root is None:
            if isLeft:
                return ""lnull""
            else:
                return ""rnull""
        return ""#"" + str(root.val) + "" "" + self.preorder(root.left, True) + "" "" + self.preorder(root.right, False)",data\repos\Leetcode\python\572_Subtree_of_Another_Tree.py,preorder,68
4668,581_Shortest_Unsorted_Continuous_Subarray.py::findUnsortedSubarray::20,"    def findUnsortedSubarray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        stack = []
        l, r = len(nums), 0
        for i in range(len(nums)):
            while len(stack) != 0 and nums[stack[-1]] > nums[i]:
                l = min(l, stack.pop())
            stack.append(i)
        stack = []
        for i in range(len(nums) - 1, -1, -1):
            while len(stack) != 0 and nums[stack[-1]] < nums[i]:
                r = max(r, stack.pop())
            stack.append(i)
        if r > l:
            return r - l + 1
        return 0",data\repos\Leetcode\python\581_Shortest_Unsorted_Continuous_Subarray.py,findUnsortedSubarray,159
4669,605_Can_Place_Flowers.py::canPlaceFlowers::2,"    def canPlaceFlowers(self, flowerbed, n):
        """"""
        :type flowerbed: List[int]
        :type n: int
        :rtype: bool
        """"""
        count = 0
        for i in range(len(flowerbed)):
            curr = flowerbed[i]
            if i - 1 >= 0:
                curr += flowerbed[i - 1]
            if i + 1 < len(flowerbed):
                curr += flowerbed[i + 1]
            if curr == 0:
                count += 1
                flowerbed[i] = 1
                if count >= n:
                    return True
        return False",data\repos\Leetcode\python\605_Can_Place_Flowers.py,canPlaceFlowers,139
4670,617_Merge_Two_Binary_Trees.py::mergeTrees::9,"    def mergeTrees(self, t1, t2):
        """"""
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """"""
        if t1 is None:
            return t2
        if t2 is None:
            return t1
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1",data\repos\Leetcode\python\617_Merge_Two_Binary_Trees.py,mergeTrees,107
4671,628_Maximum_Product_of_Three_Numbers.py::maximumProduct::12,"    def maximumProduct(self, nums):
        min1 = min2 = float('inf')
        max1 = max2 = max3 = float('-inf')
        for num in nums:
            if num <= min1:
                min2 = min1
                min1 = num
            elif num <= min2:
                min2 = num
            if num >= max1:
                max3 = max2
                max2 = max1
                max1 = num
            elif num >= max2:
                max3 = max2
                max2 = num
            elif num >= max3:
                max3 = num
        return max(min1 * min2 * max1, max1 * max2 * max3)",data\repos\Leetcode\python\628_Maximum_Product_of_Three_Numbers.py,maximumProduct,153
4672,654_Maximum_Binary_Tree.py::constructMaximumBinaryTree::10,"    def constructMaximumBinaryTree(self, nums):
        """"""
        :type nums: List[int]
        :rtype: TreeNode
        """"""
        # O (n^2) and O(n)
        if nums is None or len(nums) == 0:
            return None
        max_index, max_value = 0, 0
        for i, value in enumerate(nums):
            if value >= max_value:
                max_value = value
                max_index = i
        root = TreeNode(max_value)
        root.left = self.constructMaximumBinaryTree(nums[:max_index])
        root.right = self.constructMaximumBinaryTree(nums[max_index+1:])
        return root",data\repos\Leetcode\python\654_Maximum_Binary_Tree.py,constructMaximumBinaryTree,137
4673,665_Non-decreasing_Array.py::checkPossibility::20,"    def checkPossibility(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        # https://leetcode.com/problems/non-decreasing-array/discuss/106826/JavaC%2B%2B-Simple-greedy-like-solution-with-explanation
        broken_num = 0
        for i in range(len(nums) - 1):
            if (nums[i] > nums[i + 1]):
                broken_num += 1
                if broken_num >= 2:
                    return False
                if (i - 1 < 0 or nums[i - 1] <= nums[i + 1]):
                    # Remove i
                    nums[i] = nums[i + 1]
                else:
                    # Remove i + 1
                    nums[i + 1] = nums[i]
        return True",data\repos\Leetcode\python\665_Non-decreasing_Array.py,checkPossibility,180
4674,668_Kth_Smallest_Number_in_Multiplication_Table.py::findKthNumber::2,"    def findKthNumber(self, m: int, n: int, k: int) -> int:
        # https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/solution/
        def enough(x):
            count = 0
            # ith row [i, 2*i, 3*i, ..., n*i]
            # for each column, k = x // i
            for i in range(1, m+1):
                count += min(x // i, n)
            return count >= k

        lo, hi = 1, m * n
        while lo < hi:
            mi = (lo + hi) // 2
            if not enough(mi):
                lo = mi + 1
            else:
                hi = mi
        return lo",data\repos\Leetcode\python\668_Kth_Smallest_Number_in_Multiplication_Table.py,findKthNumber,168
4675,668_Kth_Smallest_Number_in_Multiplication_Table.py::enough::4,"        def enough(x):
            count = 0
            # ith row [i, 2*i, 3*i, ..., n*i]
            # for each column, k = x // i
            for i in range(1, m+1):
                count += min(x // i, n)
            return count >= k",data\repos\Leetcode\python\668_Kth_Smallest_Number_in_Multiplication_Table.py,enough,69
4676,671_Second_Minimum_Node_In_a_Binary_Tree.py::findSecondMinimumValue::30,"    def findSecondMinimumValue(self, root):
        if not root:
            return -1
        ans = float('inf')
        min_val = root.val
        stack = [root]
        while stack:
            curr = stack.pop()
            if not curr:
                continue
            if min_val < curr.val < ans:
                ans = curr.val
            elif curr.val == min_val:
                stack.append(curr.left)
                stack.append(curr.right)
        return ans if ans < float('inf') else -1",data\repos\Leetcode\python\671_Second_Minimum_Node_In_a_Binary_Tree.py,findSecondMinimumValue,107
4677,674_Longest_Continuous_Increasing_Subsequence.py::findLengthOfLCIS::2,"    def findLengthOfLCIS(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        if not nums or len(nums) == 0:
            return 0
        ans = curr = 1
        for i in range(len(nums) - 1):
            if nums[i] < nums[i + 1]:
                curr += 1
                ans = max(ans, curr)
            else:
                curr = 1
        return ans",data\repos\Leetcode\python\674_Longest_Continuous_Increasing_Subsequence.py,findLengthOfLCIS,104
4678,680_Valid_Palindrome_II.py::validPalindromeHelper::20,"    def validPalindromeHelper(self, s, left, right, budget):
        # Note that budget can be more than 1
        while left < len(s) and right >= 0 and left <= right and s[left] == s[right]:
            left += 1
            right -= 1
        if left >= len(s) or right < 0 or left >= right:
            return True
        if budget == 0:
            return False
        budget -= 1
        return self.validPalindromeHelper(s, left + 1, right, budget) or self.validPalindromeHelper(s, left, right - 1, budget)",data\repos\Leetcode\python\680_Valid_Palindrome_II.py,validPalindromeHelper,134
4679,692_Top_K_Frequent_Words.py::topKFrequent::23,"    def topKFrequent(self, words, k):
        count = collections.Counter(words)
        # Note that python heapq only support min heap
        # So, we can make the value negative to create a max heap
        heap = [(-freq, word) for word, freq in count.items()]
        heapq.heapify(heap)
        return [heapq.heappop(heap)[1] for _ in xrange(k)]",data\repos\Leetcode\python\692_Top_K_Frequent_Words.py,topKFrequent,86
4680,695_Max_Area_of_Island.py::maxAreaOfIsland::2,"    def maxAreaOfIsland(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        # because
        ans = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    grid[i][j] = 0
                    ans = max(self.dfs(grid, i, j), ans)
                    # ans = max(self.bfs(grid, i, j), ans)
        return ans",data\repos\Leetcode\python\695_Max_Area_of_Island.py,maxAreaOfIsland,113
4681,695_Max_Area_of_Island.py::dfs::17,"    def dfs(self, grid, i, j):
        # DFS based on stack
        stack = [(i, j)]
        area = 0
        # Stack for DFS
        while stack:
            r, c = stack.pop(-1)
            area += 1
            for nr, nc in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)):
                if (0 <= nr < len(grid) and
                        0 <= nc < len(grid[0]) and grid[nr][nc]):
                    stack.append((nr, nc))
                    grid[nr][nc] = 0
        return area",data\repos\Leetcode\python\695_Max_Area_of_Island.py,dfs,148
4682,697_Degree_of_an_Array.py::findShortestSubArray::28,"    def findShortestSubArray(self, nums):
        left, right, count = {}, {}, {}
        for i, x in enumerate(nums):
            if x not in left: left[x] = i
            right[x] = i
            count[x] = count.get(x, 0) + 1

        ans = len(nums)
        degree = max(count.values())
        for x in count:
            if count[x] == degree:
                ans = min(ans, right[x] - left[x] + 1)

        return ans",data\repos\Leetcode\python\697_Degree_of_an_Array.py,findShortestSubArray,113
4683,700_Search_in_a_Binary_Search_Tree.py::searchBST::25,"    def searchBST(self, root, val):
        while root:
            if root.val == val:
                return root
            elif root.val > val:
                root = root.left
            else:
                root = root.right
        return root",data\repos\Leetcode\python\700_Search_in_a_Binary_Search_Tree.py,searchBST,50
4684,703_Kth_Largest_Element_in_a_Stream.py::add::12,"    def add(self, val):
        # add to heaq if it's less then k
        if len(self.nums) < self.k:
            heapq.heappush(self.nums, val)
        elif val > self.nums[0]:
            # if len(heaq) == k, and val greater than smallest num
            # then pop smallest num than add val to heap
            heapq.heapreplace(self.nums, val)
        # return k largest
        return self.nums[0]",data\repos\Leetcode\python\703_Kth_Largest_Element_in_a_Stream.py,add,106
4685,706_Design_HashMap.py::find::57,"def find(bucket, key):
    # find prev node of this key
    node = bucket
    prev = None
    while node is not None and node.key != key:
        prev = node
        node = node.next
    return prev",data\repos\Leetcode\python\706_Design_HashMap.py,find,51
4686,706_Design_HashMap.py::put::11,"    def put(self, key, value):
        """"""
        value will always be non-negative.
        :type key: int
        :type value: int
        :rtype: void
        """"""
        index = hash(key) % self.size
        if self.nodes[index] is None:
            self.nodes[index] = ListNode(-1, -1)
        prev = find(self.nodes[index], key)
        if prev.next is None:
            prev.next = ListNode(key, value)
        else:
            prev.next.val = value",data\repos\Leetcode\python\706_Design_HashMap.py,put,108
4687,706_Design_HashMap.py::get::27,"    def get(self, key):
        """"""
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        :type key: int
        :rtype: int
        """"""
        index = hash(key) % self.size
        if self.nodes[index] is None:
            return -1
        prev = find(self.nodes[index], key)
        if prev.next is None:
            return -1
        else:
            return prev.next.val",data\repos\Leetcode\python\706_Design_HashMap.py,get,103
4688,706_Design_HashMap.py::remove::42,"    def remove(self, key):
        """"""
        Removes the mapping of the specified value key if this map contains a mapping for the key
        :type key: int
        :rtype: void
        """"""
        index = hash(key) % self.size
        if self.nodes[index] is None:
            return
        prev = find(self.nodes[index], key)
        if prev.next is None:
            return
        prev.next = prev.next.next",data\repos\Leetcode\python\706_Design_HashMap.py,remove,92
4689,709_To_Lower_Case.py::toLowerCase::2,"    def toLowerCase(self, str):
        """"""
        :type str: str
        :rtype: str
        """"""
        res = []
        gap = ord('a') - ord('A')
        for c in str:
            if ord(c) >= ord('A') and ord(c) <= ord('Z'):
                res.append(chr(ord(c) + gap))
            else:
                res.append(c)
        return ''.join(res)",data\repos\Leetcode\python\709_To_Lower_Case.py,toLowerCase,90
4690,716_Max_Stack.py::push::10,"    def push(self, x):
        """"""
        :type x: int
        :rtype: void
        """"""
        self.stack.append(x)
        if len(self.max_stack) == 0:
            self.max_stack.append(x)
            return
        if self.max_stack[-1] > x:
            self.max_stack.append(self.max_stack[-1])
        else:
            self.max_stack.append(x)",data\repos\Leetcode\python\716_Max_Stack.py,push,83
4691,716_Max_Stack.py::pop::24,"    def pop(self):
        """"""
        :rtype: int
        """"""
        if len(self.stack) != 0:
            self.max_stack.pop(-1)
            return self.stack.pop(-1)",data\repos\Leetcode\python\716_Max_Stack.py,pop,41
4692,716_Max_Stack.py::peekMax::38,"    def peekMax(self):
        """"""
        :rtype: int
        """"""
        if len(self.max_stack) != 0:
            return self.max_stack[-1]",data\repos\Leetcode\python\716_Max_Stack.py,peekMax,35
4693,716_Max_Stack.py::popMax::45,"    def popMax(self):
        """"""
        :rtype: int
        """"""
        val = self.peekMax()
        buff = []
        while self.top() != val:
            buff.append(self.pop())
        self.pop()
        while len(buff) != 0:
            self.push(buff.pop(-1))
        return val",data\repos\Leetcode\python\716_Max_Stack.py,popMax,65
4694,717_1-bit_and_2-bit_Characters.py::isOneBitCharacter::23,"    def isOneBitCharacter(self, bits: List[int]) -> bool:
        pos = 0
        # Go through bits
        while pos < len(bits) - 1:
            # if 1, pos + 2; if 0, pos + 1
            pos += bits[pos] + 1
        return pos == len(bits) - 1",data\repos\Leetcode\python\717_1-bit_and_2-bit_Characters.py,isOneBitCharacter,79
4695,720_Longest_Word_in_Dictionary.py::longestWord::21,"    def longestWord(self, words):
        Trie = lambda: collections.defaultdict(Trie)
        trie = Trie()
        END = True
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)[END] = i
        stack = trie.values()
        ans = """"
        while stack:
            cur = stack.pop()
            if END in cur:
                word = words[cur[END]]
                if len(word) > len(ans) or len(word) == len(ans) and word < ans:
                    ans = word
                stack.extend([cur[letter] for letter in cur if letter != END])
        return ans",data\repos\Leetcode\python\720_Longest_Word_in_Dictionary.py,longestWord,134
4696,724_Find_Pivot_Index.py::pivotIndex::2,"    def pivotIndex(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        totalsum = sum(nums)
        leftsum = 0
        for i, v in enumerate(nums):
            # leftsum == rightsum
            if leftsum == totalsum - leftsum - v:
                return i
            leftsum += v
        return -1",data\repos\Leetcode\python\724_Find_Pivot_Index.py,pivotIndex,84
4697,728_Self_Dividing_Numbers.py::selfDividingNumbers::2,"    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        # check every digit
        return [x for x in range(left, right+1) if all([int(i) != 0 and x % int(i)==0 for i in str(x)])]",data\repos\Leetcode\python\728_Self_Dividing_Numbers.py,selfDividingNumbers,63
4698,732_My_Calendar_III.py::book::8,"  def book(self, start: int, end: int) -> int:
    self.timeline[start] = self.timeline.get(start, 0) + 1
    self.timeline[end] = self.timeline.get(end, 0) - 1

    ans = 0
    activeEvents = 0

    for count in self.timeline.values():
      activeEvents += count
      ans = max(ans, activeEvents)",data\repos\Leetcode\python\732_My_Calendar_III.py,book,88
4699,733_Flood_Fill.py::floodFill::26,"    def floodFill(self, image, sr, sc, newColor):
        # BFS with queue
        r_ls, c_ls = len(image), len(image[0])
        color = image[sr][sc]
        if color == newColor:
            return image
        queue = [(sr, sc)]
        while len(queue) > 0:
            r, c = queue.pop(0)
            if image[r][c] == color:
                image[r][c] = newColor
                if r - 1 >= 0: queue.append((r - 1, c))
                if r + 1 < r_ls: queue.append((r + 1, c))
                if c - 1 >= 0: queue.append((r, c - 1))
                if c + 1 < c_ls: queue.append((r, c + 1))
        return image",data\repos\Leetcode\python\733_Flood_Fill.py,floodFill,186
4700,743_Network_Delay_Time.py::networkDelayTime::20,"    def networkDelayTime(self, times, N, K):
        # Dijkstra
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))

        dist = {node: float('inf') for node in xrange(1, N + 1)}
        seen = [False] * (N + 1)
        dist[K] = 0

        while True:
            cand_node = -1
            cand_dist = float('inf')
            for i in xrange(1, N + 1):
                if not seen[i] and dist[i] < cand_dist:
                    cand_dist = dist[i]
                    cand_node = i

            if cand_node < 0: break
            seen[cand_node] = True
            for nei, d in graph[cand_node]:
                dist[nei] = min(dist[nei], dist[cand_node] + d)

        ans = max(dist.values())
        return ans if ans < float('inf') else -1",data\repos\Leetcode\python\743_Network_Delay_Time.py,networkDelayTime,219
4701,751_IP_to_CIDR.py::ipToInt::2,"    def ipToInt(self, ip):
        ans = 0
        for x in ip.split('.'):
            ans = 256 * ans + int(x)
        return ans",data\repos\Leetcode\python\751_IP_to_CIDR.py,ipToInt,36
4702,751_IP_to_CIDR.py::intToIP::8,"    def intToIP(self, x):
        return ""."".join(str((x >> i) % 256)
                        for i in (24, 16, 8, 0))",data\repos\Leetcode\python\751_IP_to_CIDR.py,intToIP,40
4703,751_IP_to_CIDR.py::ipToCIDR::12,"    def ipToCIDR(self, ip, n):
        # Start value of IP
        start = self.ipToInt(ip)
        ans = []
        while n:
            # Last 1 of start or can start from 0
            mask = max(33 - (start & -start).bit_length(),
                       33 - n.bit_length())
            ans.append(self.intToIP(start) + '/' + str(mask))
            start += 1 << (32 - mask)
            n -= 1 << (32 - mask)
        return ans",data\repos\Leetcode\python\751_IP_to_CIDR.py,ipToCIDR,113
4704,760_Find_Anagram_Mappings.py::anagramMappings::2,"    def anagramMappings(self, A, B):
        """"""
        :type A: List[int]
        :type B: List[int]
        :rtype: List[int]
        """"""
        val_index = {}
        ans = []
        for i, n in enumerate(B):
            val_index[n] = i
        for n in A:
            ans.append(val_index[n])
        return ans",data\repos\Leetcode\python\760_Find_Anagram_Mappings.py,anagramMappings,80
4705,766_Toeplitz_Matrix.py::isToeplitzMatrix::2,"    def isToeplitzMatrix(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: bool
        """"""
        # Actually, we don't need to check the last row and column
        for r in range(len(matrix) - 1):
            for c in range(len(matrix[0]) - 1):
                if matrix[r][c] != matrix[r + 1][c + 1]:
                    return False
        return True",data\repos\Leetcode\python\766_Toeplitz_Matrix.py,isToeplitzMatrix,98
4706,771_Jewels_and_Stones.py::numJewelsInStones::2,"    def numJewelsInStones(self, J, S):
        """"""
        :type J: str
        :type S: str
        :rtype: int
        """"""
        if len(J) == 0 or len(S) == 0:
            return 0
        j_set = set(J)
        ans = 0
        for c in S:
            if c in j_set:
                ans += 1
        return ans",data\repos\Leetcode\python\771_Jewels_and_Stones.py,numJewelsInStones,95
4707,784_Letter_Case_Permutation.py::letterCasePermutation::20,"    def letterCasePermutation(self, S):
        B = sum(letter.isalpha() for letter in S)
        ans = []

        for bits in xrange(1 << B):
            b = 0
            word = []
            for letter in S:
                if letter.isalpha():
                    if (bits >> b) & 1:
                        word.append(letter.lower())
                    else:
                        word.append(letter.upper())

                    b += 1
                else:
                    word.append(letter)

            ans.append("""".join(word))
        return ans",data\repos\Leetcode\python\784_Letter_Case_Permutation.py,letterCasePermutation,110
4708,804_Unique_Morse_Code_Words.py::uniqueMorseRepresentations::10,"    def uniqueMorseRepresentations(self, words):
        """"""
        :type words: List[str]
        :rtype: int
        """"""
        if len(words) == 0:
            return 0
        ans_set = set()
        for word in words:
            morsed = """"
            for c in word:
                morsed += Morse_tab[ord(c) - ord('a')]
            
            ans_set.add(morsed)
        return len(ans_set)",data\repos\Leetcode\python\804_Unique_Morse_Code_Words.py,uniqueMorseRepresentations,98
4709,811_Subdomain_Visit_Count.py::subdomainVisits::2,"    def subdomainVisits(self, cpdomains):
        """"""
        :type cpdomains: List[str]
        :rtype: List[str]
        """"""
        domain_count = {}
        for cpdomain in cpdomains:
            count, domain = cpdomain.split(' ')
            sub_domain = domain.split('.')
            for i in range(len(sub_domain)):
                curr = '.'.join(sub_domain[i:])
                domain_count[curr] = domain_count.get(curr, 0) + int(count)
        return [str(v) + ' ' + k for k, v in domain_count.items()]",data\repos\Leetcode\python\811_Subdomain_Visit_Count.py,subdomainVisits,118
4710,819_Most_Common_Word.py::mostCommonWord::2,"    def mostCommonWord(self, paragraph, banned):
        """"""
        :type paragraph: str
        :type banned: List[str]
        :rtype: str
        """"""
        # https://leetcode.com/problems/most-common-word/discuss/193268/python-one-liner
        banned = set(banned)
        count = collections.Counter(word for word in re.split('[ !?\',;.]',
                                    paragraph.lower()) if word)
        return max((item for item in count.items() if item[0] not in banned),
                   key=operator.itemgetter(1))[0]",data\repos\Leetcode\python\819_Most_Common_Word.py,mostCommonWord,120
4711,832_Flipping_an_Image.py::flipAndInvertImage::2,"    def flipAndInvertImage(self, A):
        for row in A:
            for i in xrange((len(row) + 1) / 2):
                """"""
                In Python, the shortcut row[~i] = row[-i-1] = row[len(row) - 1 - i]
                helps us find the i-th value of the row, counting from the right.
                """"""
                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
        return A",data\repos\Leetcode\python\832_Flipping_an_Image.py,flipAndInvertImage,113
4712,836_Rectangle_Overlap.py::isRectangleOverlap::2,"    def isRectangleOverlap(self, rec1, rec2):
        """"""
        :type rec1: List[int]
        :type rec2: List[int]
        :rtype: bool
        """"""
        return not (rec1[2] <= rec2[0] or  # left
                    rec1[3] <= rec2[1] or  # bottom
                    rec1[0] >= rec2[2] or  # right
                    rec1[1] >= rec2[3])    # top",data\repos\Leetcode\python\836_Rectangle_Overlap.py,isRectangleOverlap,110
4713,844_Backspace_String_Compare.py::backspaceCompare::2,"    def backspaceCompare(self, S, T):
        """"""
        :type S: str
        :type T: str
        :rtype: bool
        """"""
        if S == T:
            return True
        s_stack = []
        t_stack = []
        for c in S:
            if c != '#':
                s_stack.append(c)
            elif len(s_stack) != 0:
                s_stack.pop(-1)
        for c in T:
            if c != '#':
                t_stack.append(c)
            elif len(t_stack) != 0:
                t_stack.pop(-1)
        return ''.join(s_stack) == ''.join(t_stack)",data\repos\Leetcode\python\844_Backspace_String_Compare.py,backspaceCompare,138
4714,852_Peak_Index_in_a_Mountain_Array.py::peakIndexInMountainArray::12,"    def peakIndexInMountainArray(self, A):
        lo, hi = 0, len(A) - 1
        while lo < hi:
            mid = (lo + hi) / 2
            if A[mid] < A[mid + 1]:
                lo = mid + 1
            else:
                hi = mid
        return lo",data\repos\Leetcode\python\852_Peak_Index_in_a_Mountain_Array.py,peakIndexInMountainArray,75
4715,867_Transpose_Matrix.py::transpose::2,"    def transpose(self, A):
        """"""
        :type A: List[List[int]]
        :rtype: List[List[int]]
        """"""
        R, C = len(A), len(A[0])
        ans = [[None] * R for _ in xrange(C)]
        for r, row in enumerate(A):
            for c, val in enumerate(row):
                ans[c][r] = val
        return ans",data\repos\Leetcode\python\867_Transpose_Matrix.py,transpose,85
4716,868_Binary_Gap.py::binaryGap::10,"    def binaryGap(self, n: int) -> int:
        # one pass and store max
        current = 1
        last1 = -1
        out = 0
        while n > 0:
            if n % 2 == 1:
                if last1 >= 1:
                    out = max(out, current - last1)
                last1 = current
            current += 1
            n = n // 2
        return out",data\repos\Leetcode\python\868_Binary_Gap.py,binaryGap,99
4717,872_Leaf-Similar_Trees.py::leafSimilar::9,"    def leafSimilar(self, root1, root2):
        """"""
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: bool
        """"""
        if not root1 and not root2:
            return True
        leaf1 = []
        leaf2 = []
        self.dfs(root1, leaf1)
        self.dfs(root2, leaf2)
        if leaf1 == leaf2:
            return True
        return False",data\repos\Leetcode\python\872_Leaf-Similar_Trees.py,leafSimilar,97
4718,872_Leaf-Similar_Trees.py::dfs::25,"    def dfs(self, node, leavels):
        if not node:
            return
        if not node.left and not node.right:
            leavels.append(node.val)
        self.dfs(node.left, leavels)
        self.dfs(node.right, leavels)",data\repos\Leetcode\python\872_Leaf-Similar_Trees.py,dfs,59
4719,876_Middle_of_the_Linked_List.py::middleNode::19,"    def middleNode(self, head):
        # Fast point is 2 times faster than slow point
        fast = slow = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow",data\repos\Leetcode\python\876_Middle_of_the_Linked_List.py,middleNode,51
4720,904_Fruit_Into_Baskets.py::totalFruit::46,"    def totalFruit(self, tree):
        ans = i = 0
        count = collections.Counter()
        for j, x in enumerate(tree):
            count[x] += 1
            while len(count) >= 3:
                count[tree[i]] -= 1
                if count[tree[i]] == 0:
                    del count[tree[i]]
                i += 1
            ans = max(ans, j - i + 1)
        return ans",data\repos\Leetcode\python\904_Fruit_Into_Baskets.py,totalFruit,99
4721,905_Sort_Array_By_Parity.py::sortArrayByParity::15,"    def sortArrayByParity(self, A):
        # Quit like quick sort or quick selection
        lo, hi = 0, len(A) - 1
        while lo < hi:
            if A[lo] % 2 > A[hi] % 2:
                A[lo], A[hi] = A[hi], A[lo]
            if A[lo] % 2 == 0: lo += 1
            if A[hi] % 2 == 1: hi -= 1
        return A",data\repos\Leetcode\python\905_Sort_Array_By_Parity.py,sortArrayByParity,117
4722,922_Sort_Array_By_Parity_II.py::sortArrayByParityII::20,"    def sortArrayByParityII(self, A):
        odd = 1
        for i in xrange(0, len(A), 2):
            if A[i] % 2:
                while A[odd] % 2:
                    odd += 2
                A[i], A[odd] = A[odd], A[i]
        return A",data\repos\Leetcode\python\922_Sort_Array_By_Parity_II.py,sortArrayByParityII,76
4723,929_Unique_Email_Addresses.py::numUniqueEmails::2,"    def numUniqueEmails(self, emails):
        """"""
        :type emails: List[str]
        :rtype: int
        """"""
        email_set = set()
        for email in emails:
            elements = email.split('@')
            email_set.add(elements[0].split('+')[0].replace('.', '') + elements[1])
        return len(email_set)",data\repos\Leetcode\python\929_Unique_Email_Addresses.py,numUniqueEmails,74
4724,933_Number_of_Recent_Calls.py::ping::6,"    def ping(self, t):
        """"""
        :type t: int
        :rtype: int
        """"""
        self.queue.append(t)
        while self.queue and self.queue[0] < t - 3000:
            self.queue.pop(0)
        return len(self.queue)",data\repos\Leetcode\python\933_Number_of_Recent_Calls.py,ping,60
4725,937_Reorder_Log_Files.py::reorderLogFiles::14,"    def reorderLogFiles(self, logs):
        letter_logs = []
        digit_logs = []
        for log in logs:
            if log.split(' ')[1].isnumeric():
                digit_logs.append(log)
            else:
                letter_logs.append(log)
        return sorted(letter_logs, key=lambda x: x.split(' ')[1:] + x.split(' ')[0]) + digit_logs",data\repos\Leetcode\python\937_Reorder_Log_Files.py,reorderLogFiles,77
4726,945_Minimum_Increment_to_Make_Array_Unique.py::minIncrementForUnique::2,"    def minIncrementForUnique(self, A):
        """"""
        :type A: List[int]
        :rtype: int
        """"""
        if A is None or len(A) == 0:
            return 0
        res = 0
        num_set = set()
        duplicate = []
        A.sort()
        left, right = A[0], A[-1]
        holes = right - left + 1
        for v in A:
            if v in num_set:
                duplicate.append(v)
            else:
                num_set.add(v)
        holes = holes - len(num_set)
        # find a hole for these numbers
        for hole in range(left + 1, right):
            if holes == 0 or len(duplicate) == 0:
                break
            if hole not in num_set and hole > duplicate[0]:
                res += hole - duplicate.pop(0)
                holes -= 1
        while len(duplicate) != 0:
            right += 1
            res += right - duplicate.pop(0)
        return res",data\repos\Leetcode\python\945_Minimum_Increment_to_Make_Array_Unique.py,minIncrementForUnique,223
4727,973_K_Closest_Points_to_Origin.py::kClosest::11,"    def kClosest(self, points, K):
        # K smallest heaq
        return heapq.nsmallest(K, points, key=lambda x: x[0] ** 2 + x[1] ** 2)",data\repos\Leetcode\python\973_K_Closest_Points_to_Origin.py,kClosest,48
4728,977_Squares_of_a_Sorted_Array.py::sortedSquares::10,"    def sortedSquares(self, A):
        pos = 0
        while pos < len(A) and A[pos] < 0:
            pos += 1
        # pos point to first positve
        # npos point to larget negative
        npos = pos - 1
        res = []
        while pos < len(A) and npos >= 0:
            if A[npos] ** 2 < A[pos] ** 2:
                res.append(A[npos] ** 2)
                npos -= 1
            else:
                res.append(A[pos] ** 2)
                pos +=1 
        while npos >= 0:
            res.append(A[npos] ** 2)
            npos -= 1
        while pos < len(A):
            res.append(A[pos] ** 2)
            pos += 1
        return res",data\repos\Leetcode\python\977_Squares_of_a_Sorted_Array.py,sortedSquares,187
4729,981_Time_Based_Store.py::get::11,"    def get(self, key, timestamp):
        values = self.store.get(key, [])
        res = """"

        l = 0
        r = len(values) - 1

        while l <= r:
            mid = (l + r) // 2
            if values[mid][1] <= timestamp:
                l = mid + 1
                res = values[mid][0]
            else:
                r = mid - 1
        
        return res",data\repos\Leetcode\python\981_Time_Based_Store.py,get,96
4730,997_Find_The_Town_Judge.py::findJudge::2,"    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        if N==1:
            return 1
        d1={}
        d2={}
        for i, j in trust:
            if j in d1:
                d1[j]+=1
            else:
                d1[j]=1
            if i in d2:
                d2[i]+=1
            else:
                d2[i]=1
        for i,j in d1.items():
            if j==N-1:
                if i not in d2:
                    return i
        return -1",data\repos\Leetcode\python\997_Find_The_Town_Judge.py,findJudge,127
